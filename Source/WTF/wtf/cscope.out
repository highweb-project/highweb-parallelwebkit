cscope 15 $HOME/WebKit_Parse_ARM/WebKit_r174059/Source/WTF/wtf               0001959500
	@ASCIICType.h

29 #ide
WTF_ASCIICTy_h


30 
	#WTF_ASCIICTy_h


	)

32 
	~<wtf/Asis.h
>

44 
mea
 
	gWTF
 {

46 
	gme
<
tyme
 
	gChTy
> 
le
 
bo
 
isASCII
(
ChTy
 
c
)

48  !(
	gc
 & ~0x7F);

51 
	gme
<
tyme
 
	gChTy
> 
le
 
bo
 
isASCIIAha
(
ChTy
 
c
)

53  (
	gc
 | 0x20>'a' && (
c
 | 0x20) <= 'z';

56 
	gme
<
tyme
 
	gChTy
> 
le
 
bo
 
isASCIIDig
(
ChTy
 
c
)

58  
	gc
 >'0' && 
c
 <= '9';

61 
	gme
<
tyme
 
	gChTy
> 
le
 
bo
 
isASCIIAhumic
(
ChTy
 
c
)

63  
isASCIIDig
(
c
|| 
isASCIIAha
(c);

66 
	gme
<
tyme
 
	gChTy
> 
le
 
bo
 
isASCIIHexDig
(
ChTy
 
c
)

68  
isASCIIDig
(
c
|| ((
	gc
 | 0x20) >= 'a' && (c | 0x20) <= 'f');

71 
	gme
<
tyme
 
	gChTy
> 
le
 
bo
 
isASCIILow
(
ChTy
 
c
)

73  
	gc
 >'a' && 
c
 <= 'z';

76 
	gme
<
tyme
 
	gChTy
> 
le
 
bo
 
isASCIIODig
(
ChTy
 
c
)

78  (
	gc
 >'0'& (
c
 <= '7');

81 
	gme
<
tyme
 
	gChTy
> 
le
 
bo
 
isASCIIPrb
(
ChTy
 
c
)

83  
	gc
 >' ' && 
c
 <= '~';

99 
	gme
<
tyme
 
	gChTy
> 
le
 
bo
 
isASCIIS
(
ChTy
 
c
)

101  
	gc
 <' ' && (
c
 == ' ' || (c <= 0xD && c >= 0x9));

104 
	gme
<
tyme
 
	gChTy
> 
le
 
bo
 
isASCIIU
(
ChTy
 
c
)

106  
	gc
 >'A' && 
c
 <= 'Z';

109 
	gme
<
tyme
 
	gChTy
> 
le
 
ChTy
 
toASCIILow
(ChTy 
c
)

111  
	gc
 | ((>'A' && 
c
 <= 'Z') << 5);

114 
	gme
<
tyme
 
	gChTy
> 
le
 
ChTy
 
toASCIILowUnchecked
(ChTy 
cha
)

121  
	gcha
 | 0x20;

124 
	gme
<
tyme
 
	gChTy
> 
le
 
ChTy
 
toASCIIU
(ChTy 
c
)

126  
	gc
 & ~((>'a' && 
c
 <= 'z') << 5);

129 
	gme
<
tyme
 
	gChTy
> 
le
 
toASCIIHexVue
(
ChTy
 
c
)

131 
ASSERT
(
isASCIIHexDig
(
c
));

132  
	gc
 < 'A' ? c - '0' : (
c
 - 'A' + 10) & 0xF;

135 
	gme
<
tyme
 
	gChTy
> 
le
 
toASCIIHexVue
(
ChTy
 
uVue
, ChTy 
lowVue
)

137 
ASSERT
(
isASCIIHexDig
(
uVue
&& isASCIIHexDig(
lowVue
));

138  ((
toASCIIHexVue
(
uVue
<< 4& 0xF0|oASCIIHexVue(
lowVue
);

141 
le
 
lowNibbToASCIIHexDig
(
c
)

143 
	gnibb
 = 
c
 & 0xF;

144  
	gnibb
 < 10 ? '0' +ibb : 'A' + 
nibb
 - 10;

147 
le
 
uNibbToASCIIHexDig
(
c
)

149 
	gnibb
 = (
c
 >> 4) & 0xF;

150  
	gnibb
 < 10 ? '0' +ibb : 'A' + 
nibb
 - 10;

153 
	gme
<
tyme
 
	gChTy
> 
le
 
bo
 
isASCIIAhaCassEqu
(
ChTy
 
cssCha
, 
cha
)

157 
ASSERT
(
cha
 >= 'a' && character <= 'z');

158  
LIKELY
(
toASCIILowUnchecked
(
cssCha
=
cha
);

163 
usg
 
	gWTF
::
isASCII
;

164 
usg
 
	gWTF
::
isASCIIAha
;

165 
usg
 
	gWTF
::
isASCIIAhumic
;

166 
usg
 
	gWTF
::
isASCIIDig
;

167 
usg
 
	gWTF
::
isASCIIHexDig
;

168 
usg
 
	gWTF
::
isASCIILow
;

169 
usg
 
	gWTF
::
isASCIIODig
;

170 
usg
 
	gWTF
::
isASCIIPrb
;

171 
usg
 
	gWTF
::
isASCIIS
;

172 
usg
 
	gWTF
::
isASCIIU
;

173 
usg
 
	gWTF
::
toASCIIHexVue
;

174 
usg
 
	gWTF
::
toASCIILow
;

175 
usg
 
	gWTF
::
toASCIILowUnchecked
;

176 
usg
 
	gWTF
::
toASCIIU
;

177 
usg
 
	gWTF
::
lowNibbToASCIIHexDig
;

178 
usg
 
	gWTF
::
uNibbToASCIIHexDig
;

179 
usg
 
	gWTF
::
isASCIIAhaCassEqu
;

	@AVLTree.h

32 #ide
AVL_TREE_H_


33 
	#AVL_TREE_H_


	)

35 
	~<y
>

36 
	~<wtf/Asis.h
>

38 
mea
 
	gWTF
 {

66 
	gme
<
	gmaxDth
>

67 as
	cAVLTeDeuBS
 {

68 
	gpublic
:

69 
bo
& 
ݔ
[](
i
{ 
ASSERT_WITH_SECURITY_IMPLICATION
(< 
maxDth
);  
	gm_da
[i]; }

70 
t
({ 
	gi
 = 0; i < 
	gmaxDth
; ++i
	gm_da
[
i
] = 
ue
; }

71 
t
({ 
	gi
 = 0; i < 
	gmaxDth
; ++i
	gm_da
[
i
] = 
l
; }

73 
	give
:

74 
d
::
y
<
bo
, 
	gmaxDth
> 
	gm_da
;

127 
	gme
 <
ass
 
	gAb
, 
	gmaxDth
 = 32, cs
	gBS
 = 
AVLTeDeuBS
<
maxDth
>>

128 as
	cAVLTe
 {

129 
public
:

131 
tyme
 
	tAb
::
	tkey
 key;

132 
tyme
 
	tAb
::
	thd
 handle;

133 
tyme
 
	tAb
::
	tsize
 size;

135 
	eSrchTy
 {

136 
	gEQUAL
 = 1,

137 
	gLESS
 = 2,

138 
	gGREATER
 = 4,

139 
	gLESS_EQUAL
 = 
EQUAL
 | 
LESS
,

140 
	gGREATER_EQUAL
 = 
EQUAL
 | 
GREATER


144 
	gAb
& 
ab
({  
	gabs
; }

146 
le
 
hd
 

(hd 
h
);

148 
le
 
hd
 
ch
(
key
 
k
, 
SrchTy
 

 = 
EQUAL
);

149 
le
 
hd
 
ch_a
();

150 
le
 
hd
 
ch_ge
();

152 
le
 
hd
 
move
(
key
 
k
);

154 
le
 
hd
 
sub
(hd 
w_node
);

156 
purge
({ 
	gabs
.
	gro
 = 
nu
(); }

158 
bo
 
is_emy
({  
	gabs
.
	gro
 =
nu
(); }

160 
AVLTe
({ 
	gabs
.
	gro
 = 
nu
(); }

162 as
	cIt
 {

163 
	gpublic
:

167 
It
({ 
dth
 = ~0U; }

169 
t_
(
AVLTe
 &

, 
key
 
k
, 
SrchTy
 

 = 
EQUAL
)

172 cڡ 
MASK_HIGH_BIT
 = () ~ ((~ () 0) >> 1);

176 
	g_
 = &

;

178 
	gcmp
, 
	grg_cmp
;

179 
hd
 
	gh
 = 
_
->
abs
.
ro
;

180 
	gd
 = 0;

182 
	gdth
 = ~0U;

184 i(
	gh
 =
nu
())

188 i(
	g
 & 
	gLESS
)

190 
	grg_cmp
 = 1;

191 i(
	g
 & 
	gGREATER
)

193 
	grg_cmp
 = -1;

196 
	grg_cmp
 = 0;

199 
	gcmp
 = 
cmp_k_n
(
k
, 
h
);

200 i(
	gcmp
 == 0) {

201 i(

 & 
EQUAL
) {

203 
dth
 = 
d
;

206 
	gcmp
 = -
rg_cmp
;

207 } i(
	grg_cmp
 != 0) {

208 i(!((
cmp
 ^ 
rg_cmp
& 
MASK_HIGH_BIT
)) {

210 
dth
 = 
d
;

213 
	gh
 = 
cmp
 < 0 ? 
g_
(
h
: 
g_gt
(h);

214 i(
	gh
 =
nu
())

216 
	gbnch
[
d
] = 
cmp
 > 0;

217 
	gth_h
[
d
++] = 
h
;

221 
t__a
(
AVLTe
 &

)

223 
	g_
 = &

;

225 
hd
 
	gh
 = 
_
->
abs
.
ro
;

227 
	gdth
 = ~0U;

229 
	gbnch
.
t
();

231 
	gh
 !
nu
()) {

232 i(
dth
 != ~0U)

233 
th_h
[
dth
] = 
h
;

234 
	gdth
++;

235 
	gh
 = 
g_
(
h
);

239 
t__ge
(
AVLTe
 &

)

241 
	g_
 = &

;

243 
hd
 
	gh
 = 
_
->
abs
.
ro
;

245 
	gdth
 = ~0U;

247 
	gbnch
.
t
();

249 
	gh
 !
nu
()) {

250 i(
dth
 != ~0U)

251 
th_h
[
dth
] = 
h
;

252 
	gdth
++;

253 
	gh
 = 
g_gt
(
h
);

257 
hd
 
	gݔ
*()

259 i(
	gdth
 == ~0U)

260  
nu
();

262  
	gdth
 =0 ? 
_
->
abs
.
ro
 : 
th_h
[
dth
 - 1];

265 
	gݔ
++()

267 i(
	gdth
 != ~0U) {

268 
hd
 
h
 = 
g_gt
(**
this
);

269 i(
	gh
 =
nu
()) {

271 i(
dth
 == 0) {

272 
dth
 = ~0U;

275 
	gdth
--;

276 } 
	gbnch
[
dth
]);

278 
	gbnch
[
dth
] = 
ue
;

279 
	gth_h
[
dth
++] = 
h
;

281 
	gh
 = 
g_
(
h
);

282 i(
	gh
 =
nu
())

284 
	gbnch
[
dth
] = 
l
;

285 
	gth_h
[
dth
++] = 
h
;

291 
	gݔ
--()

293 i(
	gdth
 != ~0U) {

294 
hd
 
h
 = 
g_
(**
this
);

295 i(
	gh
 =
nu
())

297 i(
dth
 == 0) {

298 
dth
 = ~0U;

301 
	gdth
--;

302 } !
	gbnch
[
dth
]);

304 
	gbnch
[
dth
] = 
l
;

305 
	gth_h
[
dth
++] = 
h
;

307 
	gh
 = 
g_gt
(
h
);

308 i(
	gh
 =
nu
())

310 
	gbnch
[
dth
] = 
ue
;

311 
	gth_h
[
dth
++] = 
h
;

317 
	gݔ
++({ ++(*
	gthis
); }

318 
	gݔ
--({ --(*
	gthis
); }

320 
	geed
:

323 
AVLTe
 *
_
;

329 
BS
 
	gbnch
;

332 
	gdth
;

335 
hd
 
	gth_h
[
maxDth
 - 1];

337 
cmp_k_n
(
key
 
k
, 
hd
 
h
{  
	g_
->
	gabs
.
com_key_node
(k, h); }

338 
cmp_n_n
(
hd
 
h1
, hd 
h2
{  
	g_
->
	gabs
.
com_node_node
(h1, h2); }

339 
hd
 
g_
(hd 
h
{  
	g_
->
	gabs
.
g_ss
(h); }

340 
hd
 
g_gt
(hd 
h
{  
	g_
->
	gabs
.
g_g
(h); }

341 
hd
 
nu
({  
	g_
->
	gabs
.null(); }

344 
	gme
<
tyme
 
	gfwd_
>

345 
bo
 
bud
(
fwd_
 
p
, 
size
 
num_nodes
)

347 i(
	gnum_nodes
 == 0) {

348 
abs
.
ro
 = 
nu
();

349  
	gue
;

354 
BS
 
	gbnch
;

358 
BS
 
	gm
;

361 
	gdth
 = 0;

364 
size
 
	gnum_sub
 = 
num_nodes
;

372 
hd
 
	gss_
 = 
nu
();

375 
hd
 
	gh
, 
	gchd
;

378 
	gnum_sub
 > 2) {

380 
	gnum_sub
--;

381 
	gm
[
dth
] = !!(
num_sub
 & 1);

382 
	gbnch
[
dth
++] = 
l
;

383 
	gnum_sub
 >>= 1;

386 i(
	gnum_sub
 == 2) {

392 
h
 = *
p
;

393 
	gp
++;

394 
	gchd
 = *
p
;

395 
	gp
++;

396 
t_
(
chd
, 
nu
());

397 
t_gt
(
chd
, 
nu
());

398 
t_bf
(
chd
, 0);

399 
t_gt
(
h
, 
chd
);

400 
t_
(
h
, 
nu
());

401 
t_bf
(
h
, 1);

405 
	gh
 = *
p
;

406 
	gp
++;

407 
t_
(
h
, 
nu
());

408 
t_gt
(
h
, 
nu
());

409 
t_bf
(
h
, 0);

412 
	gdth
) {

413 
	gdth
--;

414 i(!
	gbnch
[
dth
])

421 
	gchd
 = 
h
;

422 
	gh
 = 
ss_
;

423 
	gss_
 = 
g_gt
(
h
);

424 
t_gt
(
h
, 
chd
);

426 
	gnum_sub
 <<= 1;

427 
	gnum_sub
 +1 - 
m
[
dth
];

428 i(
	gnum_sub
 & (num_sub - 1))

430 
t_bf
(
h
, 0);

433 
t_bf
(
h
, 1);

436 i(
	gnum_sub
 =
num_nodes
)

443 
	gchd
 = 
h
;

444 
	gh
 = *
p
;

445 
	gp
++;

446 
t_
(
h
, 
chd
);

449 
t_gt
(
h
, 
ss_
);

450 
	gss_
 = 
h
;

453 
	gbnch
[
dth
] = 
ue
;

454 
	gnum_sub
 +
m
[
dth
++];

458 
	gabs
.
	gro
 = 
h
;

460  
	gue
;

463 
	geed
:

465 
nd
 
ass
 
It
;

469 
	gabs_us_ro
 : 
public
 
Ab
 {

471 
hd
 
ro
;

474 
abs_us_ro
 
	gabs
;

477 
hd
 
g_
(hd 
h
{  
	gabs
.
g_ss
(h); }

478 
t_
(
hd
 
h
, hd 
lh
{ 
	gabs
.
t_ss
(h,h); }

480 
hd
 
g_gt
(hd 
h
{  
	gabs
.
g_g
(h); }

481 
t_gt
(
hd
 
h
, hd 
gh
{ 
	gabs
.
t_g
(h, gh); }

483 
g_bf
(
hd
 
h
{  
	gabs
.
g_b_
(h); }

484 
t_bf
(
hd
 
h
, 
bf
{ 
	gabs
.
t_b_
(h, bf); }

486 
cmp_k_n
(
key
 
k
, 
hd
 
h
{  
	gabs
.
com_key_node
(k, h); }

487 
cmp_n_n
(
hd
 
h1
, hd 
h2
{  
	gabs
.
com_node_node
(h1, h2); }

489 
hd
 
nu
({  
	gabs
.null(); }

491 
	give
:

495 
hd
 
b
(hd 
b_h
)

497 
hd
 
dp_h
;

503 i(
g_bf
(
b_h
) > 0) {

506 
	gdp_h
 = 
g_gt
(
b_h
);

508 i(
g_bf
(
dp_h
) < 0) {

509 
hd
 
	gd_h
 = 
b_h
;

510 
	gb_h
 = 
g_
(
dp_h
);

512 
t_gt
(
d_h
, 
g_
(
b_h
));

513 
t_
(
dp_h
, 
g_gt
(
b_h
));

514 
t_
(
b_h
, 
d_h
);

515 
t_gt
(
b_h
, 
dp_h
);

517 
	gbf
 = 
g_bf
(
b_h
);

518 i(
	gbf
 != 0) {

519 i(
bf
 > 0) {

520 
t_bf
(
d_h
, -1);

521 
t_bf
(
dp_h
, 0);

523 
t_bf
(
dp_h
, 1);

524 
t_bf
(
d_h
, 0);

526 
t_bf
(
b_h
, 0);

528 
t_bf
(
d_h
, 0);

529 
t_bf
(
dp_h
, 0);

532 
t_gt
(
b_h
, 
g_
(
dp_h
));

533 
t_
(
dp_h
, 
b_h
);

534 i(
g_bf
(
dp_h
) == 0) {

535 
t_bf
(
dp_h
, -1);

536 
t_bf
(
b_h
, 1);

538 
t_bf
(
dp_h
, 0);

539 
t_bf
(
b_h
, 0);

541 
	gb_h
 = 
dp_h
;

546 
	gdp_h
 = 
g_
(
b_h
);

548 i(
g_bf
(
dp_h
) > 0) {

549 
hd
 
	gd_h
 = 
b_h
;

550 
	gb_h
 = 
g_gt
(
dp_h
);

551 
t_
(
d_h
, 
g_gt
(
b_h
));

552 
t_gt
(
dp_h
, 
g_
(
b_h
));

553 
t_gt
(
b_h
, 
d_h
);

554 
t_
(
b_h
, 
dp_h
);

556 
	gbf
 = 
g_bf
(
b_h
);

557 i(
	gbf
 != 0) {

558 i(
bf
 < 0) {

559 
t_bf
(
d_h
, 1);

560 
t_bf
(
dp_h
, 0);

562 
t_bf
(
dp_h
, -1);

563 
t_bf
(
d_h
, 0);

565 
t_bf
(
b_h
, 0);

567 
t_bf
(
d_h
, 0);

568 
t_bf
(
dp_h
, 0);

571 
t_
(
b_h
, 
g_gt
(
dp_h
));

572 
t_gt
(
dp_h
, 
b_h
);

573 i(
g_bf
(
dp_h
) == 0) {

574 
t_bf
(
dp_h
, 1);

575 
t_bf
(
b_h
, -1);

577 
t_bf
(
dp_h
, 0);

578 
t_bf
(
b_h
, 0);

580 
	gb_h
 = 
dp_h
;

584  
	gb_h
;

589 
	gme
 <
ass
 
	gAb
, 
	gmaxDth
, cs
	gBS
>

590 
le
 
tyme
 
	gAVLTe
<
	gAb
, 
	gmaxDth
, 
	gBS
>::
hd


591 
AVLTe
<
Ab
, 
	gmaxDth
, 
	gBS
>::
	$
(
hd
 
h
)

593 
	`t_
(
h
, 
	`nu
());

594 
	`t_gt
(
h
, 
	`nu
());

595 
	`t_bf
(
h
, 0);

597 i(
abs
.
ro
 =
	`nu
())

598 
abs
.
ro
 = 
h
;

601 
hd
 
unb
 = 
	`nu
();

603 
hd
 
_unb
 = 
	`nu
();

605 
unb_bf
;

608 
dth
 = 0, 
unb_dth
 = 0;

614 
BS
 
bnch
;

616 
hd
 
hh
 = 
abs
.
ro
;

617 
hd
 

 = 
	`nu
();

618 
cmp
;

621 i(
	`g_bf
(
hh
) != 0) {

622 
unb
 = 
hh
;

623 
_unb
 = 

;

624 
unb_dth
 = 
dth
;

626 
cmp
 = 
	`cmp_n_n
(
h
, 
hh
);

627 i(
cmp
 == 0)

629  
hh
;

630 

 = 
hh
;

631 
hh
 = 
cmp
 < 0 ? 
	`g_
(hh: 
	`g_gt
(hh);

632 
bnch
[
dth
++] = 
cmp
 > 0;

633 } 
hh
 !
	`nu
());

636 i(
cmp
 < 0)

637 
	`t_
(

, 
h
);

639 
	`t_gt
(

, 
h
);

641 
dth
 = 
unb_dth
;

643 i(
unb
 =
	`nu
())

644 
hh
 = 
abs
.
ro
;

646 
cmp
 = 
bnch
[
dth
++] ? 1 : -1;

647 
unb_bf
 = 
	`g_bf
(
unb
);

648 i(
cmp
 < 0)

649 
unb_bf
--;

651 
unb_bf
++;

652 
hh
 = 
cmp
 < 0 ? 
	`g_
(
unb
: 
	`g_gt
(unbal);

653 i((
unb_bf
 != -2) && (unbal_bf != 2)) {

655 
	`t_bf
(
unb
, 
unb_bf
);

656 
unb
 = 
	`nu
();

660 i(
hh
 !
	`nu
())

661 
h
 !
hh
) {

662 
cmp
 = 
bnch
[
dth
++] ? 1 : -1;

663 i(
cmp
 < 0) {

664 
	`t_bf
(
hh
, -1);

665 
hh
 = 
	`g_
(hh);

667 
	`t_bf
(
hh
, 1);

668 
hh
 = 
	`g_gt
(hh);

672 i(
unb
 !
	`nu
()) {

673 
unb
 = 
	`b
(unbal);

674 i(
_unb
 =
	`nu
())

675 
abs
.
ro
 = 
unb
;

677 
dth
 = 
unb_dth
 - 1;

678 
cmp
 = 
bnch
[
dth
] ? 1 : -1;

679 i(
cmp
 < 0)

680 
	`t_
(
_unb
, 
unb
);

682 
	`t_gt
(
_unb
, 
unb
);

687  
h
;

688 
	}
}

690 
	gme
 <
ass
 
	gAb
, 
	gmaxDth
, cs
	gBS
>

691 
le
 
tyme
 
	gAVLTe
<
	gAb
, 
	gmaxDth
, 
	gBS
>::
hd


692 
AVLTe
<
Ab
, 
	gmaxDth
, 
	gBS
>::
ch
(
key
 
k
, 
tyme
 AVLTe<Ab, 
maxDth
, 
BS
>::
SrchTy
 

)

694 cڡ 
MASK_HIGH_BIT
 = () ~ ((~ () 0) >> 1);

696 
	gcmp
, 
	grg_cmp
;

697 
hd
 
	gmch_h
 = 
nu
();

698 
hd
 
	gh
 = 
abs
.
ro
;

700 i(
	g
 & 
	gLESS
)

701 
	grg_cmp
 = 1;

702 i(
	g
 & 
	gGREATER
)

703 
	grg_cmp
 = -1;

705 
	grg_cmp
 = 0;

707 
	gh
 !
nu
()) {

708 
cmp
 = 
cmp_k_n
(
k
, 
h
);

709 i(
	gcmp
 == 0) {

710 i(

 & 
EQUAL
) {

711 
mch_h
 = 
h
;

714 
	gcmp
 = -
rg_cmp
;

715 } i(
	grg_cmp
 != 0)

716 i(!((
cmp
 ^ 
rg_cmp
& 
MASK_HIGH_BIT
))

718 
mch_h
 = 
h
;

719 
	gh
 = 
cmp
 < 0 ? 
g_
(
h
: 
g_gt
(h);

722  
	gmch_h
;

725 
	gme
 <
ass
 
	gAb
, 
	gmaxDth
, cs
	gBS
>

726 
le
 
tyme
 
	gAVLTe
<
	gAb
, 
	gmaxDth
, 
	gBS
>::
hd


727 
AVLTe
<
Ab
, 
	gmaxDth
, 
	gBS
>::
	$ch_a
()

729 
hd
 
h
 = 
abs
.
ro
, 

 = 
	`nu
();

731 
h
 !
	`nu
()) {

732 

 = 
h
;

733 
h
 = 
	`g_
(h);

736  

;

737 
	}
}

739 
	gme
 <
ass
 
	gAb
, 
	gmaxDth
, cs
	gBS
>

740 
le
 
tyme
 
	gAVLTe
<
	gAb
, 
	gmaxDth
, 
	gBS
>::
hd


741 
AVLTe
<
Ab
, 
	gmaxDth
, 
	gBS
>::
	$ch_ge
()

743 
hd
 
h
 = 
abs
.
ro
, 

 = 
	`nu
();

745 
h
 !
	`nu
()) {

746 

 = 
h
;

747 
h
 = 
	`g_gt
(h);

750  

;

751 
	}
}

753 
	gme
 <
ass
 
	gAb
, 
	gmaxDth
, cs
	gBS
>

754 
le
 
tyme
 
	gAVLTe
<
	gAb
, 
	gmaxDth
, 
	gBS
>::
hd


755 
AVLTe
<
Ab
, 
	gmaxDth
, 
	gBS
>::
	$move
(
key
 
k
)

758 
dth
 = 0, 
rm_dth
;

764 
BS
 
bnch
;

766 
hd
 
h
 = 
abs
.
ro
;

767 
hd
 

 = 
	`nu
(), 
chd
;

768 
cmp
, 
cmp_sh܋d_sub_wh_th
 = 0;

771 i(
h
 =
	`nu
())

773  
	`nu
();

774 
cmp
 = 
	`cmp_k_n
(
k
, 
h
);

775 i(
cmp
 == 0)

778 

 = 
h
;

779 
h
 = 
cmp
 < 0 ? 
	`g_
(h: 
	`g_gt
(h);

780 
bnch
[
dth
++] = 
cmp
 > 0;

781 
cmp_sh܋d_sub_wh_th
 = 
cmp
;

783 
hd
 
rm
 = 
h
;

784 
hd
 
_rm
 = 

;

785 
rm_dth
 = 
dth
;

794 i(
	`g_bf
(
h
) < 0) {

795 
chd
 = 
	`g_
(
h
);

796 
bnch
[
dth
] = 
l
;

797 
cmp
 = -1;

799 
chd
 = 
	`g_gt
(
h
);

800 
bnch
[
dth
] = 
ue
;

801 
cmp
 = 1;

803 
dth
++;

805 i(
chd
 !
	`nu
()) {

806 
cmp
 = -cmp;

808 

 = 
h
;

809 
h
 = 
chd
;

810 i(
cmp
 < 0) {

811 
chd
 = 
	`g_
(
h
);

812 
bnch
[
dth
] = 
l
;

814 
chd
 = 
	`g_gt
(
h
);

815 
bnch
[
dth
] = 
ue
;

817 
dth
++;

818 } 
chd
 !
	`nu
());

820 i(

 =
rm
)

823 
cmp_sh܋d_sub_wh_th
 = -
cmp
;

825 
cmp_sh܋d_sub_wh_th
 = 
cmp
;

828 
chd
 = 
cmp
 > 0 ? 
	`g_
(
h
: 
	`g_gt
(h);

831 i(

 =
	`nu
())

833 
abs
.
ro
 = 
chd
;

834 i(
cmp_sh܋d_sub_wh_th
 < 0)

835 
	`t_
(

, 
chd
);

837 
	`t_gt
(

, 
chd
);

843 
hd
 
th
 = 

 =
rm
 ? 
h
 :arent;

845 i(
h
 !
rm
) {

847 
	`t_
(
h
, 
	`g_
(
rm
));

848 
	`t_gt
(
h
, 
	`g_gt
(
rm
));

849 
	`t_bf
(
h
, 
	`g_bf
(
rm
));

850 i(
_rm
 =
	`nu
())

851 
abs
.
ro
 = 
h
;

853 
dth
 = 
rm_dth
 - 1;

854 i(
bnch
[
dth
])

855 
	`t_gt
(
_rm
, 
h
);

857 
	`t_
(
_rm
, 
h
);

861 i(
th
 !
	`nu
()) {

864 
h
 = 
abs
.
ro
;

865 

 = 
	`nu
();

866 
dth
 = 0;

867 
h
 !
th
) {

868 i(
bnch
[
dth
++]) {

869 
chd
 = 
	`g_gt
(
h
);

870 
	`t_gt
(
h
, 

);

872 
chd
 = 
	`g_
(
h
);

873 
	`t_
(
h
, 

);

875 

 = 
h
;

876 
h
 = 
chd
;

881 
bo
 
dud_dth
 = 
ue
;

882 
bf
;

883 
cmp
 = 
cmp_sh܋d_sub_wh_th
;

885 i(
dud_dth
) {

886 
bf
 = 
	`g_bf
(
h
);

887 i(
cmp
 < 0)

888 
bf
++;

890 
bf
--;

891 i((
bf
 == -2) || (bf == 2)) {

892 
h
 = 
	`b
(h);

893 
bf
 = 
	`g_bf
(
h
);

895 
	`t_bf
(
h
, 
bf
);

896 
dud_dth
 = (
bf
 == 0);

898 i(

 =
	`nu
())

900 
chd
 = 
h
;

901 
h
 = 

;

902 
cmp
 = 
bnch
[--
dth
] ? 1 : -1;

903 i(
cmp
 < 0) {

904 

 = 
	`g_
(
h
);

905 
	`t_
(
h
, 
chd
);

907 

 = 
	`g_gt
(
h
);

908 
	`t_gt
(
h
, 
chd
);

911 
abs
.
ro
 = 
h
;

914  
rm
;

915 
	}
}

917 
	gme
 <
ass
 
	gAb
, 
	gmaxDth
, cs
	gBS
>

918 
le
 
tyme
 
	gAVLTe
<
	gAb
, 
	gmaxDth
, 
	gBS
>::
hd


919 
AVLTe
<
Ab
, 
	gmaxDth
, 
	gBS
>::
	$sub
(
hd
 
w_node
)

921 
hd
 
h
 = 
abs
.
ro
;

922 
hd
 

 = 
	`nu
();

923 
cmp
, 
ϡ_cmp
;

927 i(
h
 =
	`nu
())

929  
	`nu
();

930 
cmp
 = 
	`cmp_n_n
(
w_node
, 
h
);

931 i(
cmp
 == 0)

934 
ϡ_cmp
 = 
cmp
;

935 

 = 
h
;

936 
h
 = 
cmp
 < 0 ? 
	`g_
(h: 
	`g_gt
(h);

940 
	`t_
(
w_node
, 
	`g_
(
h
));

941 
	`t_gt
(
w_node
, 
	`g_gt
(
h
));

942 
	`t_bf
(
w_node
, 
	`g_bf
(
h
));

944 i(

 =
	`nu
())

946 
abs
.
ro
 = 
w_node
;

949 i(
ϡ_cmp
 < 0)

950 
	`t_
(

, 
w_node
);

952 
	`t_gt
(

, 
w_node
);

955  
h
;

956 
	}
}

	@Assertions.cpp

32 #agm
GCC
 
dgnoic
 
igned
 "-Wmissing-format-attribute"

34 
	~"cfig.h
"

35 
	~"Asis.h
"

37 
	~"Comp.h
"

38 
	~<wtf/StdLibExas.h
>

39 
	~<wtf/SgExas.h
>

40 
	~<wtf/xt/CSg.h
>

41 
	~<wtf/xt/WTFSg.h
>

43 
	~<dio.h
>

44 
	~<rg.h
>

46 #i
HAVE
(
SIGNAL_H
)

47 
	~<sigl.h
>

50 #i
USE
(
CF
)

51 
	~<CeFoundi/CFSg.h
>

52 #i
PLATFORM
(
IOS
|| 
__MAC_OS_X_VERSION_MIN_REQUIRED
 >= 1080

53 
	#WTF_USE_APPLE_SYSTEM_LOG
 1

	)

54 
	~<a.h
>

58 #i
COMPILER
(
MSVC
)

59 
	~<tdbg.h
>

62 #i
OS
(
WINDOWS
)

63 
	~<wdows.h
>

66 #i
OS
(
DARWIN
)

67 
	~<sys/sysl.h
>

68 
	~<unid.h
>

71 #i
OS
(
DARWIN
|| (OS(
LINUX
&& !
defed
(
__UCLIBC__
))

72 
	~<cxxabi.h
>

73 
	~<dlf.h
>

74 
	~<execfo.h
>

79 
WTF_ATTRIBUTE_PRINTF
(1, 0)

80 
vtf_dr_comm
(cڡ * 
fm
, 
va_li
 
gs
)

82 #i
USE
(
CF
&& !
OS
(
WINDOWS
)

83 i(
rr
(
fm
, "%@")) {

84 
CFSgRef
 
cfFm
 = 
CFSgCeWhCSg
(
NULL
, 
fm
, 
kCFSgEncodgUTF8
);

86 #i
COMPILER
(
CLANG
)

87 #agm
g
 
dgnoic
 
push


88 #agm
g
 
dgnoic
 
igned
 "-Wformat-nonliteral"

90 
CFSgRef
 
r
 = 
CFSgCeWhFmAndArgumts
(
NULL
, NULL, 
cfFm
, 
gs
);

91 #i
COMPILER
(
CLANG
)

92 #agm
g
 
dgnoic
 
p


94 
CFIndex
 
ngth
 = 
CFSgGMaximumSizeFEncodg
(
CFSgGLgth
(
r
), 
kCFSgEncodgUTF8
);

95 * 
bufr
 = (*)
mloc
(
ngth
 + 1);

97 
CFSgGCSg
(
r
, 
bufr
, 
ngth
, 
kCFSgEncodgUTF8
);

99 #i
USE
(
APPLE_SYSTEM_LOG
)

100 
a_log
(0, 0, 
ASL_LEVEL_NOTICE
, "%s", 
bufr
);

102 
uts
(
bufr
, 
dr
);

104 

(
bufr
);

105 
CFR
(
r
);

106 
CFR
(
cfFm
);

110 #i
USE
(
APPLE_SYSTEM_LOG
)

111 
va_li
 
cyOfArgs
;

112 
va_cy
(
cyOfArgs
, 
gs
);

113 
a_vlog
(0, 0, 
ASL_LEVEL_NOTICE
, 
fm
, 
cyOfArgs
);

114 
va_d
(
cyOfArgs
);

119 #i
HAVE
(
ISDEBUGGERPRESENT
)

120 i(
IsDebuggP
()) {

121 
size_t
 
size
 = 1024;

124 * 
bufr
 = (*)
mloc
(
size
);

126 i(
bufr
 =
NULL
)

129 i(
_vtf
(
bufr
, 
size
, 
fm
, 
gs
) != -1) {

130 
OuutDebugSgA
(
bufr
);

131 

(
bufr
);

135 

(
bufr
);

136 
size
 *= 2;

137 } 
size
 > 1024);

140 
vrtf
(
dr
, 
fm
, 
gs
);

143 #i
COMPILER
(
CLANG
|| COMPILER(
GCC
)

144 #agm
GCC
 
dgnoic
 
push


145 #agm
GCC
 
dgnoic
 
igned
 "-Wformat-nonliteral"

148 
vtf_dr_wh_efix
(cڡ * 
efix
, cڡ * 
fm
, 
va_li
 
gs
)

150 
size_t
 
efixLgth
 = 

(
efix
);

151 
size_t
 
fmLgth
 = 

(
fm
);

152 aut
fmWhPfix
 = 
d
::
make_unique
<[]>(
efixLgth
 + 
fmLgth
 + 1);

153 
memy
(
fmWhPfix
.
g
(), 
efix
, 
efixLgth
);

154 
memy
(
fmWhPfix
.
g
(+ 
efixLgth
, 
fm
, 
fmLgth
);

155 
fmWhPfix
[
efixLgth
 + 
fmLgth
] = 0;

157 
vtf_dr_comm
(
fmWhPfix
.
g
(), 
gs
);

160 
vtf_dr_wh_ag_wle
(cڡ * 
fm
, 
va_li
 
gs
)

162 
size_t
 
fmLgth
 = 

(
fm
);

163 i(
fmLgth
 && 
fm
[formatLength - 1] == '\n') {

164 
vtf_dr_comm
(
fm
, 
gs
);

168 aut
fmWhNewle
 = 
d
::
make_unique
<[]>(
fmLgth
 + 2);

169 
memy
(
fmWhNewle
.
g
(), 
fm
, 
fmLgth
);

170 
fmWhNewle
[
fmLgth
] = '\n';

171 
fmWhNewle
[
fmLgth
 + 1] = 0;

173 
vtf_dr_comm
(
fmWhNewle
.
g
(), 
gs
);

176 #i
COMPILER
(
CLANG
|| COMPILER(
GCC
)

177 #agm
GCC
 
dgnoic
 
p


180 
WTF_ATTRIBUTE_PRINTF
(1, 2)

181 
tf_dr_comm
(cڡ * 
fm
, ...)

183 
va_li
 
gs
;

184 
va_t
(
gs
, 
fm
);

185 
vtf_dr_comm
(
fm
, 
gs
);

186 
va_d
(
gs
);

189 
tClSe
(cڡ * 
fe
, 
le
, cڡ * 
funi
)

191 #i
OS
(
WINDOWS
&& 
defed
(
_DEBUG
)

192 
_CDbgRt
(
_CRT_WARN
, 
fe
, 
le
, 
NULL
, "%s\n", 
funi
);

197 
tf_dr_comm
("%s(%d: %s\n", 
fe
, 
le
, 
funi
);

201 
WTFRtAsiFau
(cڡ * 
fe
, 
le
, cڡ * 
funi
, cڡ * 
asi
)

203 i(
asi
)

204 
tf_dr_comm
("ASSERTION FAILED: %s\n", 
asi
);

206 
tf_dr_comm
("SHOULD NEVER BE REACHED\n");

207 
tClSe
(
fe
, 
le
, 
funi
);

210 
WTFRtAsiFauWhMesge
(cڡ * 
fe
, 
le
, cڡ * 
funi
, cڡ * 
asi
, cڡ * 
fm
, ...)

212 
va_li
 
gs
;

213 
va_t
(
gs
, 
fm
);

214 
vtf_dr_wh_efix
("ASSERTION FAILED: ", 
fm
, 
gs
);

215 
va_d
(
gs
);

216 
tf_dr_comm
("\n%s\n", 
asi
);

217 
tClSe
(
fe
, 
le
, 
funi
);

220 
WTFRtArgumtAsiFau
(cڡ * 
fe
, 
le
, cڡ * 
funi
, cڡ * 
gName
, cڡ * 
asi
)

222 
tf_dr_comm
("ARGUMENT BAD: %s, %s\n", 
gName
, 
asi
);

223 
tClSe
(
fe
, 
le
, 
funi
);

226 
WTFGBacka
(** 
ack
, * 
size
)

228 #i
OS
(
DARWIN
|| (OS(
LINUX
&& !
defed
(
__UCLIBC__
))

229 *
size
 = 
backa
(
ack
, *size);

230 #i
OS
(
WINDOWS
)

234 
WORD
 (
	tNTAPI
* 
	tRCtuSckBackTFunc
)(
	tDWORD
, DWORD, 
	tPVOID
*, 
	tPDWORD
);

235 
HMODULE
 
kl32
 = ::
GModuHdW
(
L
"Kernel32.dll");

236 i(!
kl32
) {

237 *
size
 = 0;

240 
RCtuSckBackTFunc
 
uSckBackTFunc
 = 
t_
<RtlCaptureStackBackTraceFunc>(

241 ::
GProcAddss
(
kl32
, "RtlCaptureStackBackTrace"));

242 i(
uSckBackTFunc
)

243 *
size
 = 
uSckBackTFunc
(0, *size, 
ack
, 0);

245 *
size
 = 0;

247 *
size
 = 0;

251 
WTFRtBacka
()

253 cڡ 
amesToShow
 = 31;

254 cڡ 
amesToSk
 = 2;

255 * 
mes
[
amesToShow
 + 
amesToSk
];

256 
ames
 = 
amesToShow
 + 
amesToSk
;

258 
WTFGBacka
(
mes
, &
ames
);

259 
WTFPrtBacka
(
mes
 + 
amesToSk
, 
ames
 - framesToSkip);

262 #i
OS
(
DARWIN
|| OS(
LINUX
)

263 #i
PLATFORM
(
GTK
)

264 #i
defed
(
__GLIBC__
&& !defed(
__UCLIBC__
)

265 
	#WTF_USE_BACKTRACE_SYMBOLS
 1

	)

268 
	#WTF_USE_DLADDR
 1

	)

272 
WTFPrtBacka
(** 
ack
, 
size
)

274 #i
USE
(
BACKTRACE_SYMBOLS
)

275 ** 
symbs
 = 
backa_symbs
(
ack
, 
size
);

276 i(!
symbs
)

280 
i
 = 0; i < 
size
; ++i) {

281 cڡ * 
mgdName
 = 0;

282 * 
cxaDemgd
 = 0;

283 #i
USE
(
BACKTRACE_SYMBOLS
)

284 
mgdName
 = 
symbs
[
i
];

285 #i
USE
(
DLADDR
)

286 
Dl_fo
 
fo
;

287 i(
dddr
(
ack
[
i
], &
fo
&& info.
dli_ame
)

288 
mgdName
 = 
fo
.
dli_ame
;

289 i(
mgdName
)

290 
cxaDemgd
 = 
abi
::
__cxa_demg
(
mgdName
, 0, 0, 0);

292 cڡ 
ameNumb
 = 
i
 + 1;

293 i(
mgdName
 || 
cxaDemgd
)

294 
tf_dr_comm
("%-3d %%s\n", 
ameNumb
, 
ack
[
i
], 
cxaDemgd
 ? cxaDemgd : 
mgdName
);

296 
tf_dr_comm
("%-3d %p\n", 
ameNumb
, 
ack
[
i
]);

297 

(
cxaDemgd
);

300 #i
USE
(
BACKTRACE_SYMBOLS
)

301 

(
symbs
);

305 #unde
WTF_USE_BACKTRACE_SYMBOLS


306 #unde
WTF_USE_DLADDR


308 
WTFCshHookFuni
 
globHook
 = 0;

310 
WTFSCshHook
(
WTFCshHookFuni
 
funi
)

312 
globHook
 = 
funi
;

315 
WTFCsh
()

317 i(
globHook
)

318 
globHook
();

320 
WTFRtBacka
();

321 *(*)(
u_t
)0xbbadbeef = 0;

323 #i
COMPILER
(
CLANG
)

324 
__but_
();

330 
WTFCshWhSecuryImiti
()

332 i(
globHook
)

333 
globHook
();

334 
WTFRtBacka
();

335 *(*)(
u_t
)0xfbadbeef = 0;

337 #i
COMPILER
(
CLANG
)

338 
__but_
();

344 #i
HAVE
(
SIGNAL_H
)

345 
NO_RETURN
 
dumpBackaSiglHdr
(
sig
)

347 
WTFRtBacka
();

348 
ex
(128 + 
sig
);

351 
lSiglHdrsFFEs
((*
hdr
)())

353 
sigl
(
SIGILL
, 
hdr
);

354 
sigl
(
SIGTRAP
, 
hdr
);

355 
sigl
(
SIGFPE
, 
hdr
);

356 
sigl
(
SIGBUS
, 
hdr
);

357 
sigl
(
SIGSEGV
, 
hdr
);

358 
sigl
(
SIGSYS
, 
hdr
);

359 
sigl
(
SIGPIPE
, 
hdr
);

360 
sigl
(
SIGXCPU
, 
hdr
);

361 
sigl
(
SIGXFSZ
, 
hdr
);

364 
tSiglHdrsFFEs
()

366 
lSiglHdrsFFEs
(
SIG_DFL
);

370 
WTFInlRtBackaOnCshHook
()

372 #i
HAVE
(
SIGNAL_H
)

375 
WTFSCshHook
(&
tSiglHdrsFFEs
);

376 
lSiglHdrsFFEs
(&
dumpBackaSiglHdr
);

380 
bo
 
WTFIsDebuggAached
()

382 #i
OS
(
DARWIN
)

383 
kfo_oc
 
fo
;

384 
mib
[] = { 
CTL_KERN
, 
KERN_PROC
, 
KERN_PROC_PID
, 
gpid
() };

385 
size_t
 
size
 = (
fo
);

386 i(
sysl
(
mib
, (mib/ (mib[0]), &
fo
, &
size
, 
nuαr
, 0) == -1)

387  
l
;

388  
fo
.
kp_oc
.
p_ag
 & 
P_TRACED
;

390  
l
;

394 
WTFRtFE
(cڡ * 
fe
, 
le
, cڡ * 
funi
, cڡ * 
fm
, ...)

396 
va_li
 
gs
;

397 
va_t
(
gs
, 
fm
);

398 
vtf_dr_wh_efix
("FATAL ERROR: ", 
fm
, 
gs
);

399 
va_d
(
gs
);

400 
tf_dr_comm
("\n");

401 
tClSe
(
fe
, 
le
, 
funi
);

404 
WTFRtE
(cڡ * 
fe
, 
le
, cڡ * 
funi
, cڡ * 
fm
, ...)

406 
va_li
 
gs
;

407 
va_t
(
gs
, 
fm
);

408 
vtf_dr_wh_efix
("ERROR: ", 
fm
, 
gs
);

409 
va_d
(
gs
);

410 
tf_dr_comm
("\n");

411 
tClSe
(
fe
, 
le
, 
funi
);

414 
WTFLog
(
WTFLogChl
* 
chl
, cڡ * 
fm
, ...)

416 i(
chl
->
e
 !
WTFLogChlOn
)

419 
va_li
 
gs
;

420 
va_t
(
gs
, 
fm
);

421 
vtf_dr_wh_ag_wle
(
fm
, 
gs
);

422 
va_d
(
gs
);

425 
WTFLogVbo
(cڡ * 
fe
, 
le
, cڡ * 
funi
, 
WTFLogChl
* 
chl
, cڡ * 
fm
, ...)

427 i(
chl
->
e
 !
WTFLogChlOn
)

430 
va_li
 
gs
;

431 
va_t
(
gs
, 
fm
);

432 
vtf_dr_wh_ag_wle
(
fm
, 
gs
);

433 
va_d
(
gs
);

435 
tClSe
(
fe
, 
le
, 
funi
);

438 
WTFLogAlwaysV
(cڡ * 
fm
, 
va_li
 
gs
)

440 
vtf_dr_wh_ag_wle
(
fm
, 
gs
);

443 
WTFLogAlways
(cڡ * 
fm
, ...)

445 
va_li
 
gs
;

446 
va_t
(
gs
, 
fm
);

447 
WTFLogAlwaysV
(
fm
, 
gs
);

448 
va_d
(
gs
);

451 
WTFLogAlwaysAndCsh
(cڡ * 
fm
, ...)

453 
va_li
 
gs
;

454 
va_t
(
gs
, 
fm
);

455 
WTFLogAlwaysV
(
fm
, 
gs
);

456 
va_d
(
gs
);

457 
WTFCsh
();

460 
WTFLogChl
* 
WTFLogChlByName
(WTFLogChl* 
chls
[], 
size_t
 
cou
, cڡ * 
me
)

462 
size_t
 
i
 = 0; i < 
cou
; ++i) {

463 
WTFLogChl
* 
chl
 = 
chls
[
i
];

464 i(!
rcmp
(
me
, 
chl
->name))

465  
chl
;

471 
tSOfAChls
(
WTFLogChl
* 
chls
[], 
size_t
 
chlCou
, 
WTFLogChlS
 
e
)

473 
size_t
 
i
 = 0; i < 
chlCou
; ++i)

474 
chls
[
i
]->
e
 = state;

477 
WTFInlizeLogChlSsFromSg
(
WTFLogChl
* 
chls
[], 
size_t
 
cou
, cڡ * 
logLev
)

479 
Sg
 
logLevSg
 = 
logLev
;

480 
Ve
<
Sg
> 
compڒts
;

481 
logLevSg
.
l
(',', 
compڒts
);

483 
size_t
 
i
 = 0; i < 
compڒts
.
size
(); ++i) {

484 
Sg
 
compڒt
 = 
compڒts
[
i
];

486 
WTFLogChlS
 
logChlS
 = 
WTFLogChlOn
;

487 i(
compڒt
.
tsWh
('-')) {

488 
logChlS
 = 
WTFLogChlOff
;

489 
compڒt
 = compڒt.
subrg
(1);

492 i(
equIgnܚgCa
(
compڒt
, "all")) {

493 
tSOfAChls
(
chls
, 
cou
, 
logChlS
);

497 i(
WTFLogChl
* 
chl
 = 
WTFLogChlByName
(
chls
, 
cou
, 
compڒt
.
utf8
().
da
()))

498 
chl
->
e
 = 
logChlS
;

500 
WTFLogAlways
("Unknowloggg chl: %s", 
compڒt
.
utf8
().
da
());

	@Assertions.h

26 #ide
WTF_Asis_h


27 
	#WTF_Asis_h


	)

39 
	~<ys.h
>

40 
	~<dg.h
>

41 
	~<dbo.h
>

42 
	~<ddef.h
>

44 #ifde
NDEBUG


46 
	#ASSERTIONS_DISABLED_DEFAULT
 1

	)

48 
	#ASSERTIONS_DISABLED_DEFAULT
 0

	)

51 #ide
BACKTRACE_DISABLED


52 
	#BACKTRACE_DISABLED
 
ASSERTIONS_DISABLED_DEFAULT


	)

55 #ide
ASSERT_DISABLED


56 
	#ASSERT_DISABLED
 
ASSERTIONS_DISABLED_DEFAULT


	)

59 #ide
ASSERT_MSG_DISABLED


60 
	#ASSERT_MSG_DISABLED
 
ASSERTIONS_DISABLED_DEFAULT


	)

63 #ide
ASSERT_ARG_DISABLED


64 
	#ASSERT_ARG_DISABLED
 
ASSERTIONS_DISABLED_DEFAULT


	)

67 #ide
FATAL_DISABLED


68 
	#FATAL_DISABLED
 
ASSERTIONS_DISABLED_DEFAULT


	)

71 #ide
ERROR_DISABLED


72 
	#ERROR_DISABLED
 
ASSERTIONS_DISABLED_DEFAULT


	)

75 #ide
LOG_DISABLED


76 
	#LOG_DISABLED
 
ASSERTIONS_DISABLED_DEFAULT


	)

79 #i
COMPILER
(
GCC
)

80 
	#WTF_PRETTY_FUNCTION
 
__PRETTY_FUNCTION__


	)

82 
	#WTF_PRETTY_FUNCTION
 
__FUNCTION__


	)

88 #i
COMPILER
(
GCC
&& !
defed
(
__OBJC__
)

89 
	#WTF_ATTRIBUTE_PRINTF
(
fmSgArgumt
, 
exaArgumts

	`__ibu__
((
	`__fm__
(
tf
, fmSgArgumt,xaArgumts)))

	)

91 
	#WTF_ATTRIBUTE_PRINTF
(
fmSgArgumt
, 
exaArgumts
)

	)

94 #i
PLATFORM
(
IOS
)

96 #ide
WTF_EXPORT_PRIVATE


97 
	#WTF_EXPORT_PRIVATE


	)

103 #ifde
__lulus


115 #i
COMPILER
(
CLANG
|| COMPILER(
MSVC
)

116 
	#NO_RETURN_DUE_TO_CRASH
 
NO_RETURN


	)

118 
	#NO_RETURN_DUE_TO_CRASH


	)

121 um { 
WTFLogChlOff
, 
WTFLogChlOn
 } 
	tWTFLogChlS
;

124 
WTFLogChlS
 
e
;

125 cڡ * 
me
;

126 } 
	tWTFLogChl
;

128 
WTF_EXPORT_PRIVATE
 
WTFRtAsiFau
(cڡ * 
fe
, 
le
, cڡ * 
funi
, cڡ * 
asi
);

129 
WTF_EXPORT_PRIVATE
 
WTFRtAsiFauWhMesge
(cڡ * 
fe
, 
le
, cڡ * 
funi
, cڡ * 
asi
, cڡ * 
fm
, ...
WTF_ATTRIBUTE_PRINTF
(5, 6);

130 
WTF_EXPORT_PRIVATE
 
WTFRtArgumtAsiFau
(cڡ * 
fe
, 
le
, cڡ * 
funi
, cڡ * 
gName
, cڡ * 
asi
);

131 
WTF_EXPORT_PRIVATE
 
WTFRtFE
(cڡ * 
fe
, 
le
, cڡ * 
funi
, cڡ * 
fm
, ...
WTF_ATTRIBUTE_PRINTF
(4, 5);

132 
WTF_EXPORT_PRIVATE
 
WTFRtE
(cڡ * 
fe
, 
le
, cڡ * 
funi
, cڡ * 
fm
, ...
WTF_ATTRIBUTE_PRINTF
(4, 5);

133 
WTF_EXPORT_PRIVATE
 
WTFLog
(
WTFLogChl
*, cڡ * 
fm
, ...
WTF_ATTRIBUTE_PRINTF
(2, 3);

134 
WTF_EXPORT_PRIVATE
 
WTFLogVbo
(cڡ * 
fe
, 
le
, cڡ * 
funi
, 
WTFLogChl
*, cڡ * 
fm
, ...
WTF_ATTRIBUTE_PRINTF
(5, 6);

135 
WTF_EXPORT_PRIVATE
 
WTFLogAlwaysV
(cڡ * 
fm
, 
va_li
);

136 
WTF_EXPORT_PRIVATE
 
WTFLogAlways
(cڡ * 
fm
, ...
WTF_ATTRIBUTE_PRINTF
(1, 2);

137 
WTF_EXPORT_PRIVATE
 
NO_RETURN_DUE_TO_CRASH
 
WTFLogAlwaysAndCsh
(cڡ * 
fm
, ...
WTF_ATTRIBUTE_PRINTF
(1, 2);

138 
WTF_EXPORT_PRIVATE
 
WTFLogChl
* 
WTFLogChlByName
(WTFLogChl*[], 
size_t
 
cou
, const *);

139 
WTF_EXPORT_PRIVATE
 
WTFInlizeLogChlSsFromSg
(
WTFLogChl
*[], 
size_t
 
cou
, const *);

141 
WTF_EXPORT_PRIVATE
 
WTFGBacka
(** 
ack
, * 
size
);

142 
WTF_EXPORT_PRIVATE
 
WTFRtBacka
();

143 
WTF_EXPORT_PRIVATE
 
WTFPrtBacka
(** 
ack
, 
size
);

145 (*
WTFCshHookFuni
)();

146 
WTF_EXPORT_PRIVATE
 
WTFSCshHook
(
WTFCshHookFuni
);

147 
WTF_EXPORT_PRIVATE
 
WTFInlRtBackaOnCshHook
();

149 
WTF_EXPORT_PRIVATE
 
bo
 
WTFIsDebuggAached
();

151 #ifde
__lulus


155 #ide
CRASH


156 
	#CRASH
(
	`WTFCsh
()

	)

159 #ifde
__lulus


162 
WTF_EXPORT_PRIVATE
 
NO_RETURN_DUE_TO_CRASH
 
WTFCsh
();

163 #ifde
__lulus


167 #ide
CRASH_WITH_SECURITY_IMPLICATION


168 
	#CRASH_WITH_SECURITY_IMPLICATION
(
	`WTFCshWhSecuryImiti
()

	)

171 #ifde
__lulus


174 
WTF_EXPORT_PRIVATE
 
NO_RETURN_DUE_TO_CRASH
 
WTFCshWhSecuryImiti
();

175 #ifde
__lulus


184 #i
BACKTRACE_DISABLED


186 
	#BACKTRACE
((()0)

	)

190 
	#BACKTRACE
() do { \

191 
	`WTFRtBacka
(); \

192 } 
l
)

	)

202 #i
OS
(
WINDOWS
)

204 #unde
ASSERT


207 #i
ASSERT_DISABLED


209 
	#ASSERT
(
asi
(()0)

	)

210 
	#ASSERT_AT
(
asi
, 
fe
, 
le
, 
funi
(()0)

	)

211 
	#ASSERT_NOT_REACHED
((()0)

	)

212 
	#NO_RETURN_DUE_TO_ASSERT


	)

214 
	#ASSERT_UNUSED
(
vb
, 
asi
(()vb)

	)

216 #ifde
ADDRESS_SANITIZER


217 
	#ASSERT_WITH_SECURITY_IMPLICATION
(
asi
) \

218 (!(
asi
) ? \

219 (
	`WTFRtAsiFau
(
__FILE__
, 
__LINE__
, 
WTF_PRETTY_FUNCTION
, #assertion), \

220 
	`CRASH_WITH_SECURITY_IMPLICATION
()) : \

221 ()0)

	)

223 
	#ASSERT_WITH_SECURITY_IMPLICATION_DISABLED
 0

	)

225 
	#ASSERT_WITH_SECURITY_IMPLICATION
(
asi
(()0)

	)

226 
	#ASSERT_WITH_SECURITY_IMPLICATION_DISABLED
 1

	)

231 
	#ASSERT
(
asi
) \

232 (!(
asi
) ? \

233 (
	`WTFRtAsiFau
(
__FILE__
, 
__LINE__
, 
WTF_PRETTY_FUNCTION
, #assertion), \

234 
	`CRASH
()) : \

235 ()0)

	)

237 
	#ASSERT_AT
(
asi
, 
fe
, 
le
, 
funi
) \

238 (!(
asi
) ? \

239 (
	`WTFRtAsiFau
(
fe
, 
le
, 
funi
, #assertion), \

240 
	`CRASH
()) : \

241 ()0)

	)

243 
	#ASSERT_NOT_REACHED
() do { \

244 
	`WTFRtAsiFau
(
__FILE__
, 
__LINE__
, 
WTF_PRETTY_FUNCTION
, 0); \

245 
	`CRASH
(); \

246 } 0)

	)

248 
	#ASSERT_UNUSED
(
vb
, 
asi

	`ASSERT
si)

	)

250 
	#NO_RETURN_DUE_TO_ASSERT
 
NO_RETURN_DUE_TO_CRASH


	)

260 
	#ASSERT_WITH_SECURITY_IMPLICATION
(
asi
) \

261 (!(
asi
) ? \

262 (
	`WTFRtAsiFau
(
__FILE__
, 
__LINE__
, 
WTF_PRETTY_FUNCTION
, #assertion), \

263 
	`CRASH_WITH_SECURITY_IMPLICATION
()) : \

264 ()0)

	)

265 
	#ASSERT_WITH_SECURITY_IMPLICATION_DISABLED
 0

	)

270 #i
ASSERT_MSG_DISABLED


271 
	#ASSERT_WITH_MESSAGE
(
asi
, ...(()0)

	)

273 
	#ASSERT_WITH_MESSAGE
(
asi
, ...) do \

274 i(!(
asi
)) { \

275 
	`WTFRtAsiFauWhMesge
(
__FILE__
, 
__LINE__
, 
WTF_PRETTY_FUNCTION
, #asi, 
__VA_ARGS__
); \

276 
	`CRASH
(); \

278 0)

	)

283 #i
ASSERT_MSG_DISABLED


284 
	#ASSERT_WITH_MESSAGE_UNUSED
(
vb
, 
asi
, ...(()vb)

	)

286 
	#ASSERT_WITH_MESSAGE_UNUSED
(
vb
, 
asi
, ...) do \

287 i(!(
asi
)) { \

288 
	`WTFRtAsiFauWhMesge
(
__FILE__
, 
__LINE__
, 
WTF_PRETTY_FUNCTION
, #asi, 
__VA_ARGS__
); \

289 
	`CRASH
(); \

291 0)

	)

297 #i
ASSERT_ARG_DISABLED


299 
	#ASSERT_ARG
(
gName
, 
asi
(()0)

	)

303 
	#ASSERT_ARG
(
gName
, 
asi
) do \

304 i(!(
asi
)) { \

305 
	`WTFRtArgumtAsiFau
(
__FILE__
, 
__LINE__
, 
WTF_PRETTY_FUNCTION
, #argName, #assertion); \

306 
	`CRASH
(); \

308 0)

	)

313 #ide
COMPILE_ASSERT


314 #i
COMPILER_SUPPORTS
(
C_STATIC_ASSERT
)

316 
	#COMPILE_ASSERT
(
exp
, 
me

	`_Stic_as
(xp), #me)

	)

318 
	#COMPILE_ASSERT
(
exp
, 
me

	`ic_as
(xp), #me)

	)

324 #i
FATAL_DISABLED


325 
	#FATAL
(...(()0)

	)

327 
	#FATAL
(...) do { \

328 
	`WTFRtFE
(
__FILE__
, 
__LINE__
, 
WTF_PRETTY_FUNCTION
, 
__VA_ARGS__
); \

329 
	`CRASH
(); \

330 } 0)

	)

335 #i
ERROR_DISABLED


336 
	#LOG_ERROR
(...(()0)

	)

338 
	#LOG_ERROR
(...
	`WTFRtE
(
__FILE__
, 
__LINE__
, 
WTF_PRETTY_FUNCTION
, 
__VA_ARGS__
)

	)

343 #i
LOG_DISABLED


344 
	#LOG
(
chl
, ...(()0)

	)

346 
	#LOG
(
chl
, ...
	`WTFLog
(&
	`JOIN_LOG_CHANNEL_WITH_PREFIX
(
LOG_CHANNEL_PREFIX
, chl), 
__VA_ARGS__
)

	)

347 
	#JOIN_LOG_CHANNEL_WITH_PREFIX
(
efix
, 
chl

	`JOIN_LOG_CHANNEL_WITH_PREFIX_LEVEL_2
ջfix, chl)

	)

348 
	#JOIN_LOG_CHANNEL_WITH_PREFIX_LEVEL_2
(
efix
, 
chl
efix ## 
	)
channel

353 #i
LOG_DISABLED


354 
	#LOG_VERBOSE
(
chl
, ...(()0)

	)

356 
	#LOG_VERBOSE
(
chl
, ...
	`WTFLogVbo
(
__FILE__
, 
__LINE__
, 
WTF_PRETTY_FUNCTION
, &
	`JOIN_LOG_CHANNEL_WITH_PREFIX
(
LOG_CHANNEL_PREFIX
, chl), 
__VA_ARGS__
)

	)

361 #i
COMPILER
(
CLANG
)

364 #agm
g
 
dgnoic
 
push


365 #agm
g
 
dgnoic
 
igned
 "-Wmissing-noreturn"

366 
le
 
UNREACHABLE_FOR_PLATFORM
()

368 
CRASH
();

370 #agm
g
 
dgnoic
 
p


372 
	#UNREACHABLE_FOR_PLATFORM
(
	`ASSERT_NOT_REACHED
()

	)

375 #i
ASSERT_DISABLED


376 
	#RELEASE_ASSERT
(
asi
(
	`UNLIKELY
(!si)? (
	`CRASH
(): ()0)

	)

377 
	#RELEASE_ASSERT_WITH_MESSAGE
(
asi
, ...
	`RELEASE_ASSERT
si)

	)

378 
	#RELEASE_ASSERT_NOT_REACHED
(
	`CRASH
()

	)

380 
	#RELEASE_ASSERT
(
asi

	`ASSERT
si)

	)

381 
	#RELEASE_ASSERT_WITH_MESSAGE
(
asi
, ...
	`ASSERT_WITH_MESSAGE
si, 
__VA_ARGS__
)

	)

382 
	#RELEASE_ASSERT_NOT_REACHED
(
	`ASSERT_NOT_REACHED
()

	)

387 
	#TYPE_CASTS_BASE
(
ToCssName
, 
gumtTy
, 
gumtName
, 
porPdi
, 
nPdi
) \

388 
le
 
ToCssName
* 
to
##
	`ToCssName
(
gumtTy
* 
gumtName
) \

390 
	`ASSERT_WITH_SECURITY_IMPLICATION
(!
gumtName
 || (
porPdi
)); \

391  
ic_
<
ToCssName
*>(
gumtName
); \

393 
le
 cڡ 
ToCssName
* 
to
##
	`ToCssName
(cڡ 
gumtTy
* 
gumtName
) \

395 
	`ASSERT_WITH_SECURITY_IMPLICATION
(!
gumtName
 || (
porPdi
)); \

396  
ic_
<cڡ 
ToCssName
*>(
gumtName
); \

398 
le
 
ToCssName
& 
to
##
	`ToCssName
(
gumtTy
& 
gumtName
) \

400 
	`ASSERT_WITH_SECURITY_IMPLICATION
(
nPdi
); \

401  
ic_
<
ToCssName
&>(
gumtName
); \

403 
le
 cڡ 
ToCssName
& 
to
##
	`ToCssName
(cڡ 
gumtTy
& 
gumtName
) \

405 
	`ASSERT_WITH_SECURITY_IMPLICATION
(
nPdi
); \

406  
ic_
<cڡ 
ToCssName
&>(
gumtName
); \

408 
to
##
	`ToCssName
(cڡ 
ToCssName
*); \

409 
to
##
	`ToCssName
(cڡ 
ToCssName
&);

	)

	@Atomics.cpp

59 
	~"cfig.h
"

60 
	~"Atomics.h
"

68 #i
COMPILER
(
GCC
&& !
defed
(
__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8
&& 
USE
(
PTHREADS
)

70 
	~"ThadgPrimives.h
"

72 
mea
 
	gWTF
 {

74 cڡ 
size_t
 
	gkSwLockCou
 = 32;

75 
Mux
 
	gs_swLocks
[
kSwLockCou
];

77 
le
 
	gMux
& 
gSwLock
(cڡ vީ
t64_t
* 
addr
)

79  
	gs_swLocks
[(
t_
<
_t
>(
addr
>> 3U% 
kSwLockCou
];

82 
t64_t
 
omicSp
(t64_vީe* 
addd
, i64_

)

84 
	gMux
& 
	gmux
 = 
gSwLock
(
addd
);

86 
	gmux
.
lock
();

87 
t64_t
 
	gvue
 = *
addd
 + 

;

88 *
	gaddd
 = 
vue
;

89 
	gmux
.
uock
();

91  
	gvue
;

96 
t64_t
 
__sync_add_d_tch_8
(t64_vީe* 
addd
, i64_
vue
)

98  
omicSp
(
addd
, 
vue
);

101 
t64_t
 
__sync_sub_d_tch_8
(t64_vީe* 
addd
, i64_
vue
)

103  
omicSp
(
addd
, -
vue
);

	@Atomics.h

59 #ide
Atomics_h


60 
	#Atomics_h


	)

62 
	~<wtf/StdLibExas.h
>

64 #i
OS
(
WINDOWS
)

65 #i!
COMPILER
(
GCC
)

66 "C" 
_RdWreBrr
();

67 #agm
sic
(
_RdWreBrr
)

69 
	~<wdows.h
>

72 
mea
 
	gWTF
 {

74 #i
OS
(
WINDOWS
)

75 
le
 
bo
 
wkComAndSw
(vީ* 
loti
, 
exed
, 
wVue
)

77  
IlockedComExchge
(
t_
<
LONG
 vީe*>(
loti
), 
ic_
<LONG>(
wVue
), stic_<LONG>(
exed
)) == static_cast<LONG>(expected);

80 
le
 
bo
 
wkComAndSw
(*vީe* 
loti
, * 
exed
, * 
wVue
)

82  
IlockedComExchgePor
(
loti
, 
wVue
, 
exed
) ==xpected;

85 
le
 
bo
 
wkComAndSw
(vީ* 
loti
, 
exed
, 
wVue
)

87 #i
ENABLE
(
COMPARE_AND_SWAP
)

88 #i
CPU
(
X86
|| CPU(
X86_64
)

89 
	gsu
;

90 
asm
 volatile(

93 : "+a"(
exed
), "=q"(
	gsu
), "+m"(*
	gloti
)

94 : "r"(
wVue
)

97 #i
CPU
(
ARM_THUMB2
)

98 
	gtmp
;

99 
	gsu
;

100 
asm
 volatile(

107 : "+Q"(*
loti
), "=&r"(
	gsu
), "=&r"(
	gtmp
)

108 : "r"(
exed
), "r"(
	gwVue
)

110 
	gsu
 = !
su
;

111 #i
CPU
(
ARM64
&& 
COMPILER
(
GCC
)

112 
	gtmp
;

113 
	gsu
;

114 
asm
 volatile(

121 : "+r"(
loti
), "=&r"(
	gsu
), "=&r"(
	gtmp
)

122 : "r"(
exed
), "r"(
	gwVue
)

124 
	gsu
 = !
su
;

125 #i
CPU
(
ARM64
)

126 
	gtmp
;

127 
	gsu
;

128 
asm
 volatile(

135 : "+m"(*
loti
), "=&r"(
	gsu
), "=&r"(
	gtmp
)

136 : "r"(
exed
), "r"(
	gwVue
)

138 
	gsu
 = !
su
;

142  
	gsu
;

144 
UNUSED_PARAM
(
loti
);

145 
UNUSED_PARAM
(
exed
);

146 
UNUSED_PARAM
(
wVue
);

147 
CRASH
();

148  
	gl
;

152 
le
 
bo
 
wkComAndSw
(*vީe* 
loti
, * 
exed
, * 
wVue
)

154 #i
ENABLE
(
COMPARE_AND_SWAP
)

155 #i
CPU
(
X86_64
)

156 
bo
 
	gsu
;

157 
asm
 volatile(

160 : "+a"(
exed
), "=q"(
	gsu
), "+m"(*
	gloti
)

161 : "r"(
wVue
)

164  
	gsu
;

165 #i
CPU
(
ARM64
&& 
COMPILER
(
GCC
)

166 
bo
 
	gsu
;

167 * 
	gtmp
;

168 
asm
 volatile(

175 : "+r"(
loti
), "=&r"(
	gsu
), "=&r"(
	gtmp
)

176 : "r"(
exed
), "r"(
	gwVue
)

178  !
	gsu
;

179 #i
CPU
(
ARM64
)

180 
bo
 
	gsu
;

181 * 
	gtmp
;

182 
asm
 volatile(

189 : "+m"(*
loti
), "=&r"(
	gsu
), "=&r"(
	gtmp
)

190 : "r"(
exed
), "r"(
	gwVue
)

192  !
	gsu
;

194  
wkComAndSw
(
bwi_
<*>(
loti
), bwi_<>(
exed
), bwi_<>(
wVue
));

197 
UNUSED_PARAM
(
loti
);

198 
UNUSED_PARAM
(
exed
);

199 
UNUSED_PARAM
(
wVue
);

200 
CRASH
();

206 
le
 
bo
 
wkComAndSwUIP
(vީ
u_t
* 
loti
, u_
exed
, u_
wVue
)

208  
wkComAndSw
(
t_
<*vީe*>(
loti
),et_<*>(
exed
),et_<*>(
wVue
));

211 
le
 
bo
 
wkComAndSwSize
(vީ
size_t
* 
loti
, size_
exed
, size_
wVue
)

213  
wkComAndSw
(
t_
<*vީe*>(
loti
),et_<*>(
exed
),et_<*>(
wVue
));

219 
le
 
compF
()

221 #i
OS
(
WINDOWS
&& !
COMPILER
(
GCC
)

222 
_RdWreBrr
();

224 
asm
 volatile("" ::: "memory");

228 #i
CPU
(
ARM_THUMB2
|| CPU(
ARM64
)

232 
le
 
mV7_dmb
()

234 
asm
 volatile("dmb sy" ::: "memory");

238 
le
 
mV7_dmb_
()

240 
asm
 volatile("dmb st" ::: "memory");

243 
le
 
ldLdF
({ 
mV7_dmb
(); }

244 
le
 
ldSteF
({ 
mV7_dmb
(); }

245 
le
 
eLdF
({ 
mV7_dmb
(); }

246 
le
 
eSteF
({ 
mV7_dmb_
(); }

247 
le
 
memyBrrALock
({ 
mV7_dmb
(); }

248 
le
 
memyBrrBefeUock
({ 
mV7_dmb
(); }

250 #i
CPU
(
X86
|| CPU(
X86_64
)

252 
le
 
x86_mn
()

254 #i
OS
(
WINDOWS
)

259 
MemyBrr
();

261 
asm
 volatile("mfence" ::: "memory");

265 
le
 
ldLdF
({ 
compF
(); }

266 
le
 
ldSteF
({ 
compF
(); }

267 
le
 
eLdF
({ 
x86_mn
(); }

268 
le
 
eSteF
({ 
compF
(); }

269 
le
 
memyBrrALock
({ 
compF
(); }

270 
le
 
memyBrrBefeUock
({ 
compF
(); }

274 
le
 
ldLdF
({ 
compF
(); }

275 
le
 
ldSteF
({ 
compF
(); }

276 
le
 
eLdF
({ 
compF
(); }

277 
le
 
eSteF
({ 
compF
(); }

278 
le
 
memyBrrALock
({ 
compF
(); }

279 
le
 
memyBrrBefeUock
({ 
compF
(); }

283 
le
 
bo
 
wkComAndSw
(
ut8_t
* 
loti
, ut8_
exed
, ut8_
wVue
)

285 #i
ENABLE
(
COMPARE_AND_SWAP
)

286 #i!
OS
(
WINDOWS
&& (
CPU
(
X86
|| CPU(
X86_64
))

287 
	gsu
;

288 
asm
 volatile(

291 : "+a"(
exed
), "=q"(
	gsu
), "+m"(*
	gloti
)

292 : "q"(
wVue
)

295  
	gsu
;

296 #i
OS
(
WINDOWS
&& 
CPU
(
X86
)

299 
bo
 
	gsu
 = 
l
;

301 
	g__asm
 {

302 
mov
 
	g
, 
exed


303 
mov
 
	gedx
, 
loti


304 
mov
 
	g
, 
wVue


305 
lock
 
cmpxchg
 
by
 
	gr
[
edx
], 



306 
tz
 
	gsu


309  
	gsu
;

311 
u_t
 
	glotiVue
 = 
bwi_
<u_t>(
loti
);

312 
u_t
 
	gigdLotiVue
 = 
lotiVue
 & ~(() - 1);

313 
u_t
 
	glotiOfft
 = 
lotiVue
 - 
igdLotiVue
;

314 
ASSERT
(
lotiOfft
 < ());

315 * 
	gigdLoti
 = 
bwi_
<*>(
igdLotiVue
);

317 
	gdAligdVue
 = *
cڡ_
<vީ*>(
igdLoti
);

319 
ut8_t
 
	gbys
[()];

320 
	gwd
;

321 } 
	gu
;

322 
	gu
.
	gwd
 = 
dAligdVue
;

323 i(
	gu
.
	gbys
[
lotiOfft
] !
exed
)

324  
l
;

325 
	gu
.
	gbys
[
lotiOfft
] = 
wVue
;

326 
	gwAligdVue
 = 
u
.
wd
;

327  
wkComAndSw
(
igdLoti
, 
dAligdVue
, 
wAligdVue
);

330 
UNUSED_PARAM
(
loti
);

331 
UNUSED_PARAM
(
exed
);

332 
UNUSED_PARAM
(
wVue
);

333 
CRASH
();

334  
	gl
;

	@AutodrainedPool.h

29 #ide
AutodedPo_h


30 
	#AutodedPo_h


	)

32 
	~<wtf/Ncyab.h
>

34 #i
USE
(
FOUNDATION
&& !
defed
(
__OBJC__
)

35 
objc_obje
 *
	tid
;

38 
mea
 
	gWTF
 {

40 as
	cAutodedPo
 {

41 
WTF_MAKE_NONCOPYABLE
(
AutodedPo
);

42 
	gpublic
:

43 #i
USE
(
FOUNDATION
)

44 
WTF_EXPORT_PRIVATE
 
AutodedPo
();

45 
	gWTF_EXPORT_PRIVATE
 ~
AutodedPo
();

47 
exic
 
AutodedPo
() { }

48 ~
AutodedPo
() { }

51 
	give
:

52 #i
USE
(
FOUNDATION
)

53 
id
 
m_po
;

59 
usg
 
	gWTF
::
AutodedPo
;

	@Bag.h

26 #ide
Bag_h


27 
	#Bag_h


	)

29 
mea
 
	gWTF
 {

31 
	gme
<
tyme
 
	gT
>

32 as
	cBag
 {

33 
	give
:

34 as
	cNode
 {

35 
WTF_MAKE_FAST_ALLOCATED
;

36 
	gpublic
:

37 
me
<
tyme
... 
Args
>

38 
Node
(
Args
... 
gs
)

39 : 
m_em
(
gs
...)

43 
T
 
m_em
;

44 
Node
* 
	gm_xt
;

47 
	gpublic
:

48 
Bag
()

49 : 
m_hd
(
nuαr
)

53 ~
Bag
()

55 
r
();

58 
r
()

60 
	gm_hd
) {

61 
Node
* 
	gcut
 = 
m_hd
;

62 
	gm_hd
 = 
cut
->
m_xt
;

63 
de
 
	gcut
;

65 
	gm_hd
 = 
nuαr
;

68 
	gme
<
	gtyme
... 
	gArgs
>

69 
T
* 
add
(
Args
... 
gs
)

71 
Node
* 
	gwNode
 = 
w
 Node(
gs
...);

72 
	gwNode
->
	gm_xt
 = 
m_hd
;

73 
	gm_hd
 = 
wNode
;

74  &
	gwNode
->
	gm_em
;

77 as
	c
 {

78 
	gpublic
:

79 

()

80 : 
m_node
(0)

85 
bo
 
ݔ
!(cڡ {  !
m_node
; }

87 
T
* 
	gݔ
*(cڡ {  &
	gm_node
->
	gm_em
; }

89 
	g
& 
	gݔ
++()

91 
	gm_node
 = 
m_node
->
m_xt
;

92  *
	gthis
;

95 
bo
 
	gݔ
==(cڡ 

& 
h
) const

97  
m_node
 =
h
.m_node;

100 
bo
 
	gݔ
!=(cڡ 

& 
h
) const

102  !(*
this
 =
h
);

105 
	give
:

106 
me
<
tyme
 
U
> 
nd
 
ass
 
WTF
::
Bag
;

107 
Node
* 
	gm_node
;

110 

 
beg
()

112 

 
	gsu
;

113 
	gsu
.
	gm_node
 = 
m_hd
;

114  
	gsu
;

117 

 
d
() {  iterator(); }

119 
bo
 
isEmy
(cڡ {  !
	gm_hd
; }

121 
	give
:

122 
Node
* 
m_hd
;

127 
usg
 
	gWTF
::
Bag
;

	@BagToHashMap.h

26 #ide
BagToHashM_h


27 
	#BagToHashM_h


	)

29 
	~<wtf/Bag.h
>

30 
	~<wtf/DaLog.h
>

31 
	~<wtf/HashM.h
>

33 
mea
 
	gWTF
 {

35 
	gme
<
tyme
 
	gEmtTy
,ym
	gKeyTy
,ym
	gHashArg
,ym
	gKeyGrFun
>

36 
toHashM
(
Bag
<
EmtTy
>& 
bag
, 
KeyGrFun
& 
gKey
, 
HashM
<
KeyTy
, EmtTy*, 
HashArg
>& 
su
)

38 
tyme
 
	gBag
<
	gEmtTy
>::

 

 = 
bag
.
beg
(); !!
	g
; ++iter) {

39 
EmtTy
* 
	gemt
 = *

;

40 
KeyTy
 
	gkey
 = 
gKey
(*
emt
);

41 
	gsu
.
add
(
key
, 
emt
);

47 
usg
 
	gWTF
::
toHashM
;

	@BitVector.cpp

26 
	~"cfig.h
"

27 
	~"BVe.h
"

29 
	~<gܙhm
>

30 
	~<rg.h
>

31 
	~<wtf/Asis.h
>

32 
	~<wtf/FaMloc.h
>

33 
	~<wtf/StdLibExas.h
>

35 
mea
 
	gWTF
 {

37 
	gBVe
::
tSlow
(cڡ 
BVe
& 
h
)

39 
u_t
 
wBsOrPor
;

40 i(
	gh
.
isIƚe
(|| oth.
isEmyOrDedVue
())

41 
	gwBsOrPor
 = 
h
.
m_bsOrPor
;

43 
OutOfLeBs
* 
	gwOutOfLeBs
 = OutOfLeBs::

(
h
.
size
());

44 
memy
(
wOutOfLeBs
->
bs
(), 
h
.bs(), 
byCou
(h.
size
()));

45 
	gwBsOrPor
 = 
bwi_
<
u_t
>(
wOutOfLeBs
) >> 1;

47 i(!
isIƚe
(&& !
isEmyOrDedVue
())

48 
	gOutOfLeBs
::
deroy
(
outOfLeBs
());

49 
	gm_bsOrPor
 = 
wBsOrPor
;

52 
	gBVe
::
size
(
size_t
 
numBs
)

54 i(
numBs
 <
maxIƚeBs
()) {

55 i(
isIƚe
())

58 
OutOfLeBs
* 
	gmyOutOfLeBs
 = 
outOfLeBs
();

59 
	gm_bsOrPor
 = 
makeIƚeBs
(*
myOutOfLeBs
->
bs
());

60 
	gOutOfLeBs
::
deroy
(
myOutOfLeBs
);

64 
sizeOutOfLe
(
numBs
);

67 
	gBVe
::
rA
()

69 i(
isIƚe
())

70 
m_bsOrPor
 = 
makeIƚeBs
(0);

72 
memt
(
outOfLeBs
()->
bs
(), 0, 
byCou
(
size
()));

75 
	gBVe
::
OutOfLeBs
* 
BVe
::OutOfLeBs::

(
size_t
 
numBs
)

77 
numBs
 = (numB+ 
bsInPor
() - 1) & ~(bitsInPointer() - 1);

78 
size_t
 
	gsize
 = (
OutOfLeBs
+ (
u_t
* (
numBs
 / 
bsInPor
());

79 
OutOfLeBs
* 
	gsu
 = 
w
 (
NNu
, 
Mloc
(
size
)OutOfLeBs(
numBs
);

80  
	gsu
;

83 
	gBVe
::
OutOfLeBs
::
deroy
(OutOfLeBs* 
outOfLeBs
)

85 
Fe
(
outOfLeBs
);

88 
	gBVe
::
sizeOutOfLe
(
size_t
 
numBs
)

90 
ASSERT
(
numBs
 > 
maxIƚeBs
());

91 
OutOfLeBs
* 
	gwOutOfLeBs
 = OutOfLeBs::

(
numBs
);

92 
size_t
 
	gwNumWds
 = 
wOutOfLeBs
->
numWds
();

93 i(
isIƚe
()) {

95 *
	gwOutOfLeBs
->
bs
(
m_bsOrPor
 & ~(
ic_
<
u_t
>(1<< 
maxIƚeBs
());

96 
memt
(
wOutOfLeBs
->
bs
(+ 1, 0, (
wNumWds
 - 1) * (*));

98 i(
	gnumBs
 > 
size
()) {

99 
size_t
 
	gdNumWds
 = 
outOfLeBs
()->
numWds
();

100 
memy
(
wOutOfLeBs
->
bs
(), 
outOfLeBs
()->bs(), 
dNumWds
 * (*));

101 
memt
(
wOutOfLeBs
->
bs
(+ 
dNumWds
, 0, (
wNumWds
 - oldNumWords) * (*));

103 
memy
(
wOutOfLeBs
->
bs
(), 
outOfLeBs
()->bs(),ewOutOfLeBs->
numWds
() * (*));

104 
	gOutOfLeBs
::
deroy
(
outOfLeBs
());

106 
	gm_bsOrPor
 = 
bwi_
<
u_t
>(
wOutOfLeBs
) >> 1;

109 
	gBVe
::
mgeSlow
(cڡ 
BVe
& 
h
)

111 i(
h
.
isIƚe
()) {

112 
ASSERT
(!
isIƚe
());

113 *
bs
(|
nIƚeBs
(
h
.
m_bsOrPor
);

117 
suSize
(
h
.
size
());

118 
ASSERT
(!
isIƚe
());

119 
ASSERT
(!
h
.
isIƚe
());

121 
OutOfLeBs
* 
	ga
 = 
outOfLeBs
();

122 cڡ 
OutOfLeBs
* 
	gb
 = 
h
.
outOfLeBs
();

123 
	gi
 = 
a
->
numWds
(); i--;)

124 
	ga
->
bs
()[
i
] |
b
->bits()[i];

127 
	gBVe
::
frSlow
(cڡ 
BVe
& 
h
)

129 i(
h
.
isIƚe
()) {

130 
ASSERT
(!
isIƚe
());

131 *
bs
(&
nIƚeBs
(
h
.
m_bsOrPor
);

135 i(
isIƚe
()) {

136 
ASSERT
(!
h
.
isIƚe
());

137 
	gm_bsOrPor
 &*
h
.
outOfLeBs
()->
bs
();

138 
	gm_bsOrPor
 |(
ic_
<
u_t
>(1<< 
maxIƚeBs
());

139 
ASSERT
(
isIƚe
());

143 
OutOfLeBs
* 
	ga
 = 
outOfLeBs
();

144 cڡ 
OutOfLeBs
* 
	gb
 = 
h
.
outOfLeBs
();

145 
	gi
 = 
d
::
m
(
a
->
numWds
(), 
b
->numWords()); i--;)

146 
	ga
->
bs
()[
i
] &
b
->bits()[i];

148 
	gi
 = 
b
->
numWds
(); i < 
	ga
->numWords(); ++i)

149 
	ga
->
bs
()[
i
] = 0;

152 
	gBVe
::
exudeSlow
(cڡ 
BVe
& 
h
)

154 i(
h
.
isIƚe
()) {

155 
ASSERT
(!
isIƚe
());

156 *
bs
(&~
nIƚeBs
(
h
.
m_bsOrPor
);

160 i(
isIƚe
()) {

161 
ASSERT
(!
h
.
isIƚe
());

162 
	gm_bsOrPor
 &~*
h
.
outOfLeBs
()->
bs
();

163 
	gm_bsOrPor
 |(
ic_
<
u_t
>(1<< 
maxIƚeBs
());

164 
ASSERT
(
isIƚe
());

168 
OutOfLeBs
* 
	ga
 = 
outOfLeBs
();

169 cڡ 
OutOfLeBs
* 
	gb
 = 
h
.
outOfLeBs
();

170 
	gi
 = 
d
::
m
(
a
->
numWds
(), 
b
->numWords()); i--;)

171 
	ga
->
bs
()[
i
] &~
b
->bits()[i];

174 
size_t
 
	gBVe
::
bCouSlow
() const

176 
ASSERT
(!
isIƚe
());

177 cڡ 
OutOfLeBs
* 
	gbs
 = 
outOfLeBs
();

178 
size_t
 
	gsu
 = 0;

179 
	gi
 = 
bs
->
numWds
(); i--;)

180 
	gsu
 +
bCou
(
bs
->bs()[
i
]);

181  
	gsu
;

184 
bo
 
	gBVe
::
equsSlowCa
(cڡ 
BVe
& 
h
) const

186 
bo
 
su
 = 
equsSlowCaFa
(
h
);

187 
ASSERT
(
su
 =
equsSlowCaSime
(
h
));

188  
	gsu
;

191 
bo
 
	gBVe
::
equsSlowCaFa
(cڡ 
BVe
& 
h
) const

193 i(
isIƚe
(!
h
.isInline())

194  
equsSlowCaSime
(
h
);

196 cڡ 
OutOfLeBs
* 
	gmyBs
 = 
outOfLeBs
();

197 cڡ 
OutOfLeBs
* 
	ghBs
 = 
h
.
outOfLeBs
();

199 
size_t
 
	gmyNumWds
 = 
myBs
->
numWds
();

200 
size_t
 
	ghNumWds
 = 
hBs
->
numWds
();

201 
size_t
 
	gmNumWds
;

202 
size_t
 
	gmaxNumWds
;

204 cڡ 
OutOfLeBs
* 
	glgBs
;

205 i(
	gmyNumWds
 < 
	ghNumWds
) {

206 
	gmNumWds
 = 
myNumWds
;

207 
	gmaxNumWds
 = 
hNumWds
;

208 
	glgBs
 = 
hBs
;

210 
	gmNumWds
 = 
hNumWds
;

211 
	gmaxNumWds
 = 
myNumWds
;

212 
	glgBs
 = 
myBs
;

215 
size_t
 
	gi
 = 
mNumWds
; i < 
	gmaxNumWds
; ++i) {

216 i(
	glgBs
->
bs
()[
i
])

217  
	gl
;

220 
size_t
 
	gi
 = 
mNumWds
; i--;) {

221 i(
	gmyBs
->
bs
()[
i
] !
hBs
->bits()[i])

222  
l
;

225  
	gue
;

228 
bo
 
	gBVe
::
equsSlowCaSime
(cڡ 
BVe
& 
h
) const

231 
i
 = 
d
::
max
(
size
(), 
h
.size()); 
	gi
--;) {

232 i(
g
(
i
!
h
.get(i))

233  
l
;

235  
	gue
;

238 
u_t
 
	gBVe
::
hashSlowCa
() const

240 
ASSERT
(!
isIƚe
());

241 cڡ 
OutOfLeBs
* 
	gbs
 = 
outOfLeBs
();

242 
u_t
 
	gsu
 = 0;

243 
	gi
 = 
bs
->
numWds
(); i--;)

244 
	gsu
 ^
bs
->bs()[
i
];

245  
	gsu
;

248 
	gBVe
::
dump
(
PrtSm
& 
out
) const

250 
size_t
 
i
 = 0; 
	gi
 < 
size
(); ++i) {

251 i(
g
(
i
))

252 
	gout
.
tf
("1");

254 
	gout
.
tf
("-");

	@BitVector.h

26 #ide
BVe_h


27 
	#BVe_h


	)

29 
	~<dio.h
>

30 
	~<wtf/Asis.h
>

31 
	~<wtf/DaLog.h
>

32 
	~<wtf/HashFunis.h
>

33 
	~<wtf/HashTs.h
>

34 
	~<wtf/PrtSm.h
>

35 
	~<wtf/StdLibExas.h
>

37 
mea
 
	gWTF
 {

60 as
	cBVe
 {

61 
	gpublic
:

62 
BVe
()

63 : 
m_bsOrPor
(
makeIƚeBs
(0))

67 
exic
 
BVe
(
size_t
 
numBs
)

68 : 
m_bsOrPor
(
makeIƚeBs
(0))

70 
suSize
(
numBs
);

73 
BVe
(cڡ BVe& 
h
)

74 : 
m_bsOrPor
(
makeIƚeBs
(0))

76 (*
this

h
;

80 ~
BVe
()

82 i(
isIƚe
())

84 
	gOutOfLeBs
::
deroy
(
outOfLeBs
());

87 
	gBVe
& 
	gݔ
=(cڡ 
BVe
& 
h
)

89 i(
isIƚe
(&& 
h
.isInline())

90 
m_bsOrPor
 = 
h
.m_bitsOrPointer;

92 
tSlow
(
h
);

93  *
	gthis
;

96 
size_t
 
size
() const

98 i(
isIƚe
())

99  
maxIƚeBs
();

100  
outOfLeBs
()->
numBs
();

103 
suSize
(
size_t
 
numBs
)

105 i(
	gnumBs
 <
size
())

107 
sizeOutOfLe
(
numBs
);

111 
WTF_EXPORT_PRIVATE
 
size
(
size_t
 
numBs
);

113 
WTF_EXPORT_PRIVATE
 
rA
();

115 
bo
 
quickG
(
size_t
 
b
) const

117 
ASSERT_WITH_SECURITY_IMPLICATION
(
b
 < 
size
());

118  !!(
bs
()[
b
 / 
bsInPor
()] & (
	gic_
<
	gu_t
>(1<< (
	gb
 & (bitsInPointer() - 1))));

121 
bo
 
quickS
(
size_t
 
b
)

123 
ASSERT_WITH_SECURITY_IMPLICATION
(
b
 < 
size
());

124 
	gu_t
& 
	gwd
 = 
bs
()[
b
 / 
bsInPor
()];

125 
u_t
 
	gmask
 = 
ic_
<u_t>(1<< (
b
 & (
bsInPor
() - 1));

126 
bo
 
	gsu
 = !!(
wd
 & 
mask
);

127 
	gwd
 |
mask
;

128  
	gsu
;

131 
bo
 
quickCˬ
(
size_t
 
b
)

133 
ASSERT_WITH_SECURITY_IMPLICATION
(
b
 < 
size
());

134 
	gu_t
& 
	gwd
 = 
bs
()[
b
 / 
bsInPor
()];

135 
u_t
 
	gmask
 = 
ic_
<u_t>(1<< (
b
 & (
bsInPor
() - 1));

136 
bo
 
	gsu
 = !!(
wd
 & 
mask
);

137 
	gwd
 &~
mask
;

138  
	gsu
;

141 
bo
 
quickS
(
size_t
 
b
, bo 
vue
)

143 i(
	gvue
)

144  
quickS
(
b
);

145  
quickCˬ
(
b
);

148 
bo
 
g
(
size_t
 
b
) const

150 i(
	gb
 >
size
())

151  
l
;

152  
quickG
(
b
);

155 
bo
 
t
(
size_t
 
b
)

157 
suSize
(
b
 + 1);

158  
quickS
(
b
);

161 
bo
 
suSizeAndS
(
size_t
 
b
, size_
size
)

163 
suSize
(
size
);

164  
quickS
(
b
);

167 
bo
 
r
(
size_t
 
b
)

169 i(
	gb
 >
size
())

170  
l
;

171  
quickCˬ
(
b
);

174 
bo
 
t
(
size_t
 
b
, bo 
vue
)

176 i(
	gvue
)

177  
t
(
b
);

178  
r
(
b
);

181 
mge
(cڡ 
BVe
& 
h
)

183 i(!
isIƚe
(|| !
	gh
.isInline()) {

184 
mgeSlow
(
h
);

187 
	gm_bsOrPor
 |
h
.
m_bsOrPor
;

188 
ASSERT
(
isIƚe
());

191 
fr
(cڡ 
BVe
& 
h
)

193 i(!
isIƚe
(|| !
	gh
.isInline()) {

194 
frSlow
(
h
);

197 
	gm_bsOrPor
 &
h
.
m_bsOrPor
;

198 
ASSERT
(
isIƚe
());

201 
exude
(cڡ 
BVe
& 
h
)

203 i(!
isIƚe
(|| !
	gh
.isInline()) {

204 
exudeSlow
(
h
);

207 
	gm_bsOrPor
 &~
h
.
m_bsOrPor
;

208 
	gm_bsOrPor
 |(
ic_
<
u_t
>(1<< 
maxIƚeBs
());

209 
ASSERT
(
isIƚe
());

212 
size_t
 
bCou
() const

214 i(
isIƚe
())

215  
bCou
(
nIƚeBs
(
m_bsOrPor
));

216  
bCouSlow
();

219 
size_t
 
fdB
(size_
dex
, 
bo
 
vue
) const

221 
size_t
 
	gsu
 = 
fdBFa
(
dex
, 
vue
);

222 i(!
	gASSERT_DISABLED
) {

223 
size_t
 
	gexedResu
 = 
fdBSime
(
dex
, 
vue
);

224 i(
	gsu
 !
exedResu
) {

225 
daLog
("fdB(", 
dex
, ", ", 
vue
, " ", *
this
, " should havgً", 
exedResu
, " bug ", 
su
, "\n");

226 
ASSERT_NOT_REACHED
();

229  
	gsu
;

232 
WTF_EXPORT_PRIVATE
 
dump
(
PrtSm
& 
out
) const;

234 
	eEmyVueTag
 { 
	gEmyVue
 };

235 
	eDedVueTag
 { 
	gDedVue
 };

237 
BVe
(
EmyVueTag
)

238 : 
m_bsOrPor
(0)

242 
BVe
(
DedVueTag
)

243 : 
m_bsOrPor
(1)

247 
bo
 
isEmyVue
(cڡ {  !
m_bsOrPor
; }

248 
bo
 
isDedVue
(cڡ {  
	gm_bsOrPor
 == 1; }

250 
bo
 
isEmyOrDedVue
(cڡ {  
	gm_bsOrPor
 <= 1; }

252 
bo
 
	gݔ
==(cڡ 
BVe
& 
h
) const

254 i(
isIƚe
(&& 
h
.isInline())

255  
m_bsOrPor
 =
h
.m_bitsOrPointer;

256  
equsSlowCa
(
h
);

259 
hash
() const

264 
u_t
 
	gvue
;

265 i(
isIƚe
())

266 
	gvue
 = 
nIƚeBs
(
m_bsOrPor
);

268 
	gvue
 = 
hashSlowCa
();

269  
	gIHash
<
	gu_t
>::
hash
(
vue
);

272 
	give
:

273 
bsInPor
()

278 
maxIƚeBs
()

280  
bsInPor
() - 1;

283 
size_t
 
byCou
(size_
bCou
)

285  (
	gbCou
 + 7) >> 3;

288 
u_t
 
makeIƚeBs
(u_
bs
)

290 
ASSERT
(!(
bs
 & (
ic_
<
u_t
>(1<< 
maxIƚeBs
())));

291  
	gbs
 | (
	gic_
<
	gu_t
>(1<< 
maxIƚeBs
());

294 
u_t
 
nIƚeBs
(u_
bs
)

296  
	gbs
 & ~(
	gic_
<
	gu_t
>(1<< 
maxIƚeBs
());

299 
size_t
 
bCou
(
u_t
 
bs
)

301 i((
	gu_t
) == 4)

302  
WTF
::
bCou
(
ic_
<>(
bs
));

303  
	gWTF
::
bCou
(
ic_
<
ut64_t
>(
bs
));

306 
size_t
 
fdBFa
(size_
tIndex
, 
bo
 
vue
) const

308 i(
isIƚe
()) {

309 
size_t
 
	gdex
 = 
tIndex
;

310 
fdBInWd
(
m_bsOrPor
, 
dex
, 
maxIƚeBs
(), 
vue
);

311  
	gdex
;

314 cڡ 
OutOfLeBs
* 
	gbs
 = 
outOfLeBs
();

318 
u_t
 
	gskVue
 = -(
ic_
<u_t>(
vue
) ^ 1);

319 
size_t
 
	gnumWds
 = 
bs
->
numWds
();

321 
size_t
 
	gwdIndex
 = 
tIndex
 / 
bsInPor
();

322 
size_t
 
	gtIndexInWd
 = 
tIndex
 - 
wdIndex
 * 
bsInPor
();

324 
	gwdIndex
 < 
	gnumWds
) {

325 
u_t
 
	gwd
 = 
bs
->bs()[
wdIndex
];

326 i(
	gwd
 !
skVue
) {

327 
size_t
 
dex
 = 
tIndexInWd
;

328 i(
fdBInWd
(
wd
, 
dex
, 
bsInPor
(), 
vue
))

329  
wdIndex
 * 
bsInPor
(+ 
	gdex
;

332 
	gwdIndex
++;

333 
	gtIndexInWd
 = 0;

336  
	gbs
->
numBs
();

339 
size_t
 
fdBSime
(size_
dex
, 
bo
 
vue
) const

341 
	gdex
 < 
size
()) {

342 i(
g
(
dex
=
vue
)

343  
dex
;

344 
	gdex
++;

346  
size
();

349 
bo
 
fdBInWd
(
u_t
 
wd
, 
size_t
& 
dex
, size_
dIndex
, bo 
vue
)

351 
	gwd
 >>
dex
;

353 
	gdex
 < 
	gdIndex
) {

354 i((
	gwd
 & 1=
ic_
<
u_t
>(
vue
))

355  
ue
;

356 
	gdex
++;

357 
	gwd
 >>= 1;

360 
	gdex
 = 
dIndex
;

361  
	gl
;

364 as
	cOutOfLeBs
 {

365 
	gpublic
:

366 
size_t
 
numBs
(cڡ {  
m_numBs
; }

367 
size_t
 
numWds
(cڡ {  (
	gm_numBs
 + 
bsInPor
() - 1) / bitsInPointer(); }

368 
u_t
* 
bs
({  
	gbwi_
<
	gu_t
*>(
	gthis
 + 1); }

369 cڡ 
u_t
* 
bs
(cڡ {  
	gbwi_
<cڡ 
	gu_t
*>(
	gthis
 + 1); }

371 
WTF_EXPORT_PRIVATE
 
OutOfLeBs
* 

(
size_t
 
numBs
);

373 
WTF_EXPORT_PRIVATE
 
deroy
(
OutOfLeBs
*);

375 
	give
:

376 
OutOfLeBs
(
size_t
 
numBs
)

377 : 
m_numBs
(
numBs
)

381 
size_t
 
m_numBs
;

384 
bo
 
isIƚe
(cڡ {  
	gm_bsOrPor
 >> 
maxIƚeBs
(); }

386 cڡ 
OutOfLeBs
* 
outOfLeBs
(cڡ {  
	gbwi_
<cڡ 
	gOutOfLeBs
*>(
	gm_bsOrPor
 << 1); }

387 
OutOfLeBs
* 
outOfLeBs
({  
	gbwi_
<
	gOutOfLeBs
*>(
	gm_bsOrPor
 << 1); }

389 
WTF_EXPORT_PRIVATE
 
sizeOutOfLe
(
size_t
 
numBs
);

390 
WTF_EXPORT_PRIVATE
 
tSlow
(cڡ 
BVe
& 
h
);

392 
WTF_EXPORT_PRIVATE
 
mgeSlow
(cڡ 
BVe
& 
h
);

393 
WTF_EXPORT_PRIVATE
 
frSlow
(cڡ 
BVe
& 
h
);

394 
WTF_EXPORT_PRIVATE
 
exudeSlow
(cڡ 
BVe
& 
h
);

396 
WTF_EXPORT_PRIVATE
 
size_t
 
bCouSlow
() const;

398 
WTF_EXPORT_PRIVATE
 
bo
 
equsSlowCa
(cڡ 
BVe
& 
h
) const;

399 
bo
 
equsSlowCaFa
(cڡ 
BVe
& 
h
) const;

400 
bo
 
equsSlowCaSime
(cڡ 
BVe
& 
h
) const;

401 
WTF_EXPORT_PRIVATE
 
u_t
 
hashSlowCa
() const;

403 
u_t
* 
bs
()

405 i(
isIƚe
())

406  &
	gm_bsOrPor
;

407  
outOfLeBs
()->
bs
();

410 cڡ 
u_t
* 
bs
() const

412 i(
isIƚe
())

413  &
	gm_bsOrPor
;

414  
outOfLeBs
()->
bs
();

417 
u_t
 
	gm_bsOrPor
;

420 
	sBVeHash
 {

421 
hash
(cڡ 
BVe
& 
ve
{  
	gve
.hash(); }

422 
bo
 
equ
(cڡ 
BVe
& 
a
, cڡ BVe& 
b
{  
	ga
 == b; }

423 cڡ 
bo
 
	gToComToEmyOrDed
 = 
l
;

426 
	gme
<
tyme
 
	gT
> 
	gDeuHash
;

427 
	gme
<> 
	gDeuHash
<
	gBVe
> {

428 
BVeHash
 
	tHash
;

431 
	gme
<
tyme
 
	gT
> 
	gHashTs
;

432 
	gme
<> 
	gHashTs
<
	gBVe
> : 
public
 
CuomHashTs
<
BVe
> { };

436 
usg
 
	gWTF
::
BVe
;

	@Bitmap.h

19 #ide
Bm_h


20 
	#Bm_h


	)

22 
	~<y
>

23 
	~<wtf/Atomics.h
>

24 
	~<wtf/StdLibExas.h
>

25 
	~<dt.h
>

26 
	~<rg.h
>

28 
mea
 
	gWTF
 {

30 
	eBmAtomicMode
 {

32 
	gBmNAtomic
,

36 
	gBmAtomic


39 
	gme
<
size_t
 
	gSize
, 
BmAtomicMode
 
	gomicMode
 = 
BmNAtomic
, 
tyme
 
	gWdTy
 = 
ut32_t
>

40 as
	cBm
 {

41 
WTF_MAKE_FAST_ALLOCATED
;

42 
	gpublic
:

43 
Bm
();

45 
bo
 
g
(
size_t
) const;

46 
t
(
size_t
);

47 
bo
 
AndS
(
size_t
);

48 
bo
 
AndCˬ
(
size_t
);

49 
bo
 
ccutTeAndS
(
size_t
);

50 
bo
 
ccutTeAndCˬ
(
size_t
);

51 
size_t
 
xtPossiblyUnt
(size_t) const;

52 
r
(
size_t
);

53 
rA
();

54 
t64_t
 
fdRunOfZos
(
size_t
) const;

55 
size_t
 
cou
(size_t = 0) const;

56 
size_t
 
isEmy
() const;

57 
size_t
 
isFu
() const;

59 
	give
:

60 cڡ 
wdSize
 = (
WdTy
) * 8;

61 cڡ 
	gwds
 = (
Size
 + 
wdSize
 - 1) / wordSize;

68 cڡ 
WdTy
 
	ge
 = 1;

70 
	gd
::
y
<
WdTy
, 
	gwds
> 
	gbs
;

73 
	gme
<
size_t
 
	gsize
, 
BmAtomicMode
 
	gomicMode
, 
tyme
 
	gWdTy
>

74 
le
 
	gBm
<
	gsize
, 
	gomicMode
, 
	gWdTy
>::
	$Bm
()

76 
	`rA
();

77 
	}
}

79 
	gme
<
size_t
 
	gsize
, 
BmAtomicMode
 
	gomicMode
, 
tyme
 
	gWdTy
>

80 
le
 
bo
 
	gBm
<
	gsize
, 
	gomicMode
, 
	gWdTy
>::
	$g
(
size_t
 
n
) const

82  !!(
bs
[
n
 / 
wdSize
] & (
e
 << (n % wordSize)));

83 
	}
}

85 
	gme
<
size_t
 
	gsize
, 
BmAtomicMode
 
	gomicMode
, 
tyme
 
	gWdTy
>

86 
le
 
	gBm
<
	gsize
, 
	gomicMode
, 
	gWdTy
>::
	$t
(
size_t
 
n
)

88 
bs
[
n
 / 
wdSize
] |(
e
 << (n % wordSize));

89 
	}
}

91 
	gme
<
size_t
 
	gsize
, 
BmAtomicMode
 
	gomicMode
, 
tyme
 
	gWdTy
>

92 
le
 
bo
 
	gBm
<
	gsize
, 
	gomicMode
, 
	gWdTy
>::
	$AndS
(
size_t
 
n
)

94 
WdTy
 
mask
 = 
e
 << (
n
 % 
wdSize
);

95 
size_t
 
dex
 = 
n
 / 
wdSize
;

96 
bo
 
su
 = 
bs
[
dex
] & 
mask
;

97 
bs
[
dex
] |
mask
;

98  
su
;

99 
	}
}

101 
	gme
<
size_t
 
	gsize
, 
BmAtomicMode
 
	gomicMode
, 
tyme
 
	gWdTy
>

102 
le
 
bo
 
	gBm
<
	gsize
, 
	gomicMode
, 
	gWdTy
>::
	$AndCˬ
(
size_t
 
n
)

104 
WdTy
 
mask
 = 
e
 << (
n
 % 
wdSize
);

105 
size_t
 
dex
 = 
n
 / 
wdSize
;

106 
bo
 
su
 = 
bs
[
dex
] & 
mask
;

107 
bs
[
dex
] &~
mask
;

108  
su
;

109 
	}
}

111 
	gme
<
size_t
 
	gsize
, 
BmAtomicMode
 
	gomicMode
, 
tyme
 
	gWdTy
>

112 
le
 
bo
 
	gBm
<
	gsize
, 
	gomicMode
, 
	gWdTy
>::
	$ccutTeAndS
(
size_t
 
n
)

114 i(
omicMode
 =
BmNAtomic
)

115  
	`AndS
(
n
);

117 
	`ASSERT
(
omicMode
 =
BmAtomic
);

119 
WdTy
 
mask
 = 
e
 << (
n
 % 
wdSize
);

120 
size_t
 
dex
 = 
n
 / 
wdSize
;

121 
WdTy
* 
wdP
 = 
bs
.
	`da
(+ 
dex
;

122 
WdTy
 
dVue
;

124 
dVue
 = *
wdP
;

125 i(
dVue
 & 
mask
)

126  
ue
;

127 } !
	`wkComAndSw
(
wdP
, 
dVue
, oldVu| 
mask
));

128  
l
;

129 
	}
}

131 
	gme
<
size_t
 
	gsize
, 
BmAtomicMode
 
	gomicMode
, 
tyme
 
	gWdTy
>

132 
le
 
bo
 
	gBm
<
	gsize
, 
	gomicMode
, 
	gWdTy
>::
	$ccutTeAndCˬ
(
size_t
 
n
)

134 i(
omicMode
 =
BmNAtomic
)

135  
	`AndCˬ
(
n
);

137 
	`ASSERT
(
omicMode
 =
BmAtomic
);

139 
WdTy
 
mask
 = 
e
 << (
n
 % 
wdSize
);

140 
size_t
 
dex
 = 
n
 / 
wdSize
;

141 
WdTy
* 
wdP
 = 
bs
.
	`da
(+ 
dex
;

142 
WdTy
 
dVue
;

144 
dVue
 = *
wdP
;

145 i(!(
dVue
 & 
mask
))

146  
l
;

147 } !
	`wkComAndSw
(
wdP
, 
dVue
, oldVu& ~
mask
));

148  
ue
;

149 
	}
}

151 
	gme
<
size_t
 
	gsize
, 
BmAtomicMode
 
	gomicMode
, 
tyme
 
	gWdTy
>

152 
le
 
	gBm
<
	gsize
, 
	gomicMode
, 
	gWdTy
>::
	$r
(
size_t
 
n
)

154 
bs
[
n
 / 
wdSize
] &~(
e
 << (n % wordSize));

155 
	}
}

157 
	gme
<
size_t
 
	gsize
, 
BmAtomicMode
 
	gomicMode
, 
tyme
 
	gWdTy
>

158 
le
 
	gBm
<
	gsize
, 
	gomicMode
, 
	gWdTy
>::
	$rA
()

160 
	`memt
(
bs
.
	`da
(), 0, (bits));

161 
	}
}

163 
	gme
<
size_t
 
	gsize
, 
BmAtomicMode
 
	gomicMode
, 
tyme
 
	gWdTy
>

164 
le
 
size_t
 
	gBm
<
	gsize
, 
	gomicMode
, 
	gWdTy
>::
	$xtPossiblyUnt
(
size_t
 
t
) const

166 i(!~
bs
[
t
 / 
wdSize
])

167  ((
t
 / 
wdSize
) + 1) * wordSize;

168  
t
 + 1;

169 
	}
}

171 
	gme
<
size_t
 
	gsize
, 
BmAtomicMode
 
	gomicMode
, 
tyme
 
	gWdTy
>

172 
le
 
t64_t
 
	gBm
<
	gsize
, 
	gomicMode
, 
	gWdTy
>::
	$fdRunOfZos
(
size_t
 
runLgth
) const

174 i(!
runLgth
)

175 
runLgth
 = 1;

177 
size_t
 
i
 = 0; i <(
size
 - 
runLgth
) ; i++) {

178 
bo
 
found
 = 
ue
;

179 
size_t
 
j
 = 
i
; j <(+ 
runLgth
 - 1) ; j++) {

180 i(
	`g
(
j
)) {

181 
found
 = 
l
;

185 i(
found
)

186  
i
;

189 
	}
}

191 
	gme
<
size_t
 
	gsize
, 
BmAtomicMode
 
	gomicMode
, 
tyme
 
	gWdTy
>

192 
le
 
size_t
 
	gBm
<
	gsize
, 
	gomicMode
, 
	gWdTy
>::
	$cou
(
size_t
 
t
) const

194 
size_t
 
su
 = 0;

195  ; (
t
 % 
wdSize
); ++start) {

196 i(
	`g
(
t
))

197 ++
su
;

199 
size_t
 
i
 = 
t
 / 
wdSize
; i < 
wds
; ++i)

200 
su
 +
WTF
::
	`bCou
(
ic_
<>(
bs
[
i
]));

201  
su
;

202 
	}
}

204 
	gme
<
size_t
 
	gsize
, 
BmAtomicMode
 
	gomicMode
, 
tyme
 
	gWdTy
>

205 
le
 
size_t
 
	gBm
<
	gsize
, 
	gomicMode
, 
	gWdTy
>::
	$isEmy
() const

207 
size_t
 
i
 = 0; i < 
wds
; ++i)

208 i(
bs
[
i
])

209  
l
;

210  
ue
;

211 
	}
}

213 
	gme
<
size_t
 
	gsize
, 
BmAtomicMode
 
	gomicMode
, 
tyme
 
	gWdTy
>

214 
le
 
size_t
 
	gBm
<
	gsize
, 
	gomicMode
, 
	gWdTy
>::
	$isFu
() const

216 
size_t
 
i
 = 0; i < 
wds
; ++i)

217 i(~
bs
[
i
])

218  
l
;

219  
ue
;

220 
	}
}

	@BlockStack.h

26 #ide
BlockSck_h


27 
	#BlockSck_h


	)

29 
	~<wtf/Asis.h
>

30 
	~<wtf/FaMloc.h
>

31 
	~<wtf/Ve.h
>

33 
mea
 
	gWTF
 {

35 
	gme
 <
tyme
 
	gT
> cs
	cBlockSck
 {

36 
	gpublic
:

37 cڡ 
size_t
 
blockSize
 = 4096;

38 cڡ 
size_t
 
	gblockLgth
 = 
blockSize
 / (
T
);

40 
BlockSck
();

41 ~
BlockSck
();

43 
T
* 
grow
();

44 
shrk
(
T
*);

46 cڡ 
	gVe
<
	gT
*>& 
blocks
();

48 
	give
:

49 
Ve
<
T
*> 
m_blocks
;

50 
T
* 
	gm_eBlock
;

53 
	gme
 <
tyme
 
	gT
> 
	gBlockSck
<T>::
	$BlockSck
()

54 : 
	$m_eBlock
(0)

56 
	}
}

58 
me
 <
tyme
 
T
> 
BlockSck
<T>::~
	$BlockSck
()

60 i(
m_eBlock
)

61 
	`Fe
(
m_eBlock
);

62 
size_t
 
i
 = 0; i < 
m_blocks
.
	`size
(); ++i)

63 
	`Fe
(
m_blocks
[
i
]);

64 
	}
}

66 
	gme
 <
tyme
 
	gT
> 
le
 cڡ 
	gVe
<T*>& 
	gBlockSck
<T>::
	$blocks
()

68  
m_blocks
;

69 
	}
}

71 
	gme
 <
tyme
 
	gT
> 
T
* 
	gBlockSck
<T>::
	$grow
()

73 
T
* 
block
 = 
m_eBlock
 ? m_eBlock : 
ic_
<T*>(
	`Mloc
(
blockSize
));

74 
m_eBlock
 = 0;

76 
m_blocks
.
	`nd
(
block
);

77  
block
;

78 
	}
}

80 
	gme
 <
tyme
 
	gT
> 
	gBlockSck
<T>::
	$shrk
(
T
* 
wEnd
)

82 
	`ASSERT
(
wEnd
 !
m_blocks
.
	`ϡ
(+ 
blockLgth
);

83 
m_eBlock
 = 
m_blocks
.
	`ϡ
();

84 
m_blocks
.
	`moveLa
();

86 
m_blocks
.
	`ϡ
(+ 
blockLgth
 !
wEnd
) {

87 
	`Fe
(
m_blocks
.
	`ϡ
());

88 
m_blocks
.
	`moveLa
();

90 
	}
}

94 
usg
 
	gWTF
::
BlockSck
;

	@BloomFilter.h

26 #ide
BloomFr_h


27 
	#BloomFr_h


	)

29 
	~<wtf/xt/AtomicSg.h
>

31 
mea
 
	gWTF
 {

36 
	gme
 <
	gkeyBs
>

37 as
	cBloomFr
 {

38 
	gWTF_MAKE_FAST_ALLOCATED
;

39 
	gpublic
:

40 
ic_as
(
keyBs
 <= 16, "BloomFilter key size must beesshan orqualo 16!");

42 cڡ 
size_t
 
	gbSize
 = 1 << 
keyBs
;

43 cڡ 
	gkeyMask
 = (1 << 
keyBs
) - 1;

44 
ut8_t
 
maximumCou
({  
	gd
::
numic_lims
<ut8_t>::
max
(); }

46 
BloomFr
({ 
r
(); }

48 
add
(
hash
);

49 
move
(
hash
);

53 
bo
 
mayCڏ
(
hash
cڡ {  
fSl
(hash&& 
cdSl
(hash); }

57 
r
();

59 
add
(cڡ 
AtomicSg
& 
rg
{dd(rg.
im
()->
exigHash
()); }

60 
add
(cڡ 
Sg
& 
rg
{dd(rg.
im
()->
hash
()); }

61 
move
(cڡ 
AtomicSg
& 
rg
{emove(rg.
im
()->
exigHash
()); }

62 
move
(cڡ 
Sg
& 
rg
{emove(rg.
im
()->
hash
()); }

64 
bo
 
mayCڏ
(cڡ 
AtomicSg
& 
rg
cڡ {  mayCڏ(rg.
im
()->
exigHash
()); }

65 
bo
 
mayCڏ
(cڡ 
Sg
& 
rg
cڡ {  mayCڏ(rg.
im
()->
hash
()); }

67 #i!
ASSERT_DISABLED


69 
bo
 
likyEmy
() const;

70 
bo
 
isCˬ
() const;

73 
	give
:

74 
ut8_t
& 
fSl
(
hash
{  
m_b
[hash & 
keyMask
]; }

75 
	gut8_t
& 
cdSl
(
hash
{  
	gm_b
[(hash >> 16& 
keyMask
]; }

76 cڡ 
	gut8_t
& 
fSl
(
hash
cڡ {  
	gm_b
[hash & 
keyMask
]; }

77 cڡ 
	gut8_t
& 
cdSl
(
hash
cڡ {  
	gm_b
[(hash >> 16& 
keyMask
]; }

79 
ut8_t
 
	gm_b
[
bSize
];

82 
	gme
 <
	gkeyBs
>

83 
le
 
	gBloomFr
<
	gkeyBs
>::
	$add
(
hash
)

85 
ut8_t
& 
f
 = 
	`fSl
(
hash
);

86 
ut8_t
& 
cd
 = 
	`cdSl
(
hash
);

87 i(
	`LIKELY
(
f
 < 
	`maximumCou
()))

88 ++
f
;

89 i(
	`LIKELY
(
cd
 < 
	`maximumCou
()))

90 ++
cd
;

91 
	}
}

93 
	gme
 <
	gkeyBs
>

94 
le
 
	gBloomFr
<
	gkeyBs
>::
	$move
(
hash
)

96 
ut8_t
& 
f
 = 
	`fSl
(
hash
);

97 
ut8_t
& 
cd
 = 
	`cdSl
(
hash
);

98 
	`ASSERT
(
f
);

99 
	`ASSERT
(
cd
);

101 i(
	`LIKELY
(
f
 < 
	`maximumCou
()))

102 --
f
;

103 i(
	`LIKELY
(
cd
 < 
	`maximumCou
()))

104 --
cd
;

105 
	}
}

107 
	gme
 <
	gkeyBs
>

108 
le
 
	gBloomFr
<
	gkeyBs
>::
	$r
()

110 
	`memt
(
m_b
, 0, 
bSize
);

111 
	}
}

113 #i!
ASSERT_DISABLED


114 
	gme
 <
	gkeyBs
>

115 
bo
 
	gBloomFr
<
	gkeyBs
>::
	$likyEmy
() const

117 
size_t
 
n
 = 0; < 
bSize
; ++n) {

118 i(
m_b
[
n
] && m_b[n] !
	`maximumCou
())

119  
l
;

121  
ue
;

122 
	}
}

124 
	gme
 <
	gkeyBs
>

125 
bo
 
	gBloomFr
<
	gkeyBs
>::
	$isCˬ
() const

127 
size_t
 
n
 = 0; < 
bSize
; ++n) {

128 i(
m_b
[
n
])

129  
l
;

131  
ue
;

132 
	}
}

137 
usg
 
	gWTF
::
BloomFr
;

	@BoundsCheckedPointer.h

29 #ide
WTF_BoundsCheckedPor_h


30 
	#WTF_BoundsCheckedPor_h


	)

32 
	~<wtf/Asis.h
>

34 
mea
 
	gWTF
 {

44 
	gme
<
tyme
 
	gT
>

45 as
	cBoundsCheckedPor
 {

46 
	gpublic
:

47 
BoundsCheckedPor
()

48 : 
m_por
(0)

49 #i!
ASSERT_DISABLED


50 , 
m_beg
(0)

51 , 
m_d
(0)

56 
BoundsCheckedPor
(
T
* 
por
, 
size_t
 
numEmts
)

57 : 
m_por
(
por
)

58 #i!
ASSERT_DISABLED


59 , 
m_beg
(
por
)

60 , 
m_d
(
por
 + 
numEmts
)

63 
UNUSED_PARAM
(
numEmts
);

66 
BoundsCheckedPor
(
T
* 
por
, T* 
d
)

67 : 
m_por
(
por
)

68 #i!
ASSERT_DISABLED


69 , 
m_beg
(
por
)

70 , 
m_d
(
d
)

73 
UNUSED_PARAM
(
d
);

76 
BoundsCheckedPor
(
T
* 
por
, T* 
beg
, 
size_t
 
numEmts
)

77 : 
m_por
(
por
)

78 #i!
ASSERT_DISABLED


79 , 
m_beg
(
beg
)

80 , 
m_d
(
beg
 + 
numEmts
)

83 
UNUSED_PARAM
(
beg
);

84 
UNUSED_PARAM
(
numEmts
);

87 
BoundsCheckedPor
(
T
* 
por
, T* 
beg
, T* 
d
)

88 : 
m_por
(
por
)

89 #i!
ASSERT_DISABLED


90 , 
m_beg
(
beg
)

91 , 
m_d
(
d
)

94 
UNUSED_PARAM
(
beg
);

95 
UNUSED_PARAM
(
d
);

98 
	gBoundsCheckedPor
& 
	gݔ
=(
T
* 
vue
)

100 
m_por
 = 
vue
;

101  *
	gthis
;

104 
	gBoundsCheckedPor
& 
	gݔ
+=(
rdiff_t
 
amou
)

106 
m_por
 +
amou
;

107  *
	gthis
;

110 
	gBoundsCheckedPor
& 
	gݔ
-=(
rdiff_t
 
amou
)

112 
m_por
 -
amou
;

113  *
	gthis
;

116 
BoundsCheckedPor
 
	gݔ
+(
rdiff_t
 
	gamou
) const

118 
BoundsCheckedPor
 
	gsu
 = *
this
;

119 
	gsu
.
	gm_por
 +
amou
;

120  
	gsu
;

123 
BoundsCheckedPor
 
	gݔ
-(
rdiff_t
 
	gamou
) const

125 
BoundsCheckedPor
 
	gsu
 = *
this
;

126 
	gsu
.
	gm_por
 -
amou
;

127  
	gsu
;

130 
BoundsCheckedPor
 
	gݔ
++()

132 
	gm_por
++;

133  *
	gthis
;

136 
BoundsCheckedPor
 
	gݔ
--()

138 
	gm_por
--;

139  *
	gthis
;

142 
BoundsCheckedPor
 
	gݔ
++()

144 
BoundsCheckedPor
 
	gsu
 = *
this
;

145 
	gm_por
++;

146  
	gsu
;

149 
BoundsCheckedPor
 
	gݔ
--()

151 
BoundsCheckedPor
 
	gsu
 = *
this
;

152 
	gm_por
--;

153  
	gsu
;

156 
bo
 
	gݔ
<(
T
* 
	gh
) const

158  
	gm_por
 < 
	gh
;

161 
bo
 
	gݔ
<=(
T
* 
h
) const

163  
m_por
 <
h
;

166 
bo
 
	gݔ
>(
T
* 
	gh
) const

168  
	gm_por
 > 
	gh
;

171 
bo
 
	gݔ
>=(
T
* 
h
) const

173  
m_por
 >
h
;

176 
bo
 
	gݔ
==(
T
* 
h
) const

178  
m_por
 =
h
;

181 
bo
 
	gݔ
!=(
T
* 
h
) const

183  
m_por
 !
h
;

186 
bo
 
	gݔ
<(
BoundsCheckedPor
 
	gh
) const

188  
	gm_por
 < 
	gh
.m_pointer;

191 
bo
 
	gݔ
<=(
BoundsCheckedPor
 
h
) const

193  
m_por
 <
h
.m_pointer;

196 
bo
 
	gݔ
>(
BoundsCheckedPor
 
	gh
) const

198  
	gm_por
 > 
	gh
.m_pointer;

201 
bo
 
	gݔ
>=(
BoundsCheckedPor
 
h
) const

203  
m_por
 >
h
.m_pointer;

206 
bo
 
	gݔ
==(
BoundsCheckedPor
 
h
) const

208  
m_por
 =
h
.m_pointer;

211 
bo
 
	gݔ
!=(
BoundsCheckedPor
 
h
) const

213  
m_por
 !
h
.m_pointer;

216 
BoundsCheckedPor
 
	gݔ
!()

218  !
	gm_por
;

221 
T
* 
g
()

223  
	gm_por
;

226 
	gT
& 
	gݔ
*()

228 
vide
();

229  *
	gm_por
;

232 cڡ 
	gT
& 
	gݔ
*() const

234 
vide
();

235  *
	gm_por
;

238 
	gT
& 
	gݔ
[](
rdiff_t
 
	gdex
)

240 
vide
(
m_por
 + 
dex
);

241  
	gm_por
[
dex
];

244 cڡ 
	gT
& 
	gݔ
[](
rdiff_t
 
	gdex
) const

246 
vide
(
m_por
 + 
dex
);

247  
	gm_por
[
dex
];

252 
	gBoundsCheckedPor
& 
rt
(cڡ 
T
* 
sour
)

254 *
	gsour
)

255 *(*
	gthis
)++ = *
sour
++;

256  *
	gthis
;

259 
	give
:

260 
vide
(
T
* 
por
) const

262 
ASSERT_UNUSED
(
por
,o>
m_beg
);

267 
ASSERT_UNUSED
(
por
,o+ 1 <
m_d
);

270 
vide
() const

272 
vide
(
m_por
);

275 
T
* 
	gm_por
;

276 #i!
ASSERT_DISABLED


277 
T
* 
	gm_beg
;

278 
T
* 
	gm_d
;

284 
usg
 
	gWTF
::
BoundsCheckedPor
;

	@BumpPointerAllocator.h

26 #ide
BumpPorAot_h


27 
	#BumpPorAot_h


	)

29 
	~<gܙhm
>

30 
	~<wtf/PageAoti.h
>

31 
	~<wtf/PageBlock.h
>

33 
mea
 
	gWTF
 {

35 
	#MINIMUM_BUMP_POOL_SIZE
 0x1000

	)

37 as
	cBumpPorPo
 {

38 
	gpublic
:

47 
BumpPorPo
* 
suCacy
(
size_t
 
size
)

49 * 
lotiEnd
 = 
ic_
<*>(
m_cut
+ 
size
;

50 
ASSERT_WITH_SECURITY_IMPLICATION
(
lotiEnd
 > 
m_cut
);

51 i(
	glotiEnd
 <
ic_
<*>(
this
))

52  
this
;

53  
suCacyCrossPo
(
this
, 
size
);

58 * 
loc
(
size_t
 
size
)

60 * 
	gcut
 = 
m_cut
;

61 * 
	glotiEnd
 = 
ic_
<*>(
cut
+ 
size
;

62 
ASSERT_WITH_SECURITY_IMPLICATION
(
lotiEnd
 > 
cut
);

63 
ASSERT
(
lotiEnd
 <
ic_
<*>(
this
));

64 
	gm_cut
 = 
lotiEnd
;

65  
	gcut
;

81 
BumpPorPo
* 
doc
(* 
posi
)

83 i((
	gposi
 >
m_t
&& (
posi
 <
ic_
<*>(
this
))) {

84 
ASSERT
(
posi
 <
m_cut
);

85 
	gm_cut
 = 
posi
;

86  
	gthis
;

88  
docCrossPo
(
this
, 
posi
);

91 
	give
:

93 * 
ݔ
 
w
(
size_t
 
size
, cڡ 
PageAoti
& 
loti
)

95 
ASSERT
(
size
 < 
loti
.size());

96  
	gt_
<*>et_<
	g_t
>(
	gloti
.
ba
()+oti.
size
()- 
	gsize
;

99 
BumpPorPo
(cڡ 
PageAoti
& 
loti
)

100 : 
m_cut
(
loti
.
ba
())

101 , 
m_t
(
loti
.
ba
())

102 , 
m_xt
(0)

103 , 
m_evious
(0)

104 , 
m_loti
(
loti
)

108 
BumpPorPo
* 

(
size_t
 
mimumCacy
 = 0)

111 
mimumCacy
 +(
BumpPorPo
);

112 i(
	gmimumCacy
 < (
	gBumpPorPo
))

115 
size_t
 
	gpoSize
 = 
d
::
max
(
ic_
<size_t>(
MINIMUM_BUMP_POOL_SIZE
), 
WTF
::
geSize
());

116 
	gpoSize
 < 
	gmimumCacy
) {

117 
	gpoSize
 <<= 1;

119 
ASSERT
(!(
MINIMUM_BUMP_POOL_SIZE
 & (MINIMUM_BUMP_POOL_SIZE - 1)));

120 i(!
	gpoSize
)

124 
PageAoti
 
	gloti
 = PageAoti::
lo
(
poSize
);

125 i(!!
	gloti
)

126  
w
 (
loti

BumpPorPo
(allocation);

130 
shrk
()

132 
ASSERT
(!
m_evious
);

133 
	gm_cut
 = 
m_t
;

134 
	gm_xt
) {

135 
BumpPorPo
* 
	gxtNext
 = 
m_xt
->m_next;

136 
	gm_xt
->
deroy
();

137 
	gm_xt
 = 
xtNext
;

141 
deroy
()

143 
	gm_loti
.
do
();

146 
BumpPorPo
* 
suCacyCrossPo
(BumpPorPo* 
eviousPo
, 
size_t
 
size
)

149 
ASSERT
(
eviousPo
);

150 
ASSERT
((
ic_
<*>(
eviousPo
->
m_cut
+ 
size
) >reviousPool->m_current);

151 
ASSERT
((
ic_
<*>(
eviousPo
->
m_cut
+ 
size
) > static_cast<*>(previousPool));

152 
BumpPorPo
* 
	gpo
 = 
eviousPo
->
m_xt
;

154 
	gue
) {

155 i(!
	gpo
) {

157 
	gpo
 = 
BumpPorPo
::

(
size
);

158 
	geviousPo
->
	gm_xt
 = 
po
;

159 
	gpo
->
	gm_evious
 = 
eviousPo
;

160  
	gpo
;

164 * 
	gcut
 = 
po
->
m_cut
;

165 * 
	glotiEnd
 = 
ic_
<*>(
cut
+ 
size
;

166 
ASSERT_WITH_SECURITY_IMPLICATION
(
lotiEnd
 > 
cut
);

167 i(
	glotiEnd
 <
ic_
<*>(
po
))

168  
po
;

172 
BumpPorPo
* 
docCrossPo
(BumpPorPo* 
po
, * 
posi
)

175 
ASSERT
((
posi
 < 
po
->
m_t
|| (posi > 
ic_
<*>(pool)));

177 
	gue
) {

179 
	gpo
->
	gm_cut
 = 
po
->
m_t
;

180 
	gpo
 = 
po
->
m_evious
;

183 i(!
	gpo
)

184 
CRASH
();

186 i((
	gposi
 >
po
->
m_t
&& (
posi
 <
ic_
<*>(pool))) {

187 
ASSERT
(
posi
 <
po
->
m_cut
);

188 
	gpo
->
	gm_cut
 = 
posi
;

189  
	gpo
;

194 * 
	gm_cut
;

195 * 
	gm_t
;

196 
BumpPorPo
* 
	gm_xt
;

197 
BumpPorPo
* 
	gm_evious
;

198 
PageAoti
 
	gm_loti
;

200 
nd
 
ass
 
	gBumpPorAot
;

218 as
	cBumpPorAot
 {

219 
	gpublic
:

220 
BumpPorAot
()

221 : 
m_hd
(0)

225 ~
BumpPorAot
()

227 i(
m_hd
)

228 
m_hd
->
deroy
();

231 
BumpPorPo
* 
tAot
()

233 i(!
	gm_hd
)

234 
	gm_hd
 = 
BumpPorPo
::

();

235  
	gm_hd
;

238 
Aot
()

240 i(
	gm_hd
)

241 
	gm_hd
->
shrk
();

244 
	give
:

245 
BumpPorPo
* 
m_hd
;

250 
usg
 
	gWTF
::
BumpPorAot
;

	@ByteOrder.h

31 #ide
WTF_ByOrd_h


32 
	#WTF_ByOrd_h


	)

34 #i
OS
(
UNIX
)

35 
	~</.h
>

38 #i
OS
(
WINDOWS
)

40 
mea
 
	gWTF
 {

41 
le
 
ut32_t
 
wsw32
(ut32_
x
{  ((
	gx
 & 0xffff0000) >> 16) | ((x & 0x0000ffff) << 16); }

42 
le
 
ut32_t
 
bsw32
(ut32_
x
{  ((
	gx
 & 0xff000000) >> 24) | ((x & 0x00ff0000) >> 8) | ((x & 0x0000ff00) << 8) | ((x & 0x000000ff) << 24); }

43 
le
 
ut16_t
 
bsw16
(ut16_
x
{  ((
	gx
 & 0xff00) >> 8) | ((x & 0x00ff) << 8); }

46 #i
CPU
(
BIG_ENDIAN
)

47 
le
 
ut16_t
 
	$ohs
(
ut16_t
 
x
{  x; 
	}
}

48 
le
 
ut16_t
 
	$hts
(
ut16_t
 
x
{  x; 
	}
}

49 
le
 
ut32_t
 
	$ohl
(
ut32_t
 
x
{  x; 
	}
}

50 
le
 
ut32_t
 
	$htl
(
ut32_t
 
x
{  x; 
	}
}

51 #i
CPU
(
MIDDLE_ENDIAN
)

52 
le
 
ut16_t
 
	$ohs
(
ut16_t
 
x
{  x; 
	}
}

53 
le
 
ut16_t
 
	$hts
(
ut16_t
 
x
{  x; 
	}
}

54 
le
 
ut32_t
 
	$ohl
(
ut32_t
 
x
{  
WTF
::
	`wsw32
(x); 
	}
}

55 
le
 
ut32_t
 
	$htl
(
ut32_t
 
x
{  
WTF
::
	`wsw32
(x); 
	}
}

57 
le
 
ut16_t
 
	$ohs
(
ut16_t
 
x
{  
WTF
::
	`bsw16
(x); 
	}
}

58 
le
 
ut16_t
 
	$hts
(
ut16_t
 
x
{  
WTF
::
	`bsw16
(x); 
	}
}

59 
le
 
ut32_t
 
	$ohl
(
ut32_t
 
x
{  
WTF
::
	`bsw32
(x); 
	}
}

60 
le
 
ut32_t
 
	$htl
(
ut32_t
 
x
{  
WTF
::
	`bsw32
(x); 
	}
}

	@ByteSpinLock.h

26 #ide
BySpLock_h


27 
	#BySpLock_h


	)

29 
	~<thad
>

30 
	~<wtf/Asis.h
>

31 
	~<wtf/Atomics.h
>

32 
	~<wtf/Lock.h
>

33 
	~<wtf/Ncyab.h
>

35 
mea
 
	gWTF
 {

37 as
	cBySpLock
 {

38 
WTF_MAKE_NONCOPYABLE
(
BySpLock
);

39 
	gpublic
:

40 
BySpLock
()

41 : 
m_lock
(0)

45 
lock
()

47 !
wkComAndSw
(&
m_lock
, 0, 1))

48 
	gd
::
this_thad
::
yld
();

49 
memyBrrALock
();

52 
uock
()

54 
memyBrrBefeUock
();

55 
	gm_lock
 = 0;

58 
bo
 
isHd
(cڡ {  !!
	gm_lock
; }

60 
	give
:

61 
ut8_t
 
m_lock
;

64 
	gLock
<
	tBySpLock
> 
	tBySpLock
;

68 
usg
 
	gWTF
::
BySpLock
;

69 
usg
 
	gWTF
::
BySpLock
;

	@CheckedArithmetic.h

26 #ide
CheckedArhmic_h


27 
	#CheckedArhmic_h


	)

29 
	~<wtf/Asis.h
>

31 
	~<lims
>

32 
	~<dt.h
>

33 
	~<ty_as
>

67 
mea
 
	gWTF
 {

69 as
	cCheckedS
 {

70 
	gDidOvow
,

71 
	gDidNOvow


74 as
	cCshOnOvow
 {

75 
	gpublic
:

76 
NO_RETURN_DUE_TO_CRASH
 
ovowed
()

78 
CRASH
();

81 
rOvow
() { }

83 
	gpublic
:

84 
bo
 
hasOvowed
(cڡ {  
l
; }

87 as
	cRecdOvow
 {

88 
	geed
:

89 
RecdOvow
()

90 : 
m_ovowed
(
l
)

94 
ovowed
()

96 
m_ovowed
 = 
ue
;

99 
rOvow
()

101 
	gm_ovowed
 = 
l
;

104 
	gpublic
:

105 
bo
 
hasOvowed
(cڡ {  
m_ovowed
; }

107 
	give
:

108 
m_ovowed
;

111 
	gme
 <
tyme
 
	gT
, 
ass
 
	gOvowHdr
 = 
CshOnOvow
> cs
Checked
;

112 
	gme
 <
tyme
 
	gT
> 
	gRemoveChecked
;

113 
	gme
 <
tyme
 
	gT
> 
	gRemoveChecked
<
	gChecked
<T>>;

115 
	gme
 <
tyme
 
	gTg
,ym
	gSour
, 
bo
 
	grgSigd
 = 
d
::
numic_lims
<
Tg
>::
is_sigd
, bo 
	gsourSigd
 = std::numic_lims<
Sour
>::is_sigd> 
BoundsCheck
;

116 
	gme
 <
tyme
 
	gTg
,ym
	gSour
> 
	gBoundsCheck
<Tg, Sour, 
	gl
, false> {

117 
bo
 
Bounds
(
Sour
 
vue
)

121  
	gvue
 <
d
::
numic_lims
<
Tg
>::
max
();

125 
	gme
 <
tyme
 
	gTg
,ym
	gSour
> 
	gBoundsCheck
<Tg, Sour, 
	gue
,rue> {

126 
bo
 
Bounds
(
Sour
 
vue
)

130  
	gd
::
numic_lims
<
Tg
>::
m
(<
vue
 && vu<
d
::numic_lims<Tg>::
max
();

134 
	gme
 <
tyme
 
	gTg
,ym
	gSour
> 
	gBoundsCheck
<Tg, Sour, 
	gl
, 
	gue
> {

135 
bo
 
Bounds
(
Sour
 
vue
)

138 i(
	gvue
 < 0)

139  
	gl
;

142 i((
	gTg
>(
Sour
))

143  
ic_
<
Tg
>(
vue
<
d
::
numic_lims
<Tg>::
max
();

146  
	gvue
 <
ic_
<
Sour
>(
d
::
numic_lims
<
Tg
>::
max
());

150 
	gme
 <
tyme
 
	gTg
,ym
	gSour
> 
	gBoundsCheck
<Tg, Sour, 
	gue
, 
	gl
> {

151 
bo
 
Bounds
(
Sour
 
vue
)

154 i((
	gTg
<(
Sour
))

155  
vue
 <
ic_
<
Sour
>(
d
::
numic_lims
<
Tg
>::
max
());

158  
	gue
;

162 
	gme
 <
tyme
 
	gTg
,ym
	gSour
, 
bo
 
	gCElide
 = 
d
::
is_me
<
Tg
, Sour>::
vue
 || ((Tg> (
Sour
)> 
BoundsCheckElid
;

163 
	gme
 <
tyme
 
	gTg
,ym
	gSour
> 
	gBoundsCheckElid
<Tg, Sour, 
	gue
> {

164 
bo
 
Bounds
(
Sour
{  
	gue
; }

166 
	gme
 <
tyme
 
	gTg
,ym
	gSour
> 
	gBoundsCheckElid
<Tg, Sour, 
	gl
> : 
public
 
BoundsCheck
<
Tg
, Source> {

169 
	gme
 <
tyme
 
	gTg
,ym
	gSour
> 
le
 
bo
 
	$isInBounds
(
Sour
 
vue
)

171  
BoundsCheckElid
<
Tg
, 
Sour
>::
	`Bounds
(
vue
);

172 
	}
}

174 
	gme
 <
tyme
 
	gT
> 
	sRemoveChecked
 {

175 
T
 
	tC˪Ty
;

176 cڡ 
C˪Ty
 
	gDeuVue
 = 0;

179 
	gme
 <
tyme
 
	gT
> 
	gRemoveChecked
<
	gChecked
<T, 
	gCshOnOvow
>> {

180 
tyme
 
	tRemoveChecked
<
	tT
>::
	tC˪Ty
 CleanType;

181 cڡ 
C˪Ty
 
	gDeuVue
 = 0;

184 
	gme
 <
tyme
 
	gT
> 
	gRemoveChecked
<
	gChecked
<T, 
	gRecdOvow
>> {

185 
tyme
 
	tRemoveChecked
<
	tT
>::
	tC˪Ty
 CleanType;

186 cڡ 
C˪Ty
 
	gDeuVue
 = 0;

191 
	gme
 <
tyme
 
	gU
,ym
	gV
, 
bo
 
	guIsBigg
 = ((
U
> (
V
)), bo 
	gmeSize
 = ((U=(V))> 
ResuBa
;

192 
	gme
 <
tyme
 
	gU
,ym
	gV
> 
	gResuBa
<U, V, 
	gue
, 
	gl
> {

193 
U
 
	tResuTy
;

196 
	gme
 <
tyme
 
	gU
,ym
	gV
> 
	gResuBa
<U, V, 
	gl
, false> {

197 
V
 
	tResuTy
;

200 
	gme
 <
tyme
 
	gU
> 
	gResuBa
<U, U, 
	gl
, 
	gue
> {

201 
U
 
	tResuTy
;

204 
	gme
 <
tyme
 
	gU
,ym
	gV
, 
bo
 
	guIsSigd
 = 
d
::
numic_lims
<
U
>::
is_sigd
, bo 
	gvIsSigd
 = std::numic_lims<
V
>::is_sigd> 
SigdssSe
;

205 
	gme
 <
tyme
 
	gU
,ym
	gV
> 
	gSigdssSe
<U, V, 
	gue
,rue> {

206 
U
 
	tResuTy
;

209 
	gme
 <
tyme
 
	gU
,ym
	gV
> 
	gSigdssSe
<U, V, 
	gl
, false> {

210 
U
 
	tResuTy
;

213 
	gme
 <
tyme
 
	gU
,ym
	gV
> 
	gSigdssSe
<U, V, 
	gue
, 
	gl
> {

214 
V
 
	tResuTy
;

217 
	gme
 <
tyme
 
	gU
,ym
	gV
> 
	gSigdssSe
<U, V, 
	gl
, 
	gue
> {

218 
U
 
	tResuTy
;

221 
	gme
 <
tyme
 
	gU
,ym
	gV
> 
	gResuBa
<U, V, 
	gl
, 
	gue
> {

222 
tyme
 
	tSigdssSe
<
	tU
, 
	tV
>::
	tResuTy
 ResultType;

225 
	gme
 <
tyme
 
	gU
,ym
	gV
> 
	gResu
 : 
ResuBa
<tym
RemoveChecked
<
U
>::
C˪Ty
,ym
	gRemoveChecked
<V>::CleanType> {

228 
	gme
 <
tyme
 
	gLHS
,ym
	gRHS
,ym
	gResuTy
 =ym
Resu
<
LHS
, RHS>::
ResuTy
,

229 
bo
 
	glhsSigd
 = 
d
::
numic_lims
<
LHS
>::
is_sigd
, bo 
	grhsSigd
 = std::numic_lims<
RHS
>::is_sigd> 
ArhmicOtis
;

231 
	gme
 <
tyme
 
	gLHS
,ym
	gRHS
,ym
	gResuTy
> 
	gArhmicOtis
<LHS, RHS, ResuTy, 
	gue
,rue> {

235 
le
 
bo
 
signsMch
(
LHS
 
lhs
, 
RHS
 
rhs
)

237  (
	glhs
 ^ 
	grhs
) >= 0;

240 
le
 
bo
 
add
(
LHS
 
lhs
, 
RHS
 
rhs
, 
ResuTy
& 
su

	gWARN_UNUSED_RETURN


242 i(
signsMch
(
lhs
, 
rhs
)) {

243 i(
	glhs
 >= 0) {

244 i((
d
::
numic_lims
<
ResuTy
>::
max
(- 
rhs
< 
lhs
)

245  
l
;

247 
ResuTy
 
	gmp
 = 
lhs
 - 
d
::
numic_lims
<ResuTy>::
m
();

248 i(
	grhs
 < -
	gmp
)

249  
	gl
;

252 
	gsu
 = 
lhs
 + 
rhs
;

253  
	gue
;

256 
le
 
bo
 
sub
(
LHS
 
lhs
, 
RHS
 
rhs
, 
ResuTy
& 
su

	gWARN_UNUSED_RETURN


258 i(!
signsMch
(
lhs
, 
rhs
)) {

259 i(
	glhs
 >= 0) {

260 i(
lhs
 > 
d
::
numic_lims
<
ResuTy
>::
max
(+ 
rhs
)

261  
l
;

263 i(
	grhs
 > 
	gd
::
numic_lims
<
ResuTy
>::
max
(+ 
lhs
)

264  
l
;

267 
	gsu
 = 
lhs
 - 
rhs
;

268  
	gue
;

271 
le
 
bo
 
muɝly
(
LHS
 
lhs
, 
RHS
 
rhs
, 
ResuTy
& 
su

	gWARN_UNUSED_RETURN


273 i(
signsMch
(
lhs
, 
rhs
)) {

274 i(
	glhs
 >= 0) {

275 i(
lhs
 && (
d
::
numic_lims
<
ResuTy
>::
max
(/hs< 
rhs
)

276  
l
;

278 i(
	gic_
<
	gResuTy
>(
	glhs
=
d
::
numic_lims
<
ResuTy
>::
m
(|| 
ic_
<ResuTy>(
rhs
) == std::numeric_limits<ResultType>::min())

279  
l
;

280 i((
	gd
::
numic_lims
<
ResuTy
>::
max
(/ -
lhs
< -
rhs
)

281  
l
;

284 i(
	glhs
 < 0) {

285 i(
	grhs
 && 
	glhs
 < (
	gd
::
numic_lims
<
ResuTy
>::
m
(/ 
rhs
))

286  
l
;

288 i(
	glhs
 && 
	grhs
 < (
	gd
::
numic_lims
<
ResuTy
>::
m
(/ 
lhs
))

289  
l
;

292 
	gsu
 = 
lhs
 * 
rhs
;

293  
	gue
;

296 
le
 
bo
 
equs
(
LHS
 
lhs
, 
RHS
 
rhs
{  
	glhs
 ==hs; }

300 
	gme
 <
tyme
 
	gLHS
,ym
	gRHS
,ym
	gResuTy
> 
	gArhmicOtis
<LHS, RHS, ResuTy, 
	gl
, false> {

302 
le
 
bo
 
add
(
LHS
 
lhs
, 
RHS
 
rhs
, 
ResuTy
& 
su

	gWARN_UNUSED_RETURN


304 
ResuTy
 
	gmp
 = 
lhs
 + 
rhs
;

305 i(
	gmp
 < 
	glhs
)

306  
	gl
;

307 
	gsu
 = 
mp
;

308  
	gue
;

311 
le
 
bo
 
sub
(
LHS
 
lhs
, 
RHS
 
rhs
, 
ResuTy
& 
su

	gWARN_UNUSED_RETURN


313 
ResuTy
 
	gmp
 = 
lhs
 - 
rhs
;

314 i(
	gmp
 > 
	glhs
)

315  
	gl
;

316 
	gsu
 = 
mp
;

317  
	gue
;

320 
le
 
bo
 
muɝly
(
LHS
 
lhs
, 
RHS
 
rhs
, 
ResuTy
& 
su

	gWARN_UNUSED_RETURN


322 i(!
	glhs
 || !
	grhs
) {

323 
	gsu
 = 0;

324  
	gue
;

326 i(
	gd
::
numic_lims
<
ResuTy
>::
max
(/ 
lhs
 < 
rhs
)

327  
l
;

328 
	gsu
 = 
lhs
 * 
rhs
;

329  
	gue
;

332 
le
 
bo
 
equs
(
LHS
 
lhs
, 
RHS
 
rhs
{  
	glhs
 ==hs; }

336 
	gme
 <
tyme
 
	gResuTy
> 
	gArhmicOtis
<, , ResuTy, 
	gue
, 
	gl
> {

337 
le
 
bo
 
add
(
t64_t
 
lhs
, i64_
rhs
, 
ResuTy
& 
su
)

339 
t64_t
 
	gmp
 = 
lhs
 + 
rhs
;

340 i(
	gmp
 < 
	gd
::
numic_lims
<
ResuTy
>::
m
())

341  
l
;

342 i(
	gmp
 > 
	gd
::
numic_lims
<
ResuTy
>::
max
())

343  
l
;

344 
	gsu
 = 
ic_
<
ResuTy
>(
mp
);

345  
	gue
;

348 
le
 
bo
 
sub
(
t64_t
 
lhs
, i64_
rhs
, 
ResuTy
& 
su
)

350 
t64_t
 
	gmp
 = 
lhs
 - 
rhs
;

351 i(
	gmp
 < 
	gd
::
numic_lims
<
ResuTy
>::
m
())

352  
l
;

353 i(
	gmp
 > 
	gd
::
numic_lims
<
ResuTy
>::
max
())

354  
l
;

355 
	gsu
 = 
ic_
<
ResuTy
>(
mp
);

356  
	gue
;

359 
le
 
bo
 
muɝly
(
t64_t
 
lhs
, i64_
rhs
, 
ResuTy
& 
su
)

361 
t64_t
 
	gmp
 = 
lhs
 * 
rhs
;

362 i(
	gmp
 < 
	gd
::
numic_lims
<
ResuTy
>::
m
())

363  
l
;

364 i(
	gmp
 > 
	gd
::
numic_lims
<
ResuTy
>::
max
())

365  
l
;

366 
	gsu
 = 
ic_
<
ResuTy
>(
mp
);

367  
	gue
;

370 
le
 
bo
 
equs
(
lhs
, 
rhs
)

372  
	gic_
<
	gt64_t
>(
	glhs
=
ic_
<
t64_t
>(
rhs
);

376 
	gme
 <
tyme
 
	gResuTy
> 
	gArhmicOtis
<, , ResuTy, 
	gl
, 
	gue
> {

377 
le
 
bo
 
add
(
t64_t
 
lhs
, i64_
rhs
, 
ResuTy
& 
su
)

379  
	gArhmicOtis
<, , 
	gResuTy
>::
add
(
rhs
, 
lhs
, 
su
);

382 
le
 
bo
 
sub
(
t64_t
 
lhs
, i64_
rhs
, 
ResuTy
& 
su
)

384  
	gArhmicOtis
<, , 
	gResuTy
>::
sub
(
lhs
, 
rhs
, 
su
);

387 
le
 
bo
 
muɝly
(
t64_t
 
lhs
, i64_
rhs
, 
ResuTy
& 
su
)

389  
	gArhmicOtis
<, , 
	gResuTy
>::
muɝly
(
rhs
, 
lhs
, 
su
);

392 
le
 
bo
 
equs
(
lhs
, 
rhs
)

394  
	gArhmicOtis
<, , 
	gResuTy
>::
equs
(
rhs
, 
lhs
);

398 
	gme
 <
tyme
 
	gU
,ym
	gV
,ym
	gR
> 
le
 
bo
 
	$Add
(
U
 
lhs
, 
V
 
rhs
, 
R
& 
su
)

400  
ArhmicOtis
<
U
, 
V
, 
R
>::
	`add
(
lhs
, 
rhs
, 
su
);

401 
	}
}

403 
	gme
 <
tyme
 
	gU
,ym
	gV
,ym
	gR
> 
le
 
bo
 
	$Sub
(
U
 
lhs
, 
V
 
rhs
, 
R
& 
su
)

405  
ArhmicOtis
<
U
, 
V
, 
R
>::
	`sub
(
lhs
, 
rhs
, 
su
);

406 
	}
}

408 
	gme
 <
tyme
 
	gU
,ym
	gV
,ym
	gR
> 
le
 
bo
 
	$Muɝly
(
U
 
lhs
, 
V
 
rhs
, 
R
& 
su
)

410  
ArhmicOtis
<
U
, 
V
, 
R
>::
	`muɝly
(
lhs
, 
rhs
, 
su
);

411 
	}
}

413 
	gme
 <
tyme
 
	gU
,ym
	gV
> 
le
 
bo
 
	$Equs
(
U
 
lhs
, 
V
 
rhs
)

415  
ArhmicOtis
<
U
, 
V
>::
	`equs
(
lhs
, 
rhs
);

416 
	}
}

418 
	eResuOvowedTag
 { 
	gResuOvowed
 };

420 
	gme
 <
tyme
 
	gT
, 
ass
 
	gOvowHdr
> cs
	cChecked
 : 
public
 
OvowHdr
 {

421 
public
:

422 
me
 <
tyme
 
_T
, 
ass
 
	g_OvowHdr
> 
nd
 cs
	gChecked
;

423 
Checked
()

424 : 
m_vue
(0)

428 
Checked
(
ResuOvowedTag
)

429 : 
m_vue
(0)

431 
this
->
ovowed
();

434 
	gme
 <
tyme
 
	gU
> 
Checked
(
U
 
vue
)

436 i(!
	gisInBounds
<
	gT
>(
	gvue
))

437 
	gthis
->
ovowed
();

438 
	gm_vue
 = 
ic_
<
T
>(
vue
);

441 
	gme
 <
tyme
 
	gV
> 
Checked
(cڡ Checked<
T
, 
V
>& 
rhs
)

442 : 
m_vue
(
rhs
.m_value)

444 i(
rhs
.
hasOvowed
())

445 
this
->
ovowed
();

448 
	gme
 <
tyme
 
	gU
> 
Checked
(cڡ Checked<
U
, 
OvowHdr
>& 
rhs
)

449 : 
OvowHdr
(
rhs
)

451 i(!
isInBounds
<
T
>(
rhs
.
m_vue
))

452 
this
->
ovowed
();

453 
	gm_vue
 = 
ic_
<
T
>(
rhs
.
m_vue
);

456 
	gme
 <
tyme
 
	gU
,ym
	gV
> 
Checked
(cڡ Checked<
U
, 
V
>& 
rhs
)

458 i(
	grhs
.
hasOvowed
())

459 
	gthis
->
ovowed
();

460 i(!
	gisInBounds
<
	gT
>(
	grhs
.
	gm_vue
))

461 
	gthis
->
ovowed
();

462 
	gm_vue
 = 
ic_
<
T
>(
rhs
.
m_vue
);

465 cڡ 
	gChecked
& 
	gݔ
=(
Checked
 
rhs
)

467 
this
->
rOvow
();

468 i(
	grhs
.
hasOvowed
())

469 
	gthis
->
ovowed
();

470 
	gm_vue
 = 
ic_
<
T
>(
rhs
.
m_vue
);

471  *
	gthis
;

474 
	gme
 <
tyme
 
	gU
> cڡ 
	gChecked
& 
	gݔ
=(
U
 
vue
)

476  *
this
 = 
Checked
(
vue
);

479 
	gme
 <
tyme
 
	gU
,ym
	gV
> cڡ 
	gChecked
& 
	gݔ
=(cڡ 
Checked
<
U
, V>& 
	grhs
)

481  *
	gthis
 = 
Checked
(
rhs
);

485 cڡ 
	gChecked
& 
	gݔ
++()

487 i(
	gm_vue
 =
d
::
numic_lims
<
T
>::
max
())

488 
this
->
ovowed
();

489 
	gm_vue
++;

490  *
	gthis
;

493 cڡ 
	gChecked
& 
	gݔ
--()

495 i(
	gm_vue
 =
d
::
numic_lims
<
T
>::
m
())

496 
this
->
ovowed
();

497 
	gm_vue
--;

498  *
	gthis
;

502 cڡ 
Checked
 
	gݔ
++()

504 i(
	gm_vue
 =
d
::
numic_lims
<
T
>::
max
())

505 
this
->
ovowed
();

506  
Checked
(
m_vue
++);

509 cڡ 
Checked
 
	gݔ
--()

511 i(
	gm_vue
 =
d
::
numic_lims
<
T
>::
m
())

512 
this
->
ovowed
();

513  
Checked
(
m_vue
--);

517 
bo
 
	gݔ
!() const

519 i(
	gthis
->
hasOvowed
())

520 
CRASH
();

521  !
	gm_vue
;

524 * (
	tChecked
::*
	tUnecifdBoTy
);

525 
ݔ
 
	gUnecifdBoTy
*() const

527 i(
	gthis
->
hasOvowed
())

528 
CRASH
();

529  (
	gm_vue
? 
	gt_
<
	gUnecifdBoTy
*>(1) : 0;

533 
T
 
unG
() const

535 i(
	gthis
->
hasOvowed
())

536 
CRASH
();

537  
	gm_vue
;

540 
le
 
CheckedS
 
G
(
T
& 
vue
cڡ 
	gWARN_UNUSED_RETURN


542 
	gvue
 = 
m_vue
;

543 i(
	gthis
->
hasOvowed
())

544  
	gCheckedS
::
DidOvow
;

545  
	gCheckedS
::
DidNOvow
;

549 
	gme
 <
tyme
 
	gU
> cڡ 
Checked
 
	gݔ
+=(
U
 
rhs
)

551 i(!
Add
(
m_vue
, 
rhs
, m_value))

552 
this
->
ovowed
();

553  *
	gthis
;

556 
	gme
 <
tyme
 
	gU
> cڡ 
Checked
 
	gݔ
-=(
U
 
rhs
)

558 i(!
Sub
(
m_vue
, 
rhs
, m_value))

559 
this
->
ovowed
();

560  *
	gthis
;

563 
	gme
 <
tyme
 
	gU
> cڡ 
Checked
 
	gݔ
*=(
U
 
rhs
)

565 i(!
Muɝly
(
m_vue
, 
rhs
, m_value))

566 
this
->
ovowed
();

567  *
	gthis
;

570 cڡ 
Checked
 
	gݔ
*=(
rhs
)

572 
su
 = 
rhs
 * 
m_vue
;

574 i(!(
	gd
::
numic_lims
<
T
>::
m
(<
su
 && 
d
::numic_lims<T>::
max
() >=esult))

575 
this
->
ovowed
();

576 
	gm_vue
 = (
T
)
su
;

577  *
	gthis
;

580 cڡ 
Checked
 
	gݔ
*=(
rhs
)

582  *
this
 *()
rhs
;

585 
	gme
 <
tyme
 
	gU
,ym
	gV
> cڡ 
Checked
 
	gݔ
+=(Checked<
U
, V> 
	grhs
)

587 i(
	grhs
.
hasOvowed
())

588 
	gthis
->
ovowed
();

589  *
	gthis
 +
rhs
.
m_vue
;

592 
	gme
 <
tyme
 
	gU
,ym
	gV
> cڡ 
Checked
 
	gݔ
-=(Checked<
U
, V> 
	grhs
)

594 i(
	grhs
.
hasOvowed
())

595 
	gthis
->
ovowed
();

596  *
	gthis
 -
rhs
.
m_vue
;

599 
	gme
 <
tyme
 
	gU
,ym
	gV
> cڡ 
Checked
 
	gݔ
*=(Checked<
U
, V> 
	grhs
)

601 i(
	grhs
.
hasOvowed
())

602 
	gthis
->
ovowed
();

603  *
	gthis
 *
rhs
.
m_vue
;

607 
	gme
 <
tyme
 
	gV
> 
bo
 
	gݔ
==(
Checked
<
T
, V> 
	grhs
)

609  
unG
(=
rhs
.unsafeGet();

612 
	gme
 <
tyme
 
	gU
> 
bo
 
	gݔ
==(
U
 
rhs
)

614 i(
this
->
hasOvowed
())

615 
this
->
ovowed
();

616  
Equs
(
m_vue
, 
rhs
);

619 
	gme
 <
tyme
 
	gU
,ym
	gV
> cڡ 
Checked
 
	gݔ
==(Checked<
U
, V> 
	grhs
)

621  
unG
(=
Checked
(
rhs
.unsafeGet());

624 
	gme
 <
tyme
 
	gU
> 
bo
 
	gݔ
!=(
U
 
rhs
)

626  !(*
this
 =
rhs
);

629 
	give
:

631 
Checked
();

632 
Checked
();

633 
	gݔ
=();

634 
	gݔ
=();

635 
	gݔ
+=();

636 
	gݔ
+=();

637 
	gݔ
-=();

638 
	gݔ
-=();

639 
T
 
	gm_vue
;

642 
	gme
 <
tyme
 
	gU
,ym
	gV
,ym
	gOvowHdr
> 
le
 
	gChecked
<tym
	gResu
<U, V>::
ResuTy
, OvowHdr> 
	gݔ
+(Checked<U, OvowHdr> 
	glhs
, Checked<V, OvowHdr> 
	grhs
)

644 
U
 
	gx
 = 0;

645 
V
 
	gy
 = 0;

646 
bo
 
	govowed
 = 
lhs
.
G
(
x
=
CheckedS
::
DidOvow
 || 
rhs
.G(
y
) == CheckedState::DidOverflow;

647 
tyme
 
	gResu
<
	gU
, 
	gV
>::
ResuTy
 
su
 = 0;

648 
	govowed
 |!
Add
(
x
, 
y
, 
su
);

649 i(
	govowed
)

650  
	gResuOvowed
;

651  
	gsu
;

654 
	gme
 <
tyme
 
	gU
,ym
	gV
,ym
	gOvowHdr
> 
le
 
	gChecked
<tym
	gResu
<U, V>::
ResuTy
, OvowHdr> 
	gݔ
-(Checked<U, OvowHdr> 
	glhs
, Checked<V, OvowHdr> 
	grhs
)

656 
U
 
	gx
 = 0;

657 
V
 
	gy
 = 0;

658 
bo
 
	govowed
 = 
lhs
.
G
(
x
=
CheckedS
::
DidOvow
 || 
rhs
.G(
y
) == CheckedState::DidOverflow;

659 
tyme
 
	gResu
<
	gU
, 
	gV
>::
ResuTy
 
su
 = 0;

660 
	govowed
 |!
Sub
(
x
, 
y
, 
su
);

661 i(
	govowed
)

662  
	gResuOvowed
;

663  
	gsu
;

666 
	gme
 <
tyme
 
	gU
,ym
	gV
,ym
	gOvowHdr
> 
le
 
	gChecked
<tym
	gResu
<U, V>::
ResuTy
, OvowHdr> 
	gݔ
*(Checked<U, OvowHdr> 
	glhs
, Checked<V, OvowHdr> 
	grhs
)

668 
U
 
	gx
 = 0;

669 
V
 
	gy
 = 0;

670 
bo
 
	govowed
 = 
lhs
.
G
(
x
=
CheckedS
::
DidOvow
 || 
rhs
.G(
y
) == CheckedState::DidOverflow;

671 
tyme
 
	gResu
<
	gU
, 
	gV
>::
ResuTy
 
su
 = 0;

672 
	govowed
 |!
Muɝly
(
x
, 
y
, 
su
);

673 i(
	govowed
)

674  
	gResuOvowed
;

675  
	gsu
;

678 
	gme
 <
tyme
 
	gU
,ym
	gV
,ym
	gOvowHdr
> 
le
 
	gChecked
<tym
	gResu
<U, V>::
ResuTy
, OvowHdr> 
	gݔ
+(Checked<U, OvowHdr> 
	glhs
, 
V
 
	grhs
)

680  
	glhs
 + 
	gChecked
<
	gV
, 
	gOvowHdr
>(
	grhs
);

683 
	gme
 <
tyme
 
	gU
,ym
	gV
,ym
	gOvowHdr
> 
le
 
	gChecked
<tym
	gResu
<U, V>::
ResuTy
, OvowHdr> 
	gݔ
-(Checked<U, OvowHdr> 
	glhs
, 
V
 
	grhs
)

685  
	glhs
 - 
	gChecked
<
	gV
, 
	gOvowHdr
>(
	grhs
);

688 
	gme
 <
tyme
 
	gU
,ym
	gV
,ym
	gOvowHdr
> 
le
 
	gChecked
<tym
	gResu
<U, V>::
ResuTy
, OvowHdr> 
	gݔ
*(Checked<U, OvowHdr> 
	glhs
, 
V
 
	grhs
)

690  
lhs
 * 
	gChecked
<
	gV
, 
	gOvowHdr
>(
	grhs
);

693 
	gme
 <
tyme
 
	gU
,ym
	gV
,ym
	gOvowHdr
> 
le
 
	gChecked
<tym
	gResu
<U, V>::
ResuTy
, OvowHdr> 
	gݔ
+(
U
 
	glhs
, Checked<V, OvowHdr> 
	grhs
)

695  
	gChecked
<
	gU
, 
	gOvowHdr
>(
	glhs
+ 
	grhs
;

698 
	gme
 <
tyme
 
	gU
,ym
	gV
,ym
	gOvowHdr
> 
le
 
	gChecked
<tym
	gResu
<U, V>::
ResuTy
, OvowHdr> 
	gݔ
-(
U
 
	glhs
, Checked<V, OvowHdr> 
	grhs
)

700  
	gChecked
<
	gU
, 
	gOvowHdr
>(
	glhs
- 
	grhs
;

703 
	gme
 <
tyme
 
	gU
,ym
	gV
,ym
	gOvowHdr
> 
le
 
	gChecked
<tym
	gResu
<U, V>::
ResuTy
, OvowHdr> 
	gݔ
*(
U
 
	glhs
, Checked<V, OvowHdr> 
	grhs
)

705  
	gChecked
<
	gU
, 
	gOvowHdr
>(
	glhs
* 
	grhs
;

709 
	gChecked
<
	tt8_t
, 
	tRecdOvow
> 
	tCheckedI8
;

710 
	gChecked
<
	tut8_t
, 
	tRecdOvow
> 
	tCheckedUt8
;

711 
	gChecked
<
	tt16_t
, 
	tRecdOvow
> 
	tCheckedI16
;

712 
	gChecked
<
	tut16_t
, 
	tRecdOvow
> 
	tCheckedUt16
;

713 
	gChecked
<
	tt32_t
, 
	tRecdOvow
> 
	tCheckedI32
;

714 
	gChecked
<
	tut32_t
, 
	tRecdOvow
> 
	tCheckedUt32
;

715 
	gChecked
<
	tt64_t
, 
	tRecdOvow
> 
	tCheckedI64
;

716 
	gChecked
<
	tut64_t
, 
	tRecdOvow
> 
	tCheckedUt64
;

717 
	gChecked
<
	tsize_t
, 
	tRecdOvow
> 
	tCheckedSize
;

719 
	gme
<
tyme
 
	gT
,ym
	gU
>

720 
	gChecked
<
	gT
, 
	gRecdOvow
> 
	$checkedSum
(
U
 
vue
)

722  
Checked
<
T
, 
RecdOvow
>(
vue
);

723 
	}
}

724 
	gme
<
tyme
 
	gT
,ym
	gU
, 
	gtyme
... 
	gArgs
>

725 
	gChecked
<
	gT
, 
	gRecdOvow
> 
	$checkedSum
(
U
 
vue
, 
Args
... 
gs
)

727  
Checked
<
T
, 
RecdOvow
>(
vue
+ 
checkedSum
<T>(
gs
...);

728 
	}
}

733 
	gme
<
tyme
 
	gT
, 
	gtyme
... 
	gArgs
> 
bo
 
	$sumOvows
(
Args
... 
gs
)

735  
checkedSum
<
T
>(
gs
...).
	`hasOvowed
();

736 
	}
}

740 
usg
 
	gWTF
::
Checked
;

741 
usg
 
	gWTF
::
CheckedS
;

742 
usg
 
	gWTF
::
RecdOvow
;

743 
usg
 
	gWTF
::
CheckedI8
;

744 
usg
 
	gWTF
::
CheckedUt8
;

745 
usg
 
	gWTF
::
CheckedI16
;

746 
usg
 
	gWTF
::
CheckedUt16
;

747 
usg
 
	gWTF
::
CheckedI32
;

748 
usg
 
	gWTF
::
CheckedUt32
;

749 
usg
 
	gWTF
::
CheckedI64
;

750 
usg
 
	gWTF
::
CheckedUt64
;

751 
usg
 
	gWTF
::
CheckedSize
;

752 
usg
 
	gWTF
::
checkedSum
;

753 
usg
 
	gWTF
::
sumOvows
;

	@CheckedBoolean.h

26 #ide
CheckedBoޗn_h


27 
	#CheckedBoޗn_h


	)

29 
	~<wtf/Asis.h
>

31 as
	cCheckedBoޗn
 {

32 
	mpublic
:

33 #i!
ASSERT_DISABLED


34 
	$CheckedBoޗn
(cڡ 
CheckedBoޗn
& 
h
)

35 : 
	`m_vue
(
h
.
m_vue
)

36 , 
	$m_checked
(
l
)

38 
h
.
m_checked
 = 
ue
;

42 
	$CheckedBoޗn
(
bo
 
vue
)

43 : 
	$m_vue
(
vue
)

44 #i!
ASSERT_DISABLED


45 , 
	$m_checked
(
l
)

48 
	}
}

50 ~
	$CheckedBoޗn
()

52 
	`ASSERT
(
m_checked
);

53 
	}
}

55 
ݔ
 
	$bo
()

57 #i!
ASSERT_DISABLED


58 
m_checked
 = 
ue
;

60  
m_vue
;

61 
	}
}

63 
	give
:

64 
bo
 
m_vue
;

65 #i!
ASSERT_DISABLED


66 
mub
 
bo
 
	gm_checked
;

	@CommaPrinter.h

26 #ide
CommaPrr_h


27 
	#CommaPrr_h


	)

29 
	~"PrtSm.h
"

31 
mea
 
	gWTF
 {

33 as
	cCommaPrr
 {

34 
	gpublic
:

35 
CommaPrr
(cڡ * 
comma
 = ", ")

36 : 
m_comma
(
comma
)

37 , 
m_isF
(
ue
)

41 
dump
(
PrtSm
& 
out
) const

43 i(
	gm_isF
) {

44 
	gm_isF
 = 
l
;

48 
	gout
.
t
(
m_comma
);

51 
	give
:

52 cڡ * 
m_comma
;

53 
mub
 
bo
 
	gm_isF
;

58 
usg
 
	gWTF
::
CommaPrr
;

	@CompilationThread.cpp

26 
	~"cfig.h
"

27 
	~"CompiThad.h
"

29 
	~"StdLibExas.h
"

30 
	~"ThadScific.h
"

31 
	~"Thadg.h
"

32 
	~<mux
>

34 
mea
 
	gWTF
 {

36 
	gThadScific
<
	gbo
>* 
	gs_isCompiThad
;

38 
lizeCompiThads
()

40 
	gd
::
_ag
 
lizeCompiThadsOnFg
;

41 
	gd
::
_
(
lizeCompiThadsOnFg
, []{

42 
s_isCompiThad
 = 
w
 
ThadScific
<
bo
>();

46 
bo
 
isCompiThad
()

48 i(!
	gs_isCompiThad
)

49  
	gl
;

50 i(!
	gs_isCompiThad
->
isS
())

51  
	gl
;

52  **
	gs_isCompiThad
;

55 
bo
 
exchgeIsCompiThad
(bo 
wVue
)

57 
lizeCompiThads
();

58 
bo
 
	gdVue
 = 
isCompiThad
();

59 **
	gs_isCompiThad
 = 
wVue
;

60  
	gdVue
;

	@CompilationThread.h

26 #ide
CompiThad_h


27 
	#CompiThad_h


	)

29 
mea
 
	gWTF
 {

31 
WTF_EXPORT_PRIVATE
 
bo
 
exchgeIsCompiThad
(bo 
wVue
);

33 as
	cCompiSce
 {

34 
	gpublic
:

35 
CompiSce
()

36 : 
m_dVue
(
exchgeIsCompiThad
(
ue
))

40 ~
CompiSce
()

42 
exchgeIsCompiThad
(
m_dVue
);

45 
aveEly
()

47 
exchgeIsCompiThad
(
m_dVue
);

49 
	give
:

50 
bo
 
m_dVue
;

55 
usg
 
	gWTF
::
CompiSce
;

56 
usg
 
	gWTF
::
exchgeIsCompiThad
;

	@Compiler.h

26 #ide
WTF_Comp_h


27 
	#WTF_Comp_h


	)

30 
	#COMPILER
(
WTF_FEATURE
(
defed
 
WTF_COMPILER_
##WTF_FEATURE && WTF_COMPILER_##WTF_FEATURE)

	)

33 
	#COMPILER_SUPPORTS
(
WTF_COMPILER_FEATURE
(
defed
 
WTF_COMPILER_SUPPORTS_
##WTF_COMPILER_FEATURE && WTF_COMPILER_SUPPORTS_##WTF_COMPILER_FEATURE)

	)

36 
	#COMPILER_QUIRK
(
WTF_COMPILER_QUIRK
(
defed
 
WTF_COMPILER_QUIRK_
##WTF_COMPILER_QUIRK && WTF_COMPILER_QUIRK_##WTF_COMPILER_QUIRK)

	)

42 #i
defed
(
__g__
)

43 
	#WTF_COMPILER_CLANG
 1

	)

44 
	#WTF_COMPILER_SUPPORTS_BLOCKS
 
	`__has_u
(
blocks
)

	)

45 
	#WTF_COMPILER_SUPPORTS_C_STATIC_ASSERT
 
	`__has_u
(
c_ic_as
)

	)

46 
	#WTF_COMPILER_SUPPORTS_CXX_CONSTEXPR
 
	`__has_u
(
cxx_cڡex
)

	)

47 
	#WTF_COMPILER_SUPPORTS_CXX_REFERENCE_QUALIFIED_FUNCTIONS
 
	`__has_u
(
cxx_n_quifd_funis
)

	)

48 
	#WTF_COMPILER_SUPPORTS_CXX_USER_LITERALS
 
	`__has_u
(
cxx_ur_ls
)

	)

49 
	#WTF_COMPILER_SUPPORTS_FALLTHROUGH_WARNINGS
 
	`__has_u
(
cxx_ibus
&& 
	`__has_wng
("-Wimic-through")

	)

56 #i
defed
(
__GNUC__
)

57 
	#WTF_COMPILER_GCC
 1

	)

58 
	#GCC_VERSION
 (
__GNUC__
 * 10000 + 
__GNUC_MINOR__
 * 100 + 
__GNUC_PATCHLEVEL__
)

	)

59 
	#GCC_VERSION_AT_LEAST
(
maj
, 
m
, 
tch
(
GCC_VERSION
 >(maj * 10000 + m * 100 +ch))

	)

64 #i!
defed
(
GCC_VERSION_AT_LEAST
)

65 
	#GCC_VERSION_AT_LEAST
(
maj
, 
m
, 
tch
0

	)

68 #i
COMPILER
(
GCC
&& !COMPILER(
CLANG
&& !
GCC_VERSION_AT_LEAST
(4, 7, 0)

72 #i
COMPILER
(
GCC
&& !COMPILER(
CLANG
)

73 
	#WTF_COMPILER_SUPPORTS_CXX_CONSTEXPR
 1

	)

74 
	#WTF_COMPILER_SUPPORTS_CXX_USER_LITERALS
 1

	)

77 #i!
COMPILER
(
CLANG
)

78 
	#WTF_COMPILER_QUIRK_CONSIDERS_UNREACHABLE_CODE
 1

	)

81 #i
COMPILER
(
GCC
&& !COMPILER(
CLANG
&& 
defed
(
__STDC_VERSION__
) && __STDC_VERSION__ >= 201112L

82 
	#WTF_COMPILER_SUPPORTS_C_STATIC_ASSERT
 1

	)

85 #i
COMPILER
(
GCC
&& !COMPILER(
CLANG
&& 
GCC_VERSION_AT_LEAST
(4, 8, 0)

86 #agm
GCC
 
dgnoic
 
igned
 "-Wmaybe-uninitialized"

89 #i
COMPILER
(
GCC
&& !COMPILER(
CLANG
&& (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
|| (defed(
__lulus
) && __cplusplus >= 201103L))

90 #agm
GCC
 
dgnoic
 
igned
 "-Wunused-local-typedefs"

95 #i
defed
(
__MINGW32__
)

96 
	#WTF_COMPILER_MINGW
 1

	)

97 
	~<_mgw.h
>

104 #i
COMPILER
(
MINGW
&& 
defed
(
__MINGW64_VERSION_MAJOR
)

105 
	#WTF_COMPILER_MINGW64
 1

	)

110 #i
defed
(
_MSC_VER
)

111 
	#WTF_COMPILER_MSVC
 1

	)

114 #i
defed
(
_MSC_VER
) && _MSC_VER < 1800

120 #i
defed
(
__SUNPRO_CC
|| defed(
__SUNPRO_C
)

121 
	#WTF_COMPILER_SUNCC
 1

	)

128 #i
defed
(
__ARM_EABI__
|| defed(
__EABI__
)

129 
	#WTF_COMPILER_SUPPORTS_EABI
 1

	)

136 #i!
defed
(
ALWAYS_INLINE
&& 
COMPILER
(
GCC
&& defed(
NDEBUG
&& !COMPILER(
MINGW
)

137 
	#ALWAYS_INLINE
 
le
 
	`__ibu__
((
__ways_le__
))

	)

140 #i!
defed
(
ALWAYS_INLINE
&& 
COMPILER
(
MSVC
&& defed(
NDEBUG
)

141 
	#ALWAYS_INLINE
 
__fle


	)

144 #i!
defed
(
ALWAYS_INLINE
)

145 
	#ALWAYS_INLINE
 
le


	)

150 #i!
defed
(
CONSTEXPR
&& 
COMPILER_SUPPORTS
(
CXX_CONSTEXPR
)

151 
	#CONSTEXPR
 
cڡex


	)

154 #i!
defed
(
CONSTEXPR
)

155 
	#CONSTEXPR


	)

160 #i!
defed
(
FALLTHROUGH
&& 
COMPILER_SUPPORTS
(
FALLTHROUGH_WARNINGS
&& 
COMPILER
(
CLANG
)

161 
	#FALLTHROUGH
 [[
g
::
through
]]

	)

164 #i!
defed
(
FALLTHROUGH
)

165 
	#FALLTHROUGH


	)

170 #i!
defed
(
LIKELY
&& 
COMPILER
(
GCC
)

171 
	#LIKELY
(
x

	`__but_ex
(!!(x), 1)

	)

174 #i!
defed
(
LIKELY
)

175 
	#LIKELY
(
x
(x)

	)

180 #i!
defed
(
NEVER_INLINE
&& 
COMPILER
(
GCC
)

181 
	#NEVER_INLINE
 
	`__ibu__
((
__nole__
))

	)

184 #i!
defed
(
NEVER_INLINE
&& 
COMPILER
(
MSVC
)

185 
	#NEVER_INLINE
 
	`__deec
(
nole
)

	)

188 #i!
defed
(
NEVER_INLINE
)

189 
	#NEVER_INLINE


	)

194 #i!
defed
(
NO_RETURN
&& 
COMPILER
(
GCC
)

195 
	#NO_RETURN
 
	`__ibu
((
__nܑu__
))

	)

198 #i!
defed
(
NO_RETURN
&& 
COMPILER
(
MSVC
)

199 
	#NO_RETURN
 
	`__deec
(
nܑu
)

	)

202 #i!
defed
(
NO_RETURN
)

203 
	#NO_RETURN


	)

208 #i!
defed
(
NO_RETURN_WITH_VALUE
&& !
COMPILER
(
MSVC
)

209 
	#NO_RETURN_WITH_VALUE
 
NO_RETURN


	)

212 #i!
defed
(
NO_RETURN_WITH_VALUE
)

213 
	#NO_RETURN_WITH_VALUE


	)

218 #i!
defed
(
OBJC_CLASS
&& defed(
__OBJC__
)

219 
	#OBJC_CLASS
 @
ass


	)

222 #i!
defed
(
OBJC_CLASS
)

223 
	#OBJC_CLASS
 
ass


	)

228 #i!
defed
(
PURE_FUNCTION
&& 
COMPILER
(
GCC
)

229 
	#PURE_FUNCTION
 
	`__ibu__
((
__pu__
))

	)

232 #i!
defed
(
PURE_FUNCTION
)

233 
	#PURE_FUNCTION


	)

238 #i!
defed
(
REFERENCED_FROM_ASM
&& 
COMPILER
(
GCC
)

239 
	#REFERENCED_FROM_ASM
 
	`__ibu__
((
__ud__
))

	)

242 #i!
defed
(
REFERENCED_FROM_ASM
)

243 
	#REFERENCED_FROM_ASM


	)

248 #i!
defed
(
UNLIKELY
&& 
COMPILER
(
GCC
)

249 
	#UNLIKELY
(
x

	`__but_ex
(!!(x), 0)

	)

252 #i!
defed
(
UNLIKELY
)

253 
	#UNLIKELY
(
x
(x)

	)

261 #i!
defed
(
UNUSED_LABEL
&& 
COMPILER
(
MSVC
)

262 
	#UNUSED_LABEL
(
b
i(
l

	)
label

265 #i!
defed
(
UNUSED_LABEL
)

266 
	#UNUSED_LABEL
(
b

	`UNUSED_PARAM
(&&ab)

	)

271 #i!
defed
(
UNUSED_PARAM
&& 
COMPILER
(
MSVC
)

272 
	#UNUSED_PARAM
(
vb
()&
	)
variable

275 #i!
defed
(
UNUSED_PARAM
)

276 
	#UNUSED_PARAM
(
vb
()
	)
variable

281 #i!
defed
(
WARN_UNUSED_RETURN
&& 
COMPILER
(
GCC
)

282 
	#WARN_UNUSED_RETURN
 
	`__ibu__
((
__wn_unud_su__
))

	)

285 #i!
defed
(
WARN_UNUSED_RETURN
)

286 
	#WARN_UNUSED_RETURN


	)

	@Compression.cpp

26 
	~"cfig.h
"

27 
	~"Comessi.h
"

29 
	~"CheckedArhmic.h
"

31 #i
USE
(
ZLIB
&& !
COMPILER
(
MSVC
)

33 
	~<rg.h
>

34 
	~<zlib.h
>

36 
mea
 
	gWTF
 {

38 * 
zAoc
(*, 
ut32_t
 
cou
, ut32_
size
)

40 
CheckedSize
 
	glocSize
 = 
cou
;

41 
	glocSize
 *
size
;

42 i(
	glocSize
.
hasOvowed
())

43  
	gZ_NULL
;

44 * 
	gsu
 = 0;

45 i(
yFaMloc
(
locSize
.
unG
()).
gVue
(
su
))

46  
	gsu
;

47  
	gZ_NULL
;

50 
zFe
(*, * 
da
)

52 
Fe
(
da
);

55 
	gd
::
unique_r
<
GicComesdDa
> GicComesdDa::

(cڡ 
ut8_t
* 
da
, 
size_t
 
daLgth
)

57 um { 
	gMimumSize
 = (
GicComesdDa
) * 8 };

59 i(!
	gda
 || 
	gdaLgth
 < 
	gMimumSize
)

60  
	gnuαr
;

62 
z_am
 
	gam
;

63 
memt
(&
am
, 0, (stream));

64 
	gam
.
	gzloc
 = 
zAoc
;

65 
	gam
.
	gz
 = 
zFe
;

66 
	gam
.
	gda_ty
 = 
Z_BINARY
;

67 
	gam
.
	gaque
 = 
Z_NULL
;

68 
	gam
.
	gava_
 = 
daLgth
;

69 
	gam
.
	gxt_
 = 
cڡ_
<
ut8_t
*>(
da
);

71 
size_t
 
	gcutOfft
 = 
OBJECT_OFFSETOF
(
GicComesdDa
, 
m_da
);

72 
size_t
 
	gcutCacy
 = 
MlocGoodSize
(
MimumSize
);

73 
Byf
* 
	gcomesdDa
 = 
ic_
<Byf*>(
Mloc
(
cutCacy
));

74 
memt
(
comesdDa
, 0, (
GicComesdDa
));

75 
	gam
.
	gxt_out
 = 
comesdDa
 + 
cutOfft
;

76 
	gam
.
	gava_out
 = 
cutCacy
 - 
cutOfft
;

78 
deeIn
(&
am
, 
Z_BEST_COMPRESSION
);

80 
	gue
) {

81 
	gdeeResu
 = 
dee
(&
am
, 
Z_FINISH
);

82 i(
	gdeeResu
 =
Z_OK
 || !
am
.
ava_out
) {

83 
size_t
 
wCacy
 = 0;

84 
	gcutCacy
 -
am
.
ava_out
;

85 i(!
	gam
.
	gava_
)

86 
	gwCacy
 = 
cutCacy
 + 8;

89 
size_t
 
	gcomesdCڋ
 = 
am
.
xt_
 - 
da
;

90 
	gexedSize
 = 
ic_
<>(
daLgth
* 
comesdCڋ
 / 
cutCacy
;

95 
	gwCacy
 = 
d
::
max
(
ic_
<
size_t
>(
exedSize
 + 8), 
cutCacy
 + 8);

97 
	gwCacy
 = 
MlocGoodSize
(
wCacy
);

98 i(
	gwCacy
 >
daLgth
)

99 

;

100 
	gcomesdDa
 = 
ic_
<
Byf
*>(
Roc
(
comesdDa
, 
wCacy
));

101 
	gcutOfft
 = 
cutCacy
 - 
am
.
ava_out
;

102 
	gam
.
	gxt_out
 = 
comesdDa
 + 
cutOfft
;

103 
	gam
.
	gava_out
 = 
wCacy
 - 
cutCacy
;

104 
	gcutCacy
 = 
wCacy
;

108 i(
	gdeeResu
 =
Z_STREAM_END
) {

109 
ASSERT
(!
am
.
ava_
);

113 
ASSERT_NOT_REACHED
();

114 
	g
:

115 
deeEnd
(&
am
);

116 
Fe
(
comesdDa
);

117  
	gnuαr
;

119 
deeEnd
(&
am
);

120 
t64_t
 
	gtٮComesd
 = 0;

121 
t64_t
 
	gtٮIut
 = 0;

123 
	gtٮComesd
 +
cutCacy
;

124 
	gtٮIut
 +
daLgth
;

125  
	gd
::
unique_r
<
GicComesdDa
>(
w
 (
comesdDa
GicComesdDa(
daLgth
, 
am
.
tٮ_out
));

128 
bo
 
	gGicComesdDa
::
decomess
(
ut8_t
* 
dei
, 
size_t
 
bufrSize
, size_t* 
decomesdByCou
)

130 i(
	gdecomesdByCou
)

131 *
	gdecomesdByCou
 = 0;

132 
z_am
 
	gam
;

133 
memt
(&
am
, 0, (stream));

134 
	gam
.
	gzloc
 = 
zAoc
;

135 
	gam
.
	gz
 = 
zFe
;

136 
	gam
.
	gda_ty
 = 
Z_BINARY
;

137 
	gam
.
	gaque
 = 
Z_NULL
;

138 
	gam
.
	gxt_out
 = 
dei
;

139 
	gam
.
	gava_out
 = 
bufrSize
;

140 
	gam
.
	gxt_
 = 
m_da
;

141 
	gam
.
	gava_
 = 
comesdSize
();

142 i(
eIn
(&
am
!
Z_OK
) {

143 
ASSERT_NOT_REACHED
();

144  
	gl
;

147 
	geResu
 = 
e
(&
am
, 
Z_FINISH
);

148 
eEnd
(&
am
);

150 
ASSERT
(
am
.
tٮ_out
 <
bufrSize
);

151 i(
	gdecomesdByCou
)

152 *
	gdecomesdByCou
 = 
am
.
tٮ_out
;

154 i(
	geResu
 !
Z_STREAM_END
) {

155 
ASSERT_NOT_REACHED
();

156  
	gl
;

159  
	gue
;

166 
mea
 
	gWTF
 {

167 
	gd
::
unique_r
<
GicComesdDa
> GicComesdDa::

(cڡ 
ut8_t
*, 
size_t
)

169  
	gnuαr
;

172 
bo
 
	gGicComesdDa
::
decomess
(
ut8_t
*, 
size_t
, size_t*)

174  
	gl
;

	@Compression.h

26 #ide
Comessi_h


27 
	#Comessi_h


	)

29 
	~<memy
>

30 
	~<wtf/Ve.h
>

32 
mea
 
	gWTF
 {

34 as
	cGicComesdDa
 {

35 
WTF_MAKE_NONCOPYABLE
(
GicComesdDa
)

36 
	gWTF_MAKE_FAST_ALLOCATED
;

37 
	gpublic
:

38 
WTF_EXPORT_PRIVATE
 
d
::
unique_r
<
GicComesdDa
> 

(cڡ 
ut8_t
*, 
size_t
);

39 
ut32_t
 
comesdSize
(cڡ {  
	gm_comesdSize
; }

40 
ut32_t
 
igSize
(cڡ {  
	gm_igSize
; }

42 
WTF_EXPORT_PRIVATE
 
bo
 
decomess
(
ut8_t
* 
dei
, 
size_t
 
bufrSize
, size_t* 
decomesdByCou
 = 0);

44 
	give
:

45 
GicComesdDa
(
size_t
 
igSize
, size_
comesdSize
)

47 
UNUSED_PARAM
(
m_da
);

48 
ASSERT
(!
m_igSize
);

49 
ASSERT
(!
m_comesdSize
);

50 
	gm_igSize
 = 
igSize
;

51 
	gm_comesdSize
 = 
comesdSize
;

53 
ut32_t
 
	gm_igSize
;

54 
ut32_t
 
	gm_comesdSize
;

55 
ut8_t
 
	gm_da
[1];

58 
	gme
 <
tyme
 
	gT
> cs
	cComesdVe
 : 
public
 
GicComesdDa
 {

59 
public
:

60 
d
::
unique_r
<
ComesdVe
> 

(cڡ 
Ve
<
T
>& 
sour
)

62 
d
::
unique_r
<
GicComesdDa
> 
su
 = GicComesdDa::

(
t_
<cڡ 
ut8_t
*>(
sour
.
da
()), (
T
* sour.
size
());

63  
	gd
::
unique_r
<
ComesdVe
<
T
>>(
ic_
<ComesdVe<T>*>(
su
.
a
()));

66 
decomess
(
Ve
<
T
>& 
dei
)

68 
	gVe
<
	gT
> 
ouut
(
igSize
(/ (
T
));

69 
ASSERT
(
ouut
.
size
(* (
T
=
igSize
());

70 
size_t
 
	gdecomesdByCou
 = 0;

71 
	gGicComesdDa
::
decomess
(
t_
<
ut8_t
*>(
ouut
.
da
()), 
igSize
(), &
decomesdByCou
);

72 
ASSERT
(
decomesdByCou
 =
igSize
());

73 
ASSERT
(
ouut
.
size
(* (
T
=
decomesdByCou
);

75 
	gdei
.
sw
(
ouut
);

78 
size_t
 
size
(cڡ {  
igSize
(/ (
	gT
); }

81 
	gme
 <
tyme
 
	gT
> cs
	cComessibVe
 {

82 
WTF_MAKE_NONCOPYABLE
(
ComessibVe
)

83 
	gpublic
:

84 
ComessibVe
(
size_t
 
size
 = 0)

85 : 
m_decomesdDa
(
size
)

89 
tyme
 
	tVe
<
	tT
>::
	t
 iterator;

90 
tyme
 
	tVe
<
	tT
>::
	tcڡ_
 const_iterator;

92 
shrkToF
()

94 
ASSERT
(!
m_comesdDa
);

95 
	gm_comesdDa
 = 
ComesdVe
<
T
>::

(
m_decomesdDa
);

96 i(
	gm_comesdDa
)

97 
	gm_decomesdDa
.
r
();

99 
	gm_decomesdDa
.
shrkToF
();

102 
size_t
 
size
()

104 i(
	gm_comesdDa
)

105  
	gm_comesdDa
->
size
();

106  
	gm_decomesdDa
.
size
();

109 
	gme
 <
tyme
 
	gU
> 
	gT
& 
	gݔ
[](
	gChecked
<U> 
	gdex
{  
da
().

(
dex
); }

110 
	gme
 <
tyme
 
	gU
> cڡ 
	gT
& 
	gݔ
[](
	gChecked
<U> 
	gdex
cڡ {  
da
().

(
dex
); }

111 
	gme
 <
tyme
 
	gU
> 
	gT
& 

(
Checked
<
U
> 
dex
{  
da
().at(index); }

112 
	gme
 <
tyme
 
	gU
> cڡ 
	gT
& 

(
Checked
<
U
> 
dex
cڡ {  
da
().at(index); }

114 

 
beg
({  
da
().begin(); }

115 

 
d
({  
da
().end(); }

116 
cڡ_
 
beg
(cڡ {  
da
().begin(); }

117 
cڡ_
 
d
(cڡ {  
da
().end(); }

119 cڡ 
	gVe
<
	gT
>& 
da
() const

121 
decomessIfNesry
();

122  
	gm_decomesdDa
;

125 
	gVe
<
	gT
>& 
da
()

127 
decomessIfNesry
();

128  
	gm_decomesdDa
;

131 
	give
:

132 
decomessIfNesry
() const

134 i(!
m_comesdDa
)

136 
	gm_comesdDa
->
decomess
(
m_decomesdDa
);

137 
	gm_comesdDa
 = 
nuαr
;

139 
mub
 
	gVe
<
	gT
> 
	gm_decomesdDa
;

140 
mub
 
	gd
::
unique_r
<
ComesdVe
<
T
>> 
m_comesdDa
;

145 
usg
 
	gWTF
::
GicComesdDa
;

146 
usg
 
	gWTF
::
ComesdVe
;

147 
usg
 
	gWTF
::
ComessibVe
;

	@CryptographicUtilities.cpp

26 
	~"cfig.h
"

27 
	~"CryogphicUts.h
"

29 
mea
 
	gWTF
 {

32 
NEVER_INLINE
 
cڡtTimeMemcmp
(cڡ * 
voidA
, cڡ * 
voidB
, 
size_t
 
ngth
)

34 cڡ 
ut8_t
* 
	ga
 = 
ic_
<cڡ ut8_t*>(
voidA
);

35 cڡ 
ut8_t
* 
	gb
 = 
ic_
<cڡ ut8_t*>(
voidB
);

37 
ut8_t
 
	gsu
 = 0;

38 
size_t
 
	gi
 = 0; i < 
	gngth
; ++i)

39 
	gsu
 |
a
[
i
] ^ 
b
[i];

41  
	gsu
;

	@CryptographicUtilities.h

26 #ide
WTF_CryogphicUts_h


27 
	#WTF_CryogphicUts_h


	)

29 
mea
 
	gWTF
 {

32 
WTF_EXPORT_PRIVATE
 
cڡtTimeMemcmp
(cڡ *, cڡ *, 
size_t
 
ngth
);

36 
usg
 
	gWTF
::
cڡtTimeMemcmp
;

	@CryptographicallyRandomNumber.cpp

30 
	~"cfig.h
"

31 
	~"CryogphiyRdomNumb.h
"

33 
	~"NevDeroyed.h
"

34 
	~"OSRdomSour.h
"

35 
	~<mux
>

37 
mea
 
	gWTF
 {

39 
	gmea
 {

41 as
	cARC4Sm
 {

42 
	gpublic
:

43 
ARC4Sm
();

45 
ut8_t
 
	gi
;

46 
ut8_t
 
	gj
;

47 
ut8_t
 
	gs
[256];

50 as
	cARC4RdomNumbG
 {

51 
	gWTF_MAKE_FAST_ALLOCATED
;

52 
	gpublic
:

53 
ARC4RdomNumbG
();

55 
ut32_t
 
ndomNumb
();

56 
ndomVues
(* 
bufr
, 
size_t
 
ngth
);

58 
	give
:

59 
le
 
addRdomDa
(*
da
, 
ngth
);

60 

();

61 
IfNded
();

62 
le
 
ut8_t
 
gBy
();

63 
le
 
ut32_t
 
gWd
();

65 
ARC4Sm
 
	gm_am
;

66 
	gm_cou
;

67 
	gd
::
mux
 
m_mux
;

70 
	gARC4Sm
::
ARC4Sm
()

72 
n
 = 0; 
	gn
 < 256;++)

73 
	gs
[
n
] =;

74 
	gi
 = 0;

75 
	gj
 = 0;

78 
	gARC4RdomNumbG
::
ARC4RdomNumbG
()

79 : 
m_cou
(0)

83 
ARC4RdomNumbG
::
addRdomDa
(* 
da
, 
ngth
)

85 
	gm_am
.
	gi
--;

86 
	gn
 = 0; < 256;++) {

87 
	gm_am
.
	gi
++;

88 
ut8_t
 
	gsi
 = 
m_am
.
s
[m_am.
i
];

89 
	gm_am
.
	gj
 +
si
 + 
da
[
n
 % 
ngth
];

90 
	gm_am
.
	gs
[
m_am
.
i
] = m_am.
s
[m_am.
j
];

91 
	gm_am
.
	gs
[
m_am
.
j
] = 
si
;

93 
	gm_am
.
	gj
 = 
m_am
.
i
;

96 
	gARC4RdomNumbG
::

()

98 
ndomss
[128];

99 
size_t
 
	gngth
 = (
ndomss
);

100 
yogphiyRdomVuesFromOS
(
ndomss
, 
ngth
);

101 
addRdomDa
(
ndomss
, 
ngth
);

105 
	gi
 = 0; i < 256; i++)

106 
gBy
();

107 
	gm_cou
 = 1600000;

110 
	gARC4RdomNumbG
::
IfNded
()

112 i(
m_cou
 <= 0)

113 

();

116 
ut8_t
 
	gARC4RdomNumbG
::
gBy
()

118 
m_am
.
i
++;

119 
ut8_t
 
	gsi
 = 
m_am
.
s
[m_am.
i
];

120 
	gm_am
.
	gj
 +
si
;

121 
ut8_t
 
	gsj
 = 
m_am
.
s
[m_am.
j
];

122 
	gm_am
.
	gs
[
m_am
.
i
] = 
sj
;

123 
	gm_am
.
	gs
[
m_am
.
j
] = 
si
;

124  (
	gm_am
.
	gs
[(
si
 + 
sj
) & 0xff]);

127 
ut32_t
 
	gARC4RdomNumbG
::
gWd
()

129 
ut32_t
 
v
;

130 
	gv
 = 
gBy
() << 24;

131 
	gv
 |
gBy
() << 16;

132 
	gv
 |
gBy
() << 8;

133 
	gv
 |
gBy
();

134  
	gv
;

137 
ut32_t
 
	gARC4RdomNumbG
::
ndomNumb
()

139 
d
::
lock_gud
<d::
mux
> 
lock
(
m_mux
);

141 
	gm_cou
 -= 4;

142 
IfNded
();

143  
gWd
();

146 
	gARC4RdomNumbG
::
ndomVues
(* 
bufr
, 
size_t
 
ngth
)

148 
	gd
::
lock_gud
<
d
::
mux
> 
lock
(
m_mux
);

150 * 
	gsu
 = 
t_
<*>(
bufr
);

151 
IfNded
();

152 
	gngth
--) {

153 
	gm_cou
--;

154 
IfNded
();

155 
	gsu
[
ngth
] = 
gBy
();

159 
	gARC4RdomNumbG
& 
shedRdomNumbG
()

161 
	gNevDeroyed
<
	gARC4RdomNumbG
> 
	gndomNumbG
;

163  
	gndomNumbG
;

168 
ut32_t
 
	$yogphiyRdomNumb
()

170  
	`shedRdomNumbG
().
	`ndomNumb
();

171 
	}
}

173 
	$yogphiyRdomVues
(* 
bufr
, 
size_t
 
ngth
)

175 
	`shedRdomNumbG
().
	`ndomVues
(
bufr
, 
ngth
);

176 
	}
}

	@CryptographicallyRandomNumber.h

26 #ide
WTF_CryogphiyRdomNumb_h


27 
	#WTF_CryogphiyRdomNumb_h


	)

29 
	~<dt.h
>

31 
mea
 
	gWTF
 {

33 
WTF_EXPORT_PRIVATE
 
ut32_t
 
yogphiyRdomNumb
();

34 
WTF_EXPORT_PRIVATE
 
yogphiyRdomVues
(* 
bufr
, 
size_t
 
ngth
);

38 
usg
 
	gWTF
::
yogphiyRdomNumb
;

39 
usg
 
	gWTF
::
yogphiyRdomVues
;

	@CurrentTime.cpp

34 
	~"cfig.h
"

35 
	~"CutTime.h
"

37 #i
OS
(
DARWIN
)

38 
	~<mach/mach.h
>

39 
	~<mach/mach_time.h
>

40 
	~<mux
>

41 
	~<sys/time.h
>

42 #i
OS
(
WINDOWS
)

47 #unde
WIN32_LEAN_AND_MEAN


48 
	~<wdows.h
>

49 
	~<mh.h
>

50 
	~<dt.h
>

51 
	~<time.h
>

53 #i
PLATFORM
(
EFL
)

54 
	~<Ece.h
>

56 
	~<sys/time.h
>

59 #i
USE
(
GLIB
&& !
PLATFORM
(
EFL
)

60 
	~<glib.h
>

63 
mea
 
	gWTF
 {

65 #i
OS
(
WINDOWS
)

68 cڡ 
ULONGLONG
 
	gochBs
 = 116444736000000000ULL;

69 cڡ 
	ghunddsOfNocdsPMlicd
 = 10000;

71 
lowResUTCTime
()

73 
FILETIME
 
	gfeTime
;

75 
GSyemTimeAsFeTime
(&
feTime
);

81 
ULARGE_INTEGER
 
	gdeTime
;

82 
memy
(&
deTime
, &
feTime
, (dateTime));

85  (
	gdeTime
.
	gQuadPt
 - 
	gochBs
/ 
	ghunddsOfNocdsPMlicd
;

88 #i
USE
(
QUERY_PERFORMANCE_COUNTER
)

90 
LARGE_INTEGER
 
	gqpcFqucy
;

91 
bo
 
	gsyndTime
;

93 
highResUpTime
()

100 
LARGE_INTEGER
 
	gqpcLa
;

101 
DWORD
 
	gtickCouLa
;

102 
bo
 
	ged
;

104 
LARGE_INTEGER
 
	gqpc
;

105 
QuyPfmCou
(&
qpc
);

106 #i
defed
(
_M_IX86
|| defed(
__i386__
)

107 
DWORD
 
	gtickCou
 = 
GTickCou
();

109 
ULONGLONG
 
	gtickCou
 = 
GTickCou64
();

112 i(
	ged
) {

113 
__t64
 
	gqpcEpd
 = ((
qpc
.
QuadPt
 - 
qpcLa
.QuadPt* 1000/ 
qpcFqucy
.QuadPart;

114 
__t64
 
	gtickCouEpd
;

115 i(
	gtickCou
 >
tickCouLa
)

116 
tickCouEpd
 = (
tickCou
 - 
tickCouLa
);

118 #i
COMPILER
(
MINGW
)

119 
__t64
 
	gtickCouLge
 = 
tickCou
 + 0x100000000ULL;

121 
__t64
 
	gtickCouLge
 = 
tickCou
 + 0x100000000
I64
;

123 
	gtickCouEpd
 = 
tickCouLge
 - 
tickCouLa
;

128 
__t64
 
	gdiff
 = 
tickCouEpd
 - 
qpcEpd
;

129 i(
	gdiff
 > 500 || diff < -500)

130 
	gsyndTime
 = 
l
;

132 
	ged
 = 
ue
;

134 
	gqpcLa
 = 
qpc
;

135 
	gtickCouLa
 = 
tickCou
;

137  (1000.0 * 
	gqpc
.
	gQuadPt
/ 
	gic_
<>(
	gqpcFqucy
.QuadPart);

140 
bo
 
qpcAvaab
()

142 
bo
 
	gavaab
;

143 
bo
 
	gchecked
;

145 i(
	gchecked
)

146  
	gavaab
;

148 
	gavaab
 = 
QuyPfmFqucy
(&
qpcFqucy
);

149 
	gchecked
 = 
ue
;

150  
	gavaab
;

153 
cutTime
()

160 
	gsyncLowResUTCTime
;

161 
	gsyncHighResUpTime
;

162 
	gϡUTCTime
;

164 
	glowResTime
 = 
lowResUTCTime
();

166 i(!
qpcAvaab
())

167  
	glowResTime
 / 1000.0;

169 
	ghighResTime
 = 
highResUpTime
();

171 i(!
	gsyndTime
) {

172 
timeBegPiod
(1);

173 
	gsyncLowResUTCTime
 = 
lowResTime
 = 
lowResUTCTime
();

174 
timeEndPiod
(1);

175 
	gsyncHighResUpTime
 = 
highResTime
;

176 
	gsyndTime
 = 
ue
;

179 
	ghighResEpd
 = 
highResTime
 - 
syncHighResUpTime
;

180 
	gutc
 = 
syncLowResUTCTime
 + 
highResEpd
;

183 
	glowResEpd
 = 
lowResTime
 - 
syncLowResUTCTime
;

184 cڡ 
	gmaximumAowedDriMc
 = 15.625 * 2.0;

185 i(
bs
(
highResEpd
 - 
lowResEpd
> 
	gmaximumAowedDriMc
)

186 
	gsyndTime
 = 
l
;

189 cڡ 
	gbackwdTimeLim
 = 2000.0;

190 i(
	gutc
 < 
	gϡUTCTime
 && (ϡUTCTim- utc< 
	gbackwdTimeLim
)

191  
	gϡUTCTime
 / 1000.0;

192 
	gϡUTCTime
 = 
utc
;

193  
	gutc
 / 1000.0;

198 
cutTime
()

200 
bo
 
	g
 = 
l
;

201 
	gϡTime
;

202 
DWORD
 
	gϡTickCou
;

203 i(!
	g
) {

204 
	gϡTime
 = 
lowResUTCTime
();

205 
	gϡTickCou
 = 
GTickCou
();

206 
	g
 = 
ue
;

207  
	gϡTime
;

210 
DWORD
 
	gtickCouNow
 = 
GTickCou
();

211 
DWORD
 
	gd
 = 
tickCouNow
 - 
ϡTickCou
;

212 
	gtimeNow
 = 
ϡTime
 + ()
d
 / 1000.;

213 i(
	gd
 >= 0x7FFFFFFF) {

214 
ϡTime
 = 
timeNow
;

215 
	gϡTickCou
 = 
tickCouNow
;

217  
	gtimeNow
;

222 #i
USE
(
GLIB
&& !
PLATFORM
(
EFL
)

228 
cutTime
()

230 
GTimeV
 
	gnow
;

231 
g_g_cut_time
(&
now
);

232  
	gic_
<>(
	gnow
.
	gtv_c
+ stic_<>ow.
	gtv_uc
 / 1000000.0);

235 #i
PLATFORM
(
EFL
)

237 
cutTime
()

239  
ece_time_unix_g
();

244 
cutTime
()

246 
timev
 
	gnow
;

247 
gtimeofday
(&
now
, 0);

248  
	gnow
.
	gtv_c
 +ow.
	gtv_uc
 / 1000000.0;

253 #i
PLATFORM
(
EFL
)

255 
miyInsgTime
()

257  
ece_time_g
();

260 #i
USE
(
GLIB
)

262 
miyInsgTime
()

264  
	gic_
<>(
g_g_mic_time
() / 1000000.0);

267 #i
OS
(
DARWIN
)

269 
miyInsgTime
()

272 
mach_timeba_fo_da_t
 
	gtimebaInfo
;

273 
	gd
::
_ag
 
lizeTimOnFg
;

274 
	gd
::
_
(
lizeTimOnFg
, [] {

275 
kn_tu_t
 
kr
 = 
mach_timeba_fo
(&
timebaInfo
);

276 
ASSERT_UNUSED
(
kr
, k=
KERN_SUCCESS
);

277 
ASSERT
(
timebaInfo
.
dom
);

280  (
mach_absu_time
(* 
	gtimebaInfo
.
	gnum
/ (1.0e9 *imebaInfo.
	gdom
);

285 
miyInsgTime
()

287 
	gϡTime
 = 0;

288 
	gcutTimeNow
 = 
cutTime
();

289 i(
	gcutTimeNow
 < 
	gϡTime
)

290  
	gϡTime
;

291 
	gϡTime
 = 
cutTimeNow
;

292  
	gcutTimeNow
;

297 
cutCPUTime
()

299 #i
OS
(
DARWIN
)

300 
mach_msg_ty_numb_t
 
	gfoCou
 = 
THREAD_BASIC_INFO_COUNT
;

301 
thad_basic_fo_da_t
 
	gfo
;

304 
mach_pt_t
 
	gthadPt
 = 
mach_thad_lf
();

305 
thad_fo
(
thadPt
, 
THREAD_BASIC_INFO
, 
t_
<
thad_fo_t
>(&
fo
), &
foCou
);

306 
mach_pt_do
(
mach_sk_lf
(), 
thadPt
);

308 
	gtime
 = 
fo
.
ur_time
.
cds
 + info.ur_time.
miocds
 / 1000000.;

309 
	gtime
 +
fo
.
syem_time
.
cds
 + info.syem_time.
miocds
 / 1000000.;

311  
	gtime
;

312 #i
OS
(
WINDOWS
)

314 
FILETIME
 
	gfeTime
;

315 
	gfeTimeAsLg
;

316 } 
	gurTime
, 
	gklTime
;

320 
FILETIME
 
	gtiTime
, 
	gexTime
;

322 
GThadTimes
(
GCutThad
(), &
tiTime
, &
exTime
, &
klTime
.
feTime
, &
urTime
.fileTime);

324  
	gurTime
.
	gfeTimeAsLg
 / 10000000. + 
	gklTime
.fileTimeAsLong / 10000000.;

329 
	gfTime
 = 
cutTime
();

330  
cutTime
(- 
	gfTime
;

334 
cutCPUTimeMS
()

336  
cutCPUTime
() * 1000;

	@CurrentTime.h

32 #ide
CutTime_h


33 
	#CutTime_h


	)

35 
	~<time.h
>

37 
mea
 
	gWTF
 {

44 
WTF_EXPORT_PRIVATE
 
cutTime
();

47 
le
 
cutTimeMS
()

49  
cutTime
() * 1000.0;

56 
WTF_EXPORT_PRIVATE
 
miyInsgTime
();

61 
WTF_EXPORT_PRIVATE
 
cutCPUTime
();

64 
WTF_EXPORT_PRIVATE
 
cutCPUTimeMS
();

68 
usg
 
	gWTF
::
cutTime
;

69 
usg
 
	gWTF
::
cutTimeMS
;

70 
usg
 
	gWTF
::
miyInsgTime
;

71 
usg
 
	gWTF
::
cutCPUTime
;

	@DataLog.cpp

26 
	~"cfig.h
"

27 
	~"DaLog.h
"

28 
	~<dg.h
>

29 
	~<rg.h
>

30 
	~<wtf/FePrtSm.h
>

31 
	~<wtf/WTFThadDa.h
>

32 
	~<wtf/Thadg.h
>

34 #i
OS
(
UNIX
|| OS(
DARWIN
)

35 
	~<unid.h
>

38 
	#DATA_LOG_TO_FILE
 0

	)

42 
	#DATA_LOG_TO_DARWIN_TEMP_DIR
 0

	)

47 
	#DATA_LOG_FILENAME
 "/tmp/WTFLog"

	)

49 
mea
 
	gWTF
 {

51 #i
USE
(
PTHREADS
)

52 
had__t
 
	glizeLogFeOnKey
 = 
PTHREAD_ONCE_INIT
;

55 
FePrtSm
* 
	gfe
;

57 
ut64_t
 
	gfeDa
[((
FePrtSm
) + 7) / 8];

59 
lizeLogFeOn
()

61 #i
DATA_LOG_TO_FILE


62 cڡ 
	gmaxPhLgth
 = 1024;

64 
	gfameSuffix
[
maxPhLgth
 + 1];

66 #i
PLATFORM
(
WIN
)

67 
_tf
(
fameSuffix
, (fameSuffix), ".%d.txt", 
GCutProssId
());

69 
tf
(
fameSuffix
, (fameSuffix), ".%d.txt", 
gpid
());

72 #i
DATA_LOG_TO_DARWIN_TEMP_DIR


73 
	gfameBufr
[
maxPhLgth
 + 1];

74 
	gsuffixLgth
 = 

(
fameSuffix
);

76 #i
defed
(
DATA_LOG_FILENAME
)

77 * 
	glogBame
 = 
chr
(
DATA_LOG_FILENAME
, '/');

78 i(!
	glogBame
)

79 
	glogBame
 = (*)
DATA_LOG_FILENAME
;

81 cڡ * 
	glogBame
 = "WTFLog";

84 cڡ * 
	gfame
 = 0;

86 
size_t
 
	gϡCompڒtLgth
 = 

(
logBame
+ 
suffixLgth
;

87 
size_t
 
	gdmeLgth
 = 
cfr
(
_CS_DARWIN_USER_TEMP_DIR
, 
fameBufr
, 1024);

88 i((
	gdmeLgth
 + 
	gϡCompڒtLgth
 + 
	gsuffixLgth
< 
	gmaxPhLgth
) {

89 
t
(
fameBufr
, 
logBame
, 
maxPhLgth
 - 
dmeLgth
);

90 
	gfame
 = 
fameBufr
;

92 #i
defed
(
DATA_LOG_FILENAME
)

93 cڡ * 
	gfame
 = 
DATA_LOG_FILENAME
;

95 cڡ * 
	gfame
 = 
gv
("WTF_DATA_LOG_FILENAME");

97 
	gauFame
[
maxPhLgth
 + 1];

99 i(
	gfame
) {

100 #i
PLATFORM
(
WIN
)

101 
_tf
(
auFame
, uFame), "%s%s", 
fame
, 
fameSuffix
);

103 
tf
(
auFame
, uFame), "%s%s", 
fame
, 
fameSuffix
);

106 
	gfe
 = 
FePrtSm
::
ݒ
(
auFame
, "w").
a
();

107 i(
	gfe
)

108 
WTFLogAlways
("*** DaLog ouut\"%s\" ***\n", 
auFame
);

110 
WTFLogAlways
("Wng: Could oDaLog f%f wrg.\n", 
auFame
);

113 i(!
	gfe
) {

116 
	gfe
 = 
w
 (
feDa

FePrtSm
(
dr
, FePrtSm::
Brow
);

119 
tvbuf
(
fe
->fe(), 0, 
_IONBF
, 0);

122 
lizeLogFe
()

124 #i
USE
(
PTHREADS
)

125 
had_
(&
lizeLogFeOnKey
, 
lizeLogFeOn
);

127 i(!
	gfe
)

128 
lizeLogFeOn
();

132 
	gFePrtSm
& 
daFe
()

134 
lizeLogFe
();

135  *
	gfe
;

138 
daLogFV
(cڡ * 
fm
, 
va_li
 
gLi
)

140 
daFe
().
vtf
(
fm
, 
gLi
);

143 
daLogF
(cڡ * 
fm
, ...)

145 
va_li
 
	ggLi
;

146 
va_t
(
gLi
, 
fm
);

147 
daLogFV
(
fm
, 
gLi
);

148 
va_d
(
gLi
);

151 
daLogFSg
(cڡ * 
r
)

153 
daFe
().
tf
("%s", 
r
);

	@DataLog.h

26 #ide
DaLog_h


27 
	#DaLog_h


	)

29 
	~<dg.h
>

30 
	~<dio.h
>

31 
	~<wtf/FePrtSm.h
>

32 
	~<wtf/StdLibExas.h
>

34 
mea
 
	gWTF
 {

36 
WTF_EXPORT_PRIVATE
 
	gFePrtSm
& 
daFe
();

38 
WTF_EXPORT_PRIVATE
 
daLogFV
(cڡ * 
fm
, 
va_li

WTF_ATTRIBUTE_PRINTF
(1, 0);

39 
WTF_EXPORT_PRIVATE
 
daLogF
(cڡ * 
fm
, ...
WTF_ATTRIBUTE_PRINTF
(1, 2);

40 
WTF_EXPORT_PRIVATE
 
daLogFSg
(const *);

42 
	gme
<
	gtyme
... 
	gTys
>

43 
daLog
(cڡ 
Tys
&... 
vues
)

45 
daFe
().
t
(
vues
...);

50 
usg
 
	gWTF
::
daLog
;

51 
usg
 
	gWTF
::
daLogF
;

52 
usg
 
	gWTF
::
daLogFSg
;

	@DateMath.cpp

72 
	~"cfig.h
"

73 
	~"DeMh.h
"

75 
	~"Asis.h
"

76 
	~"ASCIICTy.h
"

77 
	~"CutTime.h
"

78 
	~"MhExas.h
"

79 
	~"StdLibExas.h
"

80 
	~"SgExas.h
"

82 
	~<gܙhm
>

83 
	~<lims.h
>

84 
	~<lims
>

85 
	~<dt.h
>

86 
	~<time.h
>

87 
	~<wtf/xt/SgBud.h
>

89 #i
OS
(
WINDOWS
)

90 
	~<wdows.h
>

93 #i
HAVE
(
ERRNO_H
)

94 
	~<o.h
>

97 #i
HAVE
(
SYS_TIME_H
)

98 
	~<sys/time.h
>

101 #i
HAVE
(
SYS_TIMEB_H
)

102 
	~<sys/timeb.h
>

105 
usg
 
mea
 
	gWTF
;

107 
mea
 
	gWTF
 {

111 cڡ 
	gmaxUnixTime
 = 2145859200.0;

115 cڡ 
	gmaxECMAStTime
 = 8.64E15;

119 cڡ 
	gfDayOfMth
[2][12] = {

124 
le
 
gLolTime
(cڡ 
time_t
* 
lolTime
, 
tm
* 
lolTM
)

126 #i
COMPILER
(
MINGW
)

127 *
	glolTM
 = *
loime
(
lolTime
);

128 #i
COMPILER
(
MSVC
)

129 
loime_s
(
lolTM
, 
lolTime
);

131 
loime_r
(
lolTime
, 
lolTM
);

135 
bo
 
isLpYr
(
yr
)

137 i(
	gyr
 % 4 != 0)

138  
l
;

139 i(
	gyr
 % 400 == 0)

140  
ue
;

141 i(
	gyr
 % 100 == 0)

142  
l
;

143  
	gue
;

146 
le
 
daysInYr
(
yr
)

148  365 + 
isLpYr
(
yr
);

151 
le
 
daysFrom1970ToYr
(
yr
)

158 cڡ 
	g˭DaysBefe1971By4Ru
 = 1970 / 4;

159 cڡ 
	gexudedLpDaysBefe1971By100Ru
 = 1970 / 100;

160 cڡ 
	g˭DaysBefe1971By400Ru
 = 1970 / 400;

162 cڡ 
	gyrMusO
 = 
yr
 - 1;

163 cڡ 
	gyrsToAddBy4Ru
 = 
o
(
yrMusO
 / 4.0- 
˭DaysBefe1971By4Ru
;

164 cڡ 
	gyrsToExudeBy100Ru
 = 
o
(
yrMusO
 / 100.0- 
exudedLpDaysBefe1971By100Ru
;

165 cڡ 
	gyrsToAddBy400Ru
 = 
o
(
yrMusO
 / 400.0- 
˭DaysBefe1971By400Ru
;

167  365.0 * (
	gyr
 - 1970+ 
	gyrsToAddBy4Ru
 - 
	gyrsToExudeBy100Ru
 + 
	gyrsToAddBy400Ru
;

170 
msToDays
(
ms
)

172  
o
(
ms
 / 
msPDay
);

175 
ndTwoDigNumb
(
SgBud
& 
bud
, 
numb
)

177 
ASSERT
(
numb
 >= 0);

178 
ASSERT
(
numb
 < 100);

179 
	gbud
.
nd
(
ic_
<
LCh
>('0' + 
numb
 / 10));

180 
	gbud
.
nd
(
ic_
<
LCh
>('0' + 
numb
 % 10));

183 
msToYr
(
ms
)

185 
	goxYr
 = 
ic_
<>(
o
(
ms
 / (
msPDay
 * 365.2425)) + 1970);

186 
	gmsFromAroxYrTo1970
 = 
msPDay
 * 
daysFrom1970ToYr
(
oxYr
);

187 i(
	gmsFromAroxYrTo1970
 > 
	gms
)

188  
	goxYr
 - 1;

189 i(
	gmsFromAroxYrTo1970
 + 
msPDay
 * 
daysInYr
(
oxYr
<
ms
)

190  
oxYr
 + 1;

191  
	goxYr
;

194 
dayInYr
(
ms
, 
yr
)

196  
	gic_
<>(
msToDays
(
ms
- 
daysFrom1970ToYr
(
yr
));

199 
le
 
msToMlicds
(
ms
)

201 
	gsu
 = 
fmod
(
ms
, 
msPDay
);

202 i(
	gsu
 < 0)

203 
	gsu
 +
msPDay
;

204  
	gsu
;

207 
msToMus
(
ms
)

209 
	gsu
 = 
fmod
(
o
(
ms
 / 
msPMu
), 
musPHour
);

210 i(
	gsu
 < 0)

211 
	gsu
 +
musPHour
;

212  
	gic_
<>(
	gsu
);

215 
msToHours
(
ms
)

217 
	gsu
 = 
fmod
(
o
(
ms
/
msPHour
), 
hoursPDay
);

218 i(
	gsu
 < 0)

219 
	gsu
 +
hoursPDay
;

220  
	gic_
<>(
	gsu
);

223 
mthFromDayInYr
(
dayInYr
, 
bo
 
˭Yr
)

225 cڡ 
	gd
 = 
dayInYr
;

226 
	g
;

228 i(
	gd
 < (
	g
 = 31))

230 
	g
 +(
˭Yr
 ? 29 : 28);

231 i(
	gd
 < 
	g
)

233 i(
	gd
 < (
	g
 += 31))

235 i(
	gd
 < (
	g
 += 30))

237 i(
	gd
 < (
	g
 += 31))

239 i(
	gd
 < (
	g
 += 30))

241 i(
	gd
 < (
	g
 += 31))

243 i(
	gd
 < (
	g
 += 31))

245 i(
	gd
 < (
	g
 += 30))

247 i(
	gd
 < (
	g
 += 31))

249 i(
	gd
 < (
	g
 += 30))

254 
le
 
bo
 
checkMth
(
dayInYr
, & 
tDayOfThisMth
, & 
tDayOfNextMth
, 
daysInThisMth
)

256 
	gtDayOfThisMth
 = 
tDayOfNextMth
;

257 
	gtDayOfNextMth
 +
daysInThisMth
;

258  (
	gdayInYr
 <
tDayOfNextMth
);

261 
dayInMthFromDayInYr
(
dayInYr
, 
bo
 
˭Yr
)

263 cڡ 
	gd
 = 
dayInYr
;

264 
	g
;

265 
	gxt
 = 30;

267 i(
	gd
 <
xt
)

268  
d
 + 1;

269 cڡ 
	gdaysInFeb
 = (
˭Yr
 ? 29 : 28);

270 i(
checkMth
(
d
, 

, 
xt
, 
daysInFeb
))

271  
	gd
 - 
	g
;

272 i(
checkMth
(
d
, 

, 
xt
, 31))

273  
	gd
 - 
	g
;

274 i(
checkMth
(
d
, 

, 
xt
, 30))

275  
	gd
 - 
	g
;

276 i(
checkMth
(
d
, 

, 
xt
, 31))

277  
	gd
 - 
	g
;

278 i(
checkMth
(
d
, 

, 
xt
, 30))

279  
	gd
 - 
	g
;

280 i(
checkMth
(
d
, 

, 
xt
, 31))

281  
	gd
 - 
	g
;

282 i(
checkMth
(
d
, 

, 
xt
, 31))

283  
	gd
 - 
	g
;

284 i(
checkMth
(
d
, 

, 
xt
, 30))

285  
	gd
 - 
	g
;

286 i(
checkMth
(
d
, 

, 
xt
, 31))

287  
	gd
 - 
	g
;

288 i(
checkMth
(
d
, 

, 
xt
, 30))

289  
	gd
 - 
	g
;

290 
	g
 = 
xt
;

291  
	gd
 - 
	g
;

294 
dayInYr
(
yr
, 
mth
, 
day
)

296  
	gfDayOfMth
[
isLpYr
(
yr
)][
mth
] + 
	gday
 - 1;

299 
deToDaysFrom1970
(
yr
, 
mth
, 
day
)

301 
	gyr
 +
mth
 / 12;

303 
	gmth
 %= 12;

304 i(
	gmth
 < 0) {

305 
	gmth
 += 12;

306 --
	gyr
;

309 
	gyrday
 = 
o
(
daysFrom1970ToYr
(
yr
));

310 
ASSERT
((
yr
 >1970 && 
yrday
 >= 0) || (year < 1970 && yearday < 0));

311  
	gyrday
 + 
dayInYr
(
yr
, 
mth
, 
day
);

316 
le
 
maximumYrFDST
()

321 
le
 
mimumYrFDST
()

327  
	gd
::
m
(
msToYr
(
jsCutTime
()), 
maximumYrFDST
() - 27) ;

340 
equivtYrFDST
(
yr
)

345 
	gmYr
 = 
mimumYrFDST
();

346 
	gmaxYr
 = 
maximumYrFDST
();

348 
	gdifn
;

349 i(
	gyr
 > 
	gmaxYr
)

350 
	gdifn
 = 
mYr
 - 
yr
;

351 i(
	gyr
 < 
	gmYr
)

352 
	gdifn
 = 
maxYr
 - 
yr
;

354  
	gyr
;

356 
	gquٛ
 = 
difn
 / 28;

357 
	godu
 = (
quٛ
) * 28;

359 
	gyr
 +
odu
;

360 
ASSERT
((
yr
 >
mYr
 && y<
maxYr
|| (
odu
 - y=
ic_
<>(
d
::
numic_lims
<>::
qut_NaN
())));

361  
	gyr
;

364 #i!
HAVE
(
TM_GMTOFF
)

366 
t32_t
 
lcuϋUTCOfft
()

368 #i
OS
(
WINDOWS
)

369 
TIME_ZONE_INFORMATION
 
	gtimeZeInfmi
;

370 
GTimeZeInfmi
(&
timeZeInfmi
);

371 
t32_t
 
	gbs
 = 
timeZeInfmi
.
Bs
 +imeZeInfmi.
SnddBs
;

372  -
	gbs
 * 60 * 1000;

374 
time_t
 
	glolTime
 = 
time
(0);

375 
tm
 
	glo
;

376 
gLolTime
(&
lolTime
, &
lo
);

379 
	glo
.
	gtm_c
 = 0;

380 
	glo
.
	gtm_m
 = 0;

381 
	glo
.
	gtm_hour
 = 0;

382 
	glo
.
	gtm_mday
 = 1;

383 
	glo
.
	gtm_m
 = 0;

385 
	glo
.
	gtm_wday
 = 0;

386 
	glo
.
	gtm_yday
 = 0;

387 
	glo
.
	gtm_isd
 = 0;

388 #i
HAVE
(
TM_GMTOFF
)

389 
	glo
.
	gtm_gmtoff
 = 0;

391 #i
HAVE
(
TM_ZONE
)

392 
	glo
.
	gtm_ze
 = 0;

395 #i
HAVE
(
TIMEGM
)

396 
time_t
 
	gutcOfft
 = 
timegm
(&
lo
- 
mktime
(&localt);

399 
	glo
.
	gtm_yr
 = 109;

400 
time_t
 
	gutcOfft
 = 1230768000 - 
mktime
(&
lo
);

403  
	gic_
<
	gt32_t
>(
	gutcOfft
 * 1000);

407 #i
OS
(
WINDOWS
)

409 
UnixTimeToFeTime
(
time_t
 
t
, 
LPFILETIME
 
p
)

412 
LONGLONG
 
	g
;

414 
	g
 = 
I32x32To64
(
t
, 10000000) + 116444736000000000;

415 
	gp
->
	gdwLowDeTime
 = (
DWORD
)

;

416 
	gp
->
	gdwHighDeTime
 = 

 >> 32;

423 
lcuϋDSTOfft
(
time_t
 
lolTime
, 
utcOfft
)

425 #i
OS
(
WINDOWS
)

426 
FILETIME
 
	gutcFeTime
;

427 
UnixTimeToFeTime
(
lolTime
, &
utcFeTime
);

428 
SYSTEMTIME
 
	gutcSyemTime
, 
	glolSyemTime
;

429 
FeTimeToSyemTime
(&
utcFeTime
, &
utcSyemTime
);

430 
SyemTimeToTzScificLolTime
(0, &
utcSyemTime
, &
lolSyemTime
);

432 
	gofftTime
 = (
lolTime
 * 
msPSecd
+ 
utcOfft
;

435 
	gofftHour
 = 
msToHours
(
offtTime
);

436 
	gofftMu
 = 
msToMus
(
offtTime
);

438 
	gdiff
 = ((
lolSyemTime
.
wHour
 - 
offtHour
* 
cdsPHour
+ (olSyemTime.
wMu
 - 
offtMu
) * 60);

440  
diff
 * 
	gmsPSecd
;

443 
	gofftTime
 = (
lolTime
 * 
msPSecd
+ 
utcOfft
;

446 
	gofftHour
 = 
msToHours
(
offtTime
);

447 
	gofftMu
 = 
msToMus
(
offtTime
);

449 
tm
 
	glolTM
;

450 
gLolTime
(&
lolTime
, &
lolTM
);

452 
	gdiff
 = ((
lolTM
.
tm_hour
 - 
offtHour
* 
cdsPHour
+ (olTM.
tm_m
 - 
offtMu
) * 60);

454 i(
	gdiff
 < 0)

455 
	gdiff
 +
cdsPDay
;

457  (
diff
 * 
	gmsPSecd
);

464 
LolTimeOfft
 
lcuϋLolTimeOfft
(
ms
)

471 
	gyr
 = 
msToYr
(
ms
);

472 
	gequivtYr
 = 
equivtYrFDST
(
yr
);

473 i(
	gyr
 !
equivtYr
) {

474 
bo
 
˭Yr
 = 
isLpYr
(
yr
);

475 
	gdayInYrLol
 = 
dayInYr
(
ms
, 
yr
);

476 
	gdayInMth
 = 
dayInMthFromDayInYr
(
dayInYrLol
, 
˭Yr
);

477 
	gmth
 = 
mthFromDayInYr
(
dayInYrLol
, 
˭Yr
);

478 
	gday
 = 
deToDaysFrom1970
(
equivtYr
, 
mth
, 
dayInMth
);

479 
	gms
 = (
day
 * 
msPDay
+ 
msToMlicds
(
ms
);

482 
	glolTimeSecds
 = 
ms
 / 
msPSecd
;

483 i(
	glolTimeSecds
 > 
	gmaxUnixTime
)

484 
	glolTimeSecds
 = 
maxUnixTime
;

485 i(
	glolTimeSecds
 < 0)

486 
	glolTimeSecds
 +
cdsPDay
;

488 
time_t
 
	glolTime
 = 
ic_
<time_t>(
lolTimeSecds
);

490 #i
HAVE
(
TM_GMTOFF
)

491 
tm
 
	glolTM
;

492 
gLolTime
(&
lolTime
, &
lolTM
);

493  
LolTimeOfft
(
lolTM
.
tm_isd
,olTM.
tm_gmtoff
 * 
msPSecd
);

495 
	gutcOfft
 = 
lcuϋUTCOfft
();

496 
	gdOfft
 = 
lcuϋDSTOfft
(
lolTime
, 
utcOfft
);

497  
LolTimeOfft
(
dOfft
, 
utcOfft
 + dstOffset);

501 
lizeDes
()

503 #i!
ASSERT_DISABLED


504 
bo
 
	gadyInlized
;

505 
ASSERT
(!
adyInlized
);

506 
	gadyInlized
 = 
ue
;

509 
equivtYrFDST
(2000);

512 
le
 
ymdhmsToSecds
(
yr
, 
m
, 
day
, 
hour
, 
mu
, 
cd
)

514 
	gmday
 = 
fDayOfMth
[
isLpYr
(
yr
)][
m
 - 1];

515 
	gydays
 = 
daysFrom1970ToYr
(
yr
);

517  (
	gcd
 + 
mu
 * 
	gcdsPMu
 + 
hour
 * 
	gcdsPHour
 + (
	gmday
 + 
	gday
 - 1 + 
	gydays
* 
	gcdsPDay
);

522 cڡ 
	sKnownZe
 {

523 #i!
OS
(
WINDOWS
)

526 
	gtzName
[4];

527 
	gtzOfft
;

528 } 
	gknown_zes
[] = {

541 
le
 
skSsAndCommts
(cڡ *& 
s
)

543 
	gág
 = 0;

544 
	gch
;

545 (
	gch
 = *
s
)) {

546 i(!
isASCIIS
(
ch
)) {

547 i(
ch
 == '(')

548 
ág
++;

549 i(
	gch
 =')' && 
ág
 > 0)

550 
ág
--;

551 i(
	gág
 == 0)

554 
	gs
++;

559 
fdMth
(cڡ * 
mthS
)

561 
ASSERT
(
mthS
);

562 
	ged
[4];

563 
	gi
 = 0; i < 3; ++i) {

564 i(!*
	gmthS
)

566 
	ged
[
i
] = 
ic_
<>(
toASCIILow
(*
mthS
++));

568 
	ged
[3] = '\0';

569 cڡ *
	ghayack
 = "janfebmaraprmayjunjulaugsepoctnovdec";

570 cڡ *
	gr
 = 
rr
(
hayack
, 
ed
);

571 i(
	gr
) {

572 
	gposi
 = 
ic_
<>(
r
 - 
hayack
);

573 i(
	gposi
 % 3 == 0)

574  
posi
 / 3;

579 
bo
 
rI
(cڡ * 
rg
, ** 
Posi
, 
ba
, * 
su
)

581 
	glgResu
 = 

(
rg
, 
Posi
, 
ba
);

583 i(
	grg
 =*
Posi
 || 
lgResu
 <
d
::
numic_lims
<>::
m
(||gResu >d::numic_lims<>::
max
())

584  
l
;

585 *
	gsu
 = 
ic_
<>(
lgResu
);

586  
	gue
;

589 
bo
 
rLg
(cڡ * 
rg
, ** 
Posi
, 
ba
, * 
su
)

591 *
	gsu
 = 

(
rg
, 
Posi
, 
ba
);

593 i(
	grg
 =*
Posi
 || *
su
 =
d
::
numic_lims
<>::
m
(|| *su =d::numic_lims<>::
max
())

594  
l
;

595  
	gue
;

601 * 
rES5DePti
(cڡ * 
cutPosi
, & 
yr
, & 
mth
, & 
day
)

603 * 
	gpoPPosi
;

608 i(!
rI
(
cutPosi
, &
poPPosi
, 10, &
yr
))

612 i(*
	gpoPPosi
 != '-')

613  
poPPosi
;

614 
	gcutPosi
 = 
poPPosi
 + 1;

616 i(!
isASCIIDig
(*
cutPosi
))

618 i(!
rLg
(
cutPosi
, &
poPPosi
, 10, &
mth
))

620 i((
	gpoPPosi
 - 
	gcutPosi
) != 2)

624 i(*
	gpoPPosi
 != '-')

625  
poPPosi
;

626 
	gcutPosi
 = 
poPPosi
 + 1;

628 i(!
isASCIIDig
(*
cutPosi
))

630 i(!
rLg
(
cutPosi
, &
poPPosi
, 10, &
day
))

632 i((
	gpoPPosi
 - 
	gcutPosi
) != 2)

634  
	gpoPPosi
;

640 * 
rES5TimePti
(* 
cutPosi
, & 
hours
, & 
mus
, & 
cds
, & 
timeZeSecds
)

642 * 
	gpoPPosi
;

643 i(!
isASCIIDig
(*
cutPosi
))

645 i(!
rLg
(
cutPosi
, &
poPPosi
, 10, &
hours
))

647 i(*
	gpoPPosi
 !':' || (
poPPosi
 - 
cutPosi
) != 2)

649 
	gcutPosi
 = 
poPPosi
 + 1;

651 i(!
isASCIIDig
(*
cutPosi
))

653 i(!
rLg
(
cutPosi
, &
poPPosi
, 10, &
mus
))

655 i((
	gpoPPosi
 - 
	gcutPosi
) != 2)

657 
	gcutPosi
 = 
poPPosi
;

660 i(*
	gcutPosi
 == ':') {

661 ++
cutPosi
;

663 
	gtSecds
;

664 i(!
isASCIIDig
(*
cutPosi
))

666 i(!
rLg
(
cutPosi
, &
poPPosi
, 10, &
tSecds
))

668 i((
	gpoPPosi
 - 
	gcutPosi
) != 2)

670 
	gcds
 = 
tSecds
;

671 i(*
	gpoPPosi
 == '.') {

672 
cutPosi
 = 
poPPosi
 + 1;

677 i(!
isASCIIDig
(*
cutPosi
))

681 
	gacSecds
;

682 i(!
rLg
(
cutPosi
, &
poPPosi
, 10, &
acSecds
))

685 
	gnumFcDigs
 = 
poPPosi
 - 
cutPosi
;

686 
	gcds
 +
acSecds
 * 
pow
(10.0, 
ic_
<>(-
numFcDigs
));

688 
	gcutPosi
 = 
poPPosi
;

691 i(*
	gcutPosi
 == 'Z')

692  
cutPosi
 + 1;

694 
bo
 
	gtzNegive
;

695 i(*
	gcutPosi
 == '-')

696 
tzNegive
 = 
ue
;

697 i(*
	gcutPosi
 == '+')

698 
tzNegive
 = 
l
;

700  
	gcutPosi
;

701 ++
	gcutPosi
;

703 
	gtzHours
;

704 
	gtzHoursAbs
;

705 
	gtzMus
;

707 i(!
isASCIIDig
(*
cutPosi
))

709 i(!
rLg
(
cutPosi
, &
poPPosi
, 10, &
tzHours
))

711 i(*
	gpoPPosi
 !':' || (
poPPosi
 - 
cutPosi
) != 2)

713 
	gtzHoursAbs
 = 
bs
(
tzHours
);

714 
	gcutPosi
 = 
poPPosi
 + 1;

716 i(!
isASCIIDig
(*
cutPosi
))

718 i(!
rLg
(
cutPosi
, &
poPPosi
, 10, &
tzMus
))

720 i((
	gpoPPosi
 - 
	gcutPosi
) != 2)

722 
	gcutPosi
 = 
poPPosi
;

724 i(
	gtzHoursAbs
 > 24)

726 i(
	gtzMus
 < 0 ||zMinutes > 59)

729 
	gtimeZeSecds
 = 60 * (
tzMus
 + (60 * 
tzHoursAbs
));

730 i(
	gtzNegive
)

731 
	gtimeZeSecds
 = -
timeZeSecds
;

733  
	gcutPosi
;

736 
rES5DeFromNuTmedChas
(cڡ * 
deSg
)

742 cڡ 
	gdaysPMth
[12] = { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

745 
	gyr
 = 0;

746 
	gmth
 = 1;

747 
	gday
 = 1;

748 
	ghours
 = 0;

749 
	gmus
 = 0;

750 
	gcds
 = 0;

751 
	gtimeZeSecds
 = 0;

754 * 
	gcutPosi
 = 
rES5DePti
(
deSg
, 
yr
, 
mth
, 
day
);

755 i(!
	gcutPosi
)

756  
	gd
::
numic_lims
<>::
qut_NaN
();

758 i(*
	gcutPosi
 == 'T') {

760 
cutPosi
 = 
rES5TimePti
(cutPosi + 1, 
hours
, 
mus
, 
cds
, 
timeZeSecds
);

761 i(!
	gcutPosi
)

762  
	gd
::
numic_lims
<>::
qut_NaN
();

765 i(*
	gcutPosi
)

766  
	gd
::
numic_lims
<>::
qut_NaN
();

770 i(
	gmth
 < 1 || month > 12)

771  
	gd
::
numic_lims
<>::
qut_NaN
();

772 i(
	gday
 < 1 || day > 
	gdaysPMth
[
mth
 - 1])

773  
	gd
::
numic_lims
<>::
qut_NaN
();

774 i(
	gmth
 =2 && 
day
 > 28 && !
isLpYr
(
yr
))

775  
d
::
numic_lims
<>::
qut_NaN
();

776 i(
	ghours
 < 0 || hours > 24)

777  
	gd
::
numic_lims
<>::
qut_NaN
();

778 i(
	ghours
 =24 && (
mus
 || 
cds
))

779  
d
::
numic_lims
<>::
qut_NaN
();

780 i(
	gmus
 < 0 || minutes > 59)

781  
	gd
::
numic_lims
<>::
qut_NaN
();

782 i(
	gcds
 < 0 || seconds >= 61)

783  
d
::
numic_lims
<>::
qut_NaN
();

784 i(
	gcds
 > 60) {

786 
	gcds
 = 60;

789 
	gdeSecds
 = 
ymdhmsToSecds
(
yr
, 
mth
, 
day
, 
hours
, 
mus
, 
cds
- 
	gtimeZeSecds
;

790  
deSecds
 * 
	gmsPSecd
;

794 
rDeFromNuTmedChas
(cڡ * 
deSg
, 
bo
& 
haveTZ
, & 
offt
)

796 
	ghaveTZ
 = 
l
;

797 
	gofft
 = 0;

814 
skSsAndCommts
(
deSg
);

816 
	gmth
 = -1;

817 cڡ *
	gwdS
 = 
deSg
;

819 *
	gdeSg
 && !
isASCIIDig
(*
deSg
)) {

820 i(
isASCIIS
(*
deSg
|| *
	gdeSg
 == '(') {

821 i(
deSg
 - 
wdS
 >= 3)

822 
mth
 = 
fdMth
(
wdS
);

823 
skSsAndCommts
(
deSg
);

824 
	gwdS
 = 
deSg
;

826 
	gdeSg
++;

830 i(
	gmth
 =-1 && 
wdS
 !
deSg
)

831 
mth
 = 
fdMth
(
wdS
);

833 
skSsAndCommts
(
deSg
);

835 i(!*
	gdeSg
)

836  
	gd
::
numic_lims
<>::
qut_NaN
();

839 * 
	gwPosS
;

840 
	gday
;

841 i(!
rLg
(
deSg
, &
wPosS
, 10, &
day
))

842  
	gd
::
numic_lims
<>::
qut_NaN
();

843 
	gdeSg
 = 
wPosS
;

845 i(!*
	gdeSg
)

846  
	gd
::
numic_lims
<>::
qut_NaN
();

848 i(
	gday
 < 0)

849  
	gd
::
numic_lims
<>::
qut_NaN
();

851 
	gyr
 = 0;

852 i(
	gday
 > 31) {

854 i(*
	gdeSg
 != '/')

855  
d
::
numic_lims
<>::
qut_NaN
();

857 i(!*++
	gdeSg
)

858  
	gd
::
numic_lims
<>::
qut_NaN
();

859 i(
	gday
 <
d
::
numic_lims
<>::
m
(|| 
day
 >d::numic_lims<>::
max
())

860  
d
::
numic_lims
<>::
qut_NaN
();

861 
	gyr
 = 
ic_
<>(
day
);

862 i(!
rLg
(
deSg
, &
wPosS
, 10, &
mth
))

863  
	gd
::
numic_lims
<>::
qut_NaN
();

864 
	gmth
 -= 1;

865 
	gdeSg
 = 
wPosS
;

866 i(*
	gdeSg
++ !'/' || !*
deSg
)

867  
d
::
numic_lims
<>::
qut_NaN
();

868 i(!
rLg
(
deSg
, &
wPosS
, 10, &
day
))

869  
	gd
::
numic_lims
<>::
qut_NaN
();

870 
	gdeSg
 = 
wPosS
;

871 } i(*
	gdeSg
 ='/' && 
mth
 == -1) {

872 
deSg
++;

874 
	gmth
 = 
day
 - 1;

875 i(!
rLg
(
deSg
, &
wPosS
, 10, &
day
))

876  
	gd
::
numic_lims
<>::
qut_NaN
();

877 i(
	gday
 < 1 || day > 31)

878  
	gd
::
numic_lims
<>::
qut_NaN
();

879 
	gdeSg
 = 
wPosS
;

880 i(*
	gdeSg
 == '/')

881 
deSg
++;

882 i(!*
	gdeSg
)

883  
	gd
::
numic_lims
<>::
qut_NaN
();

885 i(*
	gdeSg
 == '-')

886 
deSg
++;

888 
skSsAndCommts
(
deSg
);

890 i(*
	gdeSg
 == ',')

891 
deSg
++;

893 i(
	gmth
 == -1) {

894 
mth
 = 
fdMth
(
deSg
);

895 i(
	gmth
 == -1)

896  
d
::
numic_lims
<>::
qut_NaN
();

898 *
	gdeSg
 && *deSg !'-' && *
deSg
 !',' && !
isASCIIS
(*dateString))

899 
deSg
++;

901 i(!*
	gdeSg
)

902  
	gd
::
numic_lims
<>::
qut_NaN
();

905 i(*
	gdeSg
 !'-' && *
deSg
 !'/' && *deSg !',' && !
isASCIIS
(*dateString))

906  
d
::
numic_lims
<>::
qut_NaN
();

907 
	gdeSg
++;

911 i(
	gmth
 < 0 || month > 11)

912  
	gd
::
numic_lims
<>::
qut_NaN
();

915 i(
	gyr
 <0 && *
deSg
) {

916 i(!
rI
(
deSg
, &
wPosS
, 10, &
yr
))

917  
d
::
numic_lims
<>::
qut_NaN
();

921 
	ghour
 = 0;

922 
	gmu
 = 0;

923 
	gcd
 = 0;

924 i(!*
	gwPosS
)

925 
	gdeSg
 = 
wPosS
;

928 i(!(
isASCIIS
(*
wPosS
|| *
	gwPosS
 == ',')) {

929 i(*
wPosS
 != ':')

930  
d
::
numic_lims
<>::
qut_NaN
();

932 
	gyr
 = -1;

935 
	gdeSg
 = ++
wPosS
;

936 
skSsAndCommts
(
deSg
);

939 
rLg
(
deSg
, &
wPosS
, 10, &
hour
);

945 i(
	gwPosS
 !
deSg
) {

946 
deSg
 = 
wPosS
;

948 i(
	ghour
 < 0 || hour > 23)

949  
	gd
::
numic_lims
<>::
qut_NaN
();

951 i(!*
	gdeSg
)

952  
	gd
::
numic_lims
<>::
qut_NaN
();

955 i(*
	gdeSg
++ != ':')

956  
d
::
numic_lims
<>::
qut_NaN
();

958 i(!
rLg
(
deSg
, &
wPosS
, 10, &
mu
))

959  
	gd
::
numic_lims
<>::
qut_NaN
();

960 
	gdeSg
 = 
wPosS
;

962 i(
	gmu
 < 0 || minute > 59)

963  
	gd
::
numic_lims
<>::
qut_NaN
();

966 i(*
	gdeSg
 && *deSg !':' && !
isASCIIS
(*
deSg
))

967  
d
::
numic_lims
<>::
qut_NaN
();

970 i(*
	gdeSg
 ==':') {

971 
deSg
++;

973 i(!
rLg
(
deSg
, &
wPosS
, 10, &
cd
))

974  
	gd
::
numic_lims
<>::
qut_NaN
();

975 
	gdeSg
 = 
wPosS
;

977 i(
	gcd
 < 0 || second > 59)

978  
	gd
::
numic_lims
<>::
qut_NaN
();

981 
skSsAndCommts
(
deSg
);

983 i(
cmp
(
deSg
, "AM", 2) == 0) {

984 i(
hour
 > 12)

985  
d
::
numic_lims
<>::
qut_NaN
();

986 i(
	ghour
 == 12)

987 
hour
 = 0;

988 
	gdeSg
 += 2;

989 
skSsAndCommts
(
deSg
);

990 } i(
cmp
(
deSg
, "PM", 2) == 0) {

991 i(
hour
 > 12)

992  
d
::
numic_lims
<>::
qut_NaN
();

993 i(
	ghour
 != 12)

994 
hour
 += 12;

995 
	gdeSg
 += 2;

996 
skSsAndCommts
(
deSg
);

1002 i(
isASCIIDig
(*
deSg
&& 
	gyr
 == -1) {

1003 i(!
rI
(
deSg
, &
wPosS
, 10, &
yr
))

1004  
d
::
numic_lims
<>::
qut_NaN
();

1005 
	gdeSg
 = 
wPosS
;

1006 
skSsAndCommts
(
deSg
);

1011 i(*
	gdeSg
) {

1012 i(
cmp
(
deSg
, "GMT", 3) == 0 || strncasecmp(dateString, "UTC", 3) == 0) {

1013 
deSg
 += 3;

1014 
	ghaveTZ
 = 
ue
;

1017 i(*
	gdeSg
 ='+' || *
deSg
 == '-') {

1018 
o
;

1019 i(!
rI
(
deSg
, &
wPosS
, 10, &
o
))

1020  
	gd
::
numic_lims
<>::
qut_NaN
();

1021 
	gdeSg
 = 
wPosS
;

1023 i(
	go
 < -9959 || o > 9959)

1024  
	gd
::
numic_lims
<>::
qut_NaN
();

1026 
	gsgn
 = (
o
 < 0) ? -1 : 1;

1027 
	go
 = 
abs
(
o
);

1028 i(*
	gdeSg
 != ':') {

1029 i(
o
 >= 24)

1030 
offt
 = ((
o
 / 100* 60 + (% 100)* 
sgn
;

1032 
	gofft
 = 
o
 * 60 * 
sgn
;

1034 ++
	gdeSg
;

1035 
	go2
;

1036 i(!
rI
(
deSg
, &
wPosS
, 10, &
o2
))

1037  
	gd
::
numic_lims
<>::
qut_NaN
();

1038 
	gdeSg
 = 
wPosS
;

1039 
	gofft
 = (
o
 * 60 + 
o2
* 
sgn
;

1041 
	ghaveTZ
 = 
ue
;

1043 
size_t
 
	gi
 = 0; i < 
WTF_ARRAY_LENGTH
(
known_zes
); ++i) {

1044 i(0 =
cmp
(
deSg
, 
known_zes
[
i
].
tzName
, 

(known_zones[i].tzName))) {

1045 
	gofft
 = 
known_zes
[
i
].
tzOfft
;

1046 
	gdeSg
 +

(
known_zes
[
i
].
tzName
);

1047 
	ghaveTZ
 = 
ue
;

1054 
skSsAndCommts
(
deSg
);

1056 i(*
	gdeSg
 && 
	gyr
 == -1) {

1057 i(!
rI
(
deSg
, &
wPosS
, 10, &
yr
))

1058  
d
::
numic_lims
<>::
qut_NaN
();

1059 
	gdeSg
 = 
wPosS
;

1060 
skSsAndCommts
(
deSg
);

1064 i(*
	gdeSg
)

1065  
	gd
::
numic_lims
<>::
qut_NaN
();

1068 i(
	gyr
 >0 && 
yr
 < 100) {

1069 i(
yr
 < 50)

1070 
yr
 += 2000;

1072 
	gyr
 += 1900;

1075  
ymdhmsToSecds
(
yr
, 
mth
 + 1, 
day
, 
hour
, 
mu
, 
cd
* 
	gmsPSecd
;

1078 
rDeFromNuTmedChas
(cڡ * 
deSg
)

1080 
bo
 
	ghaveTZ
;

1081 
	gofft
;

1082 
	gms
 = 
rDeFromNuTmedChas
(
deSg
, 
haveTZ
, 
offt
);

1083 i(
	gd
::
i
(
ms
))

1084  
d
::
numic_lims
<>::
qut_NaN
();

1087 i(!
	ghaveTZ
)

1088 
	gofft
 = 
lcuϋLolTimeOfft
(
ms
).
offt
 / 
msPMu
;

1090  
	gms
 - (
offt
 * 
	gmsPMu
);

1093 
timeCl
(
t
)

1095 i(!
	gd
::
isfe
(
t
))

1096  
d
::
numic_lims
<>::
qut_NaN
();

1097 i(
bs
(
t
> 
	gmaxECMAStTime
)

1098  
	gd
::
numic_lims
<>::
qut_NaN
();

1099  
unc
(
t
);

1103 
Sg
 
makeRFC2822DeSg
(
dayOfWk
, 
day
, 
mth
, 
yr
, 
hours
, 
mus
, 
cds
, 
utcOfft
)

1105 
SgBud
 
	grgBud
;

1106 
	grgBud
.
nd
(
wkdayName
[
dayOfWk
]);

1107 
	grgBud
.
ndL
(", ");

1108 
	grgBud
.
ndNumb
(
day
);

1109 
	grgBud
.
nd
(' ');

1110 
	grgBud
.
nd
(
mthName
[
mth
]);

1111 
	grgBud
.
nd
(' ');

1112 
	grgBud
.
ndNumb
(
yr
);

1113 
	grgBud
.
nd
(' ');

1115 
ndTwoDigNumb
(
rgBud
, 
hours
);

1116 
	grgBud
.
nd
(':');

1117 
ndTwoDigNumb
(
rgBud
, 
mus
);

1118 
	grgBud
.
nd
(':');

1119 
ndTwoDigNumb
(
rgBud
, 
cds
);

1120 
	grgBud
.
nd
(' ');

1122 
	grgBud
.
nd
(
utcOfft
 > 0 ? '+' : '-');

1123 
	gabsuUTCOfft
 = 
abs
(
utcOfft
);

1124 
ndTwoDigNumb
(
rgBud
, 
absuUTCOfft
 / 60);

1125 
ndTwoDigNumb
(
rgBud
, 
absuUTCOfft
 % 60);

1127  
	grgBud
.
toSg
();

	@DateMath.h

43 #ide
DeMh_h


44 
	#DeMh_h


	)

46 
	~<mh.h
>

47 
	~<dt.h
>

48 
	~<rg.h
>

49 
	~<time.h
>

50 
	~<wtf/CutTime.h
>

51 
	~<wtf/Ncyab.h
>

52 
	~<wtf/xt/WTFSg.h
>

54 
mea
 
	gWTF
 {

56 
	sLolTimeOfft
 {

57 
LolTimeOfft
()

58 : 
isDST
(
l
)

59 , 
offt
(0)

63 
LolTimeOfft
(
bo
 
isDST
, 
offt
)

64 : 
isDST
(isDST)

65 , 
offt
(offset)

69 
bo
 
	gݔ
==(cڡ 
LolTimeOfft
& 
h
)

71  
isDST
 =
h
.isDST && 
offt
 == other.offset;

74 
bo
 
	gݔ
!=(cڡ 
LolTimeOfft
& 
h
)

76  
isDST
 !
h
.isDST || 
offt
 != other.offset;

79 
bo
 
	gisDST
;

80 
	gofft
;

83 
lizeDes
();

84 
equivtYrFDST
(
yr
);

87 
WTF_EXPORT_PRIVATE
 
rES5DeFromNuTmedChas
(cڡ * 
deSg
);

88 
WTF_EXPORT_PRIVATE
 
rDeFromNuTmedChas
(cڡ * 
deSg
);

89 
WTF_EXPORT_PRIVATE
 
rDeFromNuTmedChas
(cڡ * 
deSg
, 
bo
& 
haveTZ
, & 
offt
);

90 
WTF_EXPORT_PRIVATE
 
timeCl
();

92 
Sg
 
makeRFC2822DeSg
(
dayOfWk
, 
day
, 
mth
, 
yr
, 
hours
, 
mus
, 
cds
, 
utcOfft
);

94 
le
 
jsCutTime
()

97  
o
(
WTF
::
cutTimeMS
());

100 cڡ * cڡ 
	gwkdayName
[7] = { "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun" };

101 cڡ * cڡ 
	gmthName
[12] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };

102 cڡ * cڡ 
	gmthFuName
[12] = { "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };

104 cڡ 
	ghoursPDay
 = 24.0;

105 cڡ 
	gmusPHour
 = 60.0;

106 cڡ 
	gcdsPMu
 = 60.0;

107 cڡ 
	gmsPSecd
 = 1000.0;

108 cڡ 
	gmsPMth
 = 2592000000.0;

109 cڡ 
	gcdsPHour
 = 
cdsPMu
 * 
musPHour
;

110 cڡ 
	gcdsPDay
 = 
cdsPHour
 * 
hoursPDay
;

111 cڡ 
	gmsPMu
 = 
msPSecd
 * 
cdsPMu
;

112 cڡ 
	gmsPHour
 = 
msPSecd
 * 
cdsPHour
;

113 cڡ 
	gmsPDay
 = 
msPSecd
 * 
cdsPDay
;

115 
WTF_EXPORT_PRIVATE
 
bo
 
isLpYr
(
yr
);

118 
WTF_EXPORT_PRIVATE
 
deToDaysFrom1970
(
yr
, 
mth
, 
day
);

119 
WTF_EXPORT_PRIVATE
 
msToYr
(
ms
);

120 
WTF_EXPORT_PRIVATE
 
msToDays
(
ms
);

121 
WTF_EXPORT_PRIVATE
 
msToMus
(
ms
);

122 
WTF_EXPORT_PRIVATE
 
msToHours
(
ms
);

123 
WTF_EXPORT_PRIVATE
 
dayInYr
(
yr
, 
mth
, 
day
);

124 
WTF_EXPORT_PRIVATE
 
dayInYr
(
ms
, 
yr
);

125 
WTF_EXPORT_PRIVATE
 
mthFromDayInYr
(
dayInYr
, 
bo
 
˭Yr
);

126 
WTF_EXPORT_PRIVATE
 
dayInMthFromDayInYr
(
dayInYr
, 
bo
 
˭Yr
);

129 
WTF_EXPORT_PRIVATE
 
LolTimeOfft
 
lcuϋLolTimeOfft
(
utcInMlicds
);

133 
usg
 
	gWTF
::
isLpYr
;

134 
usg
 
	gWTF
::
deToDaysFrom1970
;

135 
usg
 
	gWTF
::
dayInMthFromDayInYr
;

136 
usg
 
	gWTF
::
dayInYr
;

137 
usg
 
	gWTF
::
musPHour
;

138 
usg
 
	gWTF
::
mthFromDayInYr
;

139 
usg
 
	gWTF
::
msPDay
;

140 
usg
 
	gWTF
::
msPHour
;

141 
usg
 
	gWTF
::
msPMu
;

142 
usg
 
	gWTF
::
msPSecd
;

143 
usg
 
	gWTF
::
msToYr
;

144 
usg
 
	gWTF
::
msToDays
;

145 
usg
 
	gWTF
::
msToMus
;

146 
usg
 
	gWTF
::
msToHours
;

147 
usg
 
	gWTF
::
cdsPDay
;

148 
usg
 
	gWTF
::
cdsPMu
;

149 
usg
 
	gWTF
::
rDeFromNuTmedChas
;

150 
usg
 
	gWTF
::
makeRFC2822DeSg
;

151 
usg
 
	gWTF
::
LolTimeOfft
;

152 
usg
 
	gWTF
::
lcuϋLolTimeOfft
;

	@DecimalNumber.cpp

26 
	~"cfig.h
"

27 
	~"DecimNumb.h
"

28 
	~<mh.h
>

29 
	~<wtf/MhExas.h
>

30 
	~<wtf/xt/WTFSg.h
>

32 
mea
 
	gWTF
 {

34 
	gDecimNumb
::
bufrLgthFSgDecim
() const

36 
ngth
 = 0;

39 i(
	gm_expڒt
 < 0) {

40 i(
	gm_sign
)

41 ++
	gngth
;

42 
	gngth
 += 2;

43 
	gngth
 +-
m_expڒt
 - 1;

44 
	gngth
 +
m_ecisi
;

45  
	gngth
;

48 
	gdigsBefeDecimPot
 = 
m_expڒt
 + 1;

53 i(
	gm_ecisi
 <
digsBefeDecimPot
) {

54 i(
m_sign
)

55 ++
ngth
;

56 
	gngth
 +
m_ecisi
;

57 
	gngth
 +
digsBefeDecimPot
 - 
m_ecisi
;

58  
	gngth
;

64 i(
	gm_sign
)

65 ++
	gngth
;

66 
	gngth
 +
digsBefeDecimPot
;

67 ++
	gngth
;

68 
	gngth
 +
m_ecisi
 - 
digsBefeDecimPot
;

70  
	gngth
;

73 
	gDecimNumb
::
bufrLgthFSgExpڒtl
() const

75 
ngth
 = 0;

76 i(
	gm_sign
)

77 ++
	gngth
;

80 ++
	gngth
;

82 i(
	gm_ecisi
 > 1) {

83 ++
	gngth
;

84 
	gngth
 +
m_ecisi
 - 1;

88 
	gngth
 += 2;

90 
	gexpڒt
 = (
m_expڒt
 >= 0) ? m_exponent : -m_exponent;

93 i(
	gexpڒt
 >= 100)

94 ++
ngth
;

95 i(
	gexpڒt
 >= 10)

96 ++
ngth
;

97 ++
	gngth
;

99  
	gngth
;

102 
	gDecimNumb
::
toSgDecim
(
LCh
* 
bufr
, 
bufrLgth
) const

104 
ASSERT_UNUSED
(
bufrLgth
, bufrLgth >
bufrLgthFSgDecim
());

107 
ASSERT
(
m_ecisi
);

108 
LCh
* 
	gxt
 = 
bufr
;

112 i(
	gm_expڒt
 < 0) {

113 
	gzos
 = -
m_expڒt
 - 1;

115 i(
	gm_sign
)

116 *
	gxt
++ = '-';

117 *
	gxt
++ = '0';

118 *
	gxt
++ = '.';

119 
	gi
 = 0; i < 
	gzos
; ++i)

120 *
	gxt
++ = '0';

121 
	gi
 = 0; i < 
	gm_ecisi
; ++i)

122 *
	gxt
++ = 
m_signifind
[
i
];

124  
	gxt
 - 
	gbufr
;

127 
	gdigsBefeDecimPot
 = 
m_expڒt
 + 1;

132 i(
	gm_ecisi
 <
digsBefeDecimPot
) {

133 i(
m_sign
)

134 *
xt
++ = '-';

135 
	gi
 = 0; i < 
	gm_ecisi
; ++i)

136 *
	gxt
++ = 
m_signifind
[
i
];

137 
	gi
 = 0; i < (
	gdigsBefeDecimPot
 - 
	gm_ecisi
); ++i)

138 *
	gxt
++ = '0';

140  
	gxt
 - 
	gbufr
;

147 i(
	gm_sign
)

148 *
	gxt
++ = '-';

149 
	gi
 = 0; i < 
	gdigsBefeDecimPot
; ++i)

150 *
	gxt
++ = 
m_signifind
[
i
];

151 *
	gxt
++ = '.';

152 
	gi
 = 
digsBefeDecimPot
; i < 
	gm_ecisi
; ++i)

153 *
	gxt
++ = 
m_signifind
[
i
];

155  
	gxt
 - 
	gbufr
;

158 
	gDecimNumb
::
toSgExpڒtl
(
LCh
* 
bufr
, 
bufrLgth
) const

160 
ASSERT_UNUSED
(
bufrLgth
, bufrLgth >
bufrLgthFSgExpڒtl
());

163 
ASSERT
(
m_ecisi
);

164 
LCh
* 
	gxt
 = 
bufr
;

167 i(
	gm_sign
)

168 *
	gxt
++ = '-';

171 *
	gxt
++ = 
m_signifind
[0];

172 i(
	gm_ecisi
 > 1) {

173 *
	gxt
++ = '.';

174 
	gi
 = 1; i < 
	gm_ecisi
; ++i)

175 *
	gxt
++ = 
m_signifind
[
i
];

179 *
	gxt
++ = 'e';

180 
	gexpڒt
;

181 i(
	gm_expڒt
 >= 0) {

182 *
xt
++ = '+';

183 
	gexpڒt
 = 
m_expڒt
;

185 *
	gxt
++ = '-';

186 
	gexpڒt
 = -
m_expڒt
;

190 i(
	gexpڒt
 >= 100)

191 *
xt
++ = '0' + 
expڒt
 / 100;

192 i(
	gexpڒt
 >= 10)

193 *
xt
++ = '0' + (
expڒt
 % 100) / 10;

194 *
	gxt
++ = '0' + 
expڒt
 % 10;

196  
	gxt
 - 
	gbufr
;

	@DecimalNumber.h

26 #ide
DecimNumb_h


27 
	#DecimNumb_h


	)

29 
	~<mh.h
>

30 
	~<wtf/dt.h
>

31 
	~<wtf/MhExas.h
>

32 
	~<wtf/xt/WTFSg.h
>

34 
mea
 
	gWTF
 {

36 
	eRoundgSignifiFigusTy
 { 
	gRoundgSignifiFigus
 };

37 
	eRoundgDecimPsTy
 { 
	gRoundgDecimPs
 };

39 as
	cDecimNumb
 {

40 
	gpublic
:

41 
DecimNumb
(
d
)

43 
ASSERT
(
d
::
isfe
(
d
));

44 
dt
(
m_signifind
, 
d
, 
m_sign
, 
m_expڒt
, 
m_ecisi
);

46 
ASSERT
(
m_ecisi
);

48 
ASSERT
(
m_signifind
[0] !'0' || !
m_expڒt
);

50 
ASSERT
(
m_signifind
[0] !'0' || 
m_ecisi
 == 1);

52 
ASSERT
(
m_signifind
[0] ='0' || m_signifind[
m_ecisi
 - 1] != '0');

55 
DecimNumb
(
d
, 
RoundgSignifiFigusTy
, 
signifiFigus
)

57 
ASSERT
(
d
::
isfe
(
d
));

58 
dtRoundSF
(
m_signifind
, 
d
, 
signifiFigus
, 
m_sign
, 
m_expڒt
, 
m_ecisi
);

60 
ASSERT_WITH_SECURITY_IMPLICATION
(
signifiFigus
 && signifiFigu<(
DtBufr
));

61 
	gm_ecisi
 < 
	gsignifiFigus
)

62 
	gm_signifind
[
m_ecisi
++] = '0';

64 
ASSERT
(
m_ecisi
);

66 
ASSERT
(
m_signifind
[0] !'0' || !
m_expڒt
);

69 
DecimNumb
(
d
, 
RoundgDecimPsTy
, 
decimPs
)

71 
ASSERT
(
d
::
isfe
(
d
));

72 
dtRoundDP
(
m_signifind
, 
d
, 
decimPs
, 
m_sign
, 
m_expڒt
, 
m_ecisi
);

74 
	gsignifiFigus
 = 1 + 
m_expڒt
 + 
decimPs
;

75 
ASSERT_WITH_SECURITY_IMPLICATION
(
signifiFigus
 && signifiFigu<(
DtBufr
));

76 
	gm_ecisi
 < 
	gsignifiFigus
)

77 
	gm_signifind
[
m_ecisi
++] = '0';

79 
ASSERT
(
m_ecisi
);

81 
ASSERT
(
m_signifind
[0] !'0' || !
m_expڒt
);

84 
WTF_EXPORT_PRIVATE
 
bufrLgthFSgDecim
() const;

85 
WTF_EXPORT_PRIVATE
 
bufrLgthFSgExpڒtl
() const;

87 
WTF_EXPORT_PRIVATE
 
toSgDecim
(
LCh
* 
bufr
, 
bufrLgth
) const;

88 
WTF_EXPORT_PRIVATE
 
toSgExpڒtl
(
LCh
* 
bufr
, 
bufrLgth
) const;

90 
bo
 
sign
(cڡ {  
	gm_sign
; }

91 
expڒt
(cڡ {  
	gm_expڒt
; }

92 cڡ * 
signifind
(cڡ {  
	gm_signifind
; }

93 
ecisi
(cڡ {  
	gm_ecisi
; }

95 
	give
:

96 
bo
 
m_sign
;

97 
	gm_expڒt
;

98 
DtBufr
 
	gm_signifind
;

99 
	gm_ecisi
;

104 
usg
 
	gWTF
::
DecimNumb
;

105 
usg
 
	gWTF
::
RoundgSignifiFigus
;

106 
usg
 
	gWTF
::
RoundgDecimPs
;

	@DeferrableRefCounted.h

26 #ide
DeabRefCoued_h


27 
	#DeabRefCoued_h


	)

29 
	~<wtf/Asis.h
>

30 
	~<wtf/FaMloc.h
>

31 
	~<wtf/Ncyab.h
>

33 
mea
 
	gWTF
 {

41 as
	cDeabRefCouedBa
 {

42 cڡ 
	gdeedFg
 = 1;

43 cڡ 
	gnmInemt
 = 2;

45 
	gpublic
:

46 
f
()

48 
m_fCou
 +
nmInemt
;

51 
bo
 
hasORef
() const

53  
fCou
() == 1;

56 
fCou
() const

58  
	gm_fCou
 / 
	gnmInemt
;

61 
bo
 
isDeed
() const

63  !!(
	gm_fCou
 & 
	gdeedFg
);

66 
	geed
:

67 
DeabRefCouedBa
()

68 : 
m_fCou
(
nmInemt
)

72 ~
DeabRefCouedBa
()

76 
bo
 
defBa
()

78 
m_fCou
 -
nmInemt
;

79  !
	gm_fCou
;

82 
bo
 
tIsDeedBa
(bo 
vue
)

84 i(
	gvue
) {

85 
	gm_fCou
 |
deedFg
;

86  
	gl
;

88 
	gm_fCou
 &~
deedFg
;

89  !
	gm_fCou
;

92 
	give
:

93 
m_fCou
;

96 
	gme
<
tyme
 
	gT
>

97 as
	cDeabRefCoued
 : 
public
 
DeabRefCouedBa
 {

98 
WTF_MAKE_NONCOPYABLE
(
DeabRefCoued
); 
	gWTF_MAKE_FAST_ALLOCATED
;

99 
	gpublic
:

100 
def
()

102 i(
defBa
())

103 
de
 
ic_
<
T
*>(
this
);

106 
bo
 
tIsDeed
(bo 
vue
)

108 i(!
tIsDeedBa
(
vue
))

109  
	gl
;

110 
de
 
	gic_
<
	gT
*>(
	gthis
);

111  
	gue
;

114 
	geed
:

115 
DeabRefCoued
() { }

116 ~
DeabRefCoued
() { }

121 
usg
 
	gWTF
::
DeabRefCoued
;

	@Deque.h

30 #ide
WTF_Deque_h


31 
	#WTF_Deque_h


	)

36 
	~<
>

37 
	~<wtf/Ve.h
>

39 
mea
 
	gWTF
 {

41 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
> 
ass
 
	gDequeItBa
;

42 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
> 
ass
 
	gDequeIt
;

43 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
> 
ass
 
	gDequeCڡIt
;

45 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
 = 0>

46 as
	cDeque
 {

47 
WTF_MAKE_FAST_ALLOCATED
;

48 
	gpublic
:

49 
DequeIt
<
	tT
, 
	tleCacy
> 
	t
;

50 
	gDequeCڡIt
<
	tT
, 
	tleCacy
> 
	tcڡ_
;

51 
	gd
::
	tv_
<
	t
>everse_iterator;

52 
	gd
::
	tv_
<
	tcڡ_
> 
	tcڡ_v_
;

54 
Deque
();

55 
Deque
(cڡ Deque<
T
, 
leCacy
>&);

56 
	gDeque
& 
	gݔ
=(cڡ 
Deque
<
T
, 
	gleCacy
>&);

57 ~
Deque
();

59 
sw
(
Deque
<
T
, 
leCacy
>&);

61 
size_t
 
size
(cڡ {  
	gm_t
 <
m_d
 ? m_d - 
m_t
 : m_d + 
m_bufr
.
cy
() - m_start; }

62 
bo
 
isEmy
(cڡ {  
	gm_t
 =
m_d
; }

64 

 
beg
({  it(
this
, 
m_t
); }

65 

 
d
({  it(
this
, 
m_d
); }

66 
cڡ_
 
beg
(cڡ {  cڡ_(
this
, 
m_t
); }

67 
cڡ_
 
d
(cڡ {  cڡ_(
this
, 
m_d
); }

68 
v_
 
rbeg
({ ev_(
d
()); }

69 
v_
 
nd
({ ev_(
beg
()); }

70 
cڡ_v_
 
rbeg
(cڡ {  cڡ_v_(
d
()); }

71 
cڡ_v_
 
nd
(cڡ {  cڡ_v_(
beg
()); }

73 
	gT
& 
f
({ 
ASSERT
(
m_t
 !
m_d
);  
	gm_bufr
.
bufr
()[m_start]; }

74 cڡ 
	gT
& 
f
(cڡ { 
ASSERT
(
m_t
 !
m_d
);  
	gm_bufr
.
bufr
()[m_start]; }

75 
T
 
keF
();

77 
	gT
& 
ϡ
({ 
ASSERT
(
m_t
 !
m_d
);  *(--
d
()); }

78 cڡ 
	gT
& 
ϡ
(cڡ { 
ASSERT
(
m_t
 !
m_d
);  *(--
d
()); }

79 
T
 
keLa
();

81 
	gme
<
tyme
 
	gU
> 
nd
(
U
&&);

82 
	gme
<
tyme
 
	gU
> 
d
(
U
&&);

83 
moveF
();

84 
moveLa
();

85 
move
(

&);

86 
move
(
cڡ_
&);

88 
r
();

90 
	gme
<
tyme
 
	gPdi
>

91 

 
fdIf
(
Pdi
&&);

93 
	give
:

94 
nd
 
ass
 
DequeItBa
<
T
, 
	gleCacy
>;

96 
	gVeBufr
<
	tT
, 
	tleCacy
> 
	tBufr
;

97 
	gVeTyOtis
<
	tT
> 
	tTyOtis
;

98 
	gDequeItBa
<
	tT
, 
	tleCacy
> 
	tItBa
;

100 
move
(
size_t
 
posi
);

101 
videIts
();

102 
deroyA
();

103 
checkVidy
() const;

104 
checkIndexVidy
(
size_t
) const;

105 
exndCacyIfNded
();

106 
exndCacy
();

108 
size_t
 
	gm_t
;

109 
size_t
 
	gm_d
;

110 
Bufr
 
	gm_bufr
;

111 #ide
NDEBUG


112 
mub
 
ItBa
* 
	gm_s
;

116 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
 = 0>

117 as
	cDequeItBa
 {

118 
eed
:

119 
DequeItBa
();

120 
DequeItBa
(cڡ 
Deque
<
T
, 
leCacy
>*, 
size_t
);

121 
DequeItBa
(const DequeIteratorBase&);

122 
	gDequeItBa
& 
	gݔ
=(cڡ 
DequeItBa
&);

123 ~
DequeItBa
();

125 
assign
(cڡ 
DequeItBa
& 
h
{ *
	gthis
 = other; }

127 
emt
();

128 
deemt
();

130 
T
* 
befe
() const;

131 
T
* 
a
() const;

133 
bo
 
isEqu
(cڡ 
DequeItBa
&) const;

135 
	give
:

136 
addToItsLi
();

137 
moveFromItsLi
();

138 
checkVidy
() const;

139 
checkVidy
(cڡ 
DequeItBa
&) const;

141 
	gDeque
<
	gT
, 
	gleCacy
>* 
	gm_deque
;

142 
size_t
 
	gm_dex
;

144 
nd
 
ass
 
	gDeque
<
	gT
, 
	gleCacy
>;

146 #ide
NDEBUG


147 
mub
 
DequeItBa
* 
	gm_xt
;

148 
mub
 
DequeItBa
* 
	gm_evious
;

152 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
 = 0>

153 
ass
 
DequeIt
 : 
public
 
DequeItBa
<
T
, 
	gleCacy
> {

154 
	give
:

155 
DequeItBa
<
	tT
, 
	tleCacy
> 
	tBa
;

156 
	gDequeIt
<
	tT
, 
	tleCacy
> 
	tIt
;

158 
	gpublic
:

159 
rdiff_t
 
	tdifn_ty
;

160 
T
 
	tvue_ty
;

161 
T
* 
	tpor
;

162 
	gT
& 
	tn
;

163 
	gd
::
	tbideiڮ__g
 
	t_gy
;

165 
DequeIt
(
Deque
<
T
, 
leCacy
>* 
deque
, 
size_t
 
dex
)

166 : 
Ba
(
deque
, 
dex
) { }

168 
DequeIt
(cڡ 
It
& 
h
: 
Ba
(other) { }

169 
DequeIt
& 
ݔ
=(cڡ 
It
& 
h
{ 
Ba
::
assign
(h);  *
	gthis
; }

171 
	gT
& 
	gݔ
*(cڡ {  *
	gBa
::
a
(); }

172 
T
* 
	gݔ
->(cڡ {  
	gBa
::
a
(); }

174 
bo
 
	gݔ
==(cڡ 
It
& 
h
cڡ {  
Ba
::
isEqu
(other); }

175 
bo
 
	gݔ
!=(cڡ 
It
& 
h
cڡ {  !
Ba
::
isEqu
(other); }

177 
	gIt
& 
	gݔ
++({ 
	gBa
::
emt
();  *
	gthis
; }

179 
	gIt
& 
	gݔ
--({ 
	gBa
::
deemt
();  *
	gthis
; }

183 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
 = 0>

184 
ass
 
DequeCڡIt
 : 
public
 
DequeItBa
<
T
, 
	gleCacy
> {

185 
	give
:

186 
DequeItBa
<
	tT
, 
	tleCacy
> 
	tBa
;

187 
	gDequeCڡIt
<
	tT
, 
	tleCacy
> 
	tIt
;

188 
	gDequeIt
<
	tT
, 
	tleCacy
> 
	tNCڡIt
;

190 
	gpublic
:

191 
rdiff_t
 
	tdifn_ty
;

192 
T
 
	tvue_ty
;

193 cڡ 
	tT
* 
	tpor
;

194 cڡ 
	tT
& 
	tn
;

195 
	gd
::
	tbideiڮ__g
 
	t_gy
;

197 
DequeCڡIt
(cڡ 
Deque
<
T
, 
leCacy
>* 
deque
, 
size_t
 
dex
)

198 : 
Ba
(
deque
, 
dex
) { }

200 
DequeCڡIt
(cڡ 
It
& 
h
: 
Ba
(other) { }

201 
DequeCڡIt
(cڡ 
NCڡIt
& 
h
: 
Ba
(other) { }

202 
DequeCڡIt
& 
ݔ
=(cڡ 
It
& 
h
{ 
Ba
::
assign
(h);  *
	gthis
; }

203 
	gDequeCڡIt
& 
	gݔ
=(cڡ 
NCڡIt
& 
h
{ 
Ba
::
assign
(h);  *
	gthis
; }

205 cڡ 
	gT
& 
	gݔ
*(cڡ {  *
	gBa
::
a
(); }

206 cڡ 
T
* 
	gݔ
->(cڡ {  
	gBa
::
a
(); }

208 
bo
 
	gݔ
==(cڡ 
It
& 
h
cڡ {  
Ba
::
isEqu
(other); }

209 
bo
 
	gݔ
!=(cڡ 
It
& 
h
cڡ {  !
Ba
::
isEqu
(other); }

211 
	gIt
& 
	gݔ
++({ 
	gBa
::
emt
();  *
	gthis
; }

213 
	gIt
& 
	gݔ
--({ 
	gBa
::
deemt
();  *
	gthis
; }

217 #ifde
NDEBUG


218 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
> 
le
 
	gDeque
<T, iƚeCacy>::
	$checkVidy
(cڡ { 
	}
}

219 
me
<
tyme
 
T
, 
size_t
 
	gleCacy
> 
le
 
	gDeque
<
	gT
, iƚeCacy>::
	$checkIndexVidy
(
size_t
cڡ { 
	}
}

220 
me
<
tyme
 
T
, 
size_t
 
	gleCacy
> 
le
 
	gDeque
<
	gT
, iƚeCacy>::
	$videIts
({ 
	}
}

222 
me
<
tyme
 
T
, 
size_t
 
	gleCacy
>

223 
	gDeque
<
	gT
, 
	gleCacy
>::
	$checkVidy
() const

227 
	`ASSERT
(
m_bufr
.
	`cy
() != 1);

229 i(!
m_bufr
.
	`cy
()) {

230 
	`ASSERT
(!
m_t
);

231 
	`ASSERT
(!
m_d
);

233 
	`ASSERT
(
m_t
 < 
m_bufr
.
	`cy
());

234 
	`ASSERT
(
m_d
 < 
m_bufr
.
	`cy
());

236 
	}
}

238 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

239 
	gDeque
<
	gT
, 
	gleCacy
>::
	$checkIndexVidy
(
size_t
 
dex
) const

241 
	`ASSERT_UNUSED
(
dex
, index <
m_bufr
.
	`cy
());

242 i(
m_t
 <
m_d
) {

243 
	`ASSERT
(
dex
 >
m_t
);

244 
	`ASSERT
(
dex
 <
m_d
);

246 
	`ASSERT
(
dex
 >
m_t
 || index <
m_d
);

248 
	}
}

250 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

251 
	gDeque
<
	gT
, 
	gleCacy
>::
	$videIts
()

253 
ItBa
* 
xt
;

254 
ItBa
* 
p
 = 
m_s
;; = 
xt
) {

255 
xt
 = 
p
->
m_xt
;

256 
p
->
m_deque
 = 0;

257 
p
->
m_xt
 = 0;

258 
p
->
m_evious
 = 0;

260 
m_s
 = 0;

261 
	}
}

264 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

265 
le
 
	gDeque
<
	gT
, 
	gleCacy
>::
	$Deque
()

266 : 
	`m_t
(0)

267 , 
	$m_d
(0)

268 #ide
NDEBUG


269 , 
	$m_s
(0)

272 
	`checkVidy
();

273 
	}
}

275 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

276 
le
 
	gDeque
<
	gT
, 
	gleCacy
>::
Deque
(cڡ Deque<
T
, 
leCacy
>& 
h
)

277 : 
m_t
(
h
.m_start)

278 , 
m_d
(
h
.m_end)

279 , 
m_bufr
(
h
.m_bufr.
	$cy
())

280 #ide
NDEBUG


281 , 
	$m_s
(0)

284 cڡ 
T
* 
hBufr
 = 
h
.
m_bufr
.
	`bufr
();

285 i(
m_t
 <
m_d
)

286 
TyOtis
::
	`unlizedCy
(
hBufr
 + 
m_t
, othBuf+ 
m_d
, 
m_bufr
.
	`bufr
() + m_start);

288 
TyOtis
::
	`unlizedCy
(
hBufr
, othBuf+ 
m_d
, 
m_bufr
.
	`bufr
());

289 
TyOtis
::
	`unlizedCy
(
hBufr
 + 
m_t
, othBuf+ 
m_bufr
.
	`cy
(), m_bufr.
	`bufr
() + m_start);

291 
	}
}

293 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

294 
le
 
	gDeque
<
	gT
, 
	gleCacy
>& Deque<T, iƚeCacy>::
ݔ
=(cڡ 
Deque
<
T
, iƚeCacy>& 
	gh
)

298 
	gDeque
<
	gT
, 
	gleCacy
> 
cy
(
h
);

299 
sw
(
cy
);

300  *
	gthis
;

303 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

304 
le
 
	gDeque
<
	gT
, 
	gleCacy
>::
	$deroyA
()

306 i(
m_t
 <
m_d
)

307 
TyOtis
::
	`deru
(
m_bufr
.
	`bufr
(+ 
m_t
, m_bufr.bufr(+ 
m_d
);

309 
TyOtis
::
	`deru
(
m_bufr
.
	`bufr
(), m_bufr.bufr(+ 
m_d
);

310 
TyOtis
::
	`deru
(
m_bufr
.
	`bufr
(+ 
m_t
, m_bufr.bufr(+ m_bufr.
	`cy
());

312 
	}
}

314 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

315 
le
 
	gDeque
<
	gT
, 
	gleCacy
>::~
	$Deque
()

317 
	`checkVidy
();

318 
	`videIts
();

319 
	`deroyA
();

320 
	}
}

322 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

323 
le
 
	gDeque
<
	gT
, 
	gleCacy
>::
sw
(
Deque
<
T
, 
leCacy
>& 
h
)

325 
checkVidy
();

326 
	gh
.
checkVidy
();

327 
videIts
();

328 
	gd
::
sw
(
m_t
, 
h
.m_start);

329 
	gd
::
sw
(
m_d
, 
h
.m_end);

330 
	gm_bufr
.
sw
(
h
.
m_bufr
, 0, 0);

331 
checkVidy
();

332 
	gh
.
checkVidy
();

335 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

336 
le
 
	gDeque
<
	gT
, 
	gleCacy
>::
	$r
()

338 
	`checkVidy
();

339 
	`videIts
();

340 
	`deroyA
();

341 
m_t
 = 0;

342 
m_d
 = 0;

343 
m_bufr
.
	`doBufr
(m_bufr.
	`bufr
());

344 
	`checkVidy
();

345 
	}
}

347 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

348 
	gme
<
tyme
 
	gPdi
>

349 
le
ut
	gDeque
<
	gT
, 
	gleCacy
>::
fdIf
(
Pdi
&& 
edi
-> 



351 

 
d_
 = 
d
();

352 

 
	g
 = 
beg
(); i!
d_
; ++it) {

353 i(
edi
(*

))

354  
	g
;

356  
	gd_
;

359 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

360 
le
 
	gDeque
<
	gT
, 
	gleCacy
>::
	$exndCacyIfNded
()

362 i(
m_t
) {

363 i(
m_d
 + 1 !
m_t
)

365 } i(
m_d
) {

366 i(
m_d
 !
m_bufr
.
	`cy
() - 1)

368 } i(
m_bufr
.
	`cy
())

371 
	`exndCacy
();

372 
	}
}

374 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

375 
	gDeque
<
	gT
, 
	gleCacy
>::
	$exndCacy
()

377 
	`checkVidy
();

378 
size_t
 
dCacy
 = 
m_bufr
.
	`cy
();

379 
T
* 
dBufr
 = 
m_bufr
.
	`bufr
();

380 
m_bufr
.
	`loBufr
(
d
::
	`max
(
ic_
<
size_t
>(16), 
dCacy
 + oldCapacity / 4 + 1));

381 i(
m_t
 <
m_d
)

382 
TyOtis
::
	`move
(
dBufr
 + 
m_t
, oldBuf+ 
m_d
, 
m_bufr
.
	`bufr
() + m_start);

384 
TyOtis
::
	`move
(
dBufr
, oldBuf+ 
m_d
, 
m_bufr
.
	`bufr
());

385 
size_t
 
wS
 = 
m_bufr
.
	`cy
(- (
dCacy
 - 
m_t
);

386 
TyOtis
::
	`move
(
dBufr
 + 
m_t
, oldBuf+ 
dCacy
, 
m_bufr
.
	`bufr
(+ 
wS
);

387 
m_t
 = 
wS
;

389 
m_bufr
.
	`doBufr
(
dBufr
);

390 
	`checkVidy
();

391 
	}
}

393 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

394 
le
ut
	gDeque
<
	gT
, 
	gleCacy
>::
keF
(-> 
T


396 
T
 
dF
 = 
WTF
::
move
(
f
());

397 
moveF
();

398  
	gdF
;

401 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

402 
le
ut
	gDeque
<
	gT
, 
	gleCacy
>::
keLa
(-> 
T


404 
T
 
dLa
 = 
WTF
::
move
(
ϡ
());

405 
moveLa
();

406  
	gdLa
;

409 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>eme<tym
	gU
>

410 
le
 
	gDeque
<
	gT
, 
	gleCacy
>::
	$nd
(
U
&& 
vue
)

412 
	`checkVidy
();

413 
	`exndCacyIfNded
();

414 
	`w
 (
NNu
, &
m_bufr
.
	`bufr
()[
m_d
]
	`T
(
d
::
fwd
<
U
>(
vue
));

415 i(
m_d
 =
m_bufr
.
	`cy
() - 1)

416 
m_d
 = 0;

418 ++
m_d
;

419 
	`checkVidy
();

420 
	}
}

422 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>eme<tym
	gU
>

423 
le
 
	gDeque
<
	gT
, 
	gleCacy
>::
	$d
(
U
&& 
vue
)

425 
	`checkVidy
();

426 
	`exndCacyIfNded
();

427 i(!
m_t
)

428 
m_t
 = 
m_bufr
.
	`cy
() - 1;

430 --
m_t
;

431 
	`w
 (
NNu
, &
m_bufr
.
	`bufr
()[
m_t
]
	`T
(
d
::
fwd
<
U
>(
vue
));

432 
	`checkVidy
();

433 
	}
}

435 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

436 
le
 
	gDeque
<
	gT
, 
	gleCacy
>::
	$moveF
()

438 
	`checkVidy
();

439 
	`videIts
();

440 
	`ASSERT
(!
	`isEmy
());

441 
TyOtis
::
	`deru
(&
m_bufr
.
	`bufr
()[
m_t
], &m_buffer.buffer()[m_start + 1]);

442 i(
m_t
 =
m_bufr
.
	`cy
() - 1)

443 
m_t
 = 0;

445 ++
m_t
;

446 
	`checkVidy
();

447 
	}
}

449 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

450 
le
 
	gDeque
<
	gT
, 
	gleCacy
>::
	$moveLa
()

452 
	`checkVidy
();

453 
	`videIts
();

454 
	`ASSERT
(!
	`isEmy
());

455 i(!
m_d
)

456 
m_d
 = 
m_bufr
.
	`cy
() - 1;

458 --
m_d
;

459 
TyOtis
::
	`deru
(&
m_bufr
.
	`bufr
()[
m_d
], &m_buffer.buffer()[m_end + 1]);

460 
	`checkVidy
();

461 
	}
}

463 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

464 
le
 
	gDeque
<
	gT
, 
	gleCacy
>::
	$move
(

& 

)

466 

.
	`checkVidy
();

467 
	`move
(

.
m_dex
);

468 
	}
}

470 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

471 
le
 
	gDeque
<
	gT
, 
	gleCacy
>::
	$move
(
cڡ_
& 

)

473 

.
	`checkVidy
();

474 
	`move
(

.
m_dex
);

475 
	}
}

477 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

478 
le
 
	gDeque
<
	gT
, 
	gleCacy
>::
	$move
(
size_t
 
posi
)

480 i(
posi
 =
m_d
)

483 
	`checkVidy
();

484 
	`videIts
();

486 
T
* 
bufr
 = 
m_bufr
.
	`bufr
();

487 
TyOtis
::
	`deru
(&
bufr
[
posi
], &buffer[position + 1]);

490 i(
posi
 >
m_t
) {

491 
TyOtis
::
	`moveOvϵg
(
bufr
 + 
m_t
, buf+ 
posi
, buffer + m_start + 1);

492 
m_t
 = (m_+ 1% 
m_bufr
.
	`cy
();

494 
TyOtis
::
	`moveOvϵg
(
bufr
 + 
posi
 + 1, buf+ 
m_d
, buffer +osition);

495 
m_d
 = (m_d - 1 + 
m_bufr
.
	`cy
()) % m_buffer.capacity();

497 
	`checkVidy
();

498 
	}
}

500 #ifde
NDEBUG


501 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
> 
le
 
	gDequeItBa
<T, iƚeCacy>::
	$checkVidy
(cڡ { 
	}
}

502 
me
<
tyme
 
T
, 
size_t
 
	gleCacy
> 
le
 
	gDequeItBa
<
	gT
, iƚeCacy>::
checkVidy
(cڡ 
DequeItBa
<T, 
leCacy
>&) const { }

503 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
> 
le
 
	gDequeItBa
<T, iƚeCacy>::
	$addToItsLi
({ 
	}
}

504 
me
<
tyme
 
T
, 
size_t
 
	gleCacy
> 
le
 
	gDequeItBa
<
	gT
, iƚeCacy>::
	$moveFromItsLi
({ 
	}
}

506 
me
<
tyme
 
T
, 
size_t
 
	gleCacy
>

507 
	gDequeItBa
<
	gT
, 
	gleCacy
>::
	$checkVidy
() const

509 
	`ASSERT
(
m_deque
);

510 
m_deque
->
	`checkIndexVidy
(
m_dex
);

511 
	}
}

513 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

514 
	gDequeItBa
<
	gT
, 
	gleCacy
>::
	$checkVidy
(cڡ 
DequeItBa
& 
h
) const

516 
	`checkVidy
();

517 
h
.
	`checkVidy
();

518 
	`ASSERT
(
m_deque
 =
h
.m_deque);

519 
	}
}

521 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

522 
	gDequeItBa
<
	gT
, 
	gleCacy
>::
	$addToItsLi
()

524 i(!
m_deque
)

525 
m_xt
 = 0;

527 
m_xt
 = 
m_deque
->
m_s
;

528 
m_deque
->
m_s
 = 
this
;

529 i(
m_xt
)

530 
m_xt
->
m_evious
 = 
this
;

532 
m_evious
 = 0;

533 
	}
}

535 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

536 
	gDequeItBa
<
	gT
, 
	gleCacy
>::
	$moveFromItsLi
()

538 i(!
m_deque
) {

539 
	`ASSERT
(!
m_xt
);

540 
	`ASSERT
(!
m_evious
);

542 i(
m_xt
) {

543 
	`ASSERT
(
m_xt
->
m_evious
 =
this
);

544 
m_xt
->
m_evious
 = m_previous;

546 i(
m_evious
) {

547 
	`ASSERT
(
m_deque
->
m_s
 !
this
);

548 
	`ASSERT
(
m_evious
->
m_xt
 =
this
);

549 
m_evious
->
m_xt
 = m_next;

551 
	`ASSERT
(
m_deque
->
m_s
 =
this
);

552 
m_deque
->
m_s
 = 
m_xt
;

555 
m_xt
 = 0;

556 
m_evious
 = 0;

557 
	}
}

560 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

561 
le
 
	gDequeItBa
<
	gT
, 
	gleCacy
>::
	$DequeItBa
()

562 : 
	$m_deque
(0)

564 
	}
}

566 
me
<
tyme
 
T
, 
size_t
 
	gleCacy
>

567 
le
 
	gDequeItBa
<
	gT
, 
	gleCacy
>::
DequeItBa
(cڡ 
Deque
<
T
, 
leCacy
>* 
deque
, 
size_t
 
dex
)

568 : 
m_deque
(
cڡ_
<
Deque
<
T
, 
leCacy
>*>(
deque
))

569 , 
	$m_dex
(
dex
)

571 
	`addToItsLi
();

572 
	`checkVidy
();

573 
	}
}

575 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

576 
le
 
	gDequeItBa
<
	gT
, 
	gleCacy
>::
	$DequeItBa
(cڡ 
DequeItBa
& 
h
)

577 : 
	`m_deque
(
h
.
m_deque
)

578 , 
	$m_dex
(
h
.
m_dex
)

580 
	`addToItsLi
();

581 
	`checkVidy
();

582 
	}
}

584 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

585 
le
 
	gDequeItBa
<
	gT
, 
	gleCacy
>& DequeItBa<T, iƚeCacy>::
ݔ
=(cڡ 
DequeItBa
& 
h
)

587 
h
.
checkVidy
();

588 
moveFromItsLi
();

590 
	gm_deque
 = 
h
.
m_deque
;

591 
	gm_dex
 = 
h
.
m_dex
;

592 
addToItsLi
();

593 
checkVidy
();

594  *
	gthis
;

597 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

598 
le
 
	gDequeItBa
<
	gT
, 
	gleCacy
>::~
	$DequeItBa
()

600 #ide
NDEBUG


601 
	`moveFromItsLi
();

602 
m_deque
 = 0;

604 
	}
}

606 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

607 
le
 
bo
 
	gDequeItBa
<
	gT
, 
	gleCacy
>::
	$isEqu
(cڡ 
DequeItBa
& 
h
) const

609 
	`checkVidy
(
h
);

610  
m_dex
 =
h
.m_index;

611 
	}
}

613 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

614 
le
 
	gDequeItBa
<
	gT
, 
	gleCacy
>::
	$emt
()

616 
	`checkVidy
();

617 
	`ASSERT
(
m_dex
 !
m_deque
->
m_d
);

618 
	`ASSERT
(
m_deque
->
m_bufr
.
	`cy
());

619 i(
m_dex
 =
m_deque
->
m_bufr
.
	`cy
() - 1)

620 
m_dex
 = 0;

622 ++
m_dex
;

623 
	`checkVidy
();

624 
	}
}

626 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

627 
le
 
	gDequeItBa
<
	gT
, 
	gleCacy
>::
	$deemt
()

629 
	`checkVidy
();

630 
	`ASSERT
(
m_dex
 !
m_deque
->
m_t
);

631 
	`ASSERT
(
m_deque
->
m_bufr
.
	`cy
());

632 i(!
m_dex
)

633 
m_dex
 = 
m_deque
->
m_bufr
.
	`cy
() - 1;

635 --
m_dex
;

636 
	`checkVidy
();

637 
	}
}

639 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

640 
le
 
T
* 
	gDequeItBa
<
	gT
, 
	gleCacy
>::
	$a
() const

642 
	`checkVidy
();

643 
	`ASSERT
(
m_dex
 !
m_deque
->
m_d
);

644  &
m_deque
->
m_bufr
.
	`bufr
()[
m_dex
];

645 
	}
}

647 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

648 
le
 
T
* 
	gDequeItBa
<
	gT
, 
	gleCacy
>::
	$befe
() const

650 
	`checkVidy
();

651 
	`ASSERT
(
m_dex
 !
m_deque
->
m_t
);

652 i(!
m_dex
)

653  &
m_deque
->
m_bufr
.
	`bufr
()[m_deque->m_bufr.
	`cy
() - 1];

654  &
m_deque
->
m_bufr
.
	`bufr
()[
m_dex
 - 1];

655 
	}
}

659 
usg
 
	gWTF
::
Deque
;

	@DisallowCType.h

29 #ide
WTF_DiowCTy_h


30 
	#WTF_DiowCTy_h


	)

43 #i!(
OS
(
DARWIN
&& 
PLATFORM
(
GTK
)&& !PLATFORM(
EFL
&& !
defed
(
_LIBCPP_VERSION
)

45 
	~<y.h
>

47 #unde
ium


48 #unde
iha


49 #unde
iscii


50 #unde
isbnk


51 #unde
isl


52 #unde
isdig


53 #unde
isgph


54 #unde
iow


55 #unde
irt


56 #unde
iun


57 #unde
isa


58 #unde
isu


59 #unde
isxdig


60 #unde
tscii


61 #unde
tow


62 #unde
tou


64 
	#ium
 
ium_WTF_Pa_u_ASCIICTy_d_of_y_e_commt__ASCIICTy_h


	)

65 
	#iha
 
iha_WTF_Pa_u_ASCIICTy_d_of_y_e_commt__ASCIICTy_h


	)

66 
	#iscii
 
iscii_WTF_Pa_u_ASCIICTy_d_of_y_e_commt__ASCIICTy_h


	)

67 
	#isbnk
 
isbnk_WTF_Pa_u_ASCIICTy_d_of_y_e_commt__ASCIICTy_h


	)

68 
	#isl
 
isl_WTF_Pa_u_ASCIICTy_d_of_y_e_commt__ASCIICTy_h


	)

69 
	#isdig
 
isdig_WTF_Pa_u_ASCIICTy_d_of_y_e_commt__ASCIICTy_h


	)

70 
	#isgph
 
isgph_WTF_Pa_u_ASCIICTy_d_of_y_e_commt__ASCIICTy_h


	)

71 
	#iow
 
iow_WTF_Pa_u_ASCIICTy_d_of_y_e_commt__ASCIICTy_h


	)

72 
	#irt
 
irt_WTF_Pa_u_ASCIICTy_d_of_y_e_commt__ASCIICTy_h


	)

73 
	#iun
 
iun_WTF_Pa_u_ASCIICTy_d_of_y_e_commt__ASCIICTy_h


	)

74 
	#isa
 
isa_WTF_Pa_u_ASCIICTy_d_of_y_e_commt__ASCIICTy_h


	)

75 
	#isu
 
isu_WTF_Pa_u_ASCIICTy_d_of_y_e_commt__ASCIICTy_h


	)

76 
	#isxdig
 
isxdig_WTF_Pa_u_ASCIICTy_d_of_y_e_commt__ASCIICTy_h


	)

77 
	#tscii
 
tscii_WTF_Pa_u_ASCIICTy_d_of_y_e_commt__ASCIICTy_h


	)

78 
	#tow
 
tow_WTF_Pa_u_ASCIICTy_d_of_y_e_commt__ASCIICTy_h


	)

79 
	#tou
 
tou_WTF_Pa_u_ASCIICTy_d_of_y_e_commt__ASCIICTy_h


	)

	@DoublyLinkedList.h

26 #ide
DoublyLkedLi_h


27 
	#DoublyLkedLi_h


	)

29 
mea
 
	gWTF
 {

32 
	gme
<
tyme
 
	gT
> cs
	cDoublyLkedLiNode
 {

33 
	gpublic
:

34 
DoublyLkedLiNode
();

36 
tPv
(
T
*);

37 
tNext
(
T
*);

39 
T
* 
ev
() const;

40 
T
* 
xt
() const;

43 
	gme
<
tyme
 
	gT
> 
le
 
	gDoublyLkedLiNode
<T>::
	$DoublyLkedLiNode
()

45 
	`tPv
(0);

46 
	`tNext
(0);

47 
	}
}

49 
	gme
<
tyme
 
	gT
> 
le
 
	gDoublyLkedLiNode
<T>::
	$tPv
(
T
* 
ev
)

51 
ic_
<
T
*>(
this
)->
m_ev
 = 
ev
;

52 
	}
}

54 
	gme
<
tyme
 
	gT
> 
le
 
	gDoublyLkedLiNode
<T>::
	$tNext
(
T
* 
xt
)

56 
ic_
<
T
*>(
this
)->
m_xt
 = 
xt
;

57 
	}
}

59 
	gme
<
tyme
 
	gT
> 
le
 
T
* 
	gDoublyLkedLiNode
<T>::
	$ev
() const

61  
ic_
<cڡ 
T
*>(
this
)->
m_ev
;

62 
	}
}

64 
	gme
<
tyme
 
	gT
> 
le
 
T
* 
	gDoublyLkedLiNode
<T>::
	$xt
() const

66  
ic_
<cڡ 
T
*>(
this
)->
m_xt
;

67 
	}
}

69 
	gme
<
tyme
 
	gT
> cs
	cDoublyLkedLi
 {

70 
	gpublic
:

71 
DoublyLkedLi
();

73 
bo
 
isEmy
() const;

74 
size_t
 
size
() const;

75 
r
();

77 
T
* 
hd
() const;

78 
T
* 
moveHd
();

80 
T
* 

() const;

82 
push
(
T
*);

83 
nd
(
T
*);

84 
move
(
T
*);

85 
nd
(
DoublyLkedLi
<
T
>&);

87 
	give
:

88 
T
* 
m_hd
;

89 
T
* 
	gm_
;

92 
	gme
<
tyme
 
	gT
> 
le
 
	gDoublyLkedLi
<T>::
	$DoublyLkedLi
()

93 : 
	`m_hd
(0)

94 , 
	$m_
(0)

96 
	}
}

98 
	gme
<
tyme
 
	gT
> 
le
 
bo
 
	gDoublyLkedLi
<T>::
	$isEmy
() const

100  !
m_hd
;

101 
	}
}

103 
	gme
<
tyme
 
	gT
> 
le
 
size_t
 
	gDoublyLkedLi
<T>::
	$size
() const

105 
size_t
 
size
 = 0;

106 
T
* 
node
 = 
m_hd
;ode;odnode->
	`xt
())

107 ++
size
;

108  
size
;

109 
	}
}

111 
	gme
<
tyme
 
	gT
> 
le
 
	gDoublyLkedLi
<T>::
	$r
()

113 
m_hd
 = 0;

114 
m_
 = 0;

115 
	}
}

117 
	gme
<
tyme
 
	gT
> 
le
 
T
* 
	gDoublyLkedLi
<T>::
	$hd
() const

119  
m_hd
;

120 
	}
}

122 
	gme
<
tyme
 
	gT
> 
le
 
T
* 
	gDoublyLkedLi
<T>::
	$
() const

124  
m_
;

125 
	}
}

127 
	gme
<
tyme
 
	gT
> 
le
 
	gDoublyLkedLi
<T>::
	$push
(
T
* 
node
)

129 i(!
m_hd
) {

130 
	`ASSERT
(!
m_
);

131 
m_hd
 = 
node
;

132 
m_
 = 
node
;

133 
node
->
	`tPv
(0);

134 
node
->
	`tNext
(0);

138 
	`ASSERT
(
m_
);

139 
m_hd
->
	`tPv
(
node
);

140 
node
->
	`tNext
(
m_hd
);

141 
node
->
	`tPv
(0);

142 
m_hd
 = 
node
;

143 
	}
}

145 
	gme
<
tyme
 
	gT
> 
le
 
	gDoublyLkedLi
<T>::
	$nd
(
T
* 
node
)

147 i(!
m_
) {

148 
	`ASSERT
(!
m_hd
);

149 
m_hd
 = 
node
;

150 
m_
 = 
node
;

151 
node
->
	`tPv
(0);

152 
node
->
	`tNext
(0);

156 
	`ASSERT
(
m_hd
);

157 
m_
->
	`tNext
(
node
);

158 
node
->
	`tPv
(
m_
);

159 
node
->
	`tNext
(0);

160 
m_
 = 
node
;

161 
	}
}

163 
	gme
<
tyme
 
	gT
> 
le
 
	gDoublyLkedLi
<T>::
	$move
(
T
* 
node
)

165 i(
node
->
	`ev
()) {

166 
	`ASSERT
(
node
 !
m_hd
);

167 
node
->
	`ev
()->
	`tNext
ode->
	`xt
());

169 
	`ASSERT
(
node
 =
m_hd
);

170 
m_hd
 = 
node
->
	`xt
();

173 i(
node
->
	`xt
()) {

174 
	`ASSERT
(
node
 !
m_
);

175 
node
->
	`xt
()->
	`tPv
ode->
	`ev
());

177 
	`ASSERT
(
node
 =
m_
);

178 
m_
 = 
node
->
	`ev
();

180 
	}
}

182 
	gme
<
tyme
 
	gT
> 
le
 
T
* 
	gDoublyLkedLi
<T>::
	$moveHd
()

184 
T
* 
node
 = 
	`hd
();

185 i(
node
)

186 
	`move
(
node
);

187  
node
;

188 
	}
}

190 
	gme
<
tyme
 
	gT
> 
le
 
	gDoublyLkedLi
<T>::
nd
(
DoublyLkedLi
<
T
>& 
h
)

192 i(!
h
.
hd
())

195 i(!
hd
()) {

196 
	gm_hd
 = 
h
.
hd
();

197 
	gm_
 = 
h
.

();

198 
	gh
.
r
();

202 
ASSERT
(

());

203 
ASSERT
(
h
.
hd
());

204 
T
* 
	ghHd
 = 
h
.
hd
();

205 
T
* 
	ghTa
 = 
h
.

();

206 
	gh
.
r
();

208 
ASSERT
(!
m_
->
xt
());

209 
	gm_
->
tNext
(
hHd
);

210 
ASSERT
(!
hHd
->
ev
());

211 
	ghHd
->
tPv
(
m_
);

212 
	gm_
 = 
hTa
;

217 
usg
 
	gWTF
::
DoublyLkedLiNode
;

218 
usg
 
	gWTF
::
DoublyLkedLi
;

	@ExportMacros.h

30 #ide
ExptMaos_h


31 
	#ExptMaos_h


	)

39 #i
OS
(
WINDOWS
)

40 
	#HAVE_INTERNAL_VISIBILITY
 1

	)

41 
	#WTF_INTERNAL


	)

42 #i
defed
(
__GNUC__
&& !defed(
__CC_ARM
&& !defed(
__ARMCC__
)

43 
	#HAVE_INTERNAL_VISIBILITY
 1

	)

44 
	#WTF_INTERNAL
 
	`__ibu__
((
	`visiby
("hidd")))

	)

46 
	#WTF_INTERNAL


	)

49 #i
OS
(
WINDOWS
)

51 
	#WTF_EXPORT_DECLARATION
 
	`__deec
(
dexpt
)

	)

52 
	#WTF_IMPORT_DECLARATION
 
	`__deec
(
dimpt
)

	)

53 
	#WTF_HIDDEN_DECLARATION


	)

55 #i
defed
(
__GNUC__
&& !defed(
__CC_ARM
&& !defed(
__ARMCC__
)

57 
	#WTF_EXPORT_DECLARATION
 
	`__ibu__
((
	`visiby
("deu")))

	)

58 
	#WTF_IMPORT_DECLARATION
 
WTF_EXPORT_DECLARATION


	)

59 
	#WTF_HIDDEN_DECLARATION
 
	`__ibu__
((
	`visiby
("hidd")))

	)

63 
	#WTF_EXPORT_DECLARATION


	)

64 
	#WTF_IMPORT_DECLARATION


	)

65 
	#WTF_HIDDEN_DECLARATION


	)

69 #i
defed
(
BUILDING_WTF
|| defed(
STATICALLY_LINKED_WITH_WTF
)

70 
	#WTF_IS_LINKED_IN_SAME_BINARY
 1

	)

74 #i
USE
(
EXPORT_MACROS
)

76 
	#WTF_EXPORT
 
WTF_EXPORT_DECLARATION


	)

77 
	#WTF_IMPORT
 
WTF_IMPORT_DECLARATION


	)

78 
	#WTF_HIDDEN
 
WTF_IMPORT_DECLARATION


	)

82 #i
defed
(
WTF_IS_LINKED_IN_SAME_BINARY
)

83 
	#WTF_EXPORTDATA
 
WTF_EXPORT


	)

85 
	#WTF_EXPORTDATA
 
WTF_IMPORT


	)

90 #i
OS
(
WINDOWS
&& !
COMPILER
(
GCC
)

91 #i
defed
(
BUILDING_WTF
|| defed(
STATICALLY_LINKED_WITH_WTF
)

92 
	#WTF_EXPORTDATA
 
	`__deec
(
dexpt
)

	)

94 
	#WTF_EXPORTDATA
 
	`__deec
(
dimpt
)

	)

97 
	#WTF_EXPORTDATA


	)

100 
	#WTF_EXPORTCLASS
 
WTF_EXPORTDATA


	)

102 
	#WTF_EXPORT


	)

103 
	#WTF_IMPORT


	)

104 
	#WTF_HIDDEN


	)

108 #i
defed
(
WTF_IS_LINKED_IN_SAME_BINARY
)

109 
	#WTF_EXPORT_PRIVATE
 
WTF_EXPORT


	)

111 
	#WTF_EXPORT_PRIVATE
 
WTF_IMPORT


	)

114 
	#WTF_EXPORT_STRING_API
 
WTF_EXPORT_PRIVATE


	)

116 
	#WTF_EXPORT_HIDDEN
 
WTF_HIDDEN


	)

118 
	#HIDDEN_INLINE
 
WTF_EXPORT_HIDDEN
 
le


	)

	@FastBitVector.cpp

26 
	~"cfig.h
"

27 
	~"FaBVe.h
"

29 
	~"PrtSm.h
"

31 
mea
 
	gWTF
 {

33 
	gFaBVe
::
dump
(
PrtSm
& 
out
) const

35 
i
 = 0; 
	gi
 < 
	gm_numBs
; ++i)

36 
	gout
.
t
(
g
(
i
) ? "1" : "-");

	@FastBitVector.h

26 #ide
FaBVe_h


27 
	#FaBVe_h


	)

29 
	~<rg.h
>

30 
	~<wtf/FaMloc.h
>

31 
	~<wtf/StdLibExas.h
>

33 
mea
 
	gWTF
 {

35 
ass
 
	gPrtSm
;

37 as
	cFaBVe
 {

38 
	gpublic
:

39 
FaBVe
()

40 : 
m_y
(0)

41 , 
m_numBs
(0)

45 
FaBVe
(cڡ FaBVe& 
h
)

46 : 
m_y
(0)

47 , 
m_numBs
(0)

49 *
	gthis
 = 
h
;

52 ~
FaBVe
()

54 i(
	gm_y
)

55 
Fe
(
m_y
);

58 
	gFaBVe
& 
	gݔ
=(cڡ 
FaBVe
& 
h
)

60 
size_t
 
ngth
 = 
h
.
yLgth
();

61 
ut32_t
* 
	gwAay
 = 
ic_
<ut32_t*>(
Cloc
(
ngth
, 4));

62 
memy
(
wAay
, 
h
.
m_y
, 
ngth
 * 4);

63 i(
	gm_y
)

64 
Fe
(
m_y
);

65 
	gm_y
 = 
wAay
;

66 
	gm_numBs
 = 
h
.
m_numBs
;

67  *
	gthis
;

70 
size_t
 
numBs
(cڡ {  
	gm_numBs
; }

72 
size
(
size_t
 
numBs
)

77 
size_t
 
	gwLgth
 = 
yLgth
(
numBs
);

78 
ut32_t
* 
	gwAay
 = 
ic_
<ut32_t*>(
Cloc
(
wLgth
, 4));

79 
memy
(
wAay
, 
m_y
, 
yLgth
() * 4);

80 i(
	gm_y
)

81 
Fe
(
m_y
);

82 
	gm_y
 = 
wAay
;

83 
	gm_numBs
 = 
numBs
;

86 
tA
()

88 
memt
(
m_y
, 255, 
yLgth
() * 4);

91 
rA
()

93 
memt
(
m_y
, 0, 
yLgth
() * 4);

96 
t
(cڡ 
FaBVe
& 
h
)

98 
ASSERT
(
m_numBs
 =
h
.m_numBits);

99 
memy
(
m_y
, 
h
.m_y, 
yLgth
() * 4);

102 
bo
 
tAndCheck
(cڡ 
FaBVe
& 
h
)

104 
bo
 
	gchged
 = 
l
;

105 
ASSERT
(
m_numBs
 =
h
.m_numBits);

106 
	gi
 = 
yLgth
(); i--;) {

107 
	gchged
 |
m_y
[
i
] !
h
.m_array[i];

108 
	gm_y
[
i
] = 
h
.
m_y
[i];

110  
	gchged
;

113 
bo
 
equs
(cڡ 
FaBVe
& 
h
) const

115 
ASSERT
(
m_numBs
 =
h
.m_numBits);

118 
	gi
 = 
yLgth
(); i--;) {

119 i(
	gm_y
[
i
] !
h
.
m_y
[i])

120  
l
;

122  
	gue
;

125 
mge
(cڡ 
FaBVe
& 
h
)

127 
ASSERT
(
m_numBs
 =
h
.m_numBits);

128 
	gi
 = 
yLgth
(); i--;)

129 
	gm_y
[
i
] |
h
.
m_y
[i];

132 
fr
(cڡ 
FaBVe
& 
h
)

134 
ASSERT
(
m_numBs
 =
h
.m_numBits);

135 
	gi
 = 
yLgth
(); i--;)

136 
	gm_y
[
i
] &
h
.
m_y
[i];

139 
exude
(cڡ 
FaBVe
& 
h
)

141 
ASSERT
(
m_numBs
 =
h
.m_numBits);

142 
	gi
 = 
yLgth
(); i--;)

143 
	gm_y
[
i
] &~
h
.
m_y
[i];

146 
t
(
size_t
 
i
)

148 
ASSERT_WITH_SECURITY_IMPLICATION
(
i
 < 
m_numBs
);

149 
	gm_y
[
i
 >> 5] |= (1 << (i & 31));

152 
r
(
size_t
 
i
)

154 
ASSERT_WITH_SECURITY_IMPLICATION
(
i
 < 
m_numBs
);

155 
	gm_y
[
i
 >> 5] &= ~(1 << (i & 31));

158 
t
(
size_t
 
i
, 
bo
 
vue
)

160 i(
	gvue
)

161 
t
(
i
);

163 
r
(
i
);

166 
bo
 
g
(
size_t
 
i
) const

168 
ASSERT_WITH_SECURITY_IMPLICATION
(
i
 < 
m_numBs
);

169  !!(
	gm_y
[
i
 >> 5] & (1 << (
	gi
 & 31)));

172 
size_t
 
bCou
() const

174 
size_t
 
	gsu
 = 0;

175 
	gi
 = 
yLgth
(); i--;)

176 
	gsu
 +
WTF
::
bCou
(
m_y
[
i
]);

177  
	gsu
;

180 
WTF_EXPORT_PRIVATE
 
dump
(
PrtSm
&) const;

182 
	give
:

183 
size_t
 
yLgth
(size_
numBs
) {  (numBits + 31) >> 5; }

184 
size_t
 
yLgth
(cڡ { ayLgth(
m_numBs
); }

186 
ut32_t
* 
	gm_y
;

187 
size_t
 
	gm_numBs
;

192 
usg
 
	gWTF
::
FaBVe
;

	@FastMalloc.cpp

77 
	~"cfig.h
"

78 
	~"FaMloc.h
"

80 
	~"Asis.h
"

81 
	~"CutTime.h
"

83 
	~<lims
>

84 #i
OS
(
WINDOWS
)

85 
	~<wdows.h
>

87 
	~<had.h
>

89 
	~<rg.h
>

90 
	~<wtf/DaLog.h
>

91 
	~<wtf/StdLibExas.h
>

93 #i
OS
(
DARWIN
)

94 
	~<mach/mach_.h
>

95 
	~<mloc/mloc.h
>

98 #ide
NO_TCMALLOC_SAMPLES


99 #ifde
WTF_CHANGES


100 
	#NO_TCMALLOC_SAMPLES


	)

104 #i(
PLATFORM
(
COCOA
&& (
CPU
(
X86_64
|| CPU(
ARM64
)))

105 
	#USE_BMALLOC
 1

	)

108 #i!(
defed
(
USE_SYSTEM_MALLOC
&& USE_SYSTEM_MALLOC&& defed(
NDEBUG
)

109 
	#FORCE_SYSTEM_MALLOC
 0

	)

111 
	#FORCE_SYSTEM_MALLOC
 1

	)

115 
	#ENABLE_TCMALLOC_HARDENING
 1

	)

118 
	#USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY
 1

	)

120 #ide
NDEBUG


121 
mea
 
	gWTF
 {

123 #i
OS
(
WINDOWS
)

125 
DWORD
 
	gisFibiddTlsIndex
 = 
TLS_OUT_OF_INDEXES
;

126 cڡ 
LPVOID
 
	gkTlsAowVue
 = 
t_
<LPVOID>(0);

127 cڡ 
LPVOID
 
	gkTlsFbiddVue
 = 
t_
<LPVOID>(1);

129 #i!
ASSERT_DISABLED


130 
bo
 
isFbidd
()

135  (
	gisFibiddTlsIndex
 !
TLS_OUT_OF_INDEXES
&& (
TlsGVue
(
isFibiddTlsIndex
=
kTlsFbiddVue
);

139 
MlocFbid
()

141 i(
	gisFibiddTlsIndex
 =
TLS_OUT_OF_INDEXES
)

142 
isFibiddTlsIndex
 = 
TlsAoc
();

143 
TlsSVue
(
isFibiddTlsIndex
, 
kTlsFbiddVue
);

146 
MlocAow
()

148 i(
	gisFibiddTlsIndex
 =
TLS_OUT_OF_INDEXES
)

150 
TlsSVue
(
isFibiddTlsIndex
, 
kTlsAowVue
);

155 
had_key_t
 
	gisFbiddKey
;

156 
had__t
 
	gisFbiddKeyOn
 = 
PTHREAD_ONCE_INIT
;

157 
lizeIsFbiddKey
()

159 
had_key_
(&
isFbiddKey
, 0);

162 #i!
ASSERT_DISABLED


163 
bo
 
isFbidd
()

165 
had_
(&
isFbiddKeyOn
, 
lizeIsFbiddKey
);

166  !!
had_gecific
(
isFbiddKey
);

170 
MlocFbid
()

172 
had_
(&
isFbiddKeyOn
, 
lizeIsFbiddKey
);

173 
had_tecific
(
isFbiddKey
, &isForbiddenKey);

176 
MlocAow
()

178 
had_
(&
isFbiddKeyOn
, 
lizeIsFbiddKey
);

179 
had_tecific
(
isFbiddKey
, 0);

186 
mea
 
	gWTF
 {

189 
mea
 
	gIl
 {

190 #i!
ENABLE
(
WTF_MALLOC_VALIDATION
)

191 
WTF_EXPORT_PRIVATE
 
NO_RETURN_DUE_TO_CRASH
 
MlocMchFaed
(*);

193 
COMPILE_ASSERT
((((
VidiHd
% (
AocAlignmtIeg
)=0), 
VidiHd_mu_odu_cܻ_ignmt
);

196 
NO_RETURN_DUE_TO_CRASH
 
MlocMchFaed
(*)

198 
CRASH
();

204 * 
ZdMloc
(
size_t
 
n
)

206 * 
	gsu
 = 
Mloc
(
n
);

207 
memt
(
su
, 0, 
n
);

208  
	gsu
;

211 * 
SDup
(cڡ * 
c
)

213 
size_t
 
	gn
 = 

(
c
) + 1;

214 * 
	gdup
 = 
ic_
<*>(
Mloc
(
n
));

215 
memy
(
dup
, 
c
, 
n
);

216  
	gdup
;

219 
TryMlocRuVue
 
yFaZdMloc
(
size_t
 
n
)

221 * 
	gsu
;

222 i(!
yFaMloc
(
n
).
gVue
(
su
))

224 
memt
(
su
, 0, 
n
);

225  
	gsu
;

230 #i
FORCE_SYSTEM_MALLOC


232 #i
OS
(
WINDOWS
)

233 
	~<mloc.h
>

236 
mea
 
	gWTF
 {

238 
size_t
 
MlocGoodSize
(size_
bys
)

240 #i
OS
(
DARWIN
)

241  
mloc_good_size
(
bys
);

243  
	gbys
;

247 
TryMlocRuVue
 
yFaMloc
(
size_t
 
n
)

249 
ASSERT
(!
isFbidd
());

251 #i
ENABLE
(
WTF_MALLOC_VALIDATION
)

252 i(
	gd
::
numic_lims
<
size_t
>::
max
(- 
Il
::
VidiBufrSize
 <
n
)

255 * 
	gsu
 = 
mloc
(
n
 + 
Il
::
VidiBufrSize
);

256 i(!
	gsu
)

258 
	gIl
::
VidiHd
* 
hd
 = 
ic_
<
Il
::VidiHd*>(
su
);

259 
	ghd
->
	gm_size
 = 
n
;

260 
	ghd
->
	gm_ty
 = 
Il
::
AocTyMloc
;

261 
	ghd
->
	gm_efix
 = 
ic_
<>(
Il
::
VidiPfix
);

262 
	gsu
 = 
hd
 + 1;

263 *
	gIl
::
MlocVidiSuffix
(
su

Il
::
VidiSuffix
;

264 
MlocVide
(
su
);

265  
	gsu
;

267  
mloc
(
n
);

271 * 
Mloc
(
size_t
 
n
)

273 
ASSERT
(!
isFbidd
());

275 #i
ENABLE
(
WTF_MALLOC_VALIDATION
)

276 
TryMlocRuVue
 
	gtuVue
 = 
yFaMloc
(
n
);

277 * 
	gsu
;

278 i(!
	gtuVue
.
gVue
(
su
))

279 
CRASH
();

281 * 
	gsu
 = 
mloc
(
n
);

284 i(!
	gsu
)

285 
CRASH
();

287  
	gsu
;

290 
TryMlocRuVue
 
yFaCloc
(
size_t
 
n_emts
, size_
emt_size
)

292 
ASSERT
(!
isFbidd
());

294 #i
ENABLE
(
WTF_MALLOC_VALIDATION
)

295 
size_t
 
	gtٮBys
 = 
n_emts
 * 
emt_size
;

296 i(
	gn_emts
 > 1 && 
	gemt_size
 && (
	gtٮBys
 /mt_size!
n_emts
)

299 
TryMlocRuVue
 
	gtuVue
 = 
yFaMloc
(
tٮBys
);

300 * 
	gsu
;

301 i(!
	gtuVue
.
gVue
(
su
))

303 
memt
(
su
, 0, 
tٮBys
);

304 
MlocVide
(
su
);

305  
	gsu
;

307  
oc
(
n_emts
, 
emt_size
);

311 * 
Cloc
(
size_t
 
n_emts
, size_
emt_size
)

313 
ASSERT
(!
isFbidd
());

315 #i
ENABLE
(
WTF_MALLOC_VALIDATION
)

316 
TryMlocRuVue
 
	gtuVue
 = 
yFaCloc
(
n_emts
, 
emt_size
);

317 * 
	gsu
;

318 i(!
	gtuVue
.
gVue
(
su
))

319 
CRASH
();

321 * 
	gsu
 = 
oc
(
n_emts
, 
emt_size
);

324 i(!
	gsu
)

325 
CRASH
();

327  
	gsu
;

330 
Fe
(* 
p
)

332 
ASSERT
(!
isFbidd
());

334 #i
ENABLE
(
WTF_MALLOC_VALIDATION
)

335 i(!
	gp
)

338 
MlocMchVideFe
(
p
, 
Il
::
AocTyMloc
);

339 
	gIl
::
VidiHd
* 
hd
 = 
Il
::
MlocVidiHd
(
p
);

340 
memt
(
p
, 0xCC, 
hd
->
m_size
);

341 

(
hd
);

343 

(
p
);

347 
TryMlocRuVue
 
yFaRoc
(* 
p
, 
size_t
 
n
)

349 
ASSERT
(!
isFbidd
());

351 #i
ENABLE
(
WTF_MALLOC_VALIDATION
)

352 i(
	gp
) {

353 i(
	gd
::
numic_lims
<
size_t
>::
max
(- 
Il
::
VidiBufrSize
 <
n
)

355 
MlocVide
(
p
);

356 
	gIl
::
VidiHd
* 
su
 = 
ic_
<
Il
::VidiHd*>(
loc
(Il::
MlocVidiHd
(
p
), 
n
 + Il::
VidiBufrSize
));

357 i(!
	gsu
)

359 
	gsu
->
	gm_size
 = 
n
;

360 
	gsu
 = 
su
 + 1;

361 *
MlocVidiSuffix
(
su

Il
::
VidiSuffix
;

362 
MlocVide
(
su
);

363  
	gsu
;

365  
Mloc
(
n
);

368  
loc
(
p
, 
n
);

372 * 
Roc
(* 
p
, 
size_t
 
n
)

374 
ASSERT
(!
isFbidd
());

376 #i
ENABLE
(
WTF_MALLOC_VALIDATION
)

377 
TryMlocRuVue
 
	gtuVue
 = 
yFaRoc
(
p
, 
n
);

378 * 
	gsu
;

379 i(!
	gtuVue
.
gVue
(
su
))

380 
CRASH
();

382 * 
	gsu
 = 
loc
(
p
, 
n
);

385 i(!
	gsu
)

386 
CRASH
();

387  
	gsu
;

390 
aFaMlocFeMemy
() { }

392 
FaMlocStiics
 
MlocStiics
()

394 
FaMlocStiics
 
	giics
 = { 0, 0, 0 };

395  
	giics
;

398 
size_t
 
MlocSize
(cڡ * 
p
)

400 #i
ENABLE
(
WTF_MALLOC_VALIDATION
)

401  
	gIl
::
MlocVidiHd
(
cڡ_
<*>(
p
))->
m_size
;

402 #i
OS
(
DARWIN
)

403  
mloc_size
(
p
);

404 #i
OS
(
WINDOWS
)

405  
_msize
(
cڡ_
<*>(
p
));

407 
UNUSED_PARAM
(
p
);

414 #i
OS
(
DARWIN
)

417 "C" 
WTF_EXPORT_PRIVATE
 cڡ 
jsce_mloc_oei
 = 0;

420 #i
defed
(
USE_BMALLOC
) && USE_BMALLOC

422 
	~<bmloc/bmloc.h
>

424 
mea
 
	gWTF
 {

426 * 
Mloc
(
size_t
 
size
)

428 
ASSERT
(!
isFbidd
());

429  
	gbmloc
::
i
::
mloc
(
size
);

432 * 
Cloc
(
size_t
 
numEmts
, size_
emtSize
)

434  
ZdMloc
(
numEmts
 * 
emtSize
);

437 * 
Roc
(* 
obje
, 
size_t
 
size
)

439  
	gbmloc
::
i
::
loc
(
obje
, 
size
);

442 
Fe
(* 
obje
)

444 
	gbmloc
::
i
::

(
obje
);

447 
size_t
 
MlocSize
(const *)

452 
size_t
 
MlocGoodSize
(size_
size
)

454  
	gsize
;

457 
TryMlocRuVue
 
yFaMloc
(
size_t
 
size
)

459  
Mloc
(
size
);

462 
TryMlocRuVue
 
yFaRoc
(* 
p
, 
size_t
 
n
)

464  
Roc
(
p
, 
n
);

467 
TryMlocRuVue
 
yFaCloc
(
size_t
 
numEmts
, size_
emtSize
)

469  
Cloc
(
numEmts
, 
emtSize
);

472 
aFaMlocFeMemy
()

474 
	gbmloc
::
i
::
svge
();

477 
FaMlocStiics
 
MlocStiics
()

479 
FaMlocStiics
 
	giics
 = { 0, 0, 0 };

480  
	giics
;

487 
	~"TCPackedCache.h
"

488 
	~"TCPageM.h
"

489 
	~"TCSpLock.h
"

490 
	~"TCSyemAoc.h
"

491 
	~"ThadScific.h
"

492 
	~<gܙhm
>

493 #i
USE
(
PTHREADS
)

494 
	~<had.h
>

496 
	~<dg.h
>

497 
	~<ddef.h
>

498 
	~<dt.h
>

499 
	~<dio.h
>

500 #i
HAVE
(
ERRNO_H
)

501 
	~<o.h
>

503 #i
OS
(
UNIX
)

504 
	~<unid.h
>

506 #i
OS
(
WINDOWS
)

507 #ide
WIN32_LEAN_AND_MEAN


508 
	#WIN32_LEAN_AND_MEAN


	)

510 
	~<wdows.h
>

513 #ifde
WTF_CHANGES


515 #i
OS
(
DARWIN
)

516 
	~<wtf/HashS.h
>

517 
	~<wtf/Ve.h
>

520 #i
HAVE
(
DISPATCH_H
)

521 
	~<dich/dich.h
>

524 #i
OS
(
DARWIN
)

525 #i
defed
(
__has_ude
&& __has_ude(<
Syem
/
had_machd
.
h
>)

526 
	~<Syem/had_machd.h
>

530 #i
defed
(
__PTK_FRAMEWORK_JAVASCRIPTCORE_KEY0
)

531 
	#WTF_USE_PTHREAD_GETSPECIFIC_DIRECT
 1

	)

534 #ide
PRIuS


535 
	#PRIuS
 "zu"

	)

542 #i
OS
(
DARWIN
)

543 #i!
USE
(
PTHREAD_GETSPECIFIC_DIRECT
)

544 * (*
	ghad_gecific_funi_por
)(
	ghad_key_t

had_gecific
;

545 
	#had_gecific
(
key

	`had_gecific_funi_por
(key)

	)

547 
	#had_gecific
(
key

	`_had_gecific_de
(key)

	)

548 
	#had_tecific
(
key
, 
v

	`_had_tecific_de
(key, (v))

	)

552 
	#DEFINE_VARIABLE
(
ty
, 
me
, 
vue
, 
mng
) \

553 
mea
 
FLAG__mea_do_n_u_dely_u_DECLARE_
##
ty
##
_d
 { \

554 
ty
 
FLAGS_
##
	`me
(
vue
); \

555 
FLAGS_no
##
me
; \

557 
usg
 
FLAG__mea_do_n_u_dely_u_DECLARE_
##
ty
##
_d
::
FLAGS_
##
me


	)

559 
	#DEFINE_t64
(
me
, 
vue
, 
mng
) \

560 
	`DEFINE_VARIABLE
(
t64_t
, 
me
, 
vue
, 
mng
)

	)

562 
	#DEFINE_doub
(
me
, 
vue
, 
mng
) \

563 
	`DEFINE_VARIABLE
(, 
me
, 
vue
, 
mng
)

	)

565 
mea
 
	gWTF
 {

567 
	#mloc
 
Mloc


	)

568 
	#oc
 
Cloc


	)

569 
	#
 
Fe


	)

570 
	#loc
 
Roc


	)

572 
	#MESSAGE
 
LOG_ERROR


	)

573 
	#CHECK_CONDITION
 
ASSERT


	)

575 #i!
OS
(
DARWIN
)

576 cڡ 
	gkLLHdgMask
 = 0;

579 
	gme
 <> 
	gErySour
;

580 
	gme
 <> 
	gErySour
<4> {

581 
ut32_t
 
vue
()

583 #i
OS
(
DARWIN
)

584  
c4ndom
();

586  
	gic_
<
	gut32_t
>(ic_<
	gu_t
>(
cutTime
(* 10000^ 
	gt_
<u_t>(&
	gkLLHdgMask
));

591 
	gme
 <> 
	gErySour
<8> {

592 
ut64_t
 
vue
()

594  
	gErySour
<4>::
vue
(| (
ic_
<
ut64_t
>(
ErySour
<4>::value()) << 32);

598 #i
ENABLE
(
TCMALLOC_HARDENING
)

607 
	gMaskKeyShi
 = 13

610 
ALWAYS_INLINE
 
u_t
 
EryVue
()

612 
u_t
 
	gvue
 = 
ErySour
<(u_t)>::
vue
() | 1;

613 
ASSERT
(
vue
);

614  
	gvue
;

617 
	#HARDENING_ENTROPY
 
	`EryVue
()

	)

618 
	#ROTATE_VALUE
(
vue
, 
amou
(((vue>> (amou)| ((vue<< ((vue* 8 - (amou))))

	)

619 #i
COMPILER
(
MSVC
)

620 
	#XOR_MASK_PTR_WITH_KEY
(
r
, 
key
, 
y
(
t_
<
	`dety
Ռ)>et_<
u_t
>Ռ)^(
	`ROTATE_VALUE
et_<u_t>(key), 
MaskKeyShi
)^y)))

	)

622 
	#XOR_MASK_PTR_WITH_KEY
(
r
, 
key
, 
y
(
t_
<
	`__tyof__
Ռ)>et_<
u_t
>Ռ)^(
	`ROTATE_VALUE
et_<u_t>(key), 
MaskKeyShi
)^y)))

	)

625 
ALWAYS_INLINE
 
ut32_t
 
dObjeSPois
()

627 
ut32_t
 
	gvue
 = 
ErySour
<(ut32_t)>::
vue
() | 1;

628 
ASSERT
(
vue
);

629  
	gvue
;

632 
ALWAYS_INLINE
 
ut32_t
 
dObjeEndPois
()

634 
ut32_t
 
	gvue
 = 
ErySour
<(ut32_t)>::
vue
() | 1;

635 
ASSERT
(
vue
);

636  
	gvue
;

639 
	#PTR_TO_UINT32
(
r

ic_
<
ut32_t
>(
t_
<
u_t
>Ռ))

	)

640 
	#END_POISON_INDEX
(
lotiSize
((otiSize- (
ut32_t
)/ (ut32_t))

	)

641 
	#POISON_ALLOCATION
(
loti
, 
lotiSize
) do { \

642 
	`ASSERT
((
lotiSize
>2 * (
ut32_t
)); \

643 
t_
<
ut32_t
*>(
loti
)[0] = 0xbadbeef1; \

644 
t_
<
ut32_t
*>(
loti
)[1] = 0xbadbeef3; \

645 i((
lotiSize
< 4 * (
ut32_t
)) \

647 
t_
<
ut32_t
*>(
loti
)[2] = 0xbadbeef5; \

648 
t_
<
ut32_t
*>(
loti
)[
	`END_POISON_INDEX
(
lotiSize
)] = 0xbadbeef7; \

649 } 
l
);

	)

651 
	#POISON_DEALLOCATION_EXPLICIT
(
loti
, 
lotiSize
, 
tPois
, 
dPois
) do { \

652 
	`ASSERT
((
lotiSize
>2 * (
ut32_t
)); \

653 
t__r
<
ut32_t
*>(
loti
)[0] = 0xbadbeef9; \

654 
t__r
<
ut32_t
*>(
loti
)[1] = 0xbadbeefb; \

655 i((
lotiSize
< 4 * (
ut32_t
)) \

657 
t__r
<
ut32_t
*>(
loti
)[2] = (
tPois
^ 
	`PTR_TO_UINT32
(allocation); \

658 
t__r
<
ut32_t
*>(
loti
)[
	`END_POISON_INDEX
(
lotiSize
)] = (
dPois
^ 
	`PTR_TO_UINT32
(allocation); \

659 } 
l
)

	)

661 
	#POISON_DEALLOCATION
(
loti
, 
lotiSize
) \

662 
	`POISON_DEALLOCATION_EXPLICIT
(
loti
, (
lotiSize
), 
	`dObjeSPois
(), 
	`dObjeEndPois
())

	)

664 
	#MAY_BE_POISONED
(
loti
, 
lotiSize
((otiSize>4 * (
ut32_t
)) && ( \

665 (
t_
<
ut32_t
*>(
loti
)[2] =(
	`dObjeSPois
(^ 
	`PTR_TO_UINT32
(allocation))) || \

666 (
t_
<
ut32_t
*>(
loti
)[
	`END_POISON_INDEX
(
lotiSize
)] =(
	`dObjeEndPois
(^ 
	`PTR_TO_UINT32
(allocation))) \

667 ))

	)

669 
	#IS_DEFINITELY_POISONED
(
loti
, 
lotiSize
((otiSize< 4 * (
ut32_t
)) || ( \

670 (
t_
<
ut32_t
*>(
loti
)[2] =(
	`dObjeSPois
(^ 
	`PTR_TO_UINT32
(allocation))) && \

671 (
t_
<
ut32_t
*>(
loti
)[
	`END_POISON_INDEX
(
lotiSize
)] =(
	`dObjeEndPois
(^ 
	`PTR_TO_UINT32
(allocation))) \

672 ))

	)

676 
	#POISON_ALLOCATION
(
loti
, 
lotiSize
)

	)

677 
	#POISON_DEALLOCATION
(
loti
, 
lotiSize
)

	)

678 
	#POISON_DEALLOCATION_EXPLICIT
(
loti
, 
lotiSize
, 
tPois
, 
dPois
)

	)

679 
	#MAY_BE_POISONED
(
loti
, 
lotiSize
(
l
)

	)

680 
	#IS_DEFINITELY_POISONED
(
loti
, 
lotiSize
(
ue
)

	)

681 
	#XOR_MASK_PTR_WITH_KEY
(
r
, 
key
, 
y
(((ry), (()key),)

	)

683 
	#HARDENING_ENTROPY
 0

	)

692 
u_t
 
	tLgth
;

697 
	#K_PAGE_SHIFT_MIN
 12

	)

698 
	#K_PAGE_SHIFT_MAX
 14

	)

699 
	#K_NUM_CLASSES_MAX
 77

	)

700 
size_t
 
	gkPageShi
 = 0;

701 
size_t
 
	gkNumCss
 = 0;

702 
size_t
 
	gkPageSize
 = 0;

703 
Lgth
 
	gkMaxVidPages
 = 0;

704 cڡ 
size_t
 
	gkMaxSize
 = 32u * 1024;

705 cڡ 
size_t
 
	gkAlignShi
 = 3;

706 cڡ 
size_t
 
	gkAlignmt
 = 1 << 
kAlignShi
;

710 cڡ 
size_t
 
	gkPageMBigAotiThshd
 = 128 << 20;

718 cڡ 
size_t
 
	gkMSyemAoc
 = 1 << (20 - 
K_PAGE_SHIFT_MAX
);

725 
	gnum_objes_to_move
[
K_NUM_CLASSES_MAX
];

732 cڡ 
	gkMaxFeLiLgth
 = 256;

735 cڡ 
size_t
 
	gkMThadCacheSize
 = 
kMaxSize
 * 2;

736 cڡ 
size_t
 
	gkMaxThadCacheSize
 = 2 << 20;

739 cڡ 
size_t
 
	gkDeuOvlThadCacheSize
 = 16 << 20;

743 cڡ 
size_t
 
	gkMaxPages
 = 
kMSyemAoc
;

746 
	gimes_li
[] = {

759 #ifde
NO_TCMALLOC_SAMPLES


760 
DEFINE_t64
(
tcmloc_me_m
, 0,

762 
size_t
 
	gme_riod
 = 0;

764 
DEFINE_t64
(
tcmloc_me_m
, 262147,

768 
size_t
 
	gme_riod
 = 262147;

772 
SpLock
 
	gme_riod_lock
 = 
SPINLOCK_INITIALIZER
;

776 
DEFINE_doub
(
tcmloc_a_
, 1,

805 cڡ 
size_t
 
	gkMaxSmlSize
 = 1024;

806 cڡ 
	gshi_amou
[2] = { 3, 7 };

807 cڡ 
	gadd_amou
[2] = { 7, 127 + (120 << 7) };

808 
	gass_y
[377];

811 
le
 
CssIndex
(
size_t
 
s
) {

812 cڡ 
	gi
 = (
s
 > 
kMaxSmlSize
);

813  
	gic_
<>((
	gs
 + 
	gadd_amou
[
i
]>> 
	gshi_amou
[i]);

817 
size_t
 
	gass_to_size
[
K_NUM_CLASSES_MAX
];

820 
size_t
 
	gass_to_ges
[
K_NUM_CLASSES_MAX
];

824 as
	cHdedSLL
 {

825 
	gpublic
:

826 
ALWAYS_INLINE
 
HdedSLL
 

(* 
vue
)

828 
HdedSLL
 
su
;

829 
	gsu
.
	gm_vue
 = 
vue
;

830  
	gsu
;

833 
ALWAYS_INLINE
 
HdedSLL
 
nu
()

835 
HdedSLL
 
	gsu
;

836 
	gsu
.
	gm_vue
 = 0;

837  
	gsu
;

840 
ALWAYS_INLINE
 
tVue
(* 
vue
{ 
	gm_vue
 = value; }

841 
ALWAYS_INLINE
 * 
vue
(cڡ {  
	gm_vue
; }

842 
ALWAYS_INLINE
 
bo
 
	gݔ
!(cڡ {  !
	gm_vue
; }

843 * (
	tHdedSLL
::*
	tUnecifdBoTy
);

844 
ALWAYS_INLINE
 
ݔ
 
UnecifdBoTy
(cڡ {  
	gm_vue
 ? &
	gHdedSLL
::
m_vue
 : 0; }

846 
bo
 
	gݔ
!=(cڡ 
HdedSLL
& 
h
cڡ {  
m_vue
 != other.m_value; }

847 
bo
 
	gݔ
==(cڡ 
HdedSLL
& 
h
cڡ {  
m_vue
 == other.m_value; }

849 
	give
:

850 * 
m_vue
;

856 
	sTCEry
 {

857 
HdedSLL
 
	ghd
;

858 
HdedSLL
 
	g
;

865 
	#K_NUM_TRANSFER_ENTRIES_MAX
 
ic_
<>(
K_NUM_CLASSES_MAX
)

	)

866 
	#kNumTnsrErs
 
ic_
<>(
kNumCss
)

	)

870 
le
 
	$LgFlo
(
size_t
 
n
) {

871 
log
 = 0;

872 
i
 = 4; i >= 0; --i) {

873 
shi
 = (1 << 
i
);

874 
size_t
 
x
 = 
n
 >> 
shi
;

875 i(
x
 != 0) {

876 
n
 = 
x
;

877 
log
 +
shi
;

880 
	`ASSERT
(
n
 == 1);

881  
log
;

882 
	}
}

885 
ALWAYS_INLINE
 
HdedSLL
 
	$SLL_Next
(
HdedSLL
 
t
, 
u_t
 
y
) {

886 * 
tVueNext
 = *(
t_
<**>(
t
.
	`vue
()));

887  
HdedSLL
::
	`
(
	`XOR_MASK_PTR_WITH_KEY
(
tVueNext
, 
t
.
	`vue
(), 
y
));

888 
	}
}

890 
ALWAYS_INLINE
 
	$SLL_SNext
(
HdedSLL
 
t
, HdedSLL 
n
, 
u_t
 
y
) {

891 *(
t_
<**>(
t
.
	`vue
())
	`XOR_MASK_PTR_WITH_KEY
(
n
.vue(),.vue(), 
y
);

892 
	}
}

894 
ALWAYS_INLINE
 
	$SLL_Push
(
HdedSLL
* 
li
, HdedSLL 
emt
, 
u_t
 
y
) {

895 
	`SLL_SNext
(
emt
, *
li
, 
y
);

896 *
li
 = 
emt
;

897 
	}
}

899 
ALWAYS_INLINE
 
HdedSLL
 
	$SLL_P
(
HdedSLL
 *
li
, 
u_t
 
y
) {

900 
HdedSLL
 
su
 = *
li
;

901 *
li
 = 
	`SLL_Next
(*li, 
y
);

902  
su
;

903 
	}
}

910 
ALWAYS_INLINE
 
	$SLL_PRge
(
HdedSLL
* 
hd
, 
N
, HdedSLL *
t
, HdedSLL *
d
, 
u_t
 
y
) {

911 i(
N
 == 0) {

912 *
t
 = 
HdedSLL
::
	`nu
();

913 *
d
 = 
HdedSLL
::
	`nu
();

917 
HdedSLL
 
tmp
 = *
hd
;

918 
i
 = 1; i < 
N
; ++i) {

919 
tmp
 = 
	`SLL_Next
mp, 
y
);

922 *
t
 = *
hd
;

923 *
d
 = 
tmp
;

924 *
hd
 = 
	`SLL_Next
(
tmp
, 
y
);

926 
	`SLL_SNext
(
tmp
, 
HdedSLL
::
	`nu
(), 
y
);

927 
	}
}

929 
ALWAYS_INLINE
 
	$SLL_PushRge
(
HdedSLL
 *
hd
, HdedSLL 
t
, HdedSLL 
d
, 
u_t
 
y
) {

930 i(!
t
) ;

931 
	`SLL_SNext
(
d
, *
hd
, 
y
);

932 *
hd
 = 
t
;

933 
	}
}

937 
ALWAYS_INLINE
 
size_t
 
	$SizeCss
(
size_t
 
size
) {

938  
ass_y
[
	`CssIndex
(
size
)];

939 
	}
}

942 
ALWAYS_INLINE
 
size_t
 
	$BySizeFCss
(
size_t
 

) {

943  
ass_to_size
[

];

944 
	}
}

945 
	$NumMoveSize
(
size_t
 
size
) {

946 i(
size
 == 0)  0;

948 
num
 = 
ic_
<>(64.0 * 1024.0 / 
size
);

949 i(
num
 < 2)um = 2;

952 i(
num
 > 
ic_
<>(0.8 * 
kMaxFeLiLgth
))

953 
num
 = 
ic_
<>(0.8 * 
kMaxFeLiLgth
);

963 i(
num
 > 32)um = 32;

965  
num
;

966 
	}
}

969 
	$InSizeCss
() {

970 #i
	`OS
(
DARWIN
)

971 
kPageShi
 = 
vm_ge_shi
;

972 
kPageShi
) {

974 
kNumCss
 = 68;

977 
kNumCss
 = 77;

980 
	`CRASH
();

983 
kPageShi
 = 12;

984 
kNumCss
 = 68;

986 
kPageSize
 = 1 << 
kPageShi
;

987 
kMaxVidPages
 = (~
ic_
<
Lgth
>(0)>> 
kPageShi
;

990 i(
	`CssIndex
(0) < 0) {

991 
	`MESSAGE
("Invid csdex %d f siz0\n", 
	`CssIndex
(0));

992 
	`CRASH
();

994 i(
ic_
<
size_t
>(
	`CssIndex
(
kMaxSize
)>(
ass_y
)) {

995 
	`MESSAGE
("Invid csdex %d f kMaxSize\n", 
	`CssIndex
(
kMaxSize
));

996 
	`CRASH
();

1000 
size_t
 
sc
 = 1;

1001 
ignshi
 = 
kAlignShi
;

1002 
ϡ_lg
 = -1;

1003 
size_t
 
size
 = 
kAlignmt
; siz<
kMaxSize
; siz+(1 << 
ignshi
)) {

1004 
lg
 = 
	`LgFlo
(
size
);

1005 i(
lg
 > 
ϡ_lg
) {

1013 i((
lg
 >7&& (
ignshi
 < 8)) {

1014 
ignshi
++;

1016 
ϡ_lg
 = 
lg
;

1021 
size_t
 
psize
 = 
kPageSize
;

1022 (
psize
 % 
size
) > (psize >> 3)) {

1023 
psize
 +
kPageSize
;

1025 cڡ 
size_t
 
my_ges
 = 
psize
 >> 
kPageShi
;

1027 i(
sc
 > 1 && 
my_ges
 =
ass_to_ges
[sc-1]) {

1030 cڡ 
size_t
 
my_objes
 = (
my_ges
 << 
kPageShi
/ 
size
;

1031 cڡ 
size_t
 
ev_objes
 = (
ass_to_ges
[
sc
-1] << 
kPageShi
)

1032 / 
ass_to_size
[
sc
-1];

1033 i(
my_objes
 =
ev_objes
) {

1035 
ass_to_size
[
sc
-1] = 
size
;

1041 
ass_to_ges
[
sc
] = 
my_ges
;

1042 
ass_to_size
[
sc
] = 
size
;

1043 
sc
++;

1045 i(
sc
 !
kNumCss
) {

1046 
	`MESSAGE
("wrgumb osizass: found %" 
PRIuS
 " instead of %d\n",

1047 
sc
, (
kNumCss
));

1048 
	`CRASH
();

1052 
xt_size
 = 0;

1053 
c
 = 1; c < 
kNumCss
; c++) {

1054 cڡ 
size_t
 
max_size__ass
 = 
ass_to_size
[
c
];

1055 
size_t
 
s
 = 
xt_size
; s <
max_size__ass
; s +
kAlignmt
) {

1056 
ass_y
[
	`CssIndex
(
s
)] = 
c
;

1058 
xt_size
 = 
ic_
<>(
max_size__ass
 + 
kAlignmt
);

1062 
size_t
 
size
 = 0; siz<
kMaxSize
; size++) {

1063 cڡ 
size_t
 
sc
 = 
	`SizeCss
(
size
);

1064 i(
sc
 == 0) {

1065 
	`MESSAGE
("Bad sizas%" 
PRIuS
 " f %" PRIuS "\n", 
sc
, 
size
);

1066 
	`CRASH
();

1068 i(
sc
 > 1 && 
size
 <
ass_to_size
[sc-1]) {

1069 
	`MESSAGE
("Aotg uesrygas%" 
PRIuS
 " for %" PRIuS

1070 "\n", 
sc
, 
size
);

1071 
	`CRASH
();

1073 i(
sc
 >
kNumCss
) {

1074 
	`MESSAGE
("Bad sizas%" 
PRIuS
 " f %" PRIuS "\n", 
sc
, 
size
);

1075 
	`CRASH
();

1077 cڡ 
size_t
 
s
 = 
ass_to_size
[
sc
];

1078 i(
size
 > 
s
) {

1079 
	`MESSAGE
("Bad siz%" 
PRIuS
 " f %" PRIuS " (s%" PRIuS ")\n", 
s
, 
size
, 
sc
);

1080 
	`CRASH
();

1082 i(
s
 == 0) {

1083 
	`MESSAGE
("Bad siz%" 
PRIuS
 " f %" PRIuS " (s%" PRIuS ")\n", 
s
, 
size
, 
sc
);

1084 
	`CRASH
();

1089 
size_t
 

 = 1; c< 
kNumCss
; ++cl) {

1090 
num_objes_to_move
[

] = 
	`NumMoveSize
(
	`BySizeFCss
(cl));

1093 #ide
WTF_CHANGES


1094 i(
l
) {

1096 
size_t
 

 = 1; c< 
kNumCss
; ++cl) {

1097 cڡ 
loc_size
 = 
ass_to_ges
[

] << 
kPageShi
;

1098 cڡ 
loc_objs
 = 
loc_size
 / 
ass_to_size
[

];

1099 cڡ 
m_ud
 = (
ass_to_size
[

-1] + 1* 
loc_objs
;

1100 cڡ 
max_wae
 = 
loc_size
 - 
m_ud
;

1101 
	`MESSAGE
("SC %3d [ %8d .. %8d ] from %8d ; %2.0f%% maxwaste\n",

1102 (

),

1103 (
ass_to_size
[

-1] + 1),

1104 (
ass_to_size
[

]),

1105 (
ass_to_ges
[

] << 
kPageShi
),

1106 
max_wae
 * 100.0 / 
loc_size


1111 
	}
}

1119 
ut64_t
 
	gmada_syem_bys
 = 0;

1120 * 
	$MaDaAoc
(
size_t
 
bys
) {

1121 * 
su
 = 
	`TCMloc_SyemAoc
(
bys
, 0);

1122 i(
su
 !
NULL
) {

1123 
mada_syem_bys
 +
bys
;

1125  
su
;

1126 
	}
}

1128 #i
defed
(
WTF_CHANGES
&& 
	$OS
(
DARWIN
)

1129 
ass
 
RemeMemyRd
;

1132 
me
 <
ass
 
T
>

1133 as
	cPageHpAot
 {

1134 
ive
:

1136 cڡ 
size_t
 
kAocInemt
 = 32 << 10;

1139 cڡ 
size_t
 
kAligdSize


1140 ((((
T
+ 
kAlignmt
 - 1) / kAlignment) * kAlignment);

1143 * 
__
;

1144 
size_t
 
_ava_
;

1147 
HdedSLL
 
lod_gis_
;

1150 
HdedSLL
 
_li_
;

1153 
u_
;

1154 
u_t
 
y_
;

1156 
public
:

1157 
	`In
(
u_t
 
y
) {

1158 
	`ASSERT
(
kAligdSize
 <
kAocInemt
);

1159 
u_
 = 0;

1160 
lod_gis_
 = 
HdedSLL
::
	`nu
();

1161 
__
 = 
NULL
;

1162 
_ava_
 = 0;

1163 
_li_
.
	`tVue
(
NULL
);

1164 
y_
 = 
y
;

1167 
T
* 
	`New
() {

1169 * 
su
;

1170 i(
_li_
) {

1171 
su
 = 
_li_
.
	`vue
();

1172 
_li_
 = 
	`SLL_Next
(_li_, 
y_
);

1174 i(
_ava_
 < 
kAligdSize
) {

1176 * 
w_loti
 = 
t_
<*>(
	`MaDaAoc
(
kAocInemt
));

1177 i(!
w_loti
)

1178 
	`CRASH
();

1180 
HdedSLL
 
w_hd
 = HdedSLL::
	`
(
w_loti
);

1181 
	`SLL_SNext
(
w_hd
, 
lod_gis_
, 
y_
);

1182 
lod_gis_
 = 
w_hd
;

1183 
__
 = 
w_loti
 + 
kAligdSize
;

1184 
_ava_
 = 
kAocInemt
 - 
kAligdSize
;

1186 
su
 = 
__
;

1187 
__
 +
kAligdSize
;

1188 
_ava_
 -
kAligdSize
;

1190 
u_
++;

1191  
t_
<
T
*>(
su
);

1194 
	`De
(
T
* 
p
) {

1195 
HdedSLL
 
w_hd
 = HdedSLL::
	`
(
p
);

1196 
	`SLL_SNext
(
w_hd
, 
_li_
, 
y_
);

1197 
_li_
 = 
w_hd
;

1198 
u_
--;

1201 
	`u
(cڡ {  
u_
; }

1203 #i
	`defed
(
WTF_CHANGES
&& 
	`OS
(
DARWIN
)

1204 
me
 <
tyme
 
Recd
>

1205 
	`cdAdmitiveRegis
(
Recd
&, cڡ 
RemeMemyRd
&);

1207 
	}
};

1214 
u_t
 
	tPageID
;

1218 
le
 
Lgth
 
	$ges
(
size_t
 
bys
) {

1219 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

1220  (
bys
 >> 
kPageShi
) +

1221 ((
bys
 & (
kPageSize
 - 1)) > 0 ? 1 : 0);

1222 
	}
}

1226 
size_t
 
	$AotiSize
(
size_t
 
bys
) {

1227 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

1228 i(
bys
 > 
kMaxSize
) {

1230 
	`ASSERT
(
bys
 <(
kMaxVidPages
 << 
kPageShi
));

1231  
	`ges
(
bys
<< 
kPageShi
;

1234  
	`BySizeFCss
(
	`SizeCss
(
bys
));

1236 
	}
}

1239 
	gkSnCookBs
 = 10,

1240 
	gkSnCookMask
 = (1 << 10) - 1,

1241 
	gkSnThisShi
 = 7

1244 
ut32_t
 
	gVidiCook
;

1245 
ut32_t
 
	$InlizCook
()

1247 
ut32_t
 
vue
 = 
ErySour
<(ut32_t)>::
	`vue
(& 
kSnCookMask
;

1248 
VidiCook
 = 
vue
;

1249  
vue
;

1250 
	}
}

1253 
	sSn
 {

1254 
PageID
 
	gt
;

1255 
Lgth
 
	gngth
;

1256 
Sn
* 
xt
(
u_t
 
y
cڡ {  
XOR_MASK_PTR_WITH_KEY
(
m_xt
, 
this
,ntropy); }

1257 
Sn
* 
meNext
(cڡ Sn* 
meSnPor
, 
u_t
 
y
cڡ {  
XOR_MASK_PTR_WITH_KEY
(
m_xt
,emoteSpanPointer,ntropy); }

1258 
Sn
* 
ev
(
u_t
 
y
cڡ {  
XOR_MASK_PTR_WITH_KEY
(
m_ev
, 
this
,ntropy); }

1259 
tNext
(
Sn
* 
xt
, 
u_t
 
y
{ 
	gm_xt
 = 
XOR_MASK_PTR_WITH_KEY
ext, 
this
,ntropy); }

1260 
tPv
(
Sn
* 
ev
, 
u_t
 
y
{ 
	gm_ev
 = 
XOR_MASK_PTR_WITH_KEY
ջv, 
this
,ntropy); }

1262 
	give
:

1263 
Sn
* 
m_xt
;

1264 
Sn
* 
	gm_ev
;

1265 
	gpublic
:

1266 
HdedSLL
 
objes
;

1267 
	g
 : 1;

1268 #ide
NO_TCMALLOC_SAMPLES


1269 
	gme
 : 1;

1271 
	gsizeass
 : 8;

1272 
	gfcou
 : 11;

1273 
bo
 
	gdecommd
 : 1;

1274 
Cook
()

1276 
	gm_cook
 = ((
t_
<
u_t
>(
this
>> 
kSnThisShi
& 
kSnCookMask
^ 
InlizCook
();

1278 
rCook
({ 
	gm_cook
 = 0; }

1279 
bo
 
isVid
() const

1281  (((
	gt_
<
	gu_t
>(
	gthis
>> 
	gkSnThisShi
& 
	gkSnCookMask
^ 
	gm_cook
=
VidiCook
;

1283 
	give
:

1284 
ut32_t
 
m_cook
 : 
kSnCookBs
;

1286 #unde
SPAN_HISTORY


1287 #ifde
SPAN_HISTORY


1289 
	gxthiy
;

1290 
	ghiy
[64];

1291 
	gvue
[64];

1295 
	#ASSERT_SPAN_COMMITTED
(


	`ASSERT
(!->
decommd
)

	)

1297 #ifde
SPAN_HISTORY


1298 
	$Evt
(
Sn
* 

, 

, 
v
 = 0) {

1299 

->
hiy
[->
xthiy
] = 

;

1300 

->
vue
[->
xthiy
] = 
v
;

1301 

->
xthiy
++;

1302 i(

->
xthiy
 =(->
hiy
)) span->nexthistory = 0;

1303 
	}
}

1305 
	#Evt
(
s
,
o
,
v
((0)

	)

1309 
	gPageHpAot
<
	gSn
> 
	g_lot
;

1310 
Sn
* 
	$NewSn
(
PageID
 
p
, 
Lgth
 
n
) {

1311 
Sn
* 
su
 = 
_lot
.
	`New
();

1312 
	`memt
(
su
, 0, (*result));

1313 
su
->
t
 = 
p
;

1314 
su
->
ngth
 = 
n
;

1315 
su
->
	`Cook
();

1316 #ifde
SPAN_HISTORY


1317 
su
->
xthiy
 = 0;

1319  
su
;

1320 
	}
}

1322 
le
 
	$DeSn
(
Sn
* 

) {

1323 
	`RELEASE_ASSERT
(

->
	`isVid
());

1324 #ide
NDEBUG


1326 
	`memt
(

, 0x3f, (*span));

1328 

->
	`rCook
();

1329 
_lot
.
	`De
(

);

1330 
	}
}

1336 
le
 
	$DLL_In
(
Sn
* 
li
, 
u_t
 
y
) {

1337 
li
->
	`tNext
i, 
y
);

1338 
li
->
	`tPv
i, 
y
);

1339 
	}
}

1341 
le
 
	$DLL_Remove
(
Sn
* 

, 
u_t
 
y
) {

1342 

->
	`ev
(
y
)->
	`tNext
(->
	`xt
(entropy),ntropy);

1343 

->
	`xt
(
y
)->
	`tPv
(->
	`ev
(entropy),ntropy);

1344 

->
	`tPv
(
NULL
, 
y
);

1345 

->
	`tNext
(
NULL
, 
y
);

1346 
	}
}

1348 
ALWAYS_INLINE
 
bo
 
	$DLL_IsEmy
(cڡ 
Sn
* 
li
, 
u_t
 
y
) {

1349  
li
->
	`xt
(
y
) ==ist;

1350 
	}
}

1352 
	$DLL_Lgth
(cڡ 
Sn
* 
li
, 
u_t
 
y
) {

1353 
su
 = 0;

1354 
Sn
* 
s
 = 
li
->
	`xt
(
y
); s !=ist; s = s->next(entropy)) {

1355 
su
++;

1357  
su
;

1358 
	}
}

1361 
	$DLL_Prt
(cڡ * 
b
, cڡ 
Sn
* 
li
) {

1362 
	`MESSAGE
("%-10%p:", 
b
, 
li
);

1363 cڡ 
Sn
* 
s
 = 
li
->
xt
; s !=ist; s = s->next) {

1364 
	`MESSAGE
(" <%p,%u,%u>", 
s
, s->
t
, s->
ngth
);

1366 
	`MESSAGE
("\n");

1367 
	}
}

1370 
le
 
	$DLL_Pnd
(
Sn
* 
li
, Sn* 

, 
u_t
 
y
) {

1371 

->
	`tNext
(
li
->
	`xt
(
y
),ntropy);

1372 

->
	`tPv
(
li
, 
y
);

1373 
li
->
	`xt
(
y
)->
	`tPv
(

,ntropy);

1374 
li
->
	`tNext
(

, 
y
);

1375 
	}
}

1381 as
	cTCMloc_C_FeLi
 {

1382 
	gpublic
:

1383 
In
(
size_t
 

, 
u_t
 
y
);

1389 
InRge
(
HdedSLL
 
t
, HdedSLL 
d
, 
N
);

1392 
RemoveRge
(
HdedSLL
* 
t
, HdedSLL* 
d
, *
N
);

1395 
size_t
 
ngth
() {

1396 
SpLockHd
 
h
(&
lock_
);

1397  
	gcou_
;

1401 
tc_ngth
() {

1402 
SpLockHd
 
h
(&
lock_
);

1403  
ud_s_
 * 
	gnum_objes_to_move
[
size_ass_
];

1406 #ifde
WTF_CHANGES


1407 
	gme
 <
ass
 
	gFd
, cs
	gRd
>

1408 
umeFeObjes
(
Fd
& 
fd
, cڡ 
Rd
& 
ad
, 
TCMloc_C_FeLi
* 
meCFeLi
)

1411 cڡ 
rdiff_t
 
	gemyOfft
 = 
t_
<cڡ *>(&
emy_
-et_<cڡ *>(
this
);

1412 
Sn
* 
	gmeEmy
 = 
t_
<Sn*>et_<*>(
meCFeLi
+ 
emyOfft
);

1413 
Sn
* 
	gmeSn
 = 
nemy_
.
meNext
(
meEmy
, 
y_
);

1414 
Sn
* 
	g
 = 
ad
(
meEmy
); s&& s!&
emy_
; 
	gmeSn
 = 

->
meNext
(
meSn
, 
y_
), span = (remoteSpan ?eader(remoteSpan) : 0))

1415 
ASSERT
(!

->
objes
);

1418 
ASSERT
(!
nemy_
.
objes
);

1419 cڡ 
rdiff_t
 
	gnemyOfft
 = 
t_
<cڡ *>(&
nemy_
-et_<cڡ *>(
this
);

1421 
Sn
* 
	gmeNemy
 = 
t_
<Sn*>et_<*>(
meCFeLi
+ 
nemyOfft
);

1422 
Sn
* 
	gmeSn
 = 
nemy_
.
meNext
(
meNemy
, 
y_
);

1424 
Sn
* 
	g
 = 
ad
(
meSn
); s&& 
	gmeSn
 !
meNemy
;emeS

->
meNext
emeSn, 
y_
), span = (remoteSpan ?eader(remoteSpan) : 0)) {

1425 
HdedSLL
 
xtObje
 = 

->
objes
; 
	gxtObje
;extObje.
tVue
(
ad
.
xtEryInHdedLkedLi
(
t_
<**>extObje.
vue
()), 
y_
))) {

1426 
	gfd
.
vis
(
xtObje
.
vue
());

1430 
	g
 = 0; sl < 
	gud_s_
; ++slot) {

1431 
HdedSLL
 
	gy
 = 
tc_s_
[

].
hd
;ry;ry.
tVue
(
ad
.
xtEryInHdedLkedLi
(
t_
<**>(
y
.
vue
()), 
y_
)))

1432 
	gfd
.
vis
(
y
.
vue
());

1437 
u_t
 
y
(cڡ {  
	gy_
; }

1438 
	give
:

1442 
HdedSLL
 
FchFromSns
();

1448 
HdedSLL
 
FchFromSnsSa
();

1453 
RLiToSns
(
HdedSLL
 
t
);

1458 
ALWAYS_INLINE
 
RToSns
(
HdedSLL
 
obje
);

1463 
ALWAYS_INLINE
 
Puϋ
();

1469 
bo
 
MakeCacheS
();

1476 
ALWAYS_INLINE
 
bo
 
EviRdomSizeCss
(
size_t
 
locked_size_ass
, bo 
f
);

1485 
bo
 
ShrkCache
(
locked_size_ass
, bo 
f
);

1489 
SpLock
 
	glock_
;

1492 
size_t
 
	gsize_ass_
;

1493 
Sn
 
	gemy_
;

1494 
Sn
 
	gnemy_
;

1495 
size_t
 
	gcou_
;

1500 
TCEry
 
	gtc_s_
[
K_NUM_TRANSFER_ENTRIES_MAX
];

1504 
t32_t
 
	gud_s_
;

1508 
t32_t
 
	gche_size_
;

1509 
u_t
 
	gy_
;

1512 #i
COMPILER
(
CLANG
&& 
	$defed
(
__has_wng
)

1513 #agm
g
 
dgnoic
 
push


1514 #i
	`__has_wng
("-Wunused-private-field")

1515 #agm
g
 
dgnoic
 
igned
 "-Wunused-private-field"

1520 
me
 <
size_t
 
SizeToPad
>

1521 as
	cTCMloc_C_FeLiPadded_Teme
 : 
public
 
TCMloc_C_FeLi
 {

1522 
ive
:

1523 
d
[64 - 
SizeToPad
];

1524 
	}
};

1528 
	gme
 <> 
ass
 
	gTCMloc_C_FeLiPadded_Teme
<0> : 
public
 
TCMloc_C_FeLi
 {

1531 
	gTCMloc_C_FeLiPadded_Teme
<(
	tTCMloc_C_FeLi
% 64> 
	tTCMloc_C_FeLiPadded
;

1533 #i
COMPILER
(
CLANG
&& 
	$defed
(
__has_wng
)

1534 #agm
g
 
dgnoic
 
p


1537 #i
	$OS
(
DARWIN
)

1538 
Sn
;

1539 
ass
 
TCMloc_PageHp
;

1540 
ass
 
TCMloc_ThadCache
;

1541 
me
 <
tyme
 
T
> 
ass
 
PageHpAot
;

1543 as
	cFaMlocZe
 {

1544 
public
:

1545 
	`
();

1547 
kn_tu_t
 
	`ume
(
sk_t
, *, 
tyMmask
, 
vm_addss_t
 
zeAddss
, 
memy_ad_t
, 
vm_nge_cd_t
);

1548 
size_t
 
	`goodSize
(
mloc_ze_t
*, size_
size
) {  size; }

1549 
boޗn_t
 
	`check
(
mloc_ze_t
*{  
ue
; }

1550 
	`t
(
mloc_ze_t
*, 
boޗn_t
) { }

1551 
	`log
(
mloc_ze_t
*, *) { }

1552 
	`fLock
(
mloc_ze_t
*) { }

1553 
	`fUock
(
mloc_ze_t
*) { }

1554 
	`iics
(
mloc_ze_t
*, 
mloc_iics_t
* 
s
{ 
	`memt
(stats, 0, (malloc_statistics_t)); }

1556 
ive
:

1557 
	`FaMlocZe
(
TCMloc_PageHp
*, 
TCMloc_ThadCache
**, 
TCMloc_C_FeLiPadded
*, 
PageHpAot
<
Sn
>*, PageHeapAllocator<TCMalloc_ThreadCache>*);

1558 
size_t
 
	`size
(
mloc_ze_t
*, const *);

1559 * 
	`zeMloc
(
mloc_ze_t
*, 
size_t
);

1560 * 
	`zeCloc
(
mloc_ze_t
*, 
size_t
 
numIms
, size_
size
);

1561 
	`zeFe
(
mloc_ze_t
*, *);

1562 * 
	`zeRoc
(
mloc_ze_t
*, *, 
size_t
);

1563 * 
	`zeVloc
(
mloc_ze_t
*, 
size_t
{ 
	`LOG_ERROR
("valloc isot supported");  0; }

1564 
	`zeDeroy
(
mloc_ze_t
*) { }

1566 
mloc_ze_t
 
m_ze
;

1567 
TCMloc_PageHp
* 
m_geHp
;

1568 
TCMloc_ThadCache
** 
m_thadHps
;

1569 
TCMloc_C_FeLiPadded
* 
m_lCaches
;

1570 
PageHpAot
<
Sn
>* 
m_Aot
;

1571 
PageHpAot
<
TCMloc_ThadCache
>* 
m_geHpAot
;

1572 
	}
};

1575 "C" (*
mloc_logg
)(
ut32_t
 
tyFgs
, 
u_t
 
ze
, u_
size
, u_
por
, u_
tuVue
, ut32_
numbOfFmesToSk
);

1579 as
	cMlocHook
 {

1580 
bo
 
ackLogggEbd
;

1582 #i
	`OS
(
DARWIN
)

1584 
	eSckLogggTy
 {

1585 
SckLogggTyAoc
 = 2,

1586 
SckLogggTyDoc
 = 4,

1589 
	`cd
(
ut32_t
 
tyFgs
, 
u_t
 
ze
, u_
size
, * 
por
, * 
tuVue
, ut32_
numbOfFmesToSk
)

1591 
	`mloc_logg
(
tyFgs
, 
ze
, 
size
, 
t_
<
u_t
>(
por
),et_<u_t>(
tuVue
), 
numbOfFmesToSk
);

1594 
NEVER_INLINE
 
	`cdAoti
(* 
por
, 
size_t
 
size
)

1598 
	`cd
(
SckLogggTyAoc
, 0, 
size
, 0, 
por
, 0);

1601 
NEVER_INLINE
 
	`cdDoti
(* 
por
)

1604 
	`cd
(
SckLogggTyDoc
, 0, 
t_
<
u_t
>(
por
), 0, 0, 0);

1609 
public
:

1610 
	`
()

1612 #i
	`OS
(
DARWIN
)

1614 
ackLogggEbd
 = 
mloc_logg
;

1618 #i
	`OS
(
DARWIN
)

1619 
ALWAYS_INLINE
 
	`InvokeNewHook
(* 
por
, 
size_t
 
size
)

1621 i(
	`UNLIKELY
(
ackLogggEbd
))

1622 
	`cdAoti
(
por
, 
size
);

1625 
ALWAYS_INLINE
 
	`InvokeDeHook
(* 
por
)

1628 i(
	`UNLIKELY
(
ackLogggEbd
))

1629 
	`cdDoti
(
por
);

1632 
ALWAYS_INLINE
 
	`InvokeNewHook
(*, 
size_t
) { }

1633 
ALWAYS_INLINE
 
	`InvokeDeHook
(*) { }

1635 
	}
};

1636 
bo
 
	gMlocHook
::
ackLogggEbd
 = 
l
;

1640 #ide
WTF_CHANGES


1643 #ifde
NO_TCMALLOC_SAMPLES


1645 
	#GSckT
(
ack
, 
dth
, 
sk
(0)

	)

1647 
	~<goog/acka.h
>

1654 #i
	$defed
(
HAVE_TLS
)

1655 
bo
 
kl_suts_s
 = 
l
;

1656 
le
 
bo
 
	$KlSutsTLS
() {

1657  
kl_suts_s
;

1658 
	}
}

1659 #i!
HAVE_DECL_UNAME


1660 
	$CheckIfKlSutsTLS
() {

1661 
kl_suts_s
 = 
l
;

1662 
	}
}

1664 
	~<sys/utame.h
>

1665 
	$CheckIfKlSutsTLS
() {

1666 
utame
 
buf
;

1667 i(
	`ume
(&
buf
) != 0) {

1668 
	`MESSAGE
("umedssumgTLS su܈Ӽno=%d)\n", 
o
);

1669 
kl_suts_s
 = 
l
;

1670 } i(
	`rcmp
(
buf
.
syame
, "linux") == 0) {

1672 i(
buf
.
a
[0] < '2' && buf.release[1] == '.')

1673 
kl_suts_s
 = 
l
;

1674 i(
buf
.
a
[0] == '2' && buf.release[1] == '.' &&

1675 
buf
.
a
[2] >= '0' && buf.release[2] < '6' &&

1676 
buf
.
a
[3] == '.')

1677 
kl_suts_s
 = 
l
;

1679 
kl_suts_s
 = 
ue
;

1681 
kl_suts_s
 = 
ue
;

1684 
	}
}

1691 #ide
__THROW


1692 
	#__THROW


1694 

	)

1702 cڡ 
	gkMaxSckDth
 = 31;

1703 
	sSckT
 {

1704 
u_t
 
	gsize
;

1705 
u_t
 
	gdth
;

1706 * 
	gack
[
kMaxSckDth
];

1708 
	gPageHpAot
<
	gSckT
> 
	gacka_lot
;

1709 
Sn
 
	gmed_objes
;

1720 
	gme
 <
	gBITS
> cs
	cMSe
 {

1721 
	gpublic
:

1722 
TCMloc_PageM3
<
	tBITS
-
	tK_PAGE_SHIFT_MIN
> 
	tTy
;

1723 
	gPackedCache
<
	tBITS
, 
	tut64_t
> 
	tCacheTy
;

1726 #i
	$defed
(
WTF_CHANGES
)

1727 #i
	`CPU
(
X86_64
|| 
	$CPU
(
ARM64
)

1732 cڡ 
size_t
 
kBsUnudOn64B
 = 16;

1734 cڡ 
size_t
 
kBsUnudOn64B
 = 0;

1738 
me
 <> 
ass
 
MSe
<64> {

1739 
public
:

1740 
TCMloc_PageM3
<64 - 
	tK_PAGE_SHIFT_MIN
 - 
	tkBsUnudOn64B
> 
	tTy
;

1741 
PackedCache
<64, 
	tut64_t
> 
	tCacheTy
;

1742 
	}
};

1746 
	gme
 <> 
ass
 
	gMSe
<32> {

1747 
	gpublic
:

1748 
TCMloc_PageM2
<32 - 
	tK_PAGE_SHIFT_MIN
> 
	tTy
;

1749 
	gPackedCache
<32 - 
	tK_PAGE_SHIFT_MIN
, 
	tut16_t
> 
	tCacheTy
;

1760 #i
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY


1776 cڡ 
	gkSvgeDayInSecds
 = 2;

1780 cڡ 
	gkSvgePage
 = .5f;

1783 cڡ 
	gkMSnLisWhSns
 = 32;

1787 cڡ 
size_t
 
	gkMimumFeCommdPageCou
 = 
kMSnLisWhSns
 * ((1.0f+kMinSpanListsWithSpans) / 2.0f);

1791 
SpLock
 
	ggehp_lock
 = 
SPINLOCK_INITIALIZER
;

1793 as
	cTCMloc_PageHp
 {

1794 
	gpublic
:

1795 

();

1798 
Sn
* 
New
(
Lgth
 
n
);

1803 
De
(
Sn
* 

);

1809 
RegiSizeCss
(
Sn
* 

, 
size_t
 
sc
);

1819 
Sn
* 
S
(Sn* 

, 
Lgth
 
n
);

1822 
le
 
Sn
* 
GDest
(
PageID
 
p
) const {

1823  
	gt_
<
	gSn
*>(
	ggem_
.
g
(
p
));

1826 #ifde
WTF_CHANGES


1827 
le
 
Sn
* 
GDestEnsuSa
(
PageID
 
p
)

1829 
	ggem_
.
Ensu
(
p
, 1);

1830  
GDest
(
p
);

1833 
size_t
 
RuedBys
() const;

1837 #ide
WTF_CHANGES


1838 
Dump
(
TCMloc_Prr
* 
out
);

1842 
le
 
ut64_t
 
SyemBys
(cڡ {  
	gsyem_bys_
; }

1845 
ut64_t
 
FeBys
() const {

1846 
ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

1847  (
	gic_
<
	gut64_t
>(
	g_ges_
<< 
	gkPageShi
);

1850 
bo
 
Check
();

1851 
size_t
 
CheckLi
(
Sn
* 
li
, 
Lgth
 
m_ges
, Lgth 
max_ges
, 
bo
 
decommd
);

1854 
RFePages
();

1855 
RFeLi
(
Sn
*, Span*);

1862 
size_t
 
GSizeCssIfCached
(
PageID
 
p
) const {

1863  
	ggem_che_
.
GOrDeu
(
p
, 0);

1865 
CacheSizeCss
(
PageID
 
p
, 
size_t
 

cڡ { 
	ggem_che_
.
Put
(p, cl); }

1867 
	give
:

1869 
MSe
<8*(
	tu_t
)>::
	tTy
 
	tPageM
;

1870 
	gMSe
<8*(
	tu_t
)>::
	tCacheTy
 
	tPageMCache
;

1871 
PageM
 
	ggem_
;

1872 
mub
 
PageMCache
 
	ggem_che_
;

1877 
	sSnLi
 {

1878 
Sn
 
	gnm
;

1879 
Sn
 
	gtued
;

1883 
SnLi
 
	grge_
;

1886 
SnLi
 
	g_
[
kMaxPages
];

1889 
u_t
 
	g_ges_
;

1892 
u_t
 
	gy_
;

1895 
ut64_t
 
	gsyem_bys_
;

1897 #i
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY


1899 
Lgth
 
	g_commd_ges_
;

1903 
Lgth
 
	gm__commd_ges_s_ϡ_svge_
;

1906 
bo
 
GrowHp
(
Lgth
 
n
);

1915 
Cve
(
Sn
* 

, 
Lgth
 
n
, 
bo
 
ad
);

1917 
RecdSn
(
Sn
* 

) {

1918 
	ggem_
.
t
(

->
t
, span);

1919 i(
	g
->
	gngth
 > 1) {

1920 
	ggem_
.
t
(

->
t
 + sn->
ngth
 - 1, span);

1926 
Sn
* 
AocLge
(
Lgth
 
n
);

1928 #i!
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY


1931 
InemlSvge
(
Lgth
 
n
);

1935 
t64_t
 
	gsvge_cou_
;

1938 
size_t
 
	gsvge_dex_
;

1940 #i
defed
(
WTF_CHANGES
&& 
OS
(
DARWIN
)

1941 
nd
 
ass
 
	gFaMlocZe
;

1944 #i
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY


1945 
lizeSvg
();

1946 
ALWAYS_INLINE
 
siglSvg
();

1947 
svge
();

1948 
ALWAYS_INLINE
 
bo
 
shouldSvge
() const;

1950 #i
HAVE
(
DISPATCH_H
|| 
OS
(
WINDOWS
)

1951 
riodicSvge
();

1952 
ALWAYS_INLINE
 
bo
 
isSvgSuded
();

1953 
ALWAYS_INLINE
 
scheduSvg
();

1954 
ALWAYS_INLINE
 
scheduSvg
();

1955 
ALWAYS_INLINE
 
sudSvg
();

1958 #i
HAVE
(
DISPATCH_H
)

1959 
dich_queue_t
 
	gm_svgeQueue
;

1960 
dich_sour_t
 
	gm_svgeTim
;

1961 
bo
 
	gm_svggSuded
;

1962 #i
OS
(
WINDOWS
)

1963 
CALLBACK
 
svgTimFed
(*, 
BOOLEAN
);

1964 
HANDLE
 
	gm_svgeQueueTim
;

1966 
NO_RETURN_WITH_VALUE
 * 
runSvgThad
(*);

1967 
NO_RETURN
 
svgThad
();

1971 
bo
 
	gm_svgeThadAive
;

1973 
had_mux_t
 
	gm_svgeMux
;

1974 
had_cd_t
 
	gm_svgeCdi
;

1980 
	gTCMloc_PageHp
::
	$
()

1982 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

1984 
gem_
.
	`
(
MaDaAoc
);

1985 
gem_che_
 = 
	`PageMCache
(0);

1986 
_ges_
 = 0;

1987 
syem_bys_
 = 0;

1988 
y_
 = 
HARDENING_ENTROPY
;

1990 #i
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY


1991 
_commd_ges_
 = 0;

1992 
m__commd_ges_s_ϡ_svge_
 = 0;

1995 
svge_cou_
 = 0;

1997 
svge_dex_
 = 
kMaxPages
-1;

1998 
	`ASSERT
(
kNumCss
 <(1 << 
PageMCache
::
kVuebs
));

1999 
	`DLL_In
(&
rge_
.
nm
, 
y_
);

2000 
	`DLL_In
(&
rge_
.
tued
, 
y_
);

2001 
size_t
 
i
 = 0; i < 
kMaxPages
; i++) {

2002 
	`DLL_In
(&
_
[
i
].
nm
, 
y_
);

2003 
	`DLL_In
(&
_
[
i
].
tued
, 
y_
);

2006 #i
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY


2007 
	`lizeSvg
();

2009 
	}
}

2011 #i
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY


2013 #i
	$HAVE
(
DISPATCH_H
)

2015 
TCMloc_PageHp
::
	$lizeSvg
()

2017 
m_svgeQueue
 = 
	`dich_queue_
("com.e.JavaStCe.FaMlocSavg", 
NULL
);

2018 
m_svgeTim
 = 
	`dich_sour_
(
DISPATCH_SOURCE_TYPE_TIMER
, 0, 0, 
m_svgeQueue
);

2019 
ut64_t
 
svgeDayInNocds
 = 
kSvgeDayInSecds
 * 
NSEC_PER_SEC
;

2020 
dich_time_t
 
tTime
 = 
	`dich_time
(
DISPATCH_TIME_NOW
, 
svgeDayInNocds
);

2021 
	`dich_sour_t_tim
(
m_svgeTim
, 
tTime
, 
svgeDayInNocds
, scavengeDelayInNanoseconds / 10);

2022 
	`dich_sour_t_evt_hdr
(
m_svgeTim
, ^{ 
	`riodicSvge
(); });

2023 
m_svggSuded
 = 
ue
;

2024 
	}
}

2026 
ALWAYS_INLINE
 
bo
 
	gTCMloc_PageHp
::
	$isSvgSuded
()

2028 
	`ASSERT
(
gehp_lock
.
	`IsHd
());

2029  
m_svggSuded
;

2030 
	}
}

2032 
ALWAYS_INLINE
 
	gTCMloc_PageHp
::
	$scheduSvg
()

2034 
	`ASSERT
(
gehp_lock
.
	`IsHd
());

2035 
m_svggSuded
 = 
l
;

2036 
	`dich_sume
(
m_svgeTim
);

2037 
	}
}

2039 
ALWAYS_INLINE
 
	gTCMloc_PageHp
::
	$scheduSvg
()

2042 
	}
}

2044 
ALWAYS_INLINE
 
TCMloc_PageHp
::
	$sudSvg
()

2046 
	`ASSERT
(
gehp_lock
.
	`IsHd
());

2047 
m_svggSuded
 = 
ue
;

2048 
	`dich_sud
(
m_svgeTim
);

2049 
	}
}

2051 #i
	$OS
(
WINDOWS
)

2053 
TCMloc_PageHp
::
	$svgTimFed
(* 
cڋxt
, 
BOOLEAN
)

2055 
ic_
<
TCMloc_PageHp
*>(
cڋxt
)->
	`riodicSvge
();

2056 
	}
}

2058 
	gTCMloc_PageHp
::
	$lizeSvg
()

2060 
m_svgeQueueTim
 = 0;

2061 
	}
}

2063 
ALWAYS_INLINE
 
bo
 
	gTCMloc_PageHp
::
	$isSvgSuded
()

2065 
	`ASSERT
(
gehp_lock
.
	`IsHd
());

2066  !
m_svgeQueueTim
;

2067 
	}
}

2069 
ALWAYS_INLINE
 
	gTCMloc_PageHp
::
	$scheduSvg
()

2073 
	`ASSERT
(
gehp_lock
.
	`IsHd
());

2074 
	`CeTimQueueTim
(&
m_svgeQueueTim
, 0, 
svgTimFed
, 
this
, 
kSvgeDayInSecds
 * 1000, 0, 
WT_EXECUTEONLYONCE
);

2075 
	}
}

2077 
ALWAYS_INLINE
 
	gTCMloc_PageHp
::
	$scheduSvg
()

2080 
	`sudSvg
();

2081 
	`scheduSvg
();

2082 
	}
}

2084 
ALWAYS_INLINE
 
	gTCMloc_PageHp
::
	$sudSvg
()

2086 
	`ASSERT
(
gehp_lock
.
	`IsHd
());

2087 
HANDLE
 
svgeQueueTim
 = 
m_svgeQueueTim
;

2088 
m_svgeQueueTim
 = 0;

2089 
	`DeTimQueueTim
(0, 
svgeQueueTim
, 0);

2090 
	}
}

2094 
	gTCMloc_PageHp
::
	$lizeSvg
()

2097 #i!
	`defed
(
PTHREAD_MUTEX_NORMAL
|| PTHREAD_MUTEX_NORMAL =
PTHREAD_MUTEX_DEFAULT


2098 
	`had_mux_
(&
m_svgeMux
, 0);

2100 
had_mux_t
 

;

2101 
	`had_mux_
(&

);

2102 
	`had_mux_y
(&

, 
PTHREAD_MUTEX_NORMAL
);

2104 
	`had_mux_
(&
m_svgeMux
, &

);

2106 
	`had_mux_deroy
(&

);

2109 
	`had_cd_
(&
m_svgeCdi
, 0);

2110 
m_svgeThadAive
 = 
ue
;

2111 
had_t
 
thad
;

2112 
	`had_
(&
thad
, 0, 
runSvgThad
, 
this
);

2113 
	}
}

2115 * 
	gTCMloc_PageHp
::
	$runSvgThad
(* 
cڋxt
)

2117 
ic_
<
TCMloc_PageHp
*>(
cڋxt
)->
	`svgThad
();

2118 #i(
	`COMPILER
(
MSVC
|| COMPILER(
SUNCC
))

2122 
	}
}

2124 
ALWAYS_INLINE
 
	gTCMloc_PageHp
::
	$siglSvg
()

2130 
	`ASSERT
(
gehp_lock
.
	`IsHd
());

2131 i(!
m_svgeThadAive
 && 
	`shouldSvge
())

2132 
	`had_cd_sigl
(&
m_svgeCdi
);

2133 
	}
}

2137 
	gTCMloc_PageHp
::
	$svge
()

2139 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

2140 
size_t
 
gesToR
 = 
m__commd_ges_s_ϡ_svge_
 * 
kSvgePage
;

2141 
size_t
 
rgPageCou
 = 
d
::
max
<size_t>(
kMimumFeCommdPageCou
, 
_commd_ges_
 - 
gesToR
);

2143 
Lgth
 
ϡFeCommdPages
 = 
_commd_ges_
;

2144 
_commd_ges_
 > 
rgPageCou
) {

2145 
	`ASSERT
(
	`Check
());

2146 
i
 = 
kMaxPages
; i > 0 && 
_commd_ges_
 >
rgPageCou
; i--) {

2147 
SnLi
* 
i
 = (
ic_
<
size_t
>(
i
=
kMaxPages
? &
rge_
 : &
_
[i];

2150 
size_t
 
ngth
 = 
	`DLL_Lgth
(&
i
->
nm
, 
y_
);

2151 
size_t
 
numSnsToRu
 = (
i
 > 
kMSnLisWhSns
? 
ngth
 :ength / 2;

2152 
j
 = 0; 
ic_
<
size_t
>(j< 
numSnsToRu
 && !
	`DLL_IsEmy
(&
i
->
nm
, 
y_
&& 
_commd_ges_
 > 
rgPageCou
; j++) {

2153 
Sn
* 
s
 = 
i
->
nm
.
	`ev
(
y_
);

2154 
	`DLL_Remove
(
s
, 
y_
);

2155 
	`ASSERT
(!
s
->
decommd
);

2156 i(!
s
->
decommd
) {

2157 
	`TCMloc_SyemR
(
t_
<*>(
s
->
t
 << 
kPageShi
),

2158 
ic_
<
size_t
>(
s
->
ngth
 << 
kPageShi
));

2159 
	`ASSERT
(
_commd_ges_
 >
s
->
ngth
);

2160 
_commd_ges_
 -
s
->
ngth
;

2161 
s
->
decommd
 = 
ue
;

2163 
	`DLL_Pnd
(&
i
->
tued
, 
s
, 
y_
);

2167 i(
ϡFeCommdPages
 =
_commd_ges_
)

2169 
ϡFeCommdPages
 = 
_commd_ges_
;

2172 
m__commd_ges_s_ϡ_svge_
 = 
_commd_ges_
;

2173 
	}
}

2175 
ALWAYS_INLINE
 
bo
 
	gTCMloc_PageHp
::
	$shouldSvge
() const

2177  
_commd_ges_
 > 
kMimumFeCommdPageCou
;

2178 
	}
}

2182 
le
 
Sn
* 
	gTCMloc_PageHp
::
	$New
(
Lgth
 
n
) {

2183 
	`ASSERT
(
	`Check
());

2184 
	`ASSERT
(
n
 > 0);

2187 
Lgth
 
s
 = 
n
; s < 
kMaxPages
; s++) {

2188 
Sn
* 

 = 
NULL
;

2189 
bo
 
ad
 = 
l
;

2190 i(!
	`DLL_IsEmy
(&
_
[
s
].
nm
, 
y_
)) {

2192 

 = &
_
[
s
].
nm
;

2193 } i(!
	`DLL_IsEmy
(&
_
[
s
].
tued
, 
y_
)) {

2195 

 = &
_
[
s
].
tued
;

2196 
ad
 = 
ue
;

2202 
Sn
* 
su
 = 

->
	`xt
(
y_
);

2203 
	`Cve
(
su
, 
n
, 
ad
);

2204 #i
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY


2207 
	`ASSERT
(
_commd_ges_
 >
n
);

2208 
_commd_ges_
 -
n
;

2209 i(
_commd_ges_
 < 
m__commd_ges_s_ϡ_svge_
)

2210 
m__commd_ges_s_ϡ_svge_
 = 
_commd_ges_
;

2212 
	`ASSERT
(
	`Check
());

2213 
_ges_
 -
n
;

2214  
su
;

2217 
Sn
* 
su
 = 
	`AocLge
(
n
);

2218 i(
su
 !
NULL
) {

2219 
	`ASSERT_SPAN_COMMITTED
(
su
);

2220  
su
;

2224 i(!
	`GrowHp
(
n
)) {

2225 
	`ASSERT
(
	`Check
());

2226  
NULL
;

2229  
	`New
(
n
);

2230 
	}
}

2232 
Sn
* 
	gTCMloc_PageHp
::
	$AocLge
(
Lgth
 
n
) {

2235 
bo
 
om_ad
 = 
l
;

2236 
Sn
 *
be
 = 
NULL
;

2239 
Sn
* 

 = 
rge_
.
nm
.
	`xt
(
y_
);

2240 

 !&
rge_
.
nm
;

2241 

 = sn->
	`xt
(
y_
)) {

2242 i(

->
ngth
 >
n
) {

2243 i((
be
 =
NULL
)

2244 || (

->
ngth
 < 
be
->length)

2245 || ((

->
ngth
 =
be
->ngth&& (->
t
 < best->start))) {

2246 
be
 = 

;

2247 
om_ad
 = 
l
;

2253 
Sn
* 

 = 
rge_
.
tued
.
	`xt
(
y_
);

2254 

 !&
rge_
.
tued
;

2255 

 = sn->
	`xt
(
y_
)) {

2256 i(

->
ngth
 >
n
) {

2257 i((
be
 =
NULL
)

2258 || (

->
ngth
 < 
be
->length)

2259 || ((

->
ngth
 =
be
->ngth&& (->
t
 < best->start))) {

2260 
be
 = 

;

2261 
om_ad
 = 
ue
;

2266 i(
be
 !
NULL
) {

2267 
	`Cve
(
be
, 
n
, 
om_ad
);

2268 #i
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY


2271 
	`ASSERT
(
_commd_ges_
 >
n
);

2272 
_commd_ges_
 -
n
;

2273 i(
_commd_ges_
 < 
m__commd_ges_s_ϡ_svge_
)

2274 
m__commd_ges_s_ϡ_svge_
 = 
_commd_ges_
;

2276 
	`ASSERT
(
	`Check
());

2277 
_ges_
 -
n
;

2278  
be
;

2280  
NULL
;

2281 
	}
}

2283 
Sn
* 
	gTCMloc_PageHp
::
	$S
(
Sn
* 

, 
Lgth
 
n
) {

2284 
	`ASSERT
(0 < 
n
);

2285 
	`ASSERT
(
n
 < 

->
ngth
);

2286 
	`ASSERT
(!

->

);

2287 
	`ASSERT
(

->
sizeass
 == 0);

2288 
	`Evt
(

, 'T', 
n
);

2290 cڡ 
Lgth
 
exa
 = 

->
ngth
 - 
n
;

2291 
Sn
* 
ov
 = 
	`NewSn
(

->
t
 + 
n
, 
exa
);

2292 
	`Evt
(
ov
, 'U', 
exa
);

2293 
	`RecdSn
(
ov
);

2294 
gem_
.
	`t
(

->
t
 + 
n
 - 1, span);

2295 

->
ngth
 = 
n
;

2297  
ov
;

2298 
	}
}

2300 
le
 
	gTCMloc_PageHp
::
	$Cve
(
Sn
* 

, 
Lgth
 
n
, 
bo
 
ad
) {

2301 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

2302 
	`ASSERT
(
n
 > 0);

2303 
	`DLL_Remove
(

, 
y_
);

2304 

->

 = 0;

2305 
	`Evt
(

, 'A', 
n
);

2307 i(
ad
) {

2309 
	`ASSERT
(

->
decommd
);

2310 
	`TCMloc_SyemComm
(
t_
<*>(

->
t
 << 
kPageShi
), 
ic_
<
size_t
>(->
ngth
 << kPageShift));

2311 

->
decommd
 = 
l
;

2312 #i
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY


2313 
_commd_ges_
 +

->
ngth
;

2317 cڡ 
exa
 = 
ic_
<>(

->
ngth
 - 
n
);

2318 
	`ASSERT
(
exa
 >= 0);

2319 i(
exa
 > 0) {

2320 
Sn
* 
ov
 = 
	`NewSn
(

->
t
 + 
n
, 
exa
);

2321 
ov
->

 = 1;

2322 
ov
->
decommd
 = 
l
;

2323 
	`Evt
(
ov
, 'S', 
exa
);

2324 
	`RecdSn
(
ov
);

2327 
SnLi
* 
li
 = (
ic_
<
size_t
>(
exa
< 
kMaxPages
? &
_
[exa] : &
rge_
;

2328 
Sn
* 
d
 = &
li
->
nm
;

2329 
	`DLL_Pnd
(
d
, 
ov
, 
y_
);

2331 

->
ngth
 = 
n
;

2332 
gem_
.
	`t
(

->
t
 + 
n
 - 1, span);

2334 
	}
}

2336 
ALWAYS_INLINE
 
	$mgeDecommdSs
(
Sn
* 
dei
, Sn* 
h
)

2338 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

2339 i(
dei
->
decommd
 && !
h
->decommitted) {

2340 
	`TCMloc_SyemR
(
t_
<*>(
h
->
t
 << 
kPageShi
),

2341 
ic_
<
size_t
>(
h
->
ngth
 << 
kPageShi
));

2342 } i(
h
->
decommd
 && !
dei
->decommitted) {

2343 
	`TCMloc_SyemR
(
t_
<*>(
dei
->
t
 << 
kPageShi
),

2344 
ic_
<
size_t
>(
dei
->
ngth
 << 
kPageShi
));

2345 
dei
->
decommd
 = 
ue
;

2347 
	}
}

2349 
le
 
	gTCMloc_PageHp
::
	$De
(
Sn
* 

) {

2350 
	`ASSERT
(
	`Check
());

2351 
	`ASSERT
(!

->

);

2352 
	`ASSERT
(

->
ngth
 > 0);

2353 
	`ASSERT
(
	`GDest
(

->
t
) == span);

2354 
	`ASSERT
(
	`GDest
(

->
t
 + sn->
ngth
 - 1) == span);

2355 

->
sizeass
 = 0;

2356 #ide
NO_TCMALLOC_SAMPLES


2357 

->
me
 = 0;

2364 #i
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY


2366 
Lgth
 
ighbܚgCommdSnsLgth
 = 0;

2368 cڡ 
PageID
 
p
 = 

->
t
;

2369 cڡ 
Lgth
 
n
 = 

->
ngth
;

2370 
Sn
* 
ev
 = 
	`GDest
(
p
-1);

2371 i(
ev
 !
NULL
 &&v->

) {

2373 
	`ASSERT
(
ev
->
t
 +v->
ngth
 =
p
);

2374 cڡ 
Lgth
 
n
 = 
ev
->
ngth
;

2375 #i
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY


2376 i(!
ev
->
decommd
)

2377 
ighbܚgCommdSnsLgth
 +
n
;

2379 
	`mgeDecommdSs
(

, 
ev
);

2380 
	`DLL_Remove
(
ev
, 
y_
);

2381 
	`DeSn
(
ev
);

2382 

->
t
 -
n
;

2383 

->
ngth
 +
n
;

2384 
gem_
.
	`t
(

->
t
, span);

2385 
	`Evt
(

, 'L', 
n
);

2387 
Sn
* 
xt
 = 
	`GDest
(
p
+
n
);

2388 i(
xt
 !
NULL
 &&ext->

) {

2390 
	`ASSERT
(
xt
->
t
 =
p
+
n
);

2391 cڡ 
Lgth
 
n
 = 
xt
->
ngth
;

2392 #i
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY


2393 i(!
xt
->
decommd
)

2394 
ighbܚgCommdSnsLgth
 +
n
;

2396 
	`mgeDecommdSs
(

, 
xt
);

2397 
	`DLL_Remove
(
xt
, 
y_
);

2398 
	`DeSn
(
xt
);

2399 

->
ngth
 +
n
;

2400 
gem_
.
	`t
(

->
t
 + sn->
ngth
 - 1, span);

2401 
	`Evt
(

, 'R', 
n
);

2404 
	`Evt
(

, 'D', sn->
ngth
);

2405 

->

 = 1;

2406 i(

->
decommd
) {

2407 i(

->
ngth
 < 
kMaxPages
)

2408 
	`DLL_Pnd
(&
_
[

->
ngth
].
tued
, sn, 
y_
);

2410 
	`DLL_Pnd
(&
rge_
.
tued
, 

, 
y_
);

2412 i(

->
ngth
 < 
kMaxPages
)

2413 
	`DLL_Pnd
(&
_
[

->
ngth
].
nm
, sn, 
y_
);

2415 
	`DLL_Pnd
(&
rge_
.
nm
, 

, 
y_
);

2417 
_ges_
 +
n
;

2419 #i
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY


2420 i(

->
decommd
) {

2423 
_commd_ges_
 -
ighbܚgCommdSnsLgth
;

2424 i(
_commd_ges_
 < 
m__commd_ges_s_ϡ_svge_
)

2425 
m__commd_ges_s_ϡ_svge_
 = 
_commd_ges_
;

2428 
_commd_ges_
 +
n
;

2432 
	`siglSvg
();

2434 
	`InemlSvge
(
n
);

2437 
	`ASSERT
(
	`Check
());

2438 
	}
}

2440 #i!
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY


2441 
	gTCMloc_PageHp
::
	$InemlSvge
(
Lgth
 
n
) {

2442 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

2444 
svge_cou_
 -
n
;

2445 i(
svge_cou_
 >= 0) ;

2447 #i
	`PLATFORM
(
IOS
)

2448 cڡ 
size_t
 
kDeuRDay
 = 64;

2452 cڡ 
size_t
 
kDeuRDay
 = 1 << 8;

2456 
size_t
 
dex
 = 
svge_dex_
 + 1;

2457 
u_t
 
y
 = 
y_
;

2458 
size_t
 
i
 = 0; i < 
kMaxPages
+1; i++) {

2459 i(
dex
 > 
kMaxPages
) index = 0;

2460 
SnLi
* 
i
 = (
dex
 =
kMaxPages
? &
rge_
 : &
_
[index];

2461 i(!
	`DLL_IsEmy
(&
i
->
nm
, 
y
)) {

2463 
Sn
* 
s
 = 
i
->
nm
.
	`ev
(
y
);

2464 
	`DLL_Remove
(
s
, 
y_
);

2465 
	`TCMloc_SyemR
(
t_
<*>(
s
->
t
 << 
kPageShi
),

2466 
ic_
<
size_t
>(
s
->
ngth
 << 
kPageShi
));

2467 
s
->
decommd
 = 
ue
;

2468 
	`DLL_Pnd
(&
i
->
tued
, 
s
, 
y
);

2470 #i
	`PLATFORM
(
IOS
)

2471 
svge_cou_
 = 
d
::
max
<
size_t
>(16UL, std::
m
<size_t>(
kDeuRDay
, kDeuRDay - (
_ges_
 / kDefaultReleaseDelay)));

2473 
svge_cou_
 = 
d
::
max
<
size_t
>(64UL, std::
m
<size_t>(
kDeuRDay
, kDeuRDay - (
_ges_
 / kDefaultReleaseDelay)));

2476 i(
dex
 =
kMaxPages
 && !
	`DLL_IsEmy
(&
i
->
nm
, 
y
))

2477 
svge_dex_
 = 
dex
 - 1;

2479 
svge_dex_
 = 
dex
;

2482 
dex
++;

2486 
svge_cou_
 = 
kDeuRDay
;

2487 
	}
}

2490 
	gTCMloc_PageHp
::
	$RegiSizeCss
(
Sn
* 

, 
size_t
 
sc
) {

2492 
	`ASSERT
(!

->

);

2493 
	`ASSERT
(
	`GDest
(

->
t
) == span);

2494 
	`ASSERT
(
	`GDest
(

->
t
+->
ngth
-1) == span);

2495 
	`Evt
(

, 'C', 
sc
);

2496 

->
sizeass
 = 
ic_
<>(
sc
);

2497 
Lgth
 
i
 = 1; i < 

->
ngth
-1; i++) {

2498 
gem_
.
	`t
(

->
t
+
i
, span);

2500 
	}
}

2502 #ifde
WTF_CHANGES


2503 
size_t
 
	gTCMloc_PageHp
::
	$RuedBys
() const {

2504 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

2505 
size_t
 
su
 = 0;

2506 
s
 = 0; s < 
kMaxPages
; s++) {

2507 cڡ 
r_ngth
 = 
	`DLL_Lgth
(&
_
[
s
].
tued
, 
y_
);

2508 
r_ges
 = 
s
 * 
r_ngth
;

2509 
su
 +
r_ges
 << 
kPageShi
;

2512 
Sn
* 
s
 = 
rge_
.
tued
.
	`xt
(
y_
); s != &large_.returned; s = s->next(entropy_))

2513 
su
 +
s
->
ngth
 << 
kPageShi
;

2514  
su
;

2515 
	}
}

2518 #ide
WTF_CHANGES


2519 
	$PagesToMB
(
ut64_t
 
ges
) {

2520 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

2521  (
ges
 << 
kPageShi
) / 1048576.0;

2522 
	}
}

2524 
	gTCMloc_PageHp
::
	$Dump
(
TCMloc_Prr
* 
out
) {

2525 
nemy_sizes
 = 0;

2526 
s
 = 0; s < 
kMaxPages
; s++) {

2527 i(!
	`DLL_IsEmy
(&
_
[
s
].
nm
|| !DLL_IsEmy(&_[s].
tued
)) {

2528 
nemy_sizes
++;

2531 
out
->
	`tf
("------------------------------------------------\n");

2532 
out
->
	`tf
("PageHeap: %d sizes; %6.1f MB free\n",

2533 
nemy_sizes
, 
	`PagesToMB
(
_ges_
));

2534 
out
->
	`tf
("------------------------------------------------\n");

2535 
ut64_t
 
tٮ_nm
 = 0;

2536 
ut64_t
 
tٮ_tued
 = 0;

2537 
s
 = 0; s < 
kMaxPages
; s++) {

2538 cڡ 
n_ngth
 = 
	`DLL_Lgth
(&
_
[
s
].
nm
);

2539 cڡ 
r_ngth
 = 
	`DLL_Lgth
(&
_
[
s
].
tued
);

2540 i(
n_ngth
 + 
r_ngth
 > 0) {

2541 
ut64_t
 
n_ges
 = 
s
 * 
n_ngth
;

2542 
ut64_t
 
r_ges
 = 
s
 * 
r_ngth
;

2543 
tٮ_nm
 +
n_ges
;

2544 
tٮ_tued
 +
r_ges
;

2545 
out
->
	`tf
("%6uages * %6u spans ~ %6.1f MB; %6.1f MB cum"

2547 
s
,

2548 (
n_ngth
 + 
r_ngth
),

2549 
	`PagesToMB
(
n_ges
 + 
r_ges
),

2550 
	`PagesToMB
(
tٮ_nm
 + 
tٮ_tued
),

2551 
	`PagesToMB
(
r_ges
),

2552 
	`PagesToMB
(
tٮ_tued
));

2556 
ut64_t
 
n_ges
 = 0;

2557 
ut64_t
 
r_ges
 = 0;

2558 
n_s
 = 0;

2559 
r_s
 = 0;

2560 
out
->
	`tf
("Normalarge spans:\n");

2561 
Sn
* 
s
 = 
rge_
.
nm
.
xt
; s != &large_.normal; s = s->next) {

2562 
out
->
	`tf
(" [ %6" 
PRIuS
 "ages ] %6.1f MB\n",

2563 
s
->
ngth
, 
	`PagesToMB
(s->length));

2564 
n_ges
 +
s
->
ngth
;

2565 
n_s
++;

2567 
out
->
	`tf
("Unmappedarge spans:\n");

2568 
Sn
* 
s
 = 
rge_
.
tued
.
xt
; s != &large_.returned; s = s->next) {

2569 
out
->
	`tf
(" [ %6" 
PRIuS
 "ages ] %6.1f MB\n",

2570 
s
->
ngth
, 
	`PagesToMB
(s->length));

2571 
r_ges
 +
s
->
ngth
;

2572 
r_s
++;

2574 
tٮ_nm
 +
n_ges
;

2575 
tٮ_tued
 +
r_ges
;

2576 
out
->
	`tf
(">255arge * %6u spans ~ %6.1f MB; %6.1f MB cum"

2578 (
n_s
 + 
r_s
),

2579 
	`PagesToMB
(
n_ges
 + 
r_ges
),

2580 
	`PagesToMB
(
tٮ_nm
 + 
tٮ_tued
),

2581 
	`PagesToMB
(
r_ges
),

2582 
	`PagesToMB
(
tٮ_tued
));

2583 
	}
}

2586 
bo
 
	gTCMloc_PageHp
::
	$GrowHp
(
Lgth
 
n
) {

2587 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

2588 
	`ASSERT
(
kMaxPages
 >
kMSyemAoc
);

2589 i(
n
 > 
kMaxVidPages
 
l
;

2590 
Lgth
 
ask
 = (
n
>
kMSyemAoc
? : 
ic_
<Length>(kMinSystemAlloc);

2591 
size_t
 
au_size
;

2592 * 
r
 = 
	`TCMloc_SyemAoc
(
ask
 << 
kPageShi
, &
au_size
, 
kPageSize
);

2593 i(
r
 =
NULL
) {

2594 i(
n
 < 
ask
) {

2596 
ask
 = 
n
;

2597 
r
 = 
	`TCMloc_SyemAoc
(
ask
 << 
kPageShi
, &
au_size
, 
kPageSize
);

2599 i(
r
 =
NULL
 
l
;

2601 
ask
 = 
au_size
 >> 
kPageShi
;

2603 
ut64_t
 
d_syem_bys
 = 
syem_bys_
;

2604 
syem_bys_
 +(
ask
 << 
kPageShi
);

2605 cڡ 
PageID
 
p
 = 
t_
<
u_t
>(
r
>> 
kPageShi
;

2606 
	`ASSERT
(
p
 > 0);

2612 i(
d_syem_bys
 < 
kPageMBigAotiThshd


2613 && 
syem_bys_
 >
kPageMBigAotiThshd
) {

2614 
gem_
.
	`PloMeMemy
();

2620 i(
gem_
.
	`Ensu
(
p
-1, 
ask
+2)) {

2625 
Sn
* 

 = 
	`NewSn
(
p
, 
ask
);

2626 
	`RecdSn
(

);

2627 
	`De
(

);

2628 
	`ASSERT
(
	`Check
());

2629  
ue
;

2633  
l
;

2635 
	}
}

2637 
bo
 
	gTCMloc_PageHp
::
	$Check
() {

2638 #i
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY


2639 
size_t
 
tٮFeCommd
 = 0;

2641 
	`ASSERT
(
_
[0].
nm
.
	`xt
(
y_
) == &free_[0].normal);

2642 
	`ASSERT
(
_
[0].
tued
.
	`xt
(
y_
) == &free_[0].returned);

2643 #i
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY


2644 
tٮFeCommd
 = 
	`CheckLi
(&
rge_
.
nm
, 
kMaxPages
, 1000000000, 
l
);

2646 
	`CheckLi
(&
rge_
.
nm
, 
kMaxPages
, 1000000000, 
l
);

2648 
	`CheckLi
(&
rge_
.
tued
, 
kMaxPages
, 1000000000, 
ue
);

2649 
Lgth
 
s
 = 1; s < 
kMaxPages
; s++) {

2650 #i
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY


2651 
tٮFeCommd
 +
	`CheckLi
(&
_
[
s
].
nm
, s, s, 
l
);

2653 
	`CheckLi
(&
_
[
s
].
nm
, s, s, 
l
);

2655 
	`CheckLi
(&
_
[
s
].
tued
, s, s, 
ue
);

2657 #i
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY


2658 
	`ASSERT
(
tٮFeCommd
 =
_commd_ges_
);

2660  
ue
;

2661 
	}
}

2663 #i
ASSERT_DISABLED


2664 
size_t
 
	gTCMloc_PageHp
::
	$CheckLi
(
Sn
*, 
Lgth
, Lgth, 
bo
) {

2666 
	}
}

2668 
size_t
 
	gTCMloc_PageHp
::
	$CheckLi
(
Sn
* 
li
, 
Lgth
 
m_ges
, Lgth 
max_ges
, 
bo
 
decommd
) {

2669 
size_t
 
Cou
 = 0;

2670 
Sn
* 
s
 = 
li
->
	`xt
(
y_
); s !=ist; s = s->next(entropy_)) {

2671 
	`CHECK_CONDITION
(
s
->

);

2672 
	`CHECK_CONDITION
(
s
->
ngth
 >
m_ges
);

2673 
	`CHECK_CONDITION
(
s
->
ngth
 <
max_ges
);

2674 
	`CHECK_CONDITION
(
	`GDest
(
s
->
t
) == s);

2675 
	`CHECK_CONDITION
(
	`GDest
(
s
->
t
+s->
ngth
-1) == s);

2676 
	`CHECK_CONDITION
(
s
->
decommd
 == decommitted);

2677 
Cou
 +
s
->
ngth
;

2679  
Cou
;

2680 
	}
}

2683 
	gTCMloc_PageHp
::
	$RFeLi
(
Sn
* 
li
, Sn* 
tued
) {

2684 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

2687 #i
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY


2688 
size_t
 
PageRedui
 = 0;

2691 !
	`DLL_IsEmy
(
li
, 
y_
)) {

2692 
Sn
* 
s
 = 
li
->
	`ev
(
y_
);

2694 
	`DLL_Remove
(
s
, 
y_
);

2695 
s
->
decommd
 = 
ue
;

2696 
	`DLL_Pnd
(
tued
, 
s
, 
y_
);

2697 
	`TCMloc_SyemR
(
t_
<*>(
s
->
t
 << 
kPageShi
),

2698 
ic_
<
size_t
>(
s
->
ngth
 << 
kPageShi
));

2699 #i
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY


2700 
PageRedui
 +
s
->
ngth
;

2704 #i
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY


2705 
_commd_ges_
 -
PageRedui
;

2706 i(
_commd_ges_
 < 
m__commd_ges_s_ϡ_svge_
)

2707 
m__commd_ges_s_ϡ_svge_
 = 
_commd_ges_
;

2709 
	}
}

2711 
	gTCMloc_PageHp
::
	$RFePages
() {

2712 
Lgth
 
s
 = 0; s < 
kMaxPages
; s++) {

2713 
	`RFeLi
(&
_
[
s
].
nm
, &_[s].
tued
);

2715 
	`RFeLi
(&
rge_
.
nm
, &rge_.
tued
);

2716 
	`ASSERT
(
	`Check
());

2717 
	}
}

2723 as
	cTCMloc_ThadCache_FeLi
 {

2724 
	give
:

2725 
HdedSLL
 
li_
;

2726 
ut16_t
 
	gngth_
;

2727 
ut16_t
 
	glow_
;

2728 
u_t
 
	gy_
;

2730 
	gpublic
:

2731 
In
(
u_t
 
y
) {

2732 
li_
.
tVue
(
NULL
);

2733 
	gngth_
 = 0;

2734 
	glow_
 = 0;

2735 
	gy_
 = 
y
;

2736 #i
ENABLE
(
TCMALLOC_HARDENING
)

2737 
ASSERT
(
y_
);

2742 
ngth
() const {

2743  
	gngth_
;

2747 
bo
 
emy
() const {

2748  !
	gli_
;

2752 
lowwmk
(cڡ {  
	glow_
; }

2753 
r_lowwmk
({ 
	glow_
 = 
ngth_
; }

2755 
ALWAYS_INLINE
 
Push
(
HdedSLL
 
r
) {

2756 
SLL_Push
(&
li_
, 
r
, 
y_
);

2757 
	gngth_
++;

2760 
PushRge
(
N
, 
HdedSLL
 
t
, HdedSLL 
d
) {

2761 
SLL_PushRge
(&
li_
, 
t
, 
d
, 
y_
);

2762 
	gngth_
 = 
ngth_
 + 
ic_
<
ut16_t
>(
N
);

2765 
PRge
(
N
, 
HdedSLL
* 
t
, HdedSLL* 
d
) {

2766 
SLL_PRge
(&
li_
, 
N
, 
t
, 
d
, 
y_
);

2767 
ASSERT
(
ngth_
 >
N
);

2768 
	gngth_
 = 
ngth_
 - 
ic_
<
ut16_t
>(
N
);

2769 i(
	gngth_
 < 
	glow_
low_ = 
ngth_
;

2772 
ALWAYS_INLINE
 * 
P
() {

2773 
ASSERT
(
li_
);

2774 
	gngth_
--;

2775 i(
	gngth_
 < 
	glow_
low_ = 
ngth_
;

2776  
SLL_P
(&
li_
, 
y_
).
vue
();

2782 
NEVER_INLINE
 
Vide
(
HdedSLL
 
missg
, 
size_t
 
size
) {

2783 
HdedSLL
 
	gnode
 = 
li_
;

2784 
UNUSED_PARAM
(
size
);

2785 
	gnode
) {

2786 
RELEASE_ASSERT
(
node
 !
missg
);

2787 
RELEASE_ASSERT
(
IS_DEFINITELY_POISONED
(
node
.
vue
(), 
size
));

2788 
	gnode
 = 
SLL_Next
(
node
, 
y_
);

2792 #ifde
WTF_CHANGES


2793 
	gme
 <
ass
 
	gFd
, cs
	gRd
>

2794 
umeFeObjes
(
Fd
& 
fd
, cڡ 
Rd
& 
ad
)

2796 
HdedSLL
 
	gxtObje
 = 
li_
;extObje;extObje.
tVue
(
ad
.
xtEryInHdedLkedLi
(
t_
<**>(
xtObje
.
vue
()), 
y_
)))

2797 
	gfd
.
vis
(
xtObje
.
vue
());

2806 as
	cTCMloc_ThadCache
 {

2807 
	give
:

2808 
TCMloc_ThadCache_FeLi
 
	tFeLi
;

2809 #i
OS
(
WINDOWS
)

2810 
DWORD
 
	tThadIdtifr
;

2812 
had_t
 
	tThadIdtifr
;

2815 
size_t
 
	gsize_
;

2816 
ThadIdtifr
 
	gtid_
;

2817 
bo
 
	g_tecific_
;

2818 
FeLi
 
	gli_
[
K_NUM_CLASSES_MAX
];

2821 
ut32_t
 
	gd_
;

2822 
size_t
 
	gbys_u_me_
;

2824 
u_t
 
	gy_
;

2827 
le
 
TCMloc_ThadCache
* 
NewHp
(
ThadIdtifr
 
tid
, 
u_t
 
y
);

2830 
DeroyThadCache
(* 
r
);

2831 
	gpublic
:

2833 
TCMloc_ThadCache
* 
xt_
;

2834 
TCMloc_ThadCache
* 
	gev_
;

2836 
In
(
ThadIdtifr
 
tid
, 
u_t
 
y
);

2837 
C˪up
();

2840 
li_ngth
(
size_t
 

cڡ {  
	gli_
[].
ngth
(); }

2843 
size_t
 
Size
(cڡ {  
	gsize_
; }

2845 
ALWAYS_INLINE
 * 
Ao
(
size_t
 
size
);

2846 
Do
(
HdedSLL
 
r
, 
size_t
 
size_ass
);

2848 
ALWAYS_INLINE
 
FchFromCCache
(
size_t
 

, size_
lotiSize
);

2849 
RToCCache
(
size_t
 

, 
N
);

2850 
Svge
();

2851 
Prt
() const;

2855 
bo
 
SameAoti
(
size_t
 
k
);

2858 
PickNextSame
(
size_t
 
k
);

2860 
InModu
();

2861 
InTSD
();

2862 
TCMloc_ThadCache
* 
GThadHp
();

2863 
TCMloc_ThadCache
* 
GCache
();

2864 
TCMloc_ThadCache
* 
GCacheIfP
();

2865 
TCMloc_ThadCache
* 
CeCacheIfNesry
();

2866 
DeCache
(
TCMloc_ThadCache
* 
hp
);

2867 
BecomeId
();

2868 
RecompuThadCacheSize
();

2870 #ifde
WTF_CHANGES


2871 
	gme
 <
ass
 
	gFd
, cs
	gRd
>

2872 
umeFeObjes
(
Fd
& 
fd
, cڡ 
Rd
& 
ad
)

2874 
ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

2875 
	gsizeCss
 = 0; sizeCs< 
	gkNumCss
; sizeClass++)

2876 
	gli_
[
sizeCss
].
umeFeObjes
(
fd
, 
ad
);

2887 
TCMloc_C_FeLiPadded
 
	gl_che
[
K_NUM_CLASSES_MAX
];

2890 
AocAlignmtIeg
 
	ggehp_memy
[((
TCMloc_PageHp
) + (AllocAlignmentInteger) - 1) / (AllocAlignmentInteger)];

2891 
bo
 
	gphed
 = 
l
;

2896 * 
	gm_memy
;

2897 
TCMloc_PageHp
* 
	gm_geHp
;

2898 } 
	tPageHpUni
;

2900 
le
 
TCMloc_PageHp
* 
	$gPageHp
()

2902 
PageHpUni
 
u
 = { &
gehp_memy
[0] };

2903  
u
.
m_geHp
;

2904 
	}
}

2906 
	#gehp
 
	$gPageHp
()

	)

2908 
size_t
 
	$MlocGoodSize
(
size_t
 
bys
)

2910 i(!
phed
)

2911 
TCMloc_ThadCache
::
	`InModu
();

2912  
	`AotiSize
(
bys
);

2913 
	}
}

2915 #i
USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY


2917 #i
HAVE
(
DISPATCH_H
|| 
	$OS
(
WINDOWS
)

2919 
TCMloc_PageHp
::
	$riodicSvge
()

2921 
SpLockHd
 
	`h
(&
gehp_lock
);

2922 
gehp
->
	`svge
();

2924 i(
	`shouldSvge
()) {

2925 
	`scheduSvg
();

2929 
	`sudSvg
();

2930 
	}
}

2932 
ALWAYS_INLINE
 
	gTCMloc_PageHp
::
	$siglSvg
()

2934 
	`ASSERT
(
gehp_lock
.
	`IsHd
());

2935 i(
	`isSvgSuded
(&& 
	`shouldSvge
())

2936 
	`scheduSvg
();

2937 
	}
}

2941 
	gTCMloc_PageHp
::
	$svgThad
()

2943 #i
	`HAVE
(
PTHREAD_SETNAME_NP
)

2944 
	`had_ame_
("JavaScriptCore: FastMalloc scavenger");

2948 
gehp_lock
.
	`Lock
();

2949 i(!
	`shouldSvge
()) {

2951 
m_svgeThadAive
 = 
l
;

2954 
gehp_lock
.
	`Uock
();

2957 
	`had_mux_lock
(&
m_svgeMux
);

2958 
	`had_cd_wa
(&
m_svgeCdi
, &
m_svgeMux
);

2961 
	`had_mux_uock
(&
m_svgeMux
);

2964 
m_svgeThadAive
 = 
ue
;

2966 
gehp_lock
.
	`Uock
();

2969 
	`p
(
kSvgeDayInSecds
);

2972 
SpLockHd
 
	`h
(&
gehp_lock
);

2973 
gehp
->
	`svge
();

2976 
	}
}

2989 #ifde
HAVE_TLS


2990 
__thad
 
TCMloc_ThadCache
 *
	gthadlol_hp
;

2997 
bo
 
	gtsd_ed
 = 
l
;

2998 #i
	$USE
(
PTHREAD_GETSPECIFIC_DIRECT
)

2999 cڡ 
had_key_t
 
hp_key
 = 
__PTK_FRAMEWORK_JAVASCRIPTCORE_KEY0
;

3001 
ThadScificKey
 
hp_key
;

3004 
ALWAYS_INLINE
 
	$tThadHp
(
TCMloc_ThadCache
* 
hp
)

3006 #i
	`USE
(
PTHREAD_GETSPECIFIC_DIRECT
)

3009 i(
	`had_gecific
(
hp_key
))

3010 
	`CRASH
();

3013 #i
	`OS
(
DARWIN
)

3016 
	`had_tecific
(
hp_key
, 
hp
);

3018 
	`thadScificS
(
hp_key
, 
hp
);

3020 
	}
}

3023 
	gPageHpAot
<
	gTCMloc_ThadCache
> 
	gthadhp_lot
;

3026 
TCMloc_ThadCache
* 
	gthad_hps
 = 
NULL
;

3027 
	gthad_hp_cou
 = 0;

3030 
size_t
 
	govl_thad_che_size
 = 
kDeuOvlThadCacheSize
;

3036 vީ
size_t
 
	gr_thad_che_size
 = 
kMaxThadCacheSize
;

3042 
	gTCMloc_C_FeLi
::
	$In
(
size_t
 

, 
u_t
 
y
) {

3043 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

3044 
lock_
.
	`In
();

3045 
size_ass_
 = 

;

3046 
y_
 = 
y
;

3047 #i
	`ENABLE
(
TCMALLOC_HARDENING
)

3048 
	`ASSERT
(
y_
);

3050 
	`DLL_In
(&
emy_
, 
y_
);

3051 
	`DLL_In
(&
nemy_
, 
y_
);

3052 
cou_
 = 0;

3054 
che_size_
 = 1;

3055 
ud_s_
 = 0;

3056 
	`ASSERT
(
che_size_
 <
kNumTnsrErs
);

3057 
	}
}

3059 
	gTCMloc_C_FeLi
::
	$RLiToSns
(
HdedSLL
 
t
) {

3060 
t
) {

3061 
HdedSLL
 
xt
 = 
	`SLL_Next
(
t
, 
y_
);

3062 
	`RToSns
(
t
);

3063 
t
 = 
xt
;

3065 
	}
}

3067 
ALWAYS_INLINE
 
	gTCMloc_C_FeLi
::
	$RToSns
(
HdedSLL
 
obje
) {

3068 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

3069 cڡ 
PageID
 
p
 = 
t_
<
u_t
>(
obje
.
	`vue
()>> 
kPageShi
;

3070 
Sn
* 

 = 
gehp
->
	`GDest
(
p
);

3071 
	`ASSERT
(

 !
NULL
);

3072 
	`ASSERT
(

->
fcou
 > 0);

3075 i(!

->
objes
) {

3076 
	`DLL_Remove
(

, 
y_
);

3077 
	`DLL_Pnd
(&
nemy_
, 

, 
y_
);

3078 
	`Evt
(

, 'N', 0);

3082 i(
l
) {

3084 
g
 = 0;

3085 
HdedSLL
 
p
 = 

->
objes
; !p; 
	`SLL_Next
, 
y_
)) {

3086 
	`ASSERT
(
p
.
	`vue
(!
obje
.value());

3087 
g
++;

3089 
	`ASSERT
(
g
 + 

->
fcou
 ==

3090 (

->
ngth
<<
kPageShi
)/
	`BySizeFCss
(->
sizeass
));

3093 
cou_
++;

3094 

->
fcou
--;

3095 i(

->
fcou
 == 0) {

3096 
	`Evt
(

, '#', 0);

3097 
cou_
 -(

->
ngth
<<
kPageShi
/ 
	`BySizeFCss
(->
sizeass
);

3098 
	`DLL_Remove
(

, 
y_
);

3101 
lock_
.
	`Uock
();

3103 
SpLockHd
 
	`h
(&
gehp_lock
);

3104 
gehp
->
	`De
(

);

3106 
lock_
.
	`Lock
();

3108 
	`SLL_SNext
(
obje
, 

->
objes
, 
y_
);

3109 

->
objes
.
	`tVue
(
obje
.
	`vue
());

3111 
	}
}

3113 
ALWAYS_INLINE
 
bo
 
	gTCMloc_C_FeLi
::
	$EviRdomSizeCss
(

3114 
size_t
 
locked_size_ass
, 
bo
 
f
) {

3115 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

3116 
_cou
 = 0;

3117 
t
 = 
_cou
++;

3118 i(
t
 >
ic_
<>(
kNumCss
)) {

3119 
t
 >
ic_
<>(
kNumCss
)) {

3120 
t
 -
kNumCss
;

3122 
_cou
 = 
t
;

3124 
	`ASSERT
(
t
 >= 0);

3125 
	`ASSERT
(
t
 < 
ic_
<>(
kNumCss
));

3126 i(
t
 =
ic_
<>(
locked_size_ass
) 
l
;

3127  
l_che
[
t
].
	`ShrkCache
(
ic_
<>(
locked_size_ass
), 
f
);

3128 
	}
}

3130 
bo
 
	gTCMloc_C_FeLi
::
	$MakeCacheS
() {

3131 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

3133 i(
ud_s_
 < 
che_size_
 
ue
;

3135 i(
che_size_
 =
kNumTnsrErs
 
l
;

3137 i(
	`EviRdomSizeCss
(
size_ass_
, 
l
) ||

3138 
	`EviRdomSizeCss
(
size_ass_
, 
ue
)) {

3140 
che_size_
++;

3141  
ue
;

3143  
l
;

3144 
	}
}

3147 
	gmea
 {

3148 as
	cLockInvr
 {

3149 
	give
:

3150 
SpLock
 *
hd_
, *
	gmp_
;

3151 
	gpublic
:

3152 
le
 
exic
 
LockInvr
(
SpLock
* 
hd
, SpLock *
mp
)

3153 : 
hd_
(
hd
), 
mp_
(
mp
{ 
	ghd_
->
Uock
(); 
	gmp_
->
Lock
(); }

3154 
	gle
 ~
LockInvr
({ 
	gmp_
->
Uock
(); 
	ghd_
->
Lock
(); }

3158 
bo
 
	gTCMloc_C_FeLi
::
	$ShrkCache
(
locked_size_ass
, 
bo
 
f
) {

3160 i(
che_size_
 =0 
l
;

3162 i(
f
 =
l
 && 
ud_s_
 =
che_size_
)  false;

3168 
LockInvr
 
	`li
(&
l_che
[
locked_size_ass
].
lock_
, &lock_);

3169 
	`ASSERT
(
ud_s_
 <
che_size_
);

3170 
	`ASSERT
(0 <
che_size_
);

3171 i(
che_size_
 =0 
l
;

3172 i(
ud_s_
 =
che_size_
) {

3173 i(
f
 =
l
)  false;

3176 
che_size_
--;

3177 
ud_s_
--;

3178 
	`RLiToSns
(
tc_s_
[
ud_s_
].
hd
);

3179  
ue
;

3181 
che_size_
--;

3182  
ue
;

3183 
	}
}

3185 
	gTCMloc_C_FeLi
::
	$InRge
(
HdedSLL
 
t
, HdedSLL 
d
, 
N
) {

3186 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

3187 
SpLockHd
 
	`h
(&
lock_
);

3188 i(
N
 =
num_objes_to_move
[
size_ass_
] &&

3189 
	`MakeCacheS
()) {

3190 

 = 
ud_s_
++;

3191 
	`ASSERT
(

 >=0);

3192 
	`ASSERT
(

 < 
kNumTnsrErs
);

3193 
TCEry
 *
y
 = &
tc_s_
[

];

3194 
y
->
hd
 = 
t
;

3195 
y
->

 = 
d
;

3198 
	`RLiToSns
(
t
);

3199 
	}
}

3201 
ALWAYS_INLINE
 
	gTCMloc_C_FeLi
::
	$RemoveRge
(
HdedSLL
* 
t
, HdedSLL* 
d
, *
N
) {

3202 
num
 = *
N
;

3203 
	`ASSERT
(
num
 > 0);

3205 
SpLockHd
 
	`h
(&
lock_
);

3206 i(
num
 =
num_objes_to_move
[
size_ass_
] && 
ud_s_
 > 0) {

3207 

 = --
ud_s_
;

3208 
	`ASSERT
(

 >= 0);

3209 
TCEry
 *
y
 = &
tc_s_
[

];

3210 *
t
 = 
y
->
hd
;

3211 *
d
 = 
y
->

;

3216 
HdedSLL
 

 = 
	`FchFromSnsSa
();

3217 i(!

) {

3219 *
t
 = *
d
 = 
HdedSLL
::
	`nu
();

3220 *
N
 = 0;

3224 
	`SLL_SNext
(

, 
HdedSLL
::
	`nu
(), 
y_
);

3225 
HdedSLL
 
hd
 = 

;

3226 
cou
 = 1;

3227 
cou
 < 
num
) {

3228 
HdedSLL
 
t
 = 
	`FchFromSns
();

3229 i(!
t
) ;

3230 
	`SLL_Push
(&
hd
, 
t
, 
y_
);

3231 
cou
++;

3233 *
t
 = 
hd
;

3234 *
d
 = 

;

3235 *
N
 = 
cou
;

3236 
	}
}

3239 
ALWAYS_INLINE
 
HdedSLL
 
	gTCMloc_C_FeLi
::
	$FchFromSnsSa
() {

3240 
HdedSLL
 
t
 = 
	`FchFromSns
();

3241 i(!
t
) {

3242 
	`Puϋ
();

3243 
t
 = 
	`FchFromSns
();

3245  
t
;

3246 
	}
}

3248 
HdedSLL
 
	gTCMloc_C_FeLi
::
	$FchFromSns
() {

3249 i(
	`DLL_IsEmy
(&
nemy_
, 
y_
) 
HdedSLL
::
	`nu
();

3250 
Sn
* 

 = 
nemy_
.
	`xt
(
y_
);

3252 
	`ASSERT
(

->
objes
);

3253 
	`ASSERT_SPAN_COMMITTED
(

);

3254 

->
fcou
++;

3255 
HdedSLL
 
su
 = 

->
objes
;

3256 

->
objes
 = 
	`SLL_Next
(
su
, 
y_
);

3257 i(!

->
objes
) {

3259 
	`DLL_Remove
(

, 
y_
);

3260 
	`DLL_Pnd
(&
emy_
, 

, 
y_
);

3261 
	`Evt
(

, 'E', 0);

3263 
cou_
--;

3264  
su
;

3265 
	}
}

3268 
ALWAYS_INLINE
 
	gTCMloc_C_FeLi
::
	$Puϋ
() {

3269 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

3271 
lock_
.
	`Uock
();

3272 cڡ 
size_t
 
ages
 = 
ass_to_ges
[
size_ass_
];

3274 
Sn
* 

;

3276 
SpLockHd
 
	`h
(&
gehp_lock
);

3277 

 = 
gehp
->
	`New
(
ages
);

3278 i(


gehp
->
	`RegiSizeCss
(, 
size_ass_
);

3280 i(

 =
NULL
) {

3281 #i
	`HAVE
(
ERRNO_H
)

3282 
	`MESSAGE
("loti faed: %d\n", 
o
);

3283 #i
	`OS
(
WINDOWS
)

3284 
	`MESSAGE
("loti faed: %d\n", ::
	`GLaE
());

3286 
	`MESSAGE
("allocation failed\n");

3288 
lock_
.
	`Lock
();

3291 
	`ASSERT_SPAN_COMMITTED
(

);

3292 
	`ASSERT
(

->
ngth
 =
ages
);

3296 
size_t
 
i
 = 0; i < 
ages
; i++) {

3297 
gehp
->
	`CacheSizeCss
(

->
t
 + 
i
, 
size_ass_
);

3302 
HdedSLL
 
hd
 = HdedSLL::
	`nu
();

3303 * 
t
 = 
t_
<*>(

-><< 
kPageShi
);

3304 cڡ 
size_t
 
size
 = 
	`BySizeFCss
(
size_ass_
);

3305 * 
r
 = 
t
 + (
ages
 << 
kPageShi
- (ҷge<< kPageShi% 
size
);

3306 
num
 = 0;

3307 #i
	`ENABLE
(
TCMALLOC_HARDENING
)

3308 
ut32_t
 
tPois
 = 
	`dObjeSPois
();

3309 
ut32_t
 
dPois
 = 
	`dObjeEndPois
();

3312 
r
 > 
t
) {

3313 
r
 -
size
;

3314 
HdedSLL
 
node
 = HdedSLL::
	`
(
r
);

3315 
	`POISON_DEALLOCATION_EXPLICIT
(
r
, 
size
, 
tPois
, 
dPois
);

3316 
	`SLL_SNext
(
node
, 
hd
, 
y_
);

3317 
hd
 = 
node
;

3318 
num
++;

3320 
	`ASSERT
(
r
 =
t
);

3321 
	`ASSERT
(
r
 =
hd
.
	`vue
());

3322 #ide
NDEBUG


3324 
HdedSLL
 
node
 = 
hd
;

3325 
node
) {

3326 
	`ASSERT
(
	`IS_DEFINITELY_POISONED
(
node
.
	`vue
(), 
size
));

3327 
node
 = 
	`SLL_Next
ode, 
y_
);

3331 

->
objes
 = 
hd
;

3332 
	`ASSERT
(

->
objes
.
	`vue
(=
hd
.value());

3333 

->
fcou
 = 0;

3336 
lock_
.
	`Lock
();

3337 
	`DLL_Pnd
(&
nemy_
, 

, 
y_
);

3338 
cou_
 +
num
;

3339 
	}
}

3345 
le
 
bo
 
	gTCMloc_ThadCache
::
	$SameAoti
(
size_t
 
k
) {

3346 i(
bys_u_me_
 < 
k
) {

3347 
	`PickNextSame
(
k
);

3348  
ue
;

3350 
bys_u_me_
 -
k
;

3351  
l
;

3353 
	}
}

3355 
	gTCMloc_ThadCache
::
	$In
(
ThadIdtifr
 
tid
, 
u_t
 
y
) {

3356 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

3357 
size_
 = 0;

3358 
xt_
 = 
NULL
;

3359 
ev_
 = 
NULL
;

3360 
tid_
 = 
tid
;

3361 
_tecific_
 = 
l
;

3362 
y_
 = 
y
;

3363 #i
	`ENABLE
(
TCMALLOC_HARDENING
)

3364 
	`ASSERT
(
y_
);

3366 
size_t
 

 = 0; c< 
kNumCss
; ++cl) {

3367 
li_
[

].
	`In
(
y_
);

3371 
bys_u_me_
 = 0;

3372 
d_
 = 
ic_
<
ut32_t
>(
t_
<
u_t
>(
this
));

3373 
i
 = 0; i < 100; i++) {

3374 
	`PickNextSame
(
ic_
<
size_t
>(
FLAGS_tcmloc_me_m
 * 2));

3376 
	}
}

3378 
	gTCMloc_ThadCache
::
	$C˪up
() {

3379 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

3381 
size_t
 

 = 0; c< 
kNumCss
; ++cl) {

3382 i(
li_
[

].
	`ngth
() > 0) {

3383 
	`RToCCache
(

, 
li_
[].
	`ngth
());

3386 
	}
}

3388 
ALWAYS_INLINE
 * 
	gTCMloc_ThadCache
::
	$Ao
(
size_t
 
size
) {

3389 
	`ASSERT
(
size
 <
kMaxSize
);

3390 cڡ 
size_t
 

 = 
	`SizeCss
(
size
);

3391 
FeLi
* 
li
 = &
li_
[

];

3392 
size_t
 
lotiSize
 = 
	`BySizeFCss
(

);

3393 i(
li
->
	`emy
()) {

3394 
	`FchFromCCache
(

, 
lotiSize
);

3395 i(
li
->
	`emy
() 
NULL
;

3397 
size_
 -
lotiSize
;

3398 * 
su
 = 
li
->
	`P
();

3399 i(!
su
)

3401 
	`RELEASE_ASSERT
(
	`IS_DEFINITELY_POISONED
(
su
, 
lotiSize
));

3402 
	`POISON_ALLOCATION
(
su
, 
lotiSize
);

3403  
su
;

3404 
	}
}

3406 
le
 
	gTCMloc_ThadCache
::
	$Do
(
HdedSLL
 
r
, 
size_t
 

) {

3407 
size_t
 
lotiSize
 = 
	`BySizeFCss
(

);

3408 
size_
 +
lotiSize
;

3409 
FeLi
* 
li
 = &
li_
[

];

3410 i(
	`MAY_BE_POISONED
(
r
.
	`vue
(), 
lotiSize
))

3411 
li
->
	`Vide
(
r
, 
lotiSize
);

3413 
	`POISON_DEALLOCATION
(
r
.
	`vue
(), 
lotiSize
);

3414 
li
->
	`Push
(
r
);

3416 i(
li
->
	`ngth
(> 
kMaxFeLiLgth
) {

3417 
	`RToCCache
(

, 
num_objes_to_move
[cl]);

3419 i(
size_
 >
r_thad_che_size

	`Svge
();

3420 
	}
}

3423 
ALWAYS_INLINE
 
	gTCMloc_ThadCache
::
	$FchFromCCache
(
size_t
 

, size_
lotiSize
) {

3424 
tch_cou
 = 
num_objes_to_move
[

];

3425 
HdedSLL
 
t
, 
d
;

3426 
l_che
[

].
	`RemoveRge
(&
t
, &
d
, &
tch_cou
);

3427 
li_
[

].
	`PushRge
(
tch_cou
, 
t
, 
d
);

3428 
size_
 +
lotiSize
 * 
tch_cou
;

3429 
	}
}

3432 
le
 
	gTCMloc_ThadCache
::
	$RToCCache
(
size_t
 

, 
N
) {

3433 
	`ASSERT
(
N
 > 0);

3434 
FeLi
* 
c
 = &
li_
[

];

3435 i(
N
 > 
c
->
	`ngth
()) N = src->length();

3436 
size_
 -
N
*
	`BySizeFCss
(

);

3440 
bch_size
 = 
num_objes_to_move
[

];

3441 
N
 > 
bch_size
) {

3442 
HdedSLL
 

, 
hd
;

3443 
c
->
	`PRge
(
bch_size
, &
hd
, &

);

3444 
l_che
[

].
	`InRge
(
hd
, 

, 
bch_size
);

3445 
N
 -
bch_size
;

3447 
HdedSLL
 

, 
hd
;

3448 
c
->
	`PRge
(
N
, &
hd
, &

);

3449 
l_che
[

].
	`InRge
(
hd
, 

, 
N
);

3450 
	}
}

3453 
le
 
	gTCMloc_ThadCache
::
	$Svge
() {

3454 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

3463 
size_t
 

 = 0; c< 
kNumCss
; cl++) {

3464 
FeLi
* 
li
 = &
li_
[

];

3465 cڡ 
lowmk
 = 
li
->
	`lowwmk
();

3466 i(
lowmk
 > 0) {

3467 cڡ 
dr
 = (
lowmk
 > 1) ?owmark/2 : 1;

3468 
	`RToCCache
(

, 
dr
);

3470 
li
->
	`r_lowwmk
();

3476 
	}
}

3478 
	gTCMloc_ThadCache
::
	$PickNextSame
(
size_t
 
k
) {

3481 cڡ 
ut32_t
 
kPy
 = (1 << 22) | (1 << 2) | (1 << 1) | (1 << 0);

3482 
ut32_t
 
r
 = 
d_
;

3483 
d_
 = (
r
 << 1^ ((
ic_
<
t32_t
>>> 31& 
kPy
);

3487 cڡ 
ag_vue
 = 
ic_
<>(
FLAGS_tcmloc_me_m
);

3488 
ϡ_ag_vue
 = -1;

3490 i(
ag_vue
 !
ϡ_ag_vue
) {

3491 
SpLockHd
 
	`h
(&
me_riod_lock
);

3492 
i
;

3493 
i
 = 0; i < (
ic_
<>((
imes_li
)/(primes_list[0])) - 1); i++) {

3494 i(
imes_li
[
i
] >
ag_vue
) {

3498 
me_riod
 = 
imes_li
[
i
];

3499 
ϡ_ag_vue
 = 
ag_vue
;

3502 
bys_u_me_
 +
d_
 % 
me_riod
;

3504 i(
k
 > (
ic_
<
size_t
>(-1) >> 2)) {

3514 
bys_u_me_
 < 
k
) {

3518 
bys_u_me_
 +(
me_riod
 >> 1);

3521 
bys_u_me_
 -
k
;

3522 
	}
}

3524 
	gTCMloc_ThadCache
::
	$InModu
() {

3531 
SpLockHd
 
	`h
(&
gehp_lock
);

3532 i(!
phed
) {

3533 
u_t
 
y
 = 
HARDENING_ENTROPY
;

3534 #ifde
WTF_CHANGES


3535 
	`InTSD
();

3537 
	`InSizeCss
();

3538 
thadhp_lot
.
	`In
(
y
);

3539 
_lot
.
	`In
(
y
);

3540 
_lot
.
	`New
();

3541 
_lot
.
	`New
();

3542 
acka_lot
.
	`In
(
y
);

3543 
	`DLL_In
(&
med_objes
, 
y
);

3544 
size_t
 
i
 = 0; i < 
kNumCss
; ++i) {

3545 
l_che
[
i
].
	`In
(i, 
y
);

3547 
gehp
->
	`
();

3548 
phed
 = 1;

3549 #i
	`defed
(
WTF_CHANGES
&& 
	`OS
(
DARWIN
)

3550 
MlocHook
::
	`
();

3551 
FaMlocZe
::
	`
();

3554 
	}
}

3556 
le
 
TCMloc_ThadCache
* 
	gTCMloc_ThadCache
::
	$NewHp
(
ThadIdtifr
 
tid
, 
u_t
 
y
) {

3558 
TCMloc_ThadCache
 *
hp
 = 
thadhp_lot
.
	`New
();

3559 
hp
->
	`In
(
tid
, 
y
);

3560 
hp
->
xt_
 = 
thad_hps
;

3561 
hp
->
ev_
 = 
NULL
;

3562 i(
thad_hps
 !
NULL
thad_hps->
ev_
 = 
hp
;

3563 
thad_hps
 = 
hp
;

3564 
thad_hp_cou
++;

3565 
	`RecompuThadCacheSize
();

3566  
hp
;

3567 
	}
}

3569 
le
 
TCMloc_ThadCache
* 
	gTCMloc_ThadCache
::
	$GThadHp
() {

3570 #ifde
HAVE_TLS


3572 i(
	`KlSutsTLS
())

3573  
thadlol_hp
;

3574 #i
	`OS
(
DARWIN
)

3575  
ic_
<
TCMloc_ThadCache
*>(
	`had_gecific
(
hp_key
));

3577  
ic_
<
TCMloc_ThadCache
*>(
	`thadScificG
(
hp_key
));

3579 
	}
}

3581 
le
 
TCMloc_ThadCache
* 
	gTCMloc_ThadCache
::
	$GCache
() {

3582 
TCMloc_ThadCache
* 
r
 = 
NULL
;

3583 i(!
tsd_ed
) {

3584 
	`InModu
();

3586 
r
 = 
	`GThadHp
();

3588 i(
r
 =
NULL
豸
	`CeCacheIfNesry
();

3589  
r
;

3590 
	}
}

3595 
le
 
TCMloc_ThadCache
* 
	gTCMloc_ThadCache
::
	$GCacheIfP
() {

3596 i(!
tsd_ed
 
NULL
;

3597 * cڡ 
p
 = 
	`GThadHp
();

3598  
t_
<
TCMloc_ThadCache
*>(
p
);

3599 
	}
}

3601 
	gTCMloc_ThadCache
::
	$InTSD
() {

3602 
	`ASSERT
(!
tsd_ed
);

3603 #i
	`USE
(
PTHREAD_GETSPECIFIC_DIRECT
)

3604 
	`had_key__
(
hp_key
, 
DeroyThadCache
);

3606 
	`thadScificKeyCe
(&
hp_key
, 
DeroyThadCache
);

3608 
tsd_ed
 = 
ue
;

3610 #i!
	`OS
(
WINDOWS
)

3612 
had_t
 
zo
;

3613 
	`memt
(&
zo
, 0, (zero));

3615 #ide
WTF_CHANGES


3616 
SpLockHd
 
	`h
(&
gehp_lock
);

3618 
	`ASSERT
(
gehp_lock
.
	`IsHd
());

3620 
TCMloc_ThadCache
* 
h
 = 
thad_hps
; h !
NULL
; h = h->
xt_
) {

3621 #i
	`OS
(
WINDOWS
)

3622 i(
h
->
tid_
 == 0) {

3623 
h
->
tid_
 = 
	`GCutThadId
();

3626 i(
	`had_equ
(
h
->
tid_
, 
zo
)) {

3627 
h
->
tid_
 = 
	`had_lf
();

3631 
	}
}

3633 
TCMloc_ThadCache
* 
	gTCMloc_ThadCache
::
	$CeCacheIfNesry
() {

3635 
TCMloc_ThadCache
* 
hp
 = 
NULL
;

3637 
SpLockHd
 
	`h
(&
gehp_lock
);

3639 #i
	`OS
(
WINDOWS
)

3640 
DWORD
 
me
;

3641 i(!
tsd_ed
) {

3642 
me
 = 0;

3644 
me
 = 
	`GCutThadId
();

3648 
had_t
 
me
;

3649 i(!
tsd_ed
) {

3650 
	`memt
(&
me
, 0, (me));

3652 
me
 = 
	`had_lf
();

3659 
TCMloc_ThadCache
* 
h
 = 
thad_hps
; h !
NULL
; h = h->
xt_
) {

3660 #i
	`OS
(
WINDOWS
)

3661 i(
h
->
tid_
 =
me
) {

3663 i(
	`had_equ
(
h
->
tid_
, 
me
)) {

3665 
hp
 = 
h
;

3670 i(
hp
 =
NULL
h
	`NewHp
(
me
, 
HARDENING_ENTROPY
);

3677 i(!
hp
->
_tecific_
 && 
tsd_ed
) {

3678 
hp
->
_tecific_
 = 
ue
;

3679 
	`tThadHp
(
hp
);

3681  
hp
;

3682 
	}
}

3684 
	gTCMloc_ThadCache
::
	$BecomeId
() {

3685 i(!
tsd_ed
) ;

3686 
TCMloc_ThadCache
* 
hp
 = 
	`GThadHp
();

3687 i(
hp
 =
NULL
) ;

3688 i(
hp
->
_tecific_
) ;

3690 
hp
->
_tecific_
 = 
ue
;

3691 
	`tThadHp
(
NULL
);

3692 #ifde
HAVE_TLS


3694 
thadlol_hp
 = 
NULL
;

3696 
hp
->
_tecific_
 = 
l
;

3697 i(
	`GThadHp
(=
hp
) {

3704 
	`DeCache
(
hp
);

3705 
	}
}

3707 
	gTCMloc_ThadCache
::
	$DeroyThadCache
(* 
r
) {

3711 i(
r
 =
NULL
) ;

3712 #ifde
HAVE_TLS


3714 
thadlol_hp
 = 
NULL
;

3716 
	`DeCache
(
t_
<
TCMloc_ThadCache
*>(
r
));

3717 
	}
}

3719 
	gTCMloc_ThadCache
::
	$DeCache
(
TCMloc_ThadCache
* 
hp
) {

3721 
hp
->
	`C˪up
();

3724 
SpLockHd
 
	`h
(&
gehp_lock
);

3725 i(
hp
->
xt_
 !
NULL
hp->xt_->
ev_
 = heap->prev_;

3726 i(
hp
->
ev_
 !
NULL
hp->ev_->
xt_
 = heap->next_;

3727 i(
thad_hps
 =
hp
thad_hphp->
xt_
;

3728 
thad_hp_cou
--;

3729 
	`RecompuThadCacheSize
();

3731 
thadhp_lot
.
	`De
(
hp
);

3732 
	}
}

3734 
	gTCMloc_ThadCache
::
	$RecompuThadCacheSize
() {

3736 
n
 = 
thad_hp_cou
 > 0 ?hread_heap_count : 1;

3737 
size_t
 
a
 = 
ovl_thad_che_size
 / 
n
;

3740 i(
a
 < 
kMThadCacheSize
) space = kMinThreadCacheSize;

3741 i(
a
 > 
kMaxThadCacheSize
) space = kMaxThreadCacheSize;

3743 
r_thad_che_size
 = 
a
;

3744 
	}
}

3746 
	gTCMloc_ThadCache
::
	$Prt
() const {

3747 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

3748 
size_t
 

 = 0; c< 
kNumCss
; ++cl) {

3749 
	`MESSAGE
(" %5" 
PRIuS
 " : %4den; %4do\n",

3750 
	`BySizeFCss
(

),

3751 
li_
[

].
	`ngth
(),

3752 
li_
[

].
	`lowwmk
());

3754 
	}
}

3757 
	sTCMlocSts
 {

3758 
ut64_t
 
	gsyem_bys
;

3759 
ut64_t
 
	gthad_bys
;

3760 
ut64_t
 
	gl_bys
;

3761 
ut64_t
 
	gsr_bys
;

3762 
ut64_t
 
	ggehp_bys
;

3763 
ut64_t
 
	gmada_bys
;

3766 #ide
WTF_CHANGES


3768 
	$ExaSts
(
TCMlocSts
* 
r
, 
ut64_t
* 
ass_cou
) {

3769 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

3770 
r
->
l_bys
 = 0;

3771 
r
->
sr_bys
 = 0;

3772 

 = 0; c< 
kNumCss
; ++cl) {

3773 cڡ 
ngth
 = 
l_che
[

].
	`ngth
();

3774 cڡ 
tc_ngth
 = 
l_che
[

].
	`tc_ngth
();

3775 
r
->
l_bys
 +
ic_
<
ut64_t
>(
	`BySizeFCss
(

)* 
ngth
;

3776 
r
->
sr_bys
 +=

3777 
ic_
<
ut64_t
>(
	`BySizeFCss
(

)* 
tc_ngth
;

3778 i(
ass_cou
ass_cou[

] = 
ngth
 + 
tc_ngth
;

3782 
r
->
thad_bys
 = 0;

3784 
SpLockHd
 
	`h
(&
gehp_lock
);

3785 
TCMloc_ThadCache
* 
h
 = 
thad_hps
; h !
NULL
; h = h->
xt_
) {

3786 
r
->
thad_bys
 +
h
->
	`Size
();

3787 i(
ass_cou
) {

3788 
size_t
 

 = 0; c< 
kNumCss
; ++cl) {

3789 
ass_cou
[

] +
h
->
	`li_ngth
(cl);

3796 
SpLockHd
 
	`h
(&
gehp_lock
);

3797 
r
->
syem_bys
 = 
gehp
->
	`SyemBys
();

3798 
r
->
mada_bys
 = 
mada_syem_bys
;

3799 
r
->
gehp_bys
 = 
gehp
->
	`FeBys
();

3801 
	}
}

3804 #ide
WTF_CHANGES


3806 
	$DumpSts
(
TCMloc_Prr
* 
out
, 
v
) {

3807 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

3808 
TCMlocSts
 
s
;

3809 
ut64_t
 
ass_cou
[
kNumCss
];

3810 
	`ExaSts
(&
s
, (
v
 >2 ? 
ass_cou
 : 
NULL
));

3812 i(
v
 >= 2) {

3813 
out
->
	`tf
("------------------------------------------------\n");

3814 
ut64_t
 
cumutive
 = 0;

3815 

 = 0; c< 
kNumCss
; ++cl) {

3816 i(
ass_cou
[

] > 0) {

3817 
ut64_t
 
ass_bys
 = 
ass_cou
[

] * 
	`BySizeFCss
(cl);

3818 
cumutive
 +
ass_bys
;

3819 
out
->
	`tf
("as%3d [ %8" 
PRIuS
 " bytes ] : "

3820 "%8" 
PRIu64
 " objs; %5.1f MB; %5.1f cum MB\n",

3821 

, 
	`BySizeFCss
(cl),

3822 
ass_cou
[

],

3823 
ass_bys
 / 1048576.0,

3824 
cumutive
 / 1048576.0);

3828 
SpLockHd
 
	`h
(&
gehp_lock
);

3829 
gehp
->
	`Dump
(
out
);

3832 cڡ 
ut64_t
 
bys__u
 = 
s
.
syem_bys


3833 - 
s
.
gehp_bys


3834 - 
s
.
l_bys


3835 - 
s
.
sr_bys


3836 - 
s
.
thad_bys
;

3838 
out
->
	`tf
("------------------------------------------------\n"

3839 "MALLOC: %12" 
PRIu64
 " Heap size\n"

3840 "MALLOC: %12" 
PRIu64
 " Bytes in use bypplication\n"

3841 "MALLOC: %12" 
PRIu64
 " Bytes free inage heap\n"

3842 "MALLOC: %12" 
PRIu64
 " Bytes free in central cache\n"

3843 "MALLOC: %12" 
PRIu64
 " Bytes free inransfer cache\n"

3844 "MALLOC: %12" 
PRIu64
 " Bytes free inhread caches\n"

3845 "MALLOC: %12" 
PRIu64
 " Spans in use\n"

3846 "MALLOC: %12" 
PRIu64
 " Thread heaps in use\n"

3847 "MALLOC: %12" 
PRIu64
 " Metadatallocated\n"

3849 
s
.
syem_bys
,

3850 
bys__u
,

3851 
s
.
gehp_bys
,

3852 
s
.
l_bys
,

3853 
s
.
sr_bys
,

3854 
s
.
thad_bys
,

3855 
	`ut64_t
(
_lot
.
	`u
()),

3856 
	`ut64_t
(
thadhp_lot
.
	`u
()),

3857 
s
.
mada_bys
);

3858 
	}
}

3860 
	$PrtSts
(
v
) {

3861 cڡ 
kBufrSize
 = 16 << 10;

3862 * 
bufr
 = 
w
 [
kBufrSize
];

3863 
TCMloc_Prr
 
	`r
(
bufr
, 
kBufrSize
);

3864 
	`DumpSts
(&
r
, 
v
);

3865 
	`wre
(
STDERR_FILENO
, 
bufr
, 
	`
(buffer));

3866 
de
[] 
bufr
;

3867 
	}
}

3869 ** 
	$DumpSckTs
() {

3871 
eded_s
 = 0;

3873 
SpLockHd
 
	`h
(&
gehp_lock
);

3874 
Sn
* 
s
 = 
med_objes
.
xt
; s != &sampled_objects; s = s->next) {

3875 
SckT
* 
ack
 = 
t_
<SckT*>(
s
->
objes
);

3876 
eded_s
 +3 + 
ack
->
dth
;

3878 
eded_s
 += 100;

3879 
eded_s
 +=eeded_slots/8;

3882 ** 
su
 = 
w
 *[
eded_s
];

3883 i(
su
 =
NULL
) {

3884 
	`MESSAGE
("tcmalloc: couldotllocate %d slots for stackraces\n",

3885 
eded_s
);

3886  
NULL
;

3889 
SpLockHd
 
	`h
(&
gehp_lock
);

3890 
ud_s
 = 0;

3891 
Sn
* 
s
 = 
med_objes
.
xt
; s != &sampled_objects; s = s->next) {

3892 
	`ASSERT_WITH_SECURITY_IMPLICATION
(
ud_s
 < 
eded_s
);

3893 
SckT
* 
ack
 = 
t_
<SckT*>(
s
->
objes
);

3894 i(
ud_s
 + 3 + 
ack
->
dth
 >
eded_s
) {

3899 
su
[
ud_s
+0] = 
t_
<*>(
ic_
<
u_t
>(1));

3900 
su
[
ud_s
+1] = 
t_
<*>(
ack
->
size
);

3901 
su
[
ud_s
+2] = 
t_
<*>(
ack
->
dth
);

3902 
d
 = 0; d < 
ack
->
dth
; d++) {

3903 
su
[
ud_s
+3+
d
] = 
ack
->stack[d];

3905 
ud_s
 +3 + 
ack
->
dth
;

3907 
su
[
ud_s
] = 
t_
<*>(
ic_
<
u_t
>(0));

3908  
su
;

3909 
	}
}

3912 #ide
WTF_CHANGES


3915 as
	cTCMlocImemti
 : 
public
 
MlocExnsi
 {

3916 
public
:

3917 
vtu
 
GSts
(* 
bufr
, 
bufr_ngth
) {

3918 
ASSERT
(
bufr_ngth
 > 0);

3919 
TCMloc_Prr
 
r
(
bufr
, 
bufr_ngth
);

3922 i(
	gbufr_ngth
 < 10000) {

3923 
DumpSts
(&
r
, 1);

3925 
DumpSts
(&
r
, 2);

3929 
vtu
 ** 
RdSckTs
() {

3930  
DumpSckTs
();

3933 
vtu
 
bo
 
GNumicPrݔty
(cڡ * 
me
, 
size_t
* 
vue
) {

3934 
ASSERT
(
me
 !
NULL
);

3936 i(
rcmp
(
me
, "generic.current_allocated_bytes") == 0) {

3937 
TCMlocSts
 
s
;

3938 
ExaSts
(&
s
, 
NULL
);

3939 *
	gvue
 = 
s
.
syem_bys


3940 - 
s
.
thad_bys


3941 - 
s
.
l_bys


3942 - 
s
.
gehp_bys
;

3943  
	gue
;

3946 i(
rcmp
(
me
, "generic.heap_size") == 0) {

3947 
TCMlocSts
 
s
;

3948 
ExaSts
(&
s
, 
NULL
);

3949 *
	gvue
 = 
s
.
syem_bys
;

3950  
	gue
;

3953 i(
rcmp
(
me
, "tcmalloc.slack_bytes") == 0) {

3956 
SpLockHd
 
l
(&
gehp_lock
);

3957 *
	gvue
 = 
gehp
->
FeBys
();

3958  
	gue
;

3961 i(
rcmp
(
me
, "tcmalloc.max_total_thread_cache_bytes") == 0) {

3962 
SpLockHd
 
l
(&
gehp_lock
);

3963 *
	gvue
 = 
ovl_thad_che_size
;

3964  
	gue
;

3967 i(
rcmp
(
me
, "tcmalloc.current_total_thread_cache_bytes") == 0) {

3968 
TCMlocSts
 
s
;

3969 
ExaSts
(&
s
, 
NULL
);

3970 *
	gvue
 = 
s
.
thad_bys
;

3971  
	gue
;

3974  
	gl
;

3977 
vtu
 
bo
 
SNumicPrݔty
(cڡ * 
me
, 
size_t
 
vue
) {

3978 
ASSERT
(
me
 !
NULL
);

3980 i(
rcmp
(
me
, "tcmalloc.max_total_thread_cache_bytes") == 0) {

3982 i(
vue
 < 
kMThadCacheSize
) value = kMinThreadCacheSize;

3983 i(
	gvue
 > (1<<30)) value = (1<<30);

3985 
SpLockHd
 
l
(&
gehp_lock
);

3986 
	govl_thad_che_size
 = 
ic_
<
size_t
>(
vue
);

3987 
	gTCMloc_ThadCache
::
RecompuThadCacheSize
();

3988  
	gue
;

3991  
	gl
;

3994 
vtu
 
MkThadId
() {

3995 
	gTCMloc_ThadCache
::
BecomeId
();

3998 
vtu
 
RFeMemy
() {

3999 
SpLockHd
 
h
(&
gehp_lock
);

4000 
	ggehp
->
RFePages
();

4017 as
	cTCMlocGud
 {

4018 
	gpublic
:

4020 
TCMlocGud
() {

4021 #ifde
HAVE_TLS


4023 
CheckIfKlSutsTLS
();

4025 #ide
WTF_CHANGES


4026 #ifde
WIN32


4027 
PchWdowsFunis
();

4030 

(
mloc
(1));

4031 
	gTCMloc_ThadCache
::
InTSD
();

4032 

(
mloc
(1));

4033 #ide
WTF_CHANGES


4034 
	gMlocExnsi
::
Regi
(
w
 
TCMlocImemti
);

4038 #ide
WTF_CHANGES


4039 ~
TCMlocGud
() {

4040 cڡ * 
	gv
 = 
gv
("MALLOCSTATS");

4041 i(
	gv
 !
NULL
) {

4042 
v
 = 
oi
(
v
);

4043 i(
	gv
 < 1)evel = 1;

4044 
PrtSts
(
v
);

4046 #ifde
WIN32


4047 
UũchWdowsFunis
();

4053 #ide
WTF_CHANGES


4054 
TCMlocGud
 
	gmodu_r_ex_hook
;

4062 #ide
WTF_CHANGES


4064 
Sn
* 
	$DoSamedAoti
(
size_t
 
size
) {

4067 
SckT
 
tmp
;

4068 
tmp
.
dth
 = 
	`GSckT
mp.
ack
, 
kMaxSckDth
, 1);

4069 
tmp
.
size
 = size;

4071 
SpLockHd
 
	`h
(&
gehp_lock
);

4073 
Sn
 *

 = 
gehp
->
	`New
(
	`ges
(
size
 == 0 ? 1 : size));

4074 i(

 =
NULL
) {

4075  
NULL
;

4079 
SckT
 *
ack
 = 
acka_lot
.
	`New
();

4080 i(
ack
 =
NULL
) {

4082  

;

4085 *
ack
 = 
tmp
;

4086 

->
me
 = 1;

4087 

->
objes
 = 
ack
;

4088 
	`DLL_Pnd
(&
med_objes
, 

);

4090  

;

4091 
	}
}

4094 #i!
ASSERT_DISABLED


4095 
le
 
bo
 
	$CheckCachedSizeCss
(*
r
) {

4096 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

4097 
PageID
 
p
 = 
t_
<
u_t
>(
r
>> 
kPageShi
;

4098 
size_t
 
ched_vue
 = 
gehp
->
	`GSizeCssIfCached
(
p
);

4099  
ched_vue
 == 0 ||

4100 
ched_vue
 =
gehp
->
	`GDest
(
p
)->
sizeass
;

4101 
	}
}

4104 
le
 * 
	$CheckedMlocResu
(*
su
)

4106 
	`ASSERT
(
su
 =0 || 
	`CheckCachedSizeCss
(result));

4107  
su
;

4108 
	}
}

4110 
le
 * 
	$SnToMlocResu
(
Sn
 *

) {

4111 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

4112 
	`ASSERT_SPAN_COMMITTED
(

);

4113 
gehp
->
	`CacheSizeCss
(

->
t
, 0);

4114 * 
su
 = 
t_
<*>(

->
t
 << 
kPageShi
);

4115 
	`POISON_ALLOCATION
(
su
, 

->
ngth
 << 
kPageShi
);

4116  
	`CheckedMlocResu
(
su
);

4117 
	}
}

4119 #ifde
WTF_CHANGES


4120 
	gme
 <
bo
 
	gashOnFau
>

4122 
ALWAYS_INLINE
 * 
	$do_mloc
(
size_t
 
size
) {

4123 * 
t
 = 
NULL
;

4125 #ifde
WTF_CHANGES


4126 
	`ASSERT
(!
	`isFbidd
());

4130 
TCMloc_ThadCache
* 
hp
 = TCMloc_ThadCache::
	`GCache
();

4131 #ide
WTF_CHANGES


4132 i((
FLAGS_tcmloc_me_m
 > 0&& 
hp
->
	`SameAoti
(
size
)) {

4133 
Sn
* 

 = 
	`DoSamedAoti
(
size
);

4134 i(

 !
NULL
) {

4135 
t
 = 
	`SnToMlocResu
(

);

4139 i(
size
 > 
kMaxSize
) {

4141 
SpLockHd
 
	`h
(&
gehp_lock
);

4142 
Sn
* 

 = 
gehp
->
	`New
(
	`ges
(
size
));

4143 i(

 !
NULL
) {

4144 
t
 = 
	`SnToMlocResu
(

);

4149 
t
 = 
	`CheckedMlocResu
(
hp
->
	`Ao
(
size
));

4151 i(!
t
) {

4152 #ifde
WTF_CHANGES


4153 i(
ashOnFau
)

4154 
	`CRASH
();

4156 
o
 = 
ENOMEM
;

4159  
t
;

4160 
	}
}

4162 
ALWAYS_INLINE
 
	$do_
(* 
r
) {

4163 i(
r
 =
NULL
) ;

4164 
	`ASSERT
(
gehp
 !
NULL
);

4165 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

4166 cڡ 
PageID
 
p
 = 
t_
<
u_t
>(
r
>> 
kPageShi
;

4167 
Sn
* 

 = 
gehp
->
	`GDest
(
p
);

4168 
	`RELEASE_ASSERT
(

->
	`isVid
());

4169 
size_t
 

 = 

->
sizeass
;

4171 i(

) {

4172 
size_t
 
bySizeFCss
 = 
	`BySizeFCss
(

);

4173 #i!(
	`CPU
(
ARM_THUMB2
&& !CPU(
APPLE_ARMV7S
))

4174 
	`RELEASE_ASSERT
(!((
t_
<*>(
r
-et_<*>(

->
t
 << 
kPageShi
)% 
bySizeFCss
));

4176 
gehp
->
	`CacheSizeCss
(
p
, 

);

4178 #ide
NO_TCMALLOC_SAMPLES


4179 
	`ASSERT
(!
gehp
->
	`GDest
(
p
)->
me
);

4181 
TCMloc_ThadCache
* 
hp
 = TCMloc_ThadCache::
	`GCacheIfP
();

4182 i(
hp
 !
NULL
) {

4183 
hp
->
	`Do
(
HdedSLL
::
	`
(
r
), 

);

4186 
	`POISON_DEALLOCATION
(
r
, 
bySizeFCss
);

4187 
	`SLL_SNext
(
HdedSLL
::
	`
(
r
), HdedSLL::
	`nu
(), 
l_che
[

].
	`y
());

4188 
l_che
[

].
	`InRge
(
HdedSLL
::
	`
(
r
), HardenedSLL::create(ptr), 1);

4191 
SpLockHd
 
	`h
(&
gehp_lock
);

4192 
	`ASSERT
(
t_
<
u_t
>(
r
% 
kPageSize
 == 0);

4193 
	`ASSERT
(

 !
NULL
 && sn->
t
 =
p
);

4194 #ide
NO_TCMALLOC_SAMPLES


4195 i(

->
me
) {

4196 
	`DLL_Remove
(

);

4197 
acka_lot
.
	`De
(
t_
<
SckT
*>(

->
objes
));

4198 

->
objes
 = 
NULL
;

4201 
	`RELEASE_ASSERT
(
t_
<*>(

->
t
 << 
kPageShi
=
r
);

4202 
	`POISON_DEALLOCATION
(
r
, 

->
ngth
 << 
kPageShi
);

4203 
gehp
->
	`De
(

);

4205 
	}
}

4207 #ide
WTF_CHANGES


4215 * 
	$do_memign
(
size_t
 
ign
, size_
size
) {

4216 
	`ASSERT
((
ign
 & (align - 1)) == 0);

4217 
	`ASSERT
(
ign
 > 0);

4218 i(
gehp
 =
NULL

TCMloc_ThadCache
::
	`InModu
();

4219 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

4222 i(
size
 == 0) size = 1;

4224 i(
size
 <
kMaxSize
 && 
ign
 < 
kPageSize
) {

4231 
size_t
 

 = 
	`SizeCss
(
size
);

4232 

 < 
kNumCss
 && ((
ass_to_size
[] & (
ign
 - 1)) != 0)) {

4233 

++;

4235 i(

 < 
kNumCss
) {

4236 
TCMloc_ThadCache
* 
hp
 = TCMloc_ThadCache::
	`GCache
();

4237  
	`CheckedMlocResu
(
hp
->
	`Ao
(
ass_to_size
[

]));

4242 
SpLockHd
 
	`h
(&
gehp_lock
);

4244 i(
ign
 <
kPageSize
) {

4248 
Sn
* 

 = 
gehp
->
	`New
(
	`ges
(
size
));

4249  

 =
NULL
 ? NULL : 
	`SnToMlocResu
(span);

4253 cڡ 
Lgth
 
loc
 = 
	`ges
(
size
 + 
ign
);

4254 
Sn
* 

 = 
gehp
->
	`New
(
loc
);

4255 i(

 =
NULL
)  NULL;

4258 
Lgth
 
sk
 = 0;

4259 (((

->
t
+
sk
<< 
kPageShi
& (
ign
 - 1)) != 0) {

4260 
sk
++;

4262 
	`ASSERT_WITH_SECURITY_IMPLICATION
(
sk
 < 
loc
);

4263 i(
sk
 > 0) {

4264 
Sn
* 

 = 
gehp
->
	`S
(

, 
sk
);

4265 
gehp
->
	`De
(

);

4266 

 = 

;

4270 cڡ 
Lgth
 
eded
 = 
	`ges
(
size
);

4271 
	`ASSERT
(

->
ngth
 >
eded
);

4272 i(

->
ngth
 > 
eded
) {

4273 
Sn
* 
a
 = 
gehp
->
	`S
(

, 
eded
);

4274 
gehp
->
	`De
(
a
);

4276  
	`SnToMlocResu
(

);

4277 
	}
}

4282 #ide
WTF_CHANGES


4283 
le
 
	$do_mloc_s
() {

4284 
	`PrtSts
(1);

4285 
	}
}

4287 
le
 
	$do_mlt
(, ) {

4289 
	}
}

4292 #ifde
HAVE_STRUCT_MALLINFO


4293 
le
 
mlfo
 
	$do_mlfo
() {

4294 
TCMlocSts
 
s
;

4295 
	`ExaSts
(&
s
, 
NULL
);

4298 
mlfo
 
fo
;

4299 
	`memt
(&
fo
, 0, (info));

4303 
fo
.
a
 = 
ic_
<>(
s
.
syem_bys
);

4304 
fo
.
fsmblks
 = 
ic_
<>(
s
.
thad_bys


4305 + 
s
.
l_bys


4306 + 
s
.
sr_bys
);

4307 
fo
.
fdblks
 = 
ic_
<>(
s
.
gehp_bys
);

4308 
fo
.
udblks
 = 
ic_
<>(
s
.
syem_bys


4309 - 
s
.
thad_bys


4310 - 
s
.
l_bys


4311 - 
s
.
sr_bys


4312 - 
s
.
gehp_bys
);

4314  
fo
;

4315 
	}
}

4327 #ide
WTF_CHANGES


4330 
	#do_mloc
 
do_mloc
<
ashOnFau
>

	)

4332 
me
 <
bo
 
ashOnFau
>

4333 
ALWAYS_INLINE
 * 
mloc
(
size_t
);

4335 * 
	$Mloc
(
size_t
 
size
)

4337 * 
su
 = 
mloc
<
ue
>(
size
);

4338 #i
	`ENABLE
(
ALLOCATION_LOGGING
)

4339 
	`daLogF
("Mlolotg %lu by(Mloc): %p.\n", 
size
, 
su
);

4341  
su
;

4342 
	}
}

4344 
TryMlocRuVue
 
	$yFaMloc
(
size_t
 
size
)

4346 
TryMlocRuVue
 
su
 = 
mloc
<
l
>(
size
);

4347 #i
	`ENABLE
(
ALLOCATION_LOGGING
)

4348 * 
por
;

4349 ()
su
.
	`gVue
(
por
);

4350 
	`daLogF
("Mlolotg %lu byryFaMloc): %p.\n", 
size
, 
por
);

4352  
su
;

4353 
	}
}

4355 
	gme
 <
bo
 
	gashOnFau
>

4356 
	gALWAYS_INLINE


4358 * 
	$mloc
(
size_t
 
size
) {

4359 #i
	`ENABLE
(
WTF_MALLOC_VALIDATION
)

4360 i(
d
::
numic_lims
<
size_t
>::
	`max
(- 
Il
::
VidiBufrSize
 <
size
)

4362 * 
su
 = 
	`do_mloc
(
size
 + 
Il
::
VidiBufrSize
);

4363 i(!
su
)

4366 
Il
::
VidiHd
* 
hd
 = 
ic_
<Il::VidiHd*>(
su
);

4367 
hd
->
m_size
 = 
size
;

4368 
hd
->
m_ty
 = 
Il
::
AocTyMloc
;

4369 
hd
->
m_efix
 = 
ic_
<>(
Il
::
VidiPfix
);

4370 
su
 = 
hd
 + 1;

4371 *
Il
::
	`MlocVidiSuffix
(
su
Il::
VidiSuffix
;

4372 
	`MlocVide
(
su
);

4374 * 
su
 = 
	`do_mloc
(
size
);

4377 
MlocHook
::
	`InvokeNewHook
(
su
, 
size
);

4378  
su
;

4379 
	}
}

4381 #ide
WTF_CHANGES


4384 
	$
(* 
r
) {

4385 #i
	`ENABLE
(
ALLOCATION_LOGGING
)

4386 
	`daLogF
("F䓚g %p.\n", 
r
);

4389 
MlocHook
::
	`InvokeDeHook
(
r
);

4391 #i
	`ENABLE
(
WTF_MALLOC_VALIDATION
)

4392 i(!
r
)

4395 
	`MlocVide
(
r
);

4396 
Il
::
VidiHd
* 
hd
 = Il::
	`MlocVidiHd
(
r
);

4397 
	`memt
(
r
, 0xCC, 
hd
->
m_size
);

4398 
	`do_
(
hd
);

4400 
	`do_
(
r
);

4402 
	}
}

4404 #ide
WTF_CHANGES


4407 
me
 <
bo
 
ashOnFau
>

4408 
ALWAYS_INLINE
 * 
oc
(
size_t
, size_t);

4410 * 
	$Cloc
(
size_t
 
n
, size_
em_size
)

4412 * 
su
 = 
oc
<
ue
>(
n
, 
em_size
);

4413 #i
	`ENABLE
(
WTF_MALLOC_VALIDATION
)

4414 
	`MlocVide
(
su
);

4416 #i
	`ENABLE
(
ALLOCATION_LOGGING
)

4417 
	`daLogF
("Mloctiguouyotg %lu * %lu by(Cloc): %p.\n", 
n
, 
em_size
, 
su
);

4419  
su
;

4420 
	}
}

4422 
TryMlocRuVue
 
	$yFaCloc
(
size_t
 
n
, size_
em_size
)

4424 * 
su
 = 
oc
<
l
>(
n
, 
em_size
);

4425 #i
	`ENABLE
(
WTF_MALLOC_VALIDATION
)

4426 
	`MlocVide
(
su
);

4428 #i
	`ENABLE
(
ALLOCATION_LOGGING
)

4429 
	`daLogF
("Mloctiguouyotg %lu * %lu byryFaCloc): %p.\n", 
n
, 
em_size
, 
su
);

4431  
su
;

4432 
	}
}

4434 
	gme
 <
bo
 
	gashOnFau
>

4435 
	gALWAYS_INLINE


4437 * 
	$oc
(
size_t
 
n
, size_
em_size
) {

4438 
size_t
 
tٮBys
 = 
n
 * 
em_size
;

4441 i(
n
 > 1 && 
em_size
 && (
tٮBys
 /lem_size) !=)

4444 #i
	`ENABLE
(
WTF_MALLOC_VALIDATION
)

4445 * 
su
 = 
mloc
<
ashOnFau
>(
tٮBys
);

4446 i(!
su
)

4449 
	`memt
(
su
, 0, 
tٮBys
);

4450 
	`MlocVide
(
su
);

4452 * 
su
 = 
	`do_mloc
(
tٮBys
);

4453 i(
su
 !
NULL
) {

4454 
	`memt
(
su
, 0, 
tٮBys
);

4458 
MlocHook
::
	`InvokeNewHook
(
su
, 
tٮBys
);

4459  
su
;

4460 
	}
}

4463 #ide
WTF_CHANGES


4464 #ide
WTF_CHANGES


4467 
	$c
(* 
r
) {

4468 #ide
WTF_CHANGES


4469 
MlocHook
::
	`InvokeDeHook
(
r
);

4471 
	`do_
(
r
);

4472 
	}
}

4475 #ide
WTF_CHANGES


4478 
me
 <
bo
 
ashOnFau
>

4479 
ALWAYS_INLINE
 * 
loc
(*, 
size_t
);

4481 * 
	$Roc
(* 
d_r
, 
size_t
 
w_size
)

4483 #i
	`ENABLE
(
WTF_MALLOC_VALIDATION
)

4484 
	`MlocVide
(
d_r
);

4486 * 
su
 = 
loc
<
ue
>(
d_r
, 
w_size
);

4487 #i
	`ENABLE
(
WTF_MALLOC_VALIDATION
)

4488 
	`MlocVide
(
su
);

4490 #i
	`ENABLE
(
ALLOCATION_LOGGING
)

4491 
	`daLogF
("Mlolotg %lu by(Roc): %-> %p.\n", 
w_size
, 
d_r
, 
su
);

4493  
su
;

4494 
	}
}

4496 
TryMlocRuVue
 
	$yFaRoc
(* 
d_r
, 
size_t
 
w_size
)

4498 #i
	`ENABLE
(
WTF_MALLOC_VALIDATION
)

4499 
	`MlocVide
(
d_r
);

4501 * 
su
 = 
loc
<
l
>(
d_r
, 
w_size
);

4502 #i
	`ENABLE
(
WTF_MALLOC_VALIDATION
)

4503 
	`MlocVide
(
su
);

4505 #i
	`ENABLE
(
ALLOCATION_LOGGING
)

4506 
	`daLogF
("Mlolotg %lu byryFaRoc): %-> %p.\n", 
w_size
, 
d_r
, 
su
);

4508  
su
;

4509 
	}
}

4511 
	gme
 <
bo
 
	gashOnFau
>

4512 
	gALWAYS_INLINE


4514 * 
	$loc
(* 
d_r
, 
size_t
 
w_size
) {

4515 i(
d_r
 =
NULL
) {

4516 #i
	`ENABLE
(
WTF_MALLOC_VALIDATION
)

4517 * 
su
 = 
mloc
<
ashOnFau
>(
w_size
);

4519 * 
su
 = 
	`do_mloc
(
w_size
);

4520 
MlocHook
::
	`InvokeNewHook
(
su
, 
w_size
);

4522  
su
;

4524 i(
w_size
 == 0) {

4525 
MlocHook
::
	`InvokeDeHook
(
d_r
);

4526 
	`
(
d_r
);

4527  
NULL
;

4530 #i
	`ENABLE
(
WTF_MALLOC_VALIDATION
)

4531 i(
d
::
numic_lims
<
size_t
>::
	`max
(- 
Il
::
VidiBufrSize
 <
w_size
)

4533 
Il
::
VidiHd
* 
hd
 = Il::
	`MlocVidiHd
(
d_r
);

4534 
	`MlocVide
(
d_r
);

4535 
d_r
 = 
hd
;

4536 
hd
->
m_size
 = 
w_size
;

4537 
w_size
 +
Il
::
VidiBufrSize
;

4540 
	`ASSERT
(
gehp
 !
NULL
);

4541 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

4544 cڡ 
PageID
 
p
 = 
t_
<
u_t
>(
d_r
>> 
kPageShi
;

4545 
size_t
 

 = 
gehp
->
	`GSizeCssIfCached
(
p
);

4546 
Sn
 *

 = 
NULL
;

4547 
size_t
 
d_size
;

4548 i(

 == 0) {

4549 

 = 
gehp
->
	`GDest
(
p
);

4550 

 = 

->
sizeass
;

4551 
gehp
->
	`CacheSizeCss
(
p
, 

);

4553 i(

 != 0) {

4554 
d_size
 = 
	`BySizeFCss
(

);

4556 
	`ASSERT
(

 !
NULL
);

4557 
d_size
 = 

->
ngth
 << 
kPageShi
;

4562 i((
w_size
 > 
d_size
|| (
	`AotiSize
(new_size) < old_size)) {

4564 * 
w_r
 = 
	`do_mloc
(
w_size
);

4565 i(
w_r
 =
NULL
) {

4566  
NULL
;

4568 
MlocHook
::
	`InvokeNewHook
(
w_r
, 
w_size
);

4569 
	`memy
(
w_r
, 
d_r
, ((
d_size
 < 
w_size
) ? old_size :ew_size));

4570 
MlocHook
::
	`InvokeDeHook
(
d_r
);

4574 
	`do_
(
d_r
);

4575 #i
	`ENABLE
(
WTF_MALLOC_VALIDATION
)

4576 
w_r
 = 
ic_
<
Il
::
VidiHd
*>(new_ptr) + 1;

4577 *
Il
::
	`MlocVidiSuffix
(
w_r
Il::
VidiSuffix
;

4579  
w_r
;

4581 #i
	`ENABLE
(
WTF_MALLOC_VALIDATION
)

4582 
d_r
 = 
ic_
<
Il
::
VidiHd
*>(old_ptr) + 1;

4583 *
Il
::
	`MlocVidiSuffix
(
d_r
Il::
VidiSuffix
;

4585  
d_r
;

4587 
	}
}

4589 #ifde
WTF_CHANGES


4590 #unde
do_mloc


4593 
SpLock
 
	gt_w_hdr_lock
 = 
SPINLOCK_INITIALIZER
;

4595 
le
 * 
	$p_loc
(
size_t
 
size
, 
bo
 
nhrow
) {

4597 * 
p
 = 
	`do_mloc
(
size
);

4598 #ifde
PREANSINEW


4599  
p
;

4601 i(
p
 =
NULL
) {

4606 
d
::
w_hdr
 
nh
;

4608 
SpLockHd
 
	`h
(&
t_w_hdr_lock
);

4609 
nh
 = 
d
::
	`t_w_hdr
(0);

4610 (
d
::
	`t_w_hdr
(
nh
);

4613 i(!
nh
) {

4614 i(
nhrow
)  0;

4615 
throw
 
d
::
	`bad_loc
();

4620 
y
 {

4621 (*
nh
)();

4622 } 
	`tch
 (cڡ 
d
::
bad_loc
&) {

4623 i(!
nhrow

throw
;

4624  
p
;

4627  
p
;

4631 
	}
}

4633 "C" * 
	$memign
(
size_t
 
ign
, size_
size

__THROW
 {

4634 * 
su
 = 
	`do_memign
(
ign
, 
size
);

4635 
MlocHook
::
	`InvokeNewHook
(
su
, 
size
);

4636  
su
;

4637 
	}
}

4639 "C" 
	$posix_memign
(** 
su_r
, 
size_t
 
ign
, size_
size
)

4640 
__THROW
 {

4641 i(((
ign
 % (*)) != 0) ||

4642 ((
ign
 & (align - 1)) != 0) ||

4643 (
ign
 == 0)) {

4644  
EINVAL
;

4647 * 
su
 = 
	`do_memign
(
ign
, 
size
);

4648 
MlocHook
::
	`InvokeNewHook
(
su
, 
size
);

4649 i(
su
 =
NULL
) {

4650  
ENOMEM
;

4652 *
su_r
 = 
su
;

4655 
	}
}

4657 
size_t
 
gesize
 = 0;

4659 "C" * 
	$vloc
(
size_t
 
size

__THROW
 {

4661 i(
gesize
 =0gesiz
	`ggesize
();

4662 * 
su
 = 
	`do_memign
(
gesize
, 
size
);

4663 
MlocHook
::
	`InvokeNewHook
(
su
, 
size
);

4664  
su
;

4665 
	}
}

4667 "C" * 
	$pvloc
(
size_t
 
size

__THROW
 {

4669 i(
gesize
 =0gesiz
	`ggesize
();

4670 
size
 = (siz+ 
gesize
 - 1) & ~(pagesize - 1);

4671 * 
su
 = 
	`do_memign
(
gesize
, 
size
);

4672 
MlocHook
::
	`InvokeNewHook
(
su
, 
size
);

4673  
su
;

4674 
	}
}

4676 "C" 
	$mloc_s
() {

4677 
	`do_mloc_s
();

4678 
	}
}

4680 "C" 
	$mlt
(
cmd
, 
vue
) {

4681  
	`do_mlt
(
cmd
, 
vue
);

4682 
	}
}

4684 #ifde
HAVE_STRUCT_MALLINFO


4685 "C" 
mlfo
 
	$mlfo
() {

4686  
	`do_mlfo
();

4687 
	}
}

4698 #i
	$defed
(
__GLIBC__
)

4700 #i
	`COMPILER
(
GCC
&& !
	`defed
(
__MACH__
&& defed(
HAVE___ATTRIBUTE__
)

4703 
	#ALIAS
(
x

	`__ibu__
 ((
wk
, 
	`s
 (x)))

	)

4704 * 
	`__libc_mloc
(
size_t
 
size

	`ALIAS
("malloc");

4705 
	`__libc_
(* 
r

	`ALIAS
("free");

4706 * 
	`__libc_loc
(* 
r
, 
size_t
 
size

	`ALIAS
("realloc");

4707 * 
	`__libc_oc
(
size_t
 
n
, size_
size

	`ALIAS
("calloc");

4708 
	`__libc_c
(* 
r

	`ALIAS
("cfree");

4709 * 
	`__libc_memign
(
size_t
 
ign
, size_
s

	`ALIAS
("memalign");

4710 * 
	`__libc_vloc
(
size_t
 
size

	`ALIAS
("valloc");

4711 * 
	`__libc_pvloc
(
size_t
 
size

	`ALIAS
("pvalloc");

4712 
	`__posix_memign
(** 
r
, 
size_t
 
a
, size_
s

	`ALIAS
("posix_memalign");

4713 #unde
ALIAS


4716 * 
	`__libc_mloc
(
size_t
 
size
{  
	`mloc
(size); }

4717 
	`__libc_
(* 
r
{ 
	`
(ptr); }

4718 * 
	`__libc_loc
(* 
r
, 
size_t
 
size
{  
	`loc
(ptr, size); }

4719 * 
	`__libc_oc
(
size_t
 
n
, size_
size
{  
	`oc
(n, size); }

4720 
	`__libc_c
(* 
r
{ 
	`c
(ptr); }

4721 * 
	`__libc_memign
(
size_t
 
ign
, size_
s
{  
	`memign
(align, s); }

4722 * 
	`__libc_vloc
(
size_t
 
size
{  
	`vloc
(size); }

4723 * 
	`__libc_pvloc
(
size_t
 
size
{  
	`pvloc
(size); }

4724 
	`__posix_memign
(** 
r
, 
size_t
 
a
, size_
s
) {

4725  
	`posix_memign
(
r
, 
a
, 
s
);

4728 
	}
}

4738 *
	$MemignOvride
(
size_t
 
ign
, size_
size
, cڡ *
Δ
)

4739 
__THROW
 {

4740 * 
su
 = 
	`do_memign
(
ign
, 
size
);

4741 
MlocHook
::
	`InvokeNewHook
(
su
, 
size
);

4742  
su
;

4743 
	}
}

4744 *(*
__memign_hook
)(
size_t
, size_t, cڡ *
MemignOvride
;

4748 #ifde
WTF_CHANGES


4749 
	$aFaMlocFeMemy
()

4752 i(
TCMloc_ThadCache
* 
thadCache
 = TCMloc_ThadCache::
	`GCacheIfP
())

4753 
thadCache
->
	`C˪up
();

4755 
SpLockHd
 
	`h
(&
gehp_lock
);

4756 
gehp
->
	`RFePages
();

4757 
	}
}

4759 
FaMlocStiics
 
	$MlocStiics
()

4761 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

4762 
FaMlocStiics
 
iics
;

4764 
SpLockHd
 
	`lockHd
(&
gehp_lock
);

4765 
iics
.
rvedVMBys
 = 
ic_
<
size_t
>(
gehp
->
	`SyemBys
());

4766 
iics
.
commdVMBys
 = stiics.
rvedVMBys
 - 
gehp
->
	`RuedBys
();

4768 
iics
.
LiBys
 = 0;

4769 

 = 0; c< 
kNumCss
; ++cl) {

4770 cڡ 
ngth
 = 
l_che
[

].
	`ngth
();

4771 cڡ 
tc_ngth
 = 
l_che
[

].
	`tc_ngth
();

4773 
iics
.
LiBys
 +
	`BySizeFCss
(

* (
ngth
 + 
tc_ngth
);

4775 
TCMloc_ThadCache
* 
thadCache
 = 
thad_hps
;hadCach;hadCachthadCache->
xt_
)

4776 
iics
.
LiBys
 +
thadCache
->
	`Size
();

4778  
iics
;

4779 
	}
}

4781 
size_t
 
	$MlocSize
(cڡ * 
r
)

4783 i(
gehp
 =
NULL

TCMloc_ThadCache
::
	`InModu
();

4784 
	`ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

4786 #i
	`ENABLE
(
WTF_MALLOC_VALIDATION
)

4787  
Il
::
	`MlocVidiHd
(
cڡ_
<*>(
r
))->
m_size
;

4789 cڡ 
PageID
 
p
 = 
t_
<
u_t
>(
r
>> 
kPageShi
;

4790 
Sn
* 

 = 
gehp
->
	`GDestEnsuSa
(
p
);

4792 i(!

 || sn->

)

4795 
HdedSLL
 

 = 

->
objes
; fe; f
	`SLL_Next
(, 
HARDENING_ENTROPY
)) {

4796 i(
r
 =

.
	`vue
())

4800 i(
size_t
 

 = 

->
sizeass
)

4801  
	`BySizeFCss
(

);

4803  

->
ngth
 << 
kPageShi
;

4805 
	}
}

4807 #i
	$OS
(
DARWIN
)

4808 as
	cRemeMemyRd
 {

4809 
sk_t
 
m_sk
;

4810 
memy_ad_t
* 
m_ad
;

4812 
public
:

4813 
	`RemeMemyRd
(
sk_t
 
sk
, 
memy_ad_t
* 
ad
)

4814 : 
	`m_sk
(
sk
)

4815 , 
	`m_ad
(
ad
)

4818 * 
	`ݔ
()(
vm_addss_t
 
addss
, 
size_t
 
size
) const

4820 * 
ouut
;

4821 
kn_tu_t
 
r
 = (*
m_ad
)(
m_sk
, 
addss
, 
size
, 
ic_
<**>(&
ouut
));

4822 i(
r
)

4823 
ouut
 = 0;

4824  
ouut
;

4827 
me
 <
tyme
 
T
>

4828 
T
* 
	`ݔ
()(T* 
addss
, 
size_t
 
size
 = (T)) const

4830  
ic_
<
T
*>((*
this
)(
t_
<
vm_addss_t
>(
addss
), 
size
));

4833 
me
 <
tyme
 
T
>

4834 
T
* 
	`xtEryInHdedLkedLi
(T** 
meAddss
, 
u_t
 
y
) const

4836 
T
** 
lolAddss
 = (*
this
)(
meAddss
);

4837 i(!
lolAddss
)

4839 
T
* 
hdedNext
 = *
lolAddss
;

4840 i(!
hdedNext
 || hdedNex=(*)
y
)

4842  
	`XOR_MASK_PTR_WITH_KEY
(
hdedNext
, 
meAddss
, 
y
);

4844 
	}
};

4846 
	gme
 <
tyme
 
	gT
>

4847 
	gme
 <
tyme
 
	gRecd
>

4848 
	gPageHpAot
<
	gT
>::
	$cdAdmitiveRegis
(
Recd
& 
cd
, cڡ 
RemeMemyRd
& 
ad
)

4850 
HdedSLL
 
admAoti
 = 
lod_gis_
;dmAoti;dmAoti.
	`tVue
(
ad
.
	`xtEryInHdedLkedLi
(
t_
<**>dmAoti.
	`vue
()), 
y_
)))

4851 
cd
.
	`cdRegi
(
t_
<
vm_addss_t
>(
admAoti
.
	`vue
()), 
kAocInemt
);

4852 
	}
}

4854 as
	cFeObjeFd
 {

4855 cڡ 
	gRemeMemyRd
& 
	gm_ad
;

4856 
	gHashS
<*> 
	gm_Objes
;

4858 
	gpublic
:

4859 
FeObjeFd
(cڡ 
RemeMemyRd
& 
ad
: 
m_ad
(reader) { }

4861 
vis
(* 
r
{ 
m_Objes
.
add
(ptr); }

4862 
bo
 
isFeObje
(* 
r
cڡ {  
	gm_Objes
.
cڏs
(ptr); }

4863 
bo
 
isFeObje
(
vm_addss_t
 
r
cڡ {  isFeObje(
t_
<*>(ptr)); }

4864 
size_t
 
ObjeCou
(cڡ {  
	gm_Objes
.
size
(); }

4866 
fdFeObjes
(
TCMloc_ThadCache
* 
thadCache
)

4868 ; 
	gthadCache
;hadCach(
thadCache
->
xt_
 ? 
m_ad
(threadCache->next_) : 0))

4869 
thadCache
->
umeFeObjes
(*
this
, 
m_ad
);

4872 
fdFeObjes
(
TCMloc_C_FeLiPadded
* 
lFeLi
, 
size_t
 
numSizes
, TCMloc_C_FeLiPadded* 
meCFeLi
)

4874 
	gi
 = 0; i < 
	gnumSizes
; i++)

4875 
	glFeLi
[
i
].
umeFeObjes
(*
this
, 
m_ad
, 
meCFeLi
 + i);

4879 as
	cPageMFeObjeFd
 {

4880 cڡ 
	gRemeMemyRd
& 
	gm_ad
;

4881 
	gFeObjeFd
& 
	gm_ObjeFd
;

4882 
u_t
 
	gm_y
;

4884 
	gpublic
:

4885 
PageMFeObjeFd
(cڡ 
RemeMemyRd
& 
ad
, 
FeObjeFd
& 
ObjeFd
, 
u_t
 
y
)

4886 : 
m_ad
(
ad
)

4887 , 
m_ObjeFd
(
ObjeFd
)

4888 , 
m_y
(
y
)

4890 #i
ENABLE
(
TCMALLOC_HARDENING
)

4891 
ASSERT
(
m_y
);

4895 
vis
(* 
r
) const

4897 
ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

4898 i(!
	gr
)

4901 
Sn
* 
	g
 = 
m_ad
(
t_
<Sn*>(
r
));

4902 i(!
	g
)

4905 i(
	g
->
	g
) {

4906 * 
	gr
 = 
t_
<*>(

->
t
 << 
kPageShi
);

4907 
	gm_ObjeFd
.
vis
(
r
);

4908 } i(
	g
->
	gsizeass
) {

4910 
HdedSLL
 
	gxtObje
 = 

->
objes
;extObje;extObje.
tVue
(
m_ad
.
xtEryInHdedLkedLi
(
t_
<**>(
xtObje
.
vue
()), 
m_y
)))

4911 
	gm_ObjeFd
.
vis
(
xtObje
.
vue
());

4913  
	g
->
	gngth
;

4917 as
	cPageMMemyUgeRecd
 {

4918 
sk_t
 
	gm_sk
;

4919 * 
	gm_cڋxt
;

4920 
	gm_tyMask
;

4921 
vm_nge_cd_t
* 
	gm_cd
;

4922 cڡ 
	gRemeMemyRd
& 
	gm_ad
;

4923 cڡ 
	gFeObjeFd
& 
	gm_ObjeFd
;

4925 
	gHashS
<*> 
	gm_Pors
;

4926 
	gVe
<
	gSn
*> 
	gm_csdSns
;

4928 
	gpublic
:

4929 
PageMMemyUgeRecd
(
sk_t
 
sk
, * 
cڋxt
, 
tyMask
, 
vm_nge_cd_t
* 
cd
, cڡ 
RemeMemyRd
& 
ad
, cڡ 
FeObjeFd
& 
ObjeFd
)

4930 : 
m_sk
(
sk
)

4931 , 
m_cڋxt
(
cڋxt
)

4932 , 
m_tyMask
(
tyMask
)

4933 , 
m_cd
(
cd
)

4934 , 
m_ad
(
ad
)

4935 , 
m_ObjeFd
(
ObjeFd
)

4938 ~
PageMMemyUgeRecd
()

4940 
ASSERT
(!
m_csdSns
.
size
());

4943 
cdPdgRegis
()

4945 
ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

4947 
bo
 
	gcdRegisCڏgPors
 = 
m_tyMask
 & 
MALLOC_PTR_REGION_RANGE_TYPE
;

4948 
bo
 
	gcdAotis
 = 
m_tyMask
 & 
MALLOC_PTR_IN_USE_RANGE_TYPE
;

4950 i(!
	gcdRegisCڏgPors
 && !
	gcdAotis
) {

4951 
	gm_csdSns
.
r
();

4955 
	gVe
<
	gvm_nge_t
, 256> 
	gporRegis
;

4956 
	gVe
<
	gvm_nge_t
, 1024> 
	glodPors
;

4957 
size_t
 
	gi
 = 0; i < 
	gm_csdSns
.
size
(); ++i) {

4958 
Sn
 *
	gtheSn
 = 
m_csdSns
[
i
];

4959 
vm_addss_t
 
	gSAddss
 = 
theSn
->
t
 << 
kPageShi
;

4960 
vm_size_t
 
	gSizeInBys
 = 
theSn
->
ngth
 * 
kPageSize
;

4962 i(
	gcdRegisCڏgPors
)

4963 
	gporRegis
.
nd
((
vm_nge_t
){
SAddss
, 
SizeInBys
});

4965 i(
	gtheSn
->
	g
 || !
	gcdAotis
)

4968 i(!
	gtheSn
->
	gsizeass
) {

4970 i(!
	gm_ObjeFd
.
isFeObje
(
SAddss
))

4971 
	glodPors
.
nd
((
vm_nge_t
){
SAddss
, 
SizeInBys
});

4973 cڡ 
size_t
 
	gobjeSize
 = 
BySizeFCss
(
theSn
->
sizeass
);

4976 cڡ 
vm_addss_t
 
	gdOfSn
 = 
SAddss
 + 
SizeInBys
;

4977 
vm_addss_t
 
	gobje
 = 
SAddss
; obje + 
	gobjeSize
 <
dOfSn
; obje +
objeSize
) {

4978 i(!
m_ObjeFd
.
isFeObje
(
obje
))

4979 
lodPors
.
nd
((
vm_nge_t
){
obje
, 
objeSize
});

4984 i(
	gcdRegisCڏgPors
)

4985 (*
	gm_cd
)(
	gm_sk
, 
	gm_cڋxt
, 
	gMALLOC_PTR_REGION_RANGE_TYPE
, 
	gporRegis
.
da
(),orRegis.
size
());

4987 i(
	gcdAotis
)

4988 (*
	gm_cd
)(
	gm_sk
, 
	gm_cڋxt
, 
	gMALLOC_PTR_IN_USE_RANGE_TYPE
, 
	glodPors
.
da
(),odPors.
size
());

4990 
	gm_csdSns
.
r
();

4993 
vis
(* 
r
)

4995 
ASSERT
(
kPageShi
 && 
kNumCss
 && 
kPageSize
);

4996 i(!
	gr
)

4999 
Sn
* 
	g
 = 
m_ad
(
t_
<Sn*>(
r
));

5000 i(!
	g
 || !->
	gt
)

5003 i(!
	gm_Pors
.
add
(
r
).
	gisNewEry
)

5004  
	g
->
	gngth
;

5006 i(!
	gm_csdSns
.
size
()) {

5007 
	gm_csdSns
.
nd
(

);

5008  
	g
->
	gngth
;

5011 
Sn
* 
	geviousSn
 = 
m_csdSns
[m_csdSns.
size
() - 1];

5012 
vm_addss_t
 
	geviousSnSAddss
 = 
eviousSn
->
t
 << 
kPageShi
;

5013 
vm_size_t
 
	geviousSnSizeInBys
 = 
eviousSn
->
ngth
 * 
kPageSize
;

5016 
vm_addss_t
 
	gSAddss
 = 

->
t
 << 
kPageShi
;

5017 i(
	gSAddss
 =
eviousSnSAddss
 + 
eviousSnSizeInBys
) {

5018 
m_csdSns
.
nd
(

);

5019  
	g
->
	gngth
;

5023 
cdPdgRegis
();

5024 
	gm_csdSns
.
nd
(

);

5026  
	g
->
	gngth
;

5030 as
	cAdmRegiRecd
 {

5031 
sk_t
 
	gm_sk
;

5032 * 
	gm_cڋxt
;

5033 
	gm_tyMask
;

5034 
vm_nge_cd_t
* 
	gm_cd
;

5036 
	gVe
<
	gvm_nge_t
, 1024> 
	gm_ndgRegis
;

5038 
	gpublic
:

5039 
AdmRegiRecd
(
sk_t
 
sk
, * 
cڋxt
, 
tyMask
, 
vm_nge_cd_t
* 
cd
)

5040 : 
m_sk
(
sk
)

5041 , 
m_cڋxt
(
cڋxt
)

5042 , 
m_tyMask
(
tyMask
)

5043 , 
m_cd
(
cd
)

5046 
cdRegi
(
vm_addss_t
 
r
, 
size_t
 
size
)

5048 i(
	gm_tyMask
 & 
	gMALLOC_ADMIN_REGION_RANGE_TYPE
)

5049 
	gm_ndgRegis
.
nd
((
vm_nge_t
){ 
r
, 
size
 });

5052 
vis
(*
r
, 
size_t
 
size
)

5054 
cdRegi
(
t_
<
vm_addss_t
>(
r
), 
size
);

5057 
cdPdgRegis
()

5059 i(
	gm_ndgRegis
.
size
()) {

5060 (*
	gm_cd
)(
	gm_sk
, 
	gm_cڋxt
, 
	gMALLOC_ADMIN_REGION_RANGE_TYPE
, 
	gm_ndgRegis
.
da
(), m_ndgRegis.
size
());

5061 
	gm_ndgRegis
.
r
();

5065 ~
AdmRegiRecd
()

5067 
ASSERT
(!
m_ndgRegis
.
size
());

5071 
kn_tu_t
 
	gFaMlocZe
::
	$ume
(
sk_t
 
sk
, * 
cڋxt
, 
tyMask
, 
vm_addss_t
 
zeAddss
, 
memy_ad_t
 
ad
, 
vm_nge_cd_t
 
cd
)

5073 
RemeMemyRd
 
	`memyRd
(
sk
, 
ad
);

5075 
	`InSizeCss
();

5077 
FaMlocZe
* 
mze
 = 
	`memyRd
(
t_
<FaMlocZe*>(
zeAddss
));

5078 
TCMloc_PageHp
* 
geHp
 = 
	`memyRd
(
mze
->
m_geHp
);

5079 
TCMloc_ThadCache
** 
thadHpsPor
 = 
	`memyRd
(
mze
->
m_thadHps
);

5080 
TCMloc_ThadCache
* 
thadHps
 = 
	`memyRd
(*
thadHpsPor
);

5082 
TCMloc_C_FeLiPadded
* 
lCaches
 = 
	`memyRd
(
mze
->
m_lCaches
, (TCMloc_C_FeLiPadded* 
kNumCss
);

5084 
FeObjeFd
 
	`fd
(
memyRd
);

5085 
fd
.
	`fdFeObjes
(
thadHps
);

5086 
fd
.
	`fdFeObjes
(
lCaches
, 
kNumCss
, 
mze
->
m_lCaches
);

5088 
TCMloc_PageHp
::
PageM
* 
geM
 = &
geHp
->
gem_
;

5089 
PageMFeObjeFd
 
	`geMFd
(
memyRd
, 
fd
, 
geHp
->
y_
);

5090 
geM
->
	`visVues
(
geMFd
, 
memyRd
);

5092 
PageMMemyUgeRecd
 
	`ugeRecd
(
sk
, 
cڋxt
, 
tyMask
, 
cd
, 
memyRd
, 
fd
);

5093 
geM
->
	`visVues
(
ugeRecd
, 
memyRd
);

5094 
ugeRecd
.
	`cdPdgRegis
();

5096 
AdmRegiRecd
 
	`admRegiRecd
(
sk
, 
cڋxt
, 
tyMask
, 
cd
);

5097 
geM
->
	`visAotis
(
admRegiRecd
, 
memyRd
);

5099 
PageHpAot
<
Sn
>* 
Aot
 = 
	`memyRd
(
mze
->
m_Aot
);

5100 
PageHpAot
<
TCMloc_ThadCache
>* 
geHpAot
 = 
	`memyRd
(
mze
->
m_geHpAot
);

5102 
Aot
->
	`cdAdmitiveRegis
(
admRegiRecd
, 
memyRd
);

5103 
geHpAot
->
	`cdAdmitiveRegis
(
admRegiRecd
, 
memyRd
);

5105 
admRegiRecd
.
	`cdPdgRegis
();

5108 
	}
}

5110 
size_t
 
	gFaMlocZe
::
	$size
(
mloc_ze_t
*, const *)

5113 
	}
}

5115 * 
	gFaMlocZe
::
	$zeMloc
(
mloc_ze_t
*, 
size_t
)

5118 
	}
}

5120 * 
	gFaMlocZe
::
	$zeCloc
(
mloc_ze_t
*, 
size_t
, size_t)

5123 
	}
}

5125 
	gFaMlocZe
::
	$zeFe
(
mloc_ze_t
*, * 
r
)

5130 
	`mloc_tf
("*** f obje %p:obeg fed wanهod\n", 
r
);

5131 
	}
}

5133 * 
	gFaMlocZe
::
	$zeRoc
(
mloc_ze_t
*, *, 
size_t
)

5136 
	}
}

5139 #unde
mloc


5140 #unde



5141 #unde
loc


5142 #unde
oc


5145 
mloc_oei_t
 
jsce_mloc_oei
 = { &
FaMlocZe
::
ume
, &FaMlocZe::
goodSize
, &FaMlocZe::
check
, &FaMlocZe::
t
,

5146 &
FaMlocZe
::
log
, &FaMlocZe::
fLock
, &FaMlocZe::
fUock
, &FaMlocZe::
iics


5153 
FaMlocZe
::FaMlocZe(
TCMloc_PageHp
* 
geHp
, 
TCMloc_ThadCache
** 
thadHps
, 
TCMloc_C_FeLiPadded
* 
lCaches
, 
PageHpAot
<
Sn
>* 
Aot
, PageHpAot<TCMloc_ThadCache>* 
geHpAot
)

5154 : 
m_geHp
(
geHp
)

5155 , 
m_thadHps
(
thadHps
)

5156 , 
m_lCaches
(
lCaches
)

5157 , 
m_Aot
(
Aot
)

5158 , 
	$m_geHpAot
(
geHpAot
)

5160 
	`memt
(&
m_ze
, 0, (m_zone));

5161 
m_ze
.
vsi
 = 4;

5162 
m_ze
.
ze_me
 = "JavaScriptCore FastMalloc";

5163 
m_ze
.
size
 = &
FaMlocZe
::size;

5164 
m_ze
.
mloc
 = &
FaMlocZe
::
zeMloc
;

5165 
m_ze
.
oc
 = &
FaMlocZe
::
zeCloc
;

5166 
m_ze
.
loc
 = &
FaMlocZe
::
zeRoc
;

5167 
m_ze
.

 = &
FaMlocZe
::
zeFe
;

5168 
m_ze
.
vloc
 = &
FaMlocZe
::
zeVloc
;

5169 
m_ze
.
deroy
 = &
FaMlocZe
::
zeDeroy
;

5170 
m_ze
.
oe
 = &
jsce_mloc_oei
;

5171 
	`mloc_ze_gi
(&
m_ze
);

5172 
	}
}

5175 
FaMlocZe
::
	$
()

5177 
FaMlocZe
 
	`ze
(
gehp
, &
thad_hps
, 
ic_
<
TCMloc_C_FeLiPadded
*>(
l_che
), &
_lot
, &
thadhp_lot
);

5178 
	}
}

	@FastMalloc.h

21 #ide
WTF_FaMloc_h


22 
	#WTF_FaMloc_h


	)

24 
	~<w
>

25 
	~<dlib.h
>

26 
	~<wtf/PossiblyNu.h
>

27 
	~<wtf/StdLibExas.h
>

29 
mea
 
	gWTF
 {

32 
WTF_EXPORT_PRIVATE
 * 
Mloc
(
size_t
);

33 
WTF_EXPORT_PRIVATE
 * 
ZdMloc
(
size_t
);

34 
WTF_EXPORT_PRIVATE
 * 
Cloc
(
size_t
 
numEmts
, size_
emtSize
);

35 
WTF_EXPORT_PRIVATE
 * 
Roc
(*, 
size_t
);

36 
WTF_EXPORT_PRIVATE
 * 
SDup
(const *);

37 
WTF_EXPORT_PRIVATE
 
size_t
 
MlocSize
(const *);

38 
WTF_EXPORT_PRIVATE
 
size_t
 
MlocGoodSize
(size_t);

40 
	sTryMlocRuVue
 {

41 
TryMlocRuVue
(* 
da
)

42 : 
m_da
(
da
)

45 
TryMlocRuVue
(cڡ TryMlocRuVue& 
sour
)

46 : 
m_da
(
sour
.m_data)

48 
sour
.
m_da
 = 0;

50 ~
TryMlocRuVue
({ 
ASSERT
(!
m_da
); }

51 
	gme
 <
tyme
 
	gT
> 
bo
 
gVue
(
T
& 
da

	gWARN_UNUSED_RETURN
;

52 
	gme
 <
tyme
 
	gT
> 
ݔ
 
	gPossiblyNu
<T>()

54 
T
 
	gvue
;

55 
gVue
(
vue
);

56  
	gPossiblyNu
<
	gT
>(
	gvue
);

58 
	give
:

59 
mub
 * 
m_da
;

62 
	gme
 <
tyme
 
	gT
> 
bo
 
	gTryMlocRuVue
::
gVue
(
T
& 
da
)

64 
	uu
 { * 
da
; 
T
 
	grg
; } 
	gs
;

65 
	gs
.
	gda
 = 
m_da
;

66 
	gda
 = 
s
.
rg
;

67 
bo
 
	gtuVue
 = !!
m_da
;

68 
	gm_da
 = 0;

69  
	gtuVue
;

72 
WTF_EXPORT_PRIVATE
 
TryMlocRuVue
 
yFaMloc
(
size_t
 
n
);

73 
TryMlocRuVue
 
yFaZdMloc
(
size_t
 
n
);

74 
WTF_EXPORT_PRIVATE
 
TryMlocRuVue
 
yFaCloc
(
size_t
 
n_emts
, size_
emt_size
);

75 
WTF_EXPORT_PRIVATE
 
TryMlocRuVue
 
yFaRoc
(* 
p
, 
size_t
 
n
);

77 
WTF_EXPORT_PRIVATE
 
Fe
(*);

79 #ide
NDEBUG


80 
WTF_EXPORT_PRIVATE
 
MlocFbid
();

81 
WTF_EXPORT_PRIVATE
 
MlocAow
();

84 
WTF_EXPORT_PRIVATE
 
aFaMlocFeMemy
();

86 
	sFaMlocStiics
 {

87 
size_t
 
	grvedVMBys
;

88 
size_t
 
	gcommdVMBys
;

89 
size_t
 
	gLiBys
;

91 
WTF_EXPORT_PRIVATE
 
FaMlocStiics
 
MlocStiics
();

95 
	tAocAlignmtIeg
;

97 
mea
 
	gIl
 {

98 
	eAocTy
 {

99 
	gAocTyMloc
 = 0x375d6750,

100 
	gAocTyCssNew
,

101 
	gAocTyCssNewAay
,

102 
	gAocTyNew
,

103 
	gAocTyNewAay


107 
	gVidiPfix
 = 0xf00df00d,

108 
	gVidiSuffix
 = 0x0badf00d

111 
	tVidiTag
;

113 
	sVidiHd
 {

114 
AocTy
 
	gm_ty
;

115 
	gm_size
;

116 
VidiTag
 
	gm_efix
;

117 
	gm_ignmt
;

120 cڡ 
	gVidiBufrSize
 = (
VidiHd
+ (
VidiTag
);

123 #i
ENABLE
(
WTF_MALLOC_VALIDATION
)

137 
mea
 
	gIl
 {

140 
MlocMchFaed
(* 
p
);

142 
le
 
VidiHd
* 
MlocVidiHd
(* 
p
)

144  
	gt_
<
	gVidiHd
*>(
	gic_
<*>(
	gp
) - (ValidationHeader));

147 
le
 
VidiTag
* 
MlocVidiSuffix
(* 
p
)

149 
VidiHd
* 
	ghd
 = 
MlocVidiHd
(
p
);

150 i(
	ghd
->
	gm_efix
 !
ic_
<>(
VidiPfix
))

151 
MlocMchFaed
(
p
);

153  
	gt_
<
	gVidiTag
*>(
	gic_
<*>(
	gp
+ 
	ghd
->
	gm_size
);

157 
le
 
AocTy
 
MlocMchVidiTy
(* 
p
)

159  
MlocVidiHd
(
p
)->
	gm_ty
;

163 
le
 
tFaMlocMchVidiTy
(* 
p
, 
AocTy
 
locTy
)

165 
MlocVidiHd
(
p
)->
	gm_ty
 = 
locTy
;

171 
le
 
MlocMchVideMloc
(* 
p
, 
Il
::
AocTy
 
locTy
)

173 i(!
p
)

176 
	gIl
::
tFaMlocMchVidiTy
(
p
, 
locTy
);

180 
le
 
MlocMchVideFe
(* 
p
, 
Il
::
AocTy
)

182 i(!
p
)

185 
	gIl
::
VidiHd
* 
hd
 = 
Il
::
MlocVidiHd
(
p
);

186 i(
	ghd
->
	gm_efix
 !
ic_
<>(
Il
::
VidiPfix
))

187 
Il
::
MlocMchFaed
(
p
);

189 i(*
	gIl
::
MlocVidiSuffix
(
p
!
Il
::
VidiSuffix
)

190 
Il
::
MlocMchFaed
(
p
);

192 
	gIl
::
tFaMlocMchVidiTy
(
p
, 
Il
::
AocTyMloc
);

195 
le
 
MlocVide
(* 
p
)

197 i(!
	gp
)

200 
	gIl
::
VidiHd
* 
hd
 = 
Il
::
MlocVidiHd
(
p
);

201 i(
	ghd
->
	gm_efix
 !
ic_
<>(
Il
::
VidiPfix
))

202 
Il
::
MlocMchFaed
(
p
);

204 i(*
	gIl
::
MlocVidiSuffix
(
p
!
Il
::
VidiSuffix
)

205 
Il
::
MlocMchFaed
(
p
);

210 
le
 
MlocMchVideMloc
(*, 
Il
::
AocTy
)

214 
le
 
MlocMchVideFe
(*, 
Il
::
AocTy
)

222 
usg
 
WTF
::
Cloc
;

223 
usg
 
	gWTF
::
Fe
;

224 
usg
 
	gWTF
::
Mloc
;

225 
usg
 
	gWTF
::
MlocGoodSize
;

226 
usg
 
	gWTF
::
MlocSize
;

227 
usg
 
	gWTF
::
Roc
;

228 
usg
 
	gWTF
::
SDup
;

229 
usg
 
	gWTF
::
ZdMloc
;

230 
usg
 
	gWTF
::
yFaCloc
;

231 
usg
 
	gWTF
::
yFaMloc
;

232 
usg
 
	gWTF
::
yFaRoc
;

233 
usg
 
	gWTF
::
yFaZdMloc
;

235 #ide
NDEBUG


236 
usg
 
	gWTF
::
MlocFbid
;

237 
usg
 
	gWTF
::
MlocAow
;

240 #i
COMPILER
(
GCC
&& 
OS
(
DARWIN
)

241 
	#WTF_PRIVATE_INLINE
 
__ive_ex__
 
le
 
	`__ibu__
((
ways_le
))

	)

242 #i
COMPILER
(
GCC
)

243 
	#WTF_PRIVATE_INLINE
 
le
 
	`__ibu__
((
ways_le
))

	)

244 #i
COMPILER
(
MSVC
)

245 
	#WTF_PRIVATE_INLINE
 
__fle


	)

247 
	#WTF_PRIVATE_INLINE
 
le


	)

250 
	#WTF_MAKE_FAST_ALLOCATED
 \

251 
public
: \

252 * 
ݔ
 
	`w
(
size_t
, * 
p
) { ; } \

253 * 
ݔ
 
w
[](
size_t
, * 
p
) { ; } \

255 * 
ݔ
 
	`w
(
size_t
 
size
) \

257 * 
p
 = ::
WTF
::
	`Mloc
(
size
); \

258 ::
WTF
::
	`MlocMchVideMloc
(
p
, ::WTF::
Il
::
AocTyCssNew
); \

259  
p
; \

262 
ݔ
 
	`de
(* 
p
) \

264 ::
WTF
::
	`MlocMchVideFe
(
p
, ::WTF::
Il
::
AocTyCssNew
); \

265 ::
WTF
::
	`Fe
(
p
); \

268 * 
ݔ
 
w
[](
size_t
 
size
) \

270 * 
p
 = ::
WTF
::
	`Mloc
(
size
); \

271 ::
WTF
::
	`MlocMchVideMloc
(
p
, ::WTF::
Il
::
AocTyCssNewAay
); \

272  
p
; \

275 
ݔ
 
de
[](* 
p
) \

277 ::
WTF
::
	`MlocMchVideFe
(
p
, ::WTF::
Il
::
AocTyCssNewAay
); \

278 ::
WTF
::
	`Fe
(
p
); \

280 * 
ݔ
 
	`w
(
size_t
, 
NNuTag
, * 
loti
) \

282 
	`ASSERT
(
loti
); \

283  
loti
; \

285 
ive
: \

286 
	t__thisIsHeToFASemicAThisMao


	)

	@FeatureDefines.h

29 #ide
WTF_FtuDefes_h


30 
	#WTF_FtuDefes_h


	)

55 #i
PLATFORM
(
IOS
)

57 #i!
defed
(
ENABLE_ASYNC_SCROLLING
)

58 
	#ENABLE_ASYNC_SCROLLING
 1

	)

61 #i!
defed
(
ENABLE_CONTEXT_MENUS
)

62 
	#ENABLE_CONTEXT_MENUS
 0

	)

65 #i!
defed
(
ENABLE_CSS_IMAGE_SET
)

66 
	#ENABLE_CSS_IMAGE_SET
 1

	)

69 #i!
defed
(
ENABLE_CURSOR_SUPPORT
)

70 
	#ENABLE_CURSOR_SUPPORT
 0

	)

73 #i!
defed
(
ENABLE_DRAG_SUPPORT
)

74 
	#ENABLE_DRAG_SUPPORT
 0

	)

77 #i!
defed
(
ENABLE_GEOLOCATION
)

78 
	#ENABLE_GEOLOCATION
 1

	)

81 #i!
defed
(
ENABLE_ICONDATABASE
)

82 
	#ENABLE_ICONDATABASE
 0

	)

85 #i!
defed
(
ENABLE_LETTERPRESS
)

86 
	#ENABLE_LETTERPRESS
 1

	)

89 #i!
defed
(
ENABLE_IOS_AUTOCORRECT_AND_AUTOCAPITALIZE
)

90 
	#ENABLE_IOS_AUTOCORRECT_AND_AUTOCAPITALIZE
 1

	)

93 #i!
defed
(
ENABLE_IOS_GESTURE_EVENTS
&& 
USE
(
APPLE_INTERNAL_SDK
)

94 
	#ENABLE_IOS_GESTURE_EVENTS
 1

	)

97 #i!
defed
(
ENABLE_IOS_TEXT_AUTOSIZING
)

98 
	#ENABLE_IOS_TEXT_AUTOSIZING
 1

	)

101 #i!
defed
(
ENABLE_IOS_TOUCH_EVENTS
&& 
USE
(
APPLE_INTERNAL_SDK
)

102 
	#ENABLE_IOS_TOUCH_EVENTS
 1

	)

105 #i!
defed
(
ENABLE_METER_ELEMENT
)

106 
	#ENABLE_METER_ELEMENT
 0

	)

109 #i!
defed
(
ENABLE_NETSCAPE_PLUGIN_API
)

110 
	#ENABLE_NETSCAPE_PLUGIN_API
 0

	)

113 #i!
defed
(
ENABLE_ORIENTATION_EVENTS
)

114 
	#ENABLE_ORIENTATION_EVENTS
 1

	)

117 #i!
defed
(
ENABLE_POINTER_LOCK
)

118 
	#ENABLE_POINTER_LOCK
 0

	)

121 #i!
defed
(
ENABLE_REMOTE_INSPECTOR
)

122 
	#ENABLE_REMOTE_INSPECTOR
 1

	)

125 #i!
defed
(
ENABLE_RESPECT_EXIF_ORIENTATION
)

126 
	#ENABLE_RESPECT_EXIF_ORIENTATION
 1

	)

129 #i!
defed
(
ENABLE_TEXT_CARET
)

130 
	#ENABLE_TEXT_CARET
 0

	)

133 #i!
defed
(
ENABLE_TEXT_SELECTION
)

134 
	#ENABLE_TEXT_SELECTION
 0

	)

139 #i!
defed
(
ENABLE_TOUCH_EVENTS
&& 
USE
(
APPLE_INTERNAL_SDK
)

140 
	#ENABLE_TOUCH_EVENTS
 1

	)

143 #i!
defed
(
ENABLE_WEB_ARCHIVE
)

144 
	#ENABLE_WEB_ARCHIVE
 1

	)

147 #i!
defed
(
ENABLE_VIEW_MODE_CSS_MEDIA
)

148 
	#ENABLE_VIEW_MODE_CSS_MEDIA
 0

	)

151 #i!
defed
(
ENABLE_WEBGL
)

152 
	#ENABLE_WEBGL
 1

	)

157 #i!
defed
(
ENABLE_XSLT
&& !
USE
(
APPLE_INTERNAL_SDK
)

158 
	#ENABLE_XSLT
 0

	)

164 #i
PLATFORM
(
MAC
)

166 #i!
defed
(
ENABLE_CSS_IMAGE_SET
)

167 
	#ENABLE_CSS_IMAGE_SET
 1

	)

170 #i!
defed
(
ENABLE_DASHBOARD_SUPPORT
)

171 
	#ENABLE_DASHBOARD_SUPPORT
 1

	)

174 #i!
defed
(
ENABLE_DELETION_UI
)

175 
	#ENABLE_DELETION_UI
 1

	)

178 #i
__MAC_OS_X_VERSION_MIN_REQUIRED
 >= 1090

179 #i!
defed
(
ENABLE_ENCRYPTED_MEDIA
)

180 
	#ENABLE_ENCRYPTED_MEDIA
 1

	)

182 #i!
defed
(
ENABLE_ENCRYPTED_MEDIA_V2
)

183 
	#ENABLE_ENCRYPTED_MEDIA_V2
 1

	)

187 #i!
defed
(
ENABLE_FULLSCREEN_API
)

188 
	#ENABLE_FULLSCREEN_API
 1

	)

191 #i
__MAC_OS_X_VERSION_MIN_REQUIRED
 >= 101000

192 #i!
defed
(
ENABLE_REMOTE_INSPECTOR
)

193 
	#ENABLE_REMOTE_INSPECTOR
 1

	)

197 #i!
defed
(
ENABLE_SMOOTH_SCROLLING
)

198 
	#ENABLE_SMOOTH_SCROLLING
 1

	)

201 #i!
defed
(
ENABLE_ASYNC_SCROLLING
)

202 
	#ENABLE_ASYNC_SCROLLING
 1

	)

205 #i
ENABLE
(
VIDEO
)

206 #i!
defed
(
ENABLE_VIDEO_TRACK
)

207 
	#ENABLE_VIDEO_TRACK
 1

	)

211 #i!
defed
(
ENABLE_VIEW_MODE_CSS_MEDIA
)

212 
	#ENABLE_VIEW_MODE_CSS_MEDIA
 0

	)

215 #i!
defed
(
ENABLE_WEB_ARCHIVE
)

216 
	#ENABLE_WEB_ARCHIVE
 1

	)

219 #i!
defed
(
ENABLE_WEB_AUDIO
)

220 
	#ENABLE_WEB_AUDIO
 1

	)

223 #i!
defed
(
ENABLE_CURSOR_VISIBILITY
)

224 
	#ENABLE_CURSOR_VISIBILITY
 1

	)

227 #i!
defed
(
ENABLE_INPUT_TYPE_COLOR
)

228 
	#ENABLE_INPUT_TYPE_COLOR
 1

	)

231 #i!
defed
(
ENABLE_INPUT_TYPE_COLOR_POPOVER
)

232 
	#ENABLE_INPUT_TYPE_COLOR_POPOVER
 1

	)

235 #i!
defed
(
ENABLE_FILE_REPLACEMENT
)

236 
	#ENABLE_FILE_REPLACEMENT
 1

	)

242 #i
PLATFORM
(
WIN
&& !PLATFORM(
WIN_CAIRO
)

244 #i!
defed
(
ENABLE_FULLSCREEN_API
)

245 
	#ENABLE_FULLSCREEN_API
 1

	)

248 #i!
defed
(
ENABLE_WEB_ARCHIVE
)

249 
	#ENABLE_WEB_ARCHIVE
 1

	)

252 #i!
defed
(
ENABLE_WEBGL
)

253 
	#ENABLE_WEBGL
 1

	)

261 #i
PLATFORM
(
WIN_CAIRO
)

263 #i!
defed
(
ENABLE_WEB_ARCHIVE
)

264 
	#ENABLE_WEB_ARCHIVE
 1

	)

267 #i!
defed
(
ENABLE_VIEW_MODE_CSS_MEDIA
)

268 
	#ENABLE_VIEW_MODE_CSS_MEDIA
 0

	)

271 #i!
defed
(
ENABLE_WEBGL
)

272 
	#ENABLE_WEBGL
 1

	)

278 #i
PLATFORM
(
EFL
)

280 #i!
defed
(
ENABLE_PLUGIN_PACKAGE_SIMPLE_HASH
)

281 
	#ENABLE_PLUGIN_PACKAGE_SIMPLE_HASH
 1

	)

287 #i
PLATFORM
(
GTK
)

289 #i
OS
(
UNIX
)

290 #i!
defed
(
ENABLE_PLUGIN_PACKAGE_SIMPLE_HASH
)

291 
	#ENABLE_PLUGIN_PACKAGE_SIMPLE_HASH
 1

	)

300 #i!
defed
(
ENABLE_3D_RENDERING
)

301 
	#ENABLE_3D_RENDERING
 0

	)

304 #i!
defed
(
ENABLE_ACCELERATED_2D_CANVAS
)

305 
	#ENABLE_ACCELERATED_2D_CANVAS
 0

	)

308 #i!
defed
(
ENABLE_ACCELERATED_OVERFLOW_SCROLLING
)

309 
	#ENABLE_ACCELERATED_OVERFLOW_SCROLLING
 0

	)

312 #i!
defed
(
ENABLE_BATTERY_STATUS
)

313 
	#ENABLE_BATTERY_STATUS
 0

	)

316 #i!
defed
(
ENABLE_CANVAS_PATH
)

317 
	#ENABLE_CANVAS_PATH
 1

	)

320 #i!
defed
(
ENABLE_CANVAS_PROXY
)

321 
	#ENABLE_CANVAS_PROXY
 0

	)

324 #i!
defed
(
ENABLE_CHANNEL_MESSAGING
)

325 
	#ENABLE_CHANNEL_MESSAGING
 1

	)

328 #i!
defed
(
ENABLE_CONTEXT_MENUS
)

329 
	#ENABLE_CONTEXT_MENUS
 1

	)

332 #i!
defed
(
ENABLE_CSP_NEXT
)

333 
	#ENABLE_CSP_NEXT
 0

	)

336 #i!
defed
(
ENABLE_CSS3_CONDITIONAL_RULES
)

337 
	#ENABLE_CSS3_CONDITIONAL_RULES
 0

	)

340 #i!
defed
(
ENABLE_CSS3_TEXT
)

341 
	#ENABLE_CSS3_TEXT
 0

	)

344 #i!
defed
(
ENABLE_CSS_BOX_DECORATION_BREAK
)

345 
	#ENABLE_CSS_BOX_DECORATION_BREAK
 1

	)

348 #i!
defed
(
ENABLE_CSS_DEVICE_ADAPTATION
)

349 
	#ENABLE_CSS_DEVICE_ADAPTATION
 0

	)

352 #i!
defed
(
ENABLE_CSS_COMPOSITING
)

353 
	#ENABLE_CSS_COMPOSITING
 0

	)

356 #i!
defed
(
ENABLE_CSS_IMAGE_ORIENTATION
)

357 
	#ENABLE_CSS_IMAGE_ORIENTATION
 0

	)

360 #i!
defed
(
ENABLE_CSS_IMAGE_RESOLUTION
)

361 
	#ENABLE_CSS_IMAGE_RESOLUTION
 0

	)

364 #i!
defed
(
ENABLE_CSS_IMAGE_SET
)

365 
	#ENABLE_CSS_IMAGE_SET
 0

	)

368 #i!
defed
(
ENABLE_CURSOR_SUPPORT
)

369 
	#ENABLE_CURSOR_SUPPORT
 1

	)

372 #i!
defed
(
ENABLE_CUSTOM_SCHEME_HANDLER
)

373 
	#ENABLE_CUSTOM_SCHEME_HANDLER
 0

	)

376 #i!
defed
(
ENABLE_DASHBOARD_SUPPORT
)

377 
	#ENABLE_DASHBOARD_SUPPORT
 0

	)

380 #i!
defed
(
ENABLE_DATALIST_ELEMENT
)

381 
	#ENABLE_DATALIST_ELEMENT
 0

	)

384 #i!
defed
(
ENABLE_DATA_TRANSFER_ITEMS
)

385 
	#ENABLE_DATA_TRANSFER_ITEMS
 0

	)

388 #i!
defed
(
ENABLE_DELETION_UI
)

389 
	#ENABLE_DELETION_UI
 0

	)

392 #i!
defed
(
ENABLE_DETAILS_ELEMENT
)

393 
	#ENABLE_DETAILS_ELEMENT
 1

	)

396 #i!
defed
(
ENABLE_DEVICE_ORIENTATION
)

397 
	#ENABLE_DEVICE_ORIENTATION
 0

	)

400 #i!
defed
(
ENABLE_DOWNLOAD_ATTRIBUTE
)

401 
	#ENABLE_DOWNLOAD_ATTRIBUTE
 0

	)

404 #i!
defed
(
ENABLE_DRAG_SUPPORT
)

405 
	#ENABLE_DRAG_SUPPORT
 1

	)

408 #i!
defed
(
ENABLE_ENCRYPTED_MEDIA
)

409 
	#ENABLE_ENCRYPTED_MEDIA
 0

	)

412 #i!
defed
(
ENABLE_ENCRYPTED_MEDIA_V2
)

413 
	#ENABLE_ENCRYPTED_MEDIA_V2
 0

	)

416 #i!
defed
(
ENABLE_FONT_LOAD_EVENTS
)

417 
	#ENABLE_FONT_LOAD_EVENTS
 0

	)

420 #i!
defed
(
ENABLE_FTPDIR
)

421 
	#ENABLE_FTPDIR
 1

	)

424 #i!
defed
(
ENABLE_FULLSCREEN_API
)

425 
	#ENABLE_FULLSCREEN_API
 0

	)

428 #i!
defed
(
ENABLE_GAMEPAD
)

429 
	#ENABLE_GAMEPAD
 0

	)

432 #i!
defed
(
ENABLE_GAMEPAD_DEPRECATED
)

433 
	#ENABLE_GAMEPAD_DEPRECATED
 0

	)

436 #i!
defed
(
ENABLE_GEOLOCATION
)

437 
	#ENABLE_GEOLOCATION
 0

	)

440 #i!
defed
(
ENABLE_HIDDEN_PAGE_DOM_TIMER_THROTTLING
)

441 
	#ENABLE_HIDDEN_PAGE_DOM_TIMER_THROTTLING
 0

	)

444 #i!
defed
(
ENABLE_ICONDATABASE
)

445 
	#ENABLE_ICONDATABASE
 1

	)

448 #i!
defed
(
ENABLE_IMAGE_DECODER_DOWN_SAMPLING
)

449 
	#ENABLE_IMAGE_DECODER_DOWN_SAMPLING
 0

	)

452 #i!
defed
(
ENABLE_INDEXED_DATABASE
)

453 
	#ENABLE_INDEXED_DATABASE
 0

	)

456 #i!
defed
(
ENABLE_INDEXED_DATABASE_IN_WORKERS
)

457 
	#ENABLE_INDEXED_DATABASE_IN_WORKERS
 0

	)

460 #i!
defed
(
ENABLE_INPUT_TYPE_COLOR
)

461 
	#ENABLE_INPUT_TYPE_COLOR
 0

	)

464 #i!
defed
(
ENABLE_INPUT_TYPE_COLOR_POPOVER
)

465 
	#ENABLE_INPUT_TYPE_COLOR_POPOVER
 0

	)

468 #i!
defed
(
ENABLE_INPUT_TYPE_DATE
)

469 
	#ENABLE_INPUT_TYPE_DATE
 0

	)

472 #i!
defed
(
ENABLE_INPUT_TYPE_DATETIME_INCOMPLETE
)

473 
	#ENABLE_INPUT_TYPE_DATETIME_INCOMPLETE
 0

	)

476 #i!
defed
(
ENABLE_INPUT_TYPE_DATETIMELOCAL
)

477 
	#ENABLE_INPUT_TYPE_DATETIMELOCAL
 0

	)

480 #i!
defed
(
ENABLE_INPUT_TYPE_MONTH
)

481 
	#ENABLE_INPUT_TYPE_MONTH
 0

	)

484 #i!
defed
(
ENABLE_INPUT_TYPE_TIME
)

485 
	#ENABLE_INPUT_TYPE_TIME
 0

	)

488 #i!
defed
(
ENABLE_INPUT_TYPE_WEEK
)

489 
	#ENABLE_INPUT_TYPE_WEEK
 0

	)

492 #i
ENABLE
(
INPUT_TYPE_DATE
|| ENABLE(
INPUT_TYPE_DATETIME_INCOMPLETE
|| ENABLE(
INPUT_TYPE_DATETIMELOCAL
|| ENABLE(
INPUT_TYPE_MONTH
|| ENABLE(
INPUT_TYPE_TIME
|| ENABLE(
INPUT_TYPE_WEEK
)

493 #i!
defed
(
ENABLE_DATE_AND_TIME_INPUT_TYPES
)

494 
	#ENABLE_DATE_AND_TIME_INPUT_TYPES
 1

	)

498 #i!
defed
(
ENABLE_INSPECTOR
)

499 
	#ENABLE_INSPECTOR
 1

	)

502 #i!
defed
(
ENABLE_JAVASCRIPT_I18N_API
)

503 
	#ENABLE_JAVASCRIPT_I18N_API
 0

	)

506 #i!
defed
(
ENABLE_LEGACY_CSS_VENDOR_PREFIXES
)

507 
	#ENABLE_LEGACY_CSS_VENDOR_PREFIXES
 0

	)

510 #i!
defed
(
ENABLE_LEGACY_NOTIFICATIONS
)

511 
	#ENABLE_LEGACY_NOTIFICATIONS
 0

	)

514 #i!
defed
(
ENABLE_LEGACY_VENDOR_PREFIXES
)

515 
	#ENABLE_LEGACY_VENDOR_PREFIXES
 0

	)

518 #i!
defed
(
ENABLE_LETTERPRESS
)

519 
	#ENABLE_LETTERPRESS
 0

	)

522 #i!
defed
(
ENABLE_LINK_PREFETCH
)

523 
	#ENABLE_LINK_PREFETCH
 0

	)

526 #i!
defed
(
ENABLE_MATHML
)

527 
	#ENABLE_MATHML
 1

	)

530 #i!
defed
(
ENABLE_MEDIA_CAPTURE
)

531 
	#ENABLE_MEDIA_CAPTURE
 0

	)

534 #i!
defed
(
ENABLE_MEDIA_CONTROLS_SCRIPT
)

535 
	#ENABLE_MEDIA_CONTROLS_SCRIPT
 0

	)

538 #i!
defed
(
ENABLE_MEDIA_SOURCE
)

539 
	#ENABLE_MEDIA_SOURCE
 0

	)

542 #i!
defed
(
ENABLE_MEDIA_STATISTICS
)

543 
	#ENABLE_MEDIA_STATISTICS
 0

	)

546 #i!
defed
(
ENABLE_MEDIA_STREAM
)

547 
	#ENABLE_MEDIA_STREAM
 0

	)

550 #i!
defed
(
ENABLE_METER_ELEMENT
)

551 
	#ENABLE_METER_ELEMENT
 1

	)

554 #i!
defed
(
ENABLE_MHTML
)

555 
	#ENABLE_MHTML
 0

	)

558 #i!
defed
(
ENABLE_MOUSE_CURSOR_SCALE
)

559 
	#ENABLE_MOUSE_CURSOR_SCALE
 0

	)

562 #i!
defed
(
ENABLE_NAVIGATOR_CONTENT_UTILS
)

563 
	#ENABLE_NAVIGATOR_CONTENT_UTILS
 0

	)

566 #i!
defed
(
ENABLE_NAVIGATOR_HWCONCURRENCY
)

567 
	#ENABLE_NAVIGATOR_HWCONCURRENCY
 1

	)

570 #i!
defed
(
ENABLE_NETSCAPE_PLUGIN_API
)

571 
	#ENABLE_NETSCAPE_PLUGIN_API
 1

	)

574 #i!
defed
(
ENABLE_NETSCAPE_PLUGIN_METADATA_CACHE
)

575 
	#ENABLE_NETSCAPE_PLUGIN_METADATA_CACHE
 0

	)

578 #i!
defed
(
ENABLE_NOTIFICATIONS
)

579 
	#ENABLE_NOTIFICATIONS
 0

	)

582 #i!
defed
(
ENABLE_OPENCL
)

583 
	#ENABLE_OPENCL
 0

	)

586 #i!
defed
(
ENABLE_OPENTYPE_VERTICAL
)

587 
	#ENABLE_OPENTYPE_VERTICAL
 0

	)

590 #i!
defed
(
ENABLE_ORIENTATION_EVENTS
)

591 
	#ENABLE_ORIENTATION_EVENTS
 0

	)

594 #i
OS
(
WINDOWS
)

595 #i!
defed
(
ENABLE_PAN_SCROLLING
)

596 
	#ENABLE_PAN_SCROLLING
 1

	)

600 #i!
defed
(
ENABLE_PLUGIN_PACKAGE_SIMPLE_HASH
)

601 
	#ENABLE_PLUGIN_PACKAGE_SIMPLE_HASH
 0

	)

604 #i!
defed
(
ENABLE_POINTER_LOCK
)

605 
	#ENABLE_POINTER_LOCK
 0

	)

608 #i!
defed
(
ENABLE_PROMISES
)

609 
	#ENABLE_PROMISES
 0

	)

612 #i!
defed
(
ENABLE_PROXIMITY_EVENTS
)

613 
	#ENABLE_PROXIMITY_EVENTS
 0

	)

616 #i!
defed
(
ENABLE_QUOTA
)

617 
	#ENABLE_QUOTA
 0

	)

620 #i!
defed
(
ENABLE_REMOTE_INSPECTOR
)

621 
	#ENABLE_REMOTE_INSPECTOR
 0

	)

624 #i!
defed
(
ENABLE_REQUEST_ANIMATION_FRAME
)

625 
	#ENABLE_REQUEST_ANIMATION_FRAME
 0

	)

628 #i!
defed
(
ENABLE_REQUEST_AUTOCOMPLETE
)

629 
	#ENABLE_REQUEST_AUTOCOMPLETE
 0

	)

632 #i!
defed
(
ENABLE_RUBBER_BANDING
)

633 
	#ENABLE_RUBBER_BANDING
 0

	)

636 #i!
defed
(
ENABLE_SATURATED_LAYOUT_ARITHMETIC
)

637 
	#ENABLE_SATURATED_LAYOUT_ARITHMETIC
 1

	)

640 #i!
defed
(
ENABLE_SHARED_WORKERS
)

641 
	#ENABLE_SHARED_WORKERS
 0

	)

644 #i!
defed
(
ENABLE_SMOOTH_SCROLLING
)

645 
	#ENABLE_SMOOTH_SCROLLING
 0

	)

648 #i!
defed
(
ENABLE_SPEECH_SYNTHESIS
)

649 
	#ENABLE_SPEECH_SYNTHESIS
 0

	)

652 #i!
defed
(
ENABLE_SPELLCHECK
)

653 
	#ENABLE_SPELLCHECK
 0

	)

656 #i!
defed
(
ENABLE_SQL_DATABASE
)

657 
	#ENABLE_SQL_DATABASE
 1

	)

660 #i!
defed
(
ENABLE_SVG_FONTS
)

661 
	#ENABLE_SVG_FONTS
 1

	)

664 #i!
defed
(
ENABLE_TEMPLATE_ELEMENT
)

665 
	#ENABLE_TEMPLATE_ELEMENT
 1

	)

668 #i!
defed
(
ENABLE_TEXT_AUTOSIZING
)

669 
	#ENABLE_TEXT_AUTOSIZING
 0

	)

672 #i!
defed
(
ENABLE_TEXT_CARET
)

673 
	#ENABLE_TEXT_CARET
 1

	)

676 #i!
defed
(
ENABLE_TEXT_SELECTION
)

677 
	#ENABLE_TEXT_SELECTION
 1

	)

680 #i!
defed
(
ENABLE_ASYNC_SCROLLING
)

681 
	#ENABLE_ASYNC_SCROLLING
 0

	)

684 #i!
defed
(
ENABLE_TOUCH_EVENTS
)

685 
	#ENABLE_TOUCH_EVENTS
 0

	)

688 #i!
defed
(
ENABLE_TOUCH_ICON_LOADING
)

689 
	#ENABLE_TOUCH_ICON_LOADING
 0

	)

692 #i!
defed
(
ENABLE_VIBRATION
)

693 
	#ENABLE_VIBRATION
 0

	)

696 #i!
defed
(
ENABLE_VIDEO
)

697 
	#ENABLE_VIDEO
 0

	)

700 #i!
defed
(
ENABLE_VIDEO_TRACK
)

701 
	#ENABLE_VIDEO_TRACK
 0

	)

704 #i!
defed
(
ENABLE_DATACUE_VALUE
)

705 
	#ENABLE_DATACUE_VALUE
 0

	)

708 #i!
defed
(
ENABLE_VIEWPORT
)

709 
	#ENABLE_VIEWPORT
 0

	)

712 #i!
defed
(
ENABLE_VIEW_MODE_CSS_MEDIA
)

713 
	#ENABLE_VIEW_MODE_CSS_MEDIA
 1

	)

716 #i!
defed
(
ENABLE_WEBGL
)

717 
	#ENABLE_WEBGL
 0

	)

720 #i!
defed
(
ENABLE_WEB_ARCHIVE
)

721 
	#ENABLE_WEB_ARCHIVE
 0

	)

724 #i!
defed
(
ENABLE_WEB_AUDIO
)

725 
	#ENABLE_WEB_AUDIO
 0

	)

728 #i!
defed
(
ENABLE_WEB_REPLAY
)

729 
	#ENABLE_WEB_REPLAY
 0

	)

732 #i!
defed
(
ENABLE_WEB_SOCKETS
)

733 
	#ENABLE_WEB_SOCKETS
 1

	)

736 #i!
defed
(
ENABLE_PICTURE_SIZES
)

737 
	#ENABLE_PICTURE_SIZES
 1

	)

740 #i!
defed
(
ENABLE_WEB_TIMING
)

741 
	#ENABLE_WEB_TIMING
 0

	)

744 #i!
defed
(
ENABLE_WILL_REVEAL_EDGE_EVENTS
)

745 
	#ENABLE_WILL_REVEAL_EDGE_EVENTS
 1

	)

748 #i!
defed
(
ENABLE_XHR_TIMEOUT
)

749 
	#ENABLE_XHR_TIMEOUT
 0

	)

752 #i!
defed
(
ENABLE_XSLT
)

753 
	#ENABLE_XSLT
 1

	)

758 #i
ENABLE
(
VIDEO_TRACK
&& !ENABLE(
VIDEO
)

762 #i
ENABLE
(
MEDIA_CONTROLS_SCRIPT
&& !ENABLE(
VIDEO
)

766 #i
ENABLE
(
REMOTE_INSPECTOR
&& !ENABLE(
INSPECTOR
)

770 #i
ENABLE
(
IOS_TOUCH_EVENTS
&& !ENABLE(
TOUCH_EVENTS
)

	@FilePrintStream.cpp

26 
	~"cfig.h
"

27 
	~"FePrtSm.h
"

29 
mea
 
	gWTF
 {

31 
	gFePrtSm
::
FePrtSm
(
FILE
* 
fe
, 
AdtiMode
 
adtiMode
)

32 : 
m_fe
(
fe
)

33 , 
m_adtiMode
(
adtiMode
)

37 
	gFePrtSm
::~
FePrtSm
()

39 i(
m_adtiMode
 =
Brow
)

41 
fo
(
m_fe
);

44 
	gd
::
unique_r
<
FePrtSm
> FePrtSm::
ݒ
(cڡ * 
fame
, cڡ * 
mode
)

46 
FILE
* 
	gfe
 = 
fݒ
(
fame
, 
mode
);

47 i(!
	gfe
)

48  
	gnuαr
;

50  
	gd
::
make_unique
<
FePrtSm
>(
fe
);

53 
	gFePrtSm
::
vtf
(cڡ * 
fm
, 
va_li
 
gLi
)

55 
vrtf
(
m_fe
, 
fm
, 
gLi
);

58 
	gFePrtSm
::
ush
()

60 
fush
(
m_fe
);

	@FilePrintStream.h

26 #ide
FePrtSm_h


27 
	#FePrtSm_h


	)

29 
	~<dio.h
>

30 
	~<wtf/PrtSm.h
>

31 
	~<wtf/OwnP.h
>

33 
mea
 
	gWTF
 {

35 as
	cFePrtSm
 : 
public
 
PrtSm
 {

36 
public
:

37 
	eAdtiMode
 {

38 
Adt
,

39 
	gBrow


42 
FePrtSm
(
FILE
*, 
AdtiMode
 = 
Adt
);

43 
	gvtu
 ~
FePrtSm
();

45 
WTF_EXPORT_PRIVATE
 
	gd
::
unique_r
<
FePrtSm
> 
ݒ
(cڡ * 
fame
, cڡ * 
mode
);

47 
FILE
* 
fe
({  
	gm_fe
; }

49 
vtu
 
vtf
(cڡ * 
fm
, 
va_li

ovride
 
WTF_ATTRIBUTE_PRINTF
(2, 0);

50 
vtu
 
ush
(
	govride
;

52 
	give
:

53 
FILE
* 
m_fe
;

54 
AdtiMode
 
	gm_adtiMode
;

59 
usg
 
	gWTF
::
FePrtSm
;

	@FlipBytes.h

26 #ide
FlBys_h


27 
	#FlBys_h


	)

29 
mea
 
	gWTF
 {

31 
le
 
bo
 
edToFlBysIfLeEndn
(bo 
leEndn
)

33 #i
CPU
(
BIG_ENDIAN
)

34  
	gleEndn
;

36  !
	gleEndn
;

40 
le
 
ut16_t
 
Bys
(ut16_
vue
)

42  ((
	gvue
 & 0x00ff) << 8)

43 | ((
	gvue
 & 0xff00) >> 8);

46 
le
 
ut32_t
 
Bys
(ut32_
vue
)

48  ((
	gvue
 & 0x000000ff) << 24)

49 | ((
	gvue
 & 0x0000ff00) << 8)

50 | ((
	gvue
 & 0x00ff0000) >> 8)

51 | ((
	gvue
 & 0xff000000) >> 24);

54 
le
 
ut64_t
 
Bys
(ut64_
vue
)

56  ((
	gvue
 & 0x00000000000000ffull) << 56)

57 | ((
	gvue
 & 0x000000000000ff00ull) << 40)

58 | ((
	gvue
 & 0x0000000000ff0000ull) << 24)

59 | ((
	gvue
 & 0x00000000ff000000ull) << 8)

60 | ((
	gvue
 & 0x000000ff00000000ull) >> 8)

61 | ((
	gvue
 & 0x0000ff0000000000ull) >> 24)

62 | ((
	gvue
 & 0x00ff000000000000ull) >> 40)

63 | ((
	gvue
 & 0xff00000000000000ull) >> 56);

66 
	gme
<
tyme
 
	gT
>

67 
le
 
T
 
Bys
(T 
vue
)

69 i((
	gvue
) == 1)

70  
vue
;

71 i((
	gvue
) == 2) {

73 
T
 
ig
;

74 
ut16_t
 
	gwd
;

75 } 
	gu
;

76 
	gu
.
	gig
 = 
vue
;

77 
	gu
.
	gwd
 = 
Bys
(
u
.
wd
);

78  
	gu
.
	gig
;

80 i((
	gvue
) == 4) {

82 
T
 
ig
;

83 
ut32_t
 
	gwd
;

84 } 
	gu
;

85 
	gu
.
	gig
 = 
vue
;

86 
	gu
.
	gwd
 = 
Bys
(
u
.
wd
);

87  
	gu
.
	gig
;

89 i((
	gvue
) == 8) {

91 
T
 
ig
;

92 
ut64_t
 
	gwd
;

93 } 
	gu
;

94 
	gu
.
	gig
 = 
vue
;

95 
	gu
.
	gwd
 = 
Bys
(
u
.
wd
);

96  
	gu
.
	gig
;

98 
RELEASE_ASSERT_NOT_REACHED
();

99  
T
();

102 
	gme
<
tyme
 
	gT
>

103 
le
 
T
 
BysIfLeEndn
(T 
vue
, 
bo
 
leEndn
)

105 i(
edToFlBysIfLeEndn
(
leEndn
))

106  
Bys
(
vue
);

107  
	gvue
;

112 
usg
 
	gWTF
::
edToFlBysIfLeEndn
;

113 
usg
 
	gWTF
::
Bys
;

114 
usg
 
	gWTF
::
BysIfLeEndn
;

	@Forward.h

21 #ide
WTF_Fwd_h


22 
	#WTF_Fwd_h


	)

24 
	~<ddef.h
>

26 
mea
 
	gWTF
 {

28 
	gme
<
tyme
 
	gT
> 
ass
 
	gFuni
;

29 
	gme
<
tyme
 
	gT
> 
ass
 
	gLazyNevDeroyed
;

30 
	gme
<
tyme
 
	gT
> 
ass
 
	gNevDeroyed
;

31 
	gme
<
tyme
 
	gT
> 
ass
 
	gOwnP
;

32 
	gme
<
tyme
 
	gT
> 
ass
 
	gPassOwnP
;

33 
	gme
<
tyme
 
	gT
> 
ass
 
	gPassRef
;

34 
	gme
<
tyme
 
	gT
> 
ass
 
	gPassRefP
;

35 
	gme
<
tyme
 
	gT
> 
ass
 
	gRefP
;

36 
	gme
<
tyme
 
	gT
> 
ass
 
	gRef
;

37 
	gme
<
tyme
 
	gT
> 
ass
 
	gSgBufr
;

39 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
> 
ass
 
	gVe
;

41 
ass
 
	gAtomicSg
;

42 
ass
 
	gAtomicSgIm
;

43 
ass
 
	gBySemhe
;

44 
ass
 
	gCSg
;

45 
ass
 
	gDecod
;

46 
ass
 
	gEncod
;

47 
ass
 
	gFuniDich
;

48 
ass
 
	gPrtSm
;

49 
ass
 
	gSg
;

50 
ass
 
	gSgBud
;

51 
ass
 
	gSgIm
;

52 
ass
 
	gSgVw
;

56 
usg
 
	gWTF
::
AtomicSg
;

57 
usg
 
	gWTF
::
AtomicSgIm
;

58 
usg
 
	gWTF
::
BySemhe
;

59 
usg
 
	gWTF
::
CSg
;

60 
usg
 
	gWTF
::
Decod
;

61 
usg
 
	gWTF
::
Encod
;

62 
usg
 
	gWTF
::
Funi
;

63 
usg
 
	gWTF
::
FuniDich
;

64 
usg
 
	gWTF
::
LazyNevDeroyed
;

65 
usg
 
	gWTF
::
NevDeroyed
;

66 
usg
 
	gWTF
::
OwnP
;

67 
usg
 
	gWTF
::
PassOwnP
;

68 
usg
 
	gWTF
::
PassRef
;

69 
usg
 
	gWTF
::
PassRefP
;

70 
usg
 
	gWTF
::
PrtSm
;

71 
usg
 
	gWTF
::
Ref
;

72 
usg
 
	gWTF
::
RefP
;

73 
usg
 
	gWTF
::
Sg
;

74 
usg
 
	gWTF
::
SgBufr
;

75 
usg
 
	gWTF
::
SgBud
;

76 
usg
 
	gWTF
::
SgIm
;

77 
usg
 
	gWTF
::
SgVw
;

78 
usg
 
	gWTF
::
Ve
;

	@FunctionDispatcher.cpp

26 
	~"cfig.h
"

27 
	~"FuniDich.h
"

29 
mea
 
	gWTF
 {

31 
	gFuniDich
::
FuniDich
()

35 
FuniDich
::~FunctionDispatcher()

	@FunctionDispatcher.h

26 
	~<funiڮ
>

27 
	~<wtf/ThadSaRefCoued.h
>

29 
mea
 
	gWTF
 {

34 
ass
 
	gFuniDich
 : 
public
 
ThadSaRefCoued
<
FuniDich
> {

35 
public
:

36 
WTF_EXPORT_PRIVATE
 
vtu
 ~
FuniDich
();

38 
vtu
 
dich
(
d
::
funi
<()>) = 0;

40 
	geed
:

41 
WTF_EXPORT_PRIVATE
 
FuniDich
();

46 
usg
 
	gWTF
::
FuniDich
;

	@Functional.h

26 #ide
WTF_Funiڮ_h


27 
	#WTF_Funiڮ_h


	)

29 
	~<wtf/Asis.h
>

30 
	~<wtf/PassRefP.h
>

31 
	~<wtf/RefP.h
>

32 
	~<wtf/ThadSaRefCoued.h
>

33 
	~<wtf/WkP.h
>

35 #i
OS
(
DARWIN
&& 
COMPILER_SUPPORTS
(
BLOCKS
)

36 
	~<Block.h
>

37 
	~<wtf/ObjcRuimeExas.h
>

40 
mea
 
	gWTF
 {

47 
	gme
<
tyme
 
	gT
>

48 as
	cHasRefAndDef
 {

49 
	tYesTy
;

50 
	sNoTy
 {

51 
	gddg
[8];

54 
	sBaMix
 {

55 
def
();

56 
f
();

59 
	gBa
 : 
public
 
T
,ubli
	gBaMix
 { };

61 
	gme
<
tyme
 
	gU
, U> 

62 
	sTyCheck
 { };

64 
	gme
<
tyme
 
	gU
>

65 
NoTy
 
fCheck
(
U
*, 
TyCheck
<(
BaMix
::*)(), &U::
f
>* = 0);

66 
YesTy
 
fCheck
(...);

68 
	gme
<
tyme
 
	gU
>

69 
NoTy
 
defCheck
(
U
*, 
TyCheck
<(
BaMix
::*)(), &U::
def
>* = 0);

70 
YesTy
 
defCheck
(...);

72 
	gpublic
:

73 cڡ 
bo
 
vue
 = (
fCheck
(
ic_
<
Ba
*>(0))=(
YesTy
&& (
defCheck
(static_cast<Base*>(0))) == (YesType);

78 
	gme
<
	gtyme
>

79 
ass
 
	gFuniW
;

83 
	gme
<
tyme
 
	gR
>

84 
ass
 
	gFuniW
<
R
 (*)()> {

85 
	gpublic
:

86 
R
 
	tResuTy
;

87 cڡ 
bo
 
	gshouldRefFPam
 = 
l
;

89 
exic
 
FuniW
(
R
 (*
funi
)())

90 : 
m_funi
(
funi
)

94 
R
 
ݔ
()()

96  
m_funi
();

99 
	give
:

100 
R
 (*
m_funi
)();

103 
	gme
<
tyme
 
	gR
,ym
	gP1
>

104 
ass
 
	gFuniW
<
	$R
 (*)(
P1
)> {

105 
public
:

106 
R
 
	tResuTy
;

107 cڡ 
bo
 
shouldRefFPam
 = 
l
;

109 
exic
 
	`FuniW
(
	`R
 (*
funi
)(
P1
))

110 : 
	`m_funi
(
funi
)

114 
R
 
	`ݔ
()(
P1
 
p1
)

116  
	`m_funi
(
p1
);

119 
ive
:

120 
	`R
 (*
m_funi
)(
P1
);

121 
	}
};

123 
	gme
<
tyme
 
	gR
,ym
	gP1
,ym
	gP2
>

124 
ass
 
	gFuniW
<
	$R
 (*)(
P1
, 
P2
)> {

125 
public
:

126 
R
 
	tResuTy
;

127 cڡ 
bo
 
shouldRefFPam
 = 
l
;

129 
exic
 
	`FuniW
(
	`R
 (*
funi
)(
P1
, 
P2
))

130 : 
	`m_funi
(
funi
)

134 
R
 
	`ݔ
()(
P1
 
p1
, 
P2
 
p2
)

136  
	`m_funi
(
p1
, 
p2
);

139 
ive
:

140 
	`R
 (*
m_funi
)(
P1
, 
P2
);

141 
	}
};

143 
	gme
<
tyme
 
	gR
,ym
	gP1
,ym
	gP2
,ym
	gP3
>

144 
ass
 
	gFuniW
<
	$R
 (*)(
P1
, 
P2
, 
P3
)> {

145 
public
:

146 
R
 
	tResuTy
;

147 cڡ 
bo
 
shouldRefFPam
 = 
l
;

149 
exic
 
	`FuniW
(
	`R
 (*
funi
)(
P1
, 
P2
, 
P3
))

150 : 
	`m_funi
(
funi
)

154 
R
 
	`ݔ
()(
P1
 
p1
, 
P2
 
p2
, 
P3
 
p3
)

156  
	`m_funi
(
p1
, 
p2
, 
p3
);

159 
ive
:

160 
	`R
 (*
m_funi
)(
P1
, 
P2
, 
P3
);

161 
	}
};

163 
	gme
<
tyme
 
	gR
,ym
	gP1
,ym
	gP2
,ym
	gP3
,ym
	gP4
>

164 
ass
 
	gFuniW
<
	$R
 (*)(
P1
, 
P2
, 
P3
, 
P4
)> {

165 
public
:

166 
R
 
	tResuTy
;

167 cڡ 
bo
 
shouldRefFPam
 = 
l
;

169 
exic
 
	`FuniW
(
	`R
 (*
funi
)(
P1
, 
P2
, 
P3
, 
P4
))

170 : 
	`m_funi
(
funi
)

174 
R
 
	`ݔ
()(
P1
 
p1
, 
P2
 
p2
, 
P3
 
p3
, 
P4
 
p4
)

176  
	`m_funi
(
p1
, 
p2
, 
p3
, 
p4
);

179 
ive
:

180 
	`R
 (*
m_funi
)(
P1
, 
P2
, 
P3
, 
P4
);

181 
	}
};

183 
	gme
<
tyme
 
	gR
,ym
	gP1
,ym
	gP2
,ym
	gP3
,ym
	gP4
,ym
	gP5
>

184 
ass
 
	gFuniW
<
	$R
 (*)(
P1
, 
P2
, 
P3
, 
P4
, 
P5
)> {

185 
public
:

186 
R
 
	tResuTy
;

187 cڡ 
bo
 
shouldRefFPam
 = 
l
;

189 
exic
 
	`FuniW
(
	`R
 (*
funi
)(
P1
, 
P2
, 
P3
, 
P4
, 
P5
))

190 : 
	`m_funi
(
funi
)

194 
R
 
	`ݔ
()(
P1
 
p1
, 
P2
 
p2
, 
P3
 
p3
, 
P4
 
p4
, 
P5
 
p5
)

196  
	`m_funi
(
p1
, 
p2
, 
p3
, 
p4
, 
p5
);

199 
ive
:

200 
	`R
 (*
m_funi
)(
P1
, 
P2
, 
P3
, 
P4
, 
P5
);

201 
	}
};

205 
	gme
<
tyme
 
	gR
,ym
	gC
>

206 
ass
 
	gFuniW
<
R
 (
C
::*)()> {

207 
public
:

208 
R
 
	tResuTy
;

209 cڡ 
bo
 
	gshouldRefFPam
 = 
HasRefAndDef
<
C
>::
vue
;

211 
exic
 
FuniW
(
R
 (
C
::*
funi
)())

212 : 
m_funi
(
funi
)

216 
R
 
ݔ
()(
C
* 
c
)

218  (
c
->*
m_funi
)();

221 
R
 
ݔ
()(cڡ 
	gWkP
<
	gC
>& 
	gc
)

223 
C
* 
	gobj
 = 
c
.
g
();

224 i(!
	gobj
)

225  
R
();

226  (
	gobj
->*
	gm_funi
)();

229 
	give
:

230 
R
 (
C
::*
m_funi
)();

233 
	gme
<
tyme
 
	gR
,ym
	gC
,ym
	gP1
>

234 
ass
 
	gFuniW
<
	$R
 (
C
::*)(
P1
)> {

235 
public
:

236 
R
 
	tResuTy
;

237 cڡ 
bo
 
shouldRefFPam
 = 
HasRefAndDef
<
C
>::
vue
;

239 
exic
 
	`FuniW
(
	`R
 (
C
::*
funi
)(
P1
))

240 : 
	`m_funi
(
funi
)

244 
R
 
	`ݔ
()(
C
* 
c
, 
P1
 
p1
)

246  (
c
->*
m_funi
)(
p1
);

249 
R
 
	`ݔ
()(cڡ 
WkP
<
C
>& 
c
, 
P1
 
p1
)

251 
C
* 
obj
 = 
c
.
	`g
();

252 i(!
obj
)

253  
	`R
();

254  (
obj
->*
m_funi
)(
p1
);

257 
ive
:

258 
	`R
 (
C
::*
m_funi
)(
P1
);

259 
	}
};

261 
	gme
<
tyme
 
	gR
,ym
	gC
,ym
	gP1
,ym
	gP2
>

262 
ass
 
	gFuniW
<
	$R
 (
C
::*)(
P1
, 
P2
)> {

263 
public
:

264 
R
 
	tResuTy
;

265 cڡ 
bo
 
shouldRefFPam
 = 
HasRefAndDef
<
C
>::
vue
;

267 
exic
 
	`FuniW
(
	`R
 (
C
::*
funi
)(
P1
, 
P2
))

268 : 
	`m_funi
(
funi
)

272 
R
 
	`ݔ
()(
C
* 
c
, 
P1
 
p1
, 
P2
 
p2
)

274  (
c
->*
m_funi
)(
p1
, 
p2
);

277 
R
 
	`ݔ
()(cڡ 
WkP
<
C
>& 
c
, 
P1
 
p1
, 
P2
 
p2
)

279 
C
* 
obj
 = 
c
.
	`g
();

280 i(!
obj
)

281  
	`R
();

282  (
obj
->*
m_funi
)(
p1
, 
p2
);

285 
ive
:

286 
	`R
 (
C
::*
m_funi
)(
P1
, 
P2
);

287 
	}
};

289 
	gme
<
tyme
 
	gR
,ym
	gC
,ym
	gP1
,ym
	gP2
,ym
	gP3
>

290 
ass
 
	gFuniW
<
	$R
 (
C
::*)(
P1
, 
P2
, 
P3
)> {

291 
public
:

292 
R
 
	tResuTy
;

293 cڡ 
bo
 
shouldRefFPam
 = 
HasRefAndDef
<
C
>::
vue
;

295 
exic
 
	`FuniW
(
	`R
 (
C
::*
funi
)(
P1
, 
P2
, 
P3
))

296 : 
	`m_funi
(
funi
)

300 
R
 
	`ݔ
()(
C
* 
c
, 
P1
 
p1
, 
P2
 
p2
, 
P3
 
p3
)

302  (
c
->*
m_funi
)(
p1
, 
p2
, 
p3
);

305 
R
 
	`ݔ
()(cڡ 
WkP
<
C
>& 
c
, 
P1
 
p1
, 
P2
 
p2
, 
P3
 
p3
)

307 
C
* 
obj
 = 
c
.
	`g
();

308 i(!
obj
)

309  
	`R
();

310  (
obj
->*
m_funi
)(
p1
, 
p2
, 
p3
);

313 
ive
:

314 
	`R
 (
C
::*
m_funi
)(
P1
, 
P2
, 
P3
);

315 
	}
};

317 
	gme
<
tyme
 
	gR
,ym
	gC
,ym
	gP1
,ym
	gP2
,ym
	gP3
,ym
	gP4
>

318 
ass
 
	gFuniW
<
	$R
 (
C
::*)(
P1
, 
P2
, 
P3
, 
P4
)> {

319 
public
:

320 
R
 
	tResuTy
;

321 cڡ 
bo
 
shouldRefFPam
 = 
HasRefAndDef
<
C
>::
vue
;

323 
exic
 
	`FuniW
(
	`R
 (
C
::*
funi
)(
P1
, 
P2
, 
P3
, 
P4
))

324 : 
	`m_funi
(
funi
)

328 
R
 
	`ݔ
()(
C
* 
c
, 
P1
 
p1
, 
P2
 
p2
, 
P3
 
p3
, 
P4
 
p4
)

330  (
c
->*
m_funi
)(
p1
, 
p2
, 
p3
, 
p4
);

333 
R
 
	`ݔ
()(cڡ 
WkP
<
C
>& 
c
, 
P1
 
p1
, 
P2
 
p2
, 
P3
 
p3
, 
P4
 
p4
)

335 
C
* 
obj
 = 
c
.
	`g
();

336 i(!
obj
)

337  
	`R
();

338  (
obj
->*
m_funi
)(
p1
, 
p2
, 
p3
, 
p4
);

341 
ive
:

342 
	`R
 (
C
::*
m_funi
)(
P1
, 
P2
, 
P3
, 
P4
);

343 
	}
};

345 
	gme
<
tyme
 
	gR
,ym
	gC
,ym
	gP1
,ym
	gP2
,ym
	gP3
,ym
	gP4
,ym
	gP5
>

346 
ass
 
	gFuniW
<
	$R
 (
C
::*)(
P1
, 
P2
, 
P3
, 
P4
, 
P5
)> {

347 
public
:

348 
R
 
	tResuTy
;

349 cڡ 
bo
 
shouldRefFPam
 = 
HasRefAndDef
<
C
>::
vue
;

351 
exic
 
	`FuniW
(
	`R
 (
C
::*
funi
)(
P1
, 
P2
, 
P3
, 
P4
, 
P5
))

352 : 
	`m_funi
(
funi
)

356 
R
 
	`ݔ
()(
C
* 
c
, 
P1
 
p1
, 
P2
 
p2
, 
P3
 
p3
, 
P4
 
p4
, 
P5
 
p5
)

358  (
c
->*
m_funi
)(
p1
, 
p2
, 
p3
, 
p4
, 
p5
);

361 
R
 
	`ݔ
()(cڡ 
WkP
<
C
>& 
c
, 
P1
 
p1
, 
P2
 
p2
, 
P3
 
p3
, 
P4
 
p4
, 
P5
 
p5
)

363 
C
* 
obj
 = 
c
.
	`g
();

364 i(!
obj
)

365  
	`R
();

366  (
obj
->*
m_funi
)(
p1
, 
p2
, 
p3
, 
p4
, 
p5
);

369 
ive
:

370 
	`R
 (
C
::*
m_funi
)(
P1
, 
P2
, 
P3
, 
P4
, 
P5
);

371 
	}
};

373 #i
OS
(
DARWIN
&& 
	$COMPILER_SUPPORTS
(
BLOCKS
)

374 
me
<
tyme
 
R
>

375 
ass
 
FuniW
<
	`R
 (^)()> {

376 
public
:

377 
R
 
	tResuTy
;

378 cڡ 
bo
 
shouldRefFPam
 = 
l
;

380 
exic
 
	`FuniW
(
	`R
 (^
block
)())

381 : 
	`m_block
(
	`Block_cy
(
block
))

385 
	`FuniW
(cڡ 
FuniW
& 
h
)

386 : 
	`m_block
(
	`Block_cy
(
h
.
m_block
))

390 ~
	`FuniW
()

392 
	`Block_a
(
m_block
);

395 
R
 
	`ݔ
()()

397  
	`m_block
();

400 
ive
:

401 
	`R
 (^
m_block
)();

402 
	}
};

405 
	gme
<
tyme
 
	gT
, 
bo
 
	gshouldRefAndDef
> 
	sRefAndDef
 {

406 
f
(
T
) { }

407 
def
(
T
) { }

410 
	gme
<
tyme
 
	gT
> 
	gRefAndDef
<T*, 
	gue
> {

411 
f
(
T
* 
t
{ 
	gt
->ref(); }

412 
def
(
T
* 
t
{ 
	gt
->deref(); }

415 
	gme
<
tyme
 
	gT
> 
	sPamStageTs
 {

416 
T
 
	tStageTy
;

418 
StageTy
 
wp
(cڡ 
T
& 
vue
{  
	gvue
; }

419 cڡ 
	gT
& 
unwp
(cڡ 
StageTy
& 
vue
{  
	gvue
; }

422 
	gme
<
tyme
 
	gT
> 
	gPamStageTs
<
	gPassRefP
<T>> {

423 
	gRefP
<
	tT
> 
	tStageTy
;

425 
StageTy
 
wp
(
PassRefP
<
T
> 
vue
{  
	gvue
; }

426 
T
* 
unwp
(cڡ 
StageTy
& 
vue
{  
	gvue
.
g
(); }

429 
	gme
<
tyme
 
	gT
> 
	gPamStageTs
<
	gRefP
<T>> {

430 
	gRefP
<
	tT
> 
	tStageTy
;

432 
StageTy
 
wp
(
RefP
<
T
> 
vue
{  
	gvue
.
a
(); }

433 
T
* 
unwp
(cڡ 
StageTy
& 
vue
{  
	gvue
.
g
(); }

436 
	gme
<
	gtyme
> 
ass
 
	gRaP
;

438 
	gme
<
tyme
 
	gT
> 
	gPamStageTs
<
	gRaP
<T>> {

439 
	gRaP
<
	tT
> 
	tStageTy
;

441 
StageTy
 
wp
(cڡ 
RaP
<
T
>& 
vue
{  
	gvue
; }

442 
tyme
 
	gRaP
<
	gT
>::
PTy
 
unwp
(cڡ 
StageTy
& 
vue
{  vue.
g
(); }

445 
ass
 
	gFuniImBa
 : 
public
 
ThadSaRefCoued
<
FuniImBa
> {

446 
public
:

447 
vtu
 ~
FuniImBa
() { }

450 
	gme
<
	gtyme
>

451 
ass
 
	gFuniIm
;

453 
	gme
<
tyme
 
	gR
>

454 
ass
 
	gFuniIm
<
R
 ()> : 
public
 
FuniImBa
 {

455 
public
:

456 
vtu
 
R
 
ݔ
()() = 0;

459 
	gme
<
tyme
 
	gFuniW
,ym
	gFuniTy
>

460 
ass
 
	gBoundFuniIm
;

462 
	gme
<
tyme
 
	gFuniW
,ym
	gR
>

463 
ass
 
	gBoundFuniIm
<
	gFuniW
, 
R
 ()> : 
public
 
FuniIm
<
tyme
 
FuniW
::
ResuTy
 ()> {

464 
public
:

465 
exic
 
BoundFuniIm
(
FuniW
 
funiW
)

466 : 
m_funiW
(
funiW
)

470 
vtu
 
tyme
 
FuniW
::
ResuTy
 
ݔ
()()

472  
m_funiW
();

475 
	give
:

476 
FuniW
 
m_funiW
;

479 
	gme
<
tyme
 
	gFuniW
,ym
	gR
,ym
	gP1
>

480 
ass
 
	gBoundFuniIm
<
	gFuniW
, 
R
 (
P1
)> : 
public
 
FuniIm
<
tyme
 
FuniW
::
ResuTy
 ()> {

481 
public
:

482 
BoundFuniIm
(
FuniW
 
funiW
, cڡ 
P1
& 
p1
)

483 : 
m_funiW
(
funiW
)

484 , 
m_p1
(
PamStageTs
<
P1
>::
wp
(
p1
))

486 
RefAndDef
<
P1
, 
	gFuniW
::
shouldRefFPam
>::
f
(
m_p1
);

489 ~
BoundFuniIm
()

491 
	gRefAndDef
<
	gP1
, 
	gFuniW
::
shouldRefFPam
>::
def
(
m_p1
);

494 
vtu
 
tyme
 
	gFuniW
::
ResuTy
 
ݔ
()()

496  
m_funiW
(
PamStageTs
<
P1
>::
unwp
(
m_p1
));

499 
	give
:

500 
FuniW
 
m_funiW
;

501 
tyme
 
	gPamStageTs
<
	gP1
>::
StageTy
 
m_p1
;

504 
	gme
<
tyme
 
	gFuniW
,ym
	gR
,ym
	gP1
,ym
	gP2
>

505 
ass
 
	gBoundFuniIm
<
	gFuniW
, 
R
 (
P1
, 
P2
)> : 
public
 
FuniIm
<
tyme
 
FuniW
::
ResuTy
 ()> {

506 
public
:

507 
BoundFuniIm
(
FuniW
 
funiW
, cڡ 
P1
& 
p1
, cڡ 
P2
& 
p2
)

508 : 
m_funiW
(
funiW
)

509 , 
m_p1
(
PamStageTs
<
P1
>::
wp
(
p1
))

510 , 
m_p2
(
PamStageTs
<
P2
>::
wp
(
p2
))

512 
RefAndDef
<
P1
, 
	gFuniW
::
shouldRefFPam
>::
f
(
m_p1
);

515 ~
BoundFuniIm
()

517 
	gRefAndDef
<
	gP1
, 
	gFuniW
::
shouldRefFPam
>::
def
(
m_p1
);

520 
vtu
 
tyme
 
	gFuniW
::
ResuTy
 
ݔ
()()

522  
m_funiW
(
PamStageTs
<
P1
>::
unwp
(
m_p1
), PamStageTs<
P2
>::unwp(
m_p2
));

525 
	give
:

526 
FuniW
 
m_funiW
;

527 
tyme
 
	gPamStageTs
<
	gP1
>::
StageTy
 
m_p1
;

528 
tyme
 
	gPamStageTs
<
	gP2
>::
StageTy
 
m_p2
;

531 
	gme
<
tyme
 
	gFuniW
,ym
	gR
,ym
	gP1
,ym
	gP2
,ym
	gP3
>

532 
ass
 
	gBoundFuniIm
<
	gFuniW
, 
R
 (
P1
, 
P2
, 
P3
)> : 
public
 
FuniIm
<
tyme
 
FuniW
::
ResuTy
 ()> {

533 
public
:

534 
BoundFuniIm
(
FuniW
 
funiW
, cڡ 
P1
& 
p1
, cڡ 
P2
& 
p2
, cڡ 
P3
& 
p3
)

535 : 
m_funiW
(
funiW
)

536 , 
m_p1
(
PamStageTs
<
P1
>::
wp
(
p1
))

537 , 
m_p2
(
PamStageTs
<
P2
>::
wp
(
p2
))

538 , 
m_p3
(
PamStageTs
<
P3
>::
wp
(
p3
))

540 
RefAndDef
<
P1
, 
	gFuniW
::
shouldRefFPam
>::
f
(
m_p1
);

543 ~
BoundFuniIm
()

545 
	gRefAndDef
<
	gP1
, 
	gFuniW
::
shouldRefFPam
>::
def
(
m_p1
);

548 
vtu
 
tyme
 
	gFuniW
::
ResuTy
 
ݔ
()()

550  
m_funiW
(
PamStageTs
<
P1
>::
unwp
(
m_p1
), PamStageTs<
P2
>::unwp(
m_p2
), PamStageTs<
P3
>::unwp(
m_p3
));

553 
	give
:

554 
FuniW
 
m_funiW
;

555 
tyme
 
	gPamStageTs
<
	gP1
>::
StageTy
 
m_p1
;

556 
tyme
 
	gPamStageTs
<
	gP2
>::
StageTy
 
m_p2
;

557 
tyme
 
	gPamStageTs
<
	gP3
>::
StageTy
 
m_p3
;

560 
	gme
<
tyme
 
	gFuniW
,ym
	gR
,ym
	gP1
,ym
	gP2
,ym
	gP3
,ym
	gP4
>

561 
ass
 
	gBoundFuniIm
<
	gFuniW
, 
R
 (
P1
, 
P2
, 
P3
, 
P4
)> : 
public
 
FuniIm
<
tyme
 
FuniW
::
ResuTy
 ()> {

562 
public
:

563 
BoundFuniIm
(
FuniW
 
funiW
, cڡ 
P1
& 
p1
, cڡ 
P2
& 
p2
, cڡ 
P3
& 
p3
, cڡ 
P4
& 
p4
)

564 : 
m_funiW
(
funiW
)

565 , 
m_p1
(
PamStageTs
<
P1
>::
wp
(
p1
))

566 , 
m_p2
(
PamStageTs
<
P2
>::
wp
(
p2
))

567 , 
m_p3
(
PamStageTs
<
P3
>::
wp
(
p3
))

568 , 
m_p4
(
PamStageTs
<
P4
>::
wp
(
p4
))

570 
RefAndDef
<
P1
, 
	gFuniW
::
shouldRefFPam
>::
f
(
m_p1
);

573 ~
BoundFuniIm
()

575 
	gRefAndDef
<
	gP1
, 
	gFuniW
::
shouldRefFPam
>::
def
(
m_p1
);

578 
vtu
 
tyme
 
	gFuniW
::
ResuTy
 
ݔ
()()

580  
m_funiW
(
PamStageTs
<
P1
>::
unwp
(
m_p1
), PamStageTs<
P2
>::unwp(
m_p2
), PamStageTs<
P3
>::unwp(
m_p3
), PamStageTs<
P4
>::unwp(
m_p4
));

583 
	give
:

584 
FuniW
 
m_funiW
;

585 
tyme
 
	gPamStageTs
<
	gP1
>::
StageTy
 
m_p1
;

586 
tyme
 
	gPamStageTs
<
	gP2
>::
StageTy
 
m_p2
;

587 
tyme
 
	gPamStageTs
<
	gP3
>::
StageTy
 
m_p3
;

588 
tyme
 
	gPamStageTs
<
	gP4
>::
StageTy
 
m_p4
;

591 
	gme
<
tyme
 
	gFuniW
,ym
	gR
,ym
	gP1
,ym
	gP2
,ym
	gP3
,ym
	gP4
,ym
	gP5
>

592 
ass
 
	gBoundFuniIm
<
	gFuniW
, 
R
 (
P1
, 
P2
, 
P3
, 
P4
, 
P5
)> : 
public
 
FuniIm
<
tyme
 
FuniW
::
ResuTy
 ()> {

593 
public
:

594 
BoundFuniIm
(
FuniW
 
funiW
, cڡ 
P1
& 
p1
, cڡ 
P2
& 
p2
, cڡ 
P3
& 
p3
, cڡ 
P4
& 
p4
, cڡ 
P5
& 
p5
)

595 : 
m_funiW
(
funiW
)

596 , 
m_p1
(
PamStageTs
<
P1
>::
wp
(
p1
))

597 , 
m_p2
(
PamStageTs
<
P2
>::
wp
(
p2
))

598 , 
m_p3
(
PamStageTs
<
P3
>::
wp
(
p3
))

599 , 
m_p4
(
PamStageTs
<
P4
>::
wp
(
p4
))

600 , 
m_p5
(
PamStageTs
<
P5
>::
wp
(
p5
))

602 
RefAndDef
<
P1
, 
	gFuniW
::
shouldRefFPam
>::
f
(
m_p1
);

605 ~
BoundFuniIm
()

607 
	gRefAndDef
<
	gP1
, 
	gFuniW
::
shouldRefFPam
>::
def
(
m_p1
);

610 
vtu
 
tyme
 
	gFuniW
::
ResuTy
 
ݔ
()()

612  
m_funiW
(
PamStageTs
<
P1
>::
unwp
(
m_p1
), PamStageTs<
P2
>::unwp(
m_p2
), PamStageTs<
P3
>::unwp(
m_p3
), PamStageTs<
P4
>::unwp(
m_p4
), PamStageTs<
P5
>::unwp(
m_p5
));

615 
	give
:

616 
FuniW
 
m_funiW
;

617 
tyme
 
	gPamStageTs
<
	gP1
>::
StageTy
 
m_p1
;

618 
tyme
 
	gPamStageTs
<
	gP2
>::
StageTy
 
m_p2
;

619 
tyme
 
	gPamStageTs
<
	gP3
>::
StageTy
 
m_p3
;

620 
tyme
 
	gPamStageTs
<
	gP4
>::
StageTy
 
m_p4
;

621 
tyme
 
	gPamStageTs
<
	gP5
>::
StageTy
 
m_p5
;

624 
	gme
<
tyme
 
	gFuniW
,ym
	gR
,ym
	gP1
,ym
	gP2
,ym
	gP3
,ym
	gP4
,ym
	gP5
,ym
	gP6
>

625 
ass
 
	gBoundFuniIm
<
	gFuniW
, 
R
 (
P1
, 
P2
, 
P3
, 
P4
, 
P5
, 
P6
)> : 
public
 
FuniIm
<
tyme
 
FuniW
::
ResuTy
 ()> {

626 
public
:

627 
BoundFuniIm
(
FuniW
 
funiW
, cڡ 
P1
& 
p1
, cڡ 
P2
& 
p2
, cڡ 
P3
& 
p3
, cڡ 
P4
& 
p4
, cڡ 
P5
& 
p5
, cڡ 
P6
& 
p6
)

628 : 
m_funiW
(
funiW
)

629 , 
m_p1
(
PamStageTs
<
P1
>::
wp
(
p1
))

630 , 
m_p2
(
PamStageTs
<
P2
>::
wp
(
p2
))

631 , 
m_p3
(
PamStageTs
<
P3
>::
wp
(
p3
))

632 , 
m_p4
(
PamStageTs
<
P4
>::
wp
(
p4
))

633 , 
m_p5
(
PamStageTs
<
P5
>::
wp
(
p5
))

634 , 
m_p6
(
PamStageTs
<
P6
>::
wp
(
p6
))

636 
RefAndDef
<
P1
, 
	gFuniW
::
shouldRefFPam
>::
f
(
m_p1
);

639 ~
BoundFuniIm
()

641 
	gRefAndDef
<
	gP1
, 
	gFuniW
::
shouldRefFPam
>::
def
(
m_p1
);

644 
vtu
 
tyme
 
	gFuniW
::
ResuTy
 
ݔ
()()

646  
m_funiW
(
PamStageTs
<
P1
>::
unwp
(
m_p1
), PamStageTs<
P2
>::unwp(
m_p2
), PamStageTs<
P3
>::unwp(
m_p3
), PamStageTs<
P4
>::unwp(
m_p4
), PamStageTs<
P5
>::unwp(
m_p5
), PamStageTs<
P6
>::unwp(
m_p6
));

649 
	give
:

650 
FuniW
 
m_funiW
;

651 
tyme
 
	gPamStageTs
<
	gP1
>::
StageTy
 
m_p1
;

652 
tyme
 
	gPamStageTs
<
	gP2
>::
StageTy
 
m_p2
;

653 
tyme
 
	gPamStageTs
<
	gP3
>::
StageTy
 
m_p3
;

654 
tyme
 
	gPamStageTs
<
	gP4
>::
StageTy
 
m_p4
;

655 
tyme
 
	gPamStageTs
<
	gP5
>::
StageTy
 
m_p5
;

656 
tyme
 
	gPamStageTs
<
	gP6
>::
StageTy
 
m_p6
;

659 as
	cFuniBa
 {

660 
	gpublic
:

661 
bo
 
isNu
() const

663  !
m_im
;

666 
	geed
:

667 
FuniBa
()

671 
exic
 
FuniBa
(
PassRefP
<
FuniImBa
> 
im
)

672 : 
m_im
(
im
)

676 
me
<
tyme
 
FuniTy
> 
FuniIm
<FuniTy>* 
im
() const

678  
ic_
<
FuniIm
<
FuniTy
>*>(
m_im
.
g
());

681 
	give
:

682 
RefP
<
FuniImBa
> 
m_im
;

685 
	gme
<
	gtyme
>

686 
ass
 
	gFuni
;

688 
	gme
<
tyme
 
	gR
>

689 
ass
 
	gFuni
<
R
 ()> : 
public
 
FuniBa
 {

690 
public
:

691 
Funi
()

695 
Funi
(
PassRefP
<
FuniIm
<
R
 ()>> 
im
)

696 : 
FuniBa
(
im
)

700 
R
 
ݔ
()() const

702 
ASSERT
(!
isNu
());

704  
	gim
<
R
 ()>()->
ݔ
()();

707 #i
OS
(
DARWIN
&& 
COMPILER_SUPPORTS
(
BLOCKS
)

708 (^
	gBlockTy
)();

709 
ݔ
 
BlockTy
() const

713 
	gRefP
<
	gFuniIm
<
R
 ()>> 
	gfuniIm
 = 
im
<R ()>();

714 
BlockTy
 
	gblock
 = ^{

715 
funiIm
->
ݔ
()();

728 
id
 
	gcݛdBlock
 = 
wtfObjcMsgSd
<id>((id)
block
, 
l_giName
("copy"));

729 
id
 
	gautܖdBlock
 = 
wtfObjcMsgSd
<id>(
cݛdBlock
, 
l_giName
("autorelease"));

730  (
	gBlockTy
)
	gautܖdBlock
;

735 
	gme
<
tyme
 
	gFuniTy
>

736 
	gFuni
<
tyme
 
	gFuniW
<
	gFuniTy
>::
ResuTy
 ()> 
	$bd
(
FuniTy
 
funi
)

738  
Funi
<
tyme
 
FuniW
<
FuniTy
>::
	`ResuTy
 ()>(
	`adtRef
(
w
 
BoundFuniIm
<FuniW<FuniTy>,ymFuniW<FuniTy>::ResuTy ()>(FuniW<FuniTy>(
funi
))));

739 
	}
}

741 
	gme
<
tyme
 
	gFuniTy
,ym
	gA1
>

742 
	gFuni
<
tyme
 
	gFuniW
<
	gFuniTy
>::
ResuTy
 ()> 
	$bd
(
FuniTy
 
funi
, cڡ 
A1
& 
a1
)

744  
Funi
<
tyme
 
FuniW
<
FuniTy
>::
	`ResuTy
 ()>(
	`adtRef
(
w
 
BoundFuniIm
<FuniW<FuniTy>,ymFuniW<FuniTy>::ResuTy (
A1
)>(FuniW<FuniTy>(
funi
), 
a1
)));

745 
	}
}

747 
	gme
<
tyme
 
	gFuniTy
,ym
	gA1
,ym
	gA2
>

748 
	gFuni
<
tyme
 
	gFuniW
<
	gFuniTy
>::
ResuTy
 ()> 
	$bd
(
FuniTy
 
funi
, cڡ 
A1
& 
a1
, cڡ 
A2
& 
a2
)

750  
Funi
<
tyme
 
FuniW
<
FuniTy
>::
	`ResuTy
 ()>(
	`adtRef
(
w
 
BoundFuniIm
<FuniW<FuniTy>,ymFuniW<FuniTy>::ResuTy (
A1
, 
A2
)>(FuniW<FuniTy>(
funi
), 
a1
, 
a2
)));

751 
	}
}

753 
	gme
<
tyme
 
	gFuniTy
,ym
	gA1
,ym
	gA2
,ym
	gA3
>

754 
	gFuni
<
tyme
 
	gFuniW
<
	gFuniTy
>::
ResuTy
 ()> 
	$bd
(
FuniTy
 
funi
, cڡ 
A1
& 
a1
, cڡ 
A2
& 
a2
, cڡ 
A3
& 
a3
)

756  
Funi
<
tyme
 
FuniW
<
FuniTy
>::
	`ResuTy
 ()>(
	`adtRef
(
w
 
BoundFuniIm
<FuniW<FuniTy>,ymFuniW<FuniTy>::ResuTy (
A1
, 
A2
, 
A3
)>(FuniW<FuniTy>(
funi
), 
a1
, 
a2
, 
a3
)));

757 
	}
}

759 
	gme
<
tyme
 
	gFuniTy
,ym
	gA1
,ym
	gA2
,ym
	gA3
,ym
	gA4
>

760 
	gFuni
<
tyme
 
	gFuniW
<
	gFuniTy
>::
ResuTy
 ()> 
	$bd
(
FuniTy
 
funi
, cڡ 
A1
& 
a1
, cڡ 
A2
& 
a2
, cڡ 
A3
& 
a3
, cڡ 
A4
& 
a4
)

762  
Funi
<
tyme
 
FuniW
<
FuniTy
>::
	`ResuTy
 ()>(
	`adtRef
(
w
 
BoundFuniIm
<FuniW<FuniTy>,ymFuniW<FuniTy>::ResuTy (
A1
, 
A2
, 
A3
, 
A4
)>(FuniW<FuniTy>(
funi
), 
a1
, 
a2
, 
a3
, 
a4
)));

763 
	}
}

765 
	gme
<
tyme
 
	gFuniTy
,ym
	gA1
,ym
	gA2
,ym
	gA3
,ym
	gA4
,ym
	gA5
>

766 
	gFuni
<
tyme
 
	gFuniW
<
	gFuniTy
>::
ResuTy
 ()> 
	$bd
(
FuniTy
 
funi
, cڡ 
A1
& 
a1
, cڡ 
A2
& 
a2
, cڡ 
A3
& 
a3
, cڡ 
A4
& 
a4
, cڡ 
A5
& 
a5
)

768  
Funi
<
tyme
 
FuniW
<
FuniTy
>::
	`ResuTy
 ()>(
	`adtRef
(
w
 
BoundFuniIm
<FuniW<FuniTy>,ymFuniW<FuniTy>::ResuTy (
A1
, 
A2
, 
A3
, 
A4
, 
A5
)>(FuniW<FuniTy>(
funi
), 
a1
, 
a2
, 
a3
, 
a4
, 
a5
)));

769 
	}
}

771 
	gme
<
tyme
 
	gFuniTy
,ym
	gA1
,ym
	gA2
,ym
	gA3
,ym
	gA4
,ym
	gA5
,ym
	gA6
>

772 
	gFuni
<
tyme
 
	gFuniW
<
	gFuniTy
>::
ResuTy
 ()> 
	$bd
(
FuniTy
 
funi
, cڡ 
A1
& 
a1
, cڡ 
A2
& 
a2
, cڡ 
A3
& 
a3
, cڡ 
A4
& 
a4
, cڡ 
A5
& 
a5
, cڡ 
A6
& 
a6
)

774  
Funi
<
tyme
 
FuniW
<
FuniTy
>::
	`ResuTy
 ()>(
	`adtRef
(
w
 
BoundFuniIm
<FuniW<FuniTy>,ymFuniW<FuniTy>::ResuTy (
A1
, 
A2
, 
A3
, 
A4
, 
A5
, 
A6
)>(FuniW<FuniTy>(
funi
), 
a1
, 
a2
, 
a3
, 
a4
, 
a5
, 
a6
)));

775 
	}
}

779 
usg
 
	gWTF
::
Funi
;

780 
usg
 
	gWTF
::
bd
;

	@GetPtr.h

21 #ide
WTF_GP_h


22 
	#WTF_GP_h


	)

24 
	~<memy
>

26 
mea
 
	gWTF
 {

28 
	gme
 <
tyme
 
	gT
> 
le
 
T
* 
gP
(T* 
p
{  
	gp
; }

30 
	gme
 <
tyme
 
	gT
> 
	sIsSmtP
 {

31 cڡ 
bo
 
	gvue
 = 
l
;

34 
	gme
 <
tyme
 
	gT
, 
bo
 
	gisSmtP
>

35 
	gGPHrBa
;

37 
	gme
 <
tyme
 
	gT
>

38 
	gGPHrBa
<
	gT
, 
	gl
 > {

39 
T
* 
	tPTy
;

40 
T
* 
gP
(T& 
p
{  &
	gp
; }

43 
	gme
 <
tyme
 
	gT
>

44 
	gGPHrBa
<
	gT
, 
	gue
 > {

45 
tyme
 
	tT
::
	tPTy
 PtrType;

46 
PTy
 
gP
(cڡ 
T
& 
p
{  
	gp
.
g
(); }

49 
	gme
 <
tyme
 
	gT
>

50 
	gGPHr
 : 
GPHrBa
<
T
, 
	gIsSmtP
<
	gT
>::
vue
> {

53 
	gme
 <
tyme
 
	gT
>

54 
le
 
tyme
 
	gGPHr
<
	gT
>::
PTy
 
gP
(
T
& 
p
)

56  
GPHr
<
T
>::
gP
(
p
);

59 
	gme
 <
tyme
 
	gT
>

60 
le
 
tyme
 
	gGPHr
<
	gT
>::
PTy
 
gP
(cڡ 
T
& 
p
)

62  
GPHr
<
T
>::
gP
(
p
);

67 
	gme
 <
tyme
 
	gT
,ym
	gD
> 
	gIsSmtP
<
	gd
::
unique_r
<
T
, Deleter>> {

68 cڡ 
bo
 
	gvue
 = 
ue
;

71 
	gme
 <
tyme
 
	gT
,ym
	gD
>

72 
	gGPHr
<
	gd
::
unique_r
<
T
, 
	gD
>> {

73 
T
* 
	tPTy
;

74 
T
* 
gP
(cڡ 
d
::
unique_r
<T, 
D
>& 
p
{  
	gp
.
g
(); }

	@GregorianDateTime.cpp

25 
	~"cfig.h
"

26 
	~"GgܟnDeTime.h
"

28 
	~"DeMh.h
"

30 #i
OS
(
WINDOWS
)

31 
	~<wdows.h
>

33 
	~<time.h
>

36 
mea
 
	gWTF
 {

38 
	gGgܟnDeTime
::
tToCutLolTime
()

40 #i
OS
(
WINDOWS
)

41 
SYSTEMTIME
 
syemTime
;

42 
GLolTime
(&
syemTime
);

43 
TIME_ZONE_INFORMATION
 
	gtimeZeInfmi
;

44 
DWORD
 
	gtimeZeId
 = 
GTimeZeInfmi
(&
timeZeInfmi
);

46 
LONG
 
	gbs
 = 
timeZeInfmi
.
Bs
;

47 i(
	gtimeZeId
 =
TIME_ZONE_ID_DAYLIGHT
)

48 
bs
 +
timeZeInfmi
.
DaylightBs
;

49 i(
	gtimeZeId
 =
TIME_ZONE_ID_STANDARD
)

50 
bs
 +
timeZeInfmi
.
SnddBs
;

52 
ASSERT
(
timeZeId
 =
TIME_ZONE_ID_UNKNOWN
);

54 
	gm_yr
 = 
syemTime
.
wYr
;

55 
	gm_mth
 = 
syemTime
.
wMth
 - 1;

56 
	gm_mthDay
 = 
syemTime
.
wDay
;

57 
	gm_yrDay
 = 
dayInYr
(
m_yr
, 
m_mth
, 
m_mthDay
);

58 
	gm_wkDay
 = 
syemTime
.
wDayOfWk
;

59 
	gm_hour
 = 
syemTime
.
wHour
;

60 
	gm_mu
 = 
syemTime
.
wMu
;

61 
	gm_cd
 = 
syemTime
.
wSecd
;

62 
	gm_utcOfft
 = -
bs
 * 
cdsPMu
;

63 
	gm_isDST
 = 
timeZeId
 =
TIME_ZONE_ID_DAYLIGHT
 ? 1 : 0;

65 
tm
 
	glolTM
;

66 
time_t
 
	glolTime
 = 
time
(0);

67 
loime_r
(&
lolTime
, &
lolTM
);

69 
	gm_yr
 = 
lolTM
.
tm_yr
 + 1900;

70 
	gm_mth
 = 
lolTM
.
tm_m
;

71 
	gm_mthDay
 = 
lolTM
.
tm_mday
;

72 
	gm_yrDay
 = 
lolTM
.
tm_yday
;

73 
	gm_wkDay
 = 
lolTM
.
tm_wday
;

74 
	gm_hour
 = 
lolTM
.
tm_hour
;

75 
	gm_mu
 = 
lolTM
.
tm_m
;

76 
	gm_cd
 = 
lolTM
.
tm_c
;

77 
	gm_isDST
 = 
lolTM
.
tm_isd
;

78 #i
HAVE
(
TM_GMTOFF
)

79 
	gm_utcOfft
 = 
lolTM
.
tm_gmtoff
;

81 
	gm_utcOfft
 = 
lcuϋLolTimeOfft
(
lolTime
 * 
msPSecd
).
offt
 / msPerSecond;

	@GregorianDateTime.h

25 #ide
WTF_GgܟnDeTime_h


26 
	#WTF_GgܟnDeTime_h


	)

28 
	~<rg.h
>

29 
	~<time.h
>

30 
	~<wtf/Ncyab.h
>

32 
mea
 
	gWTF
 {

34 as
	cGgܟnDeTime
 {

35 
WTF_MAKE_NONCOPYABLE
(
GgܟnDeTime
);

36 
	gpublic
:

37 
GgܟnDeTime
()

38 : 
m_yr
(0)

39 , 
m_mth
(0)

40 , 
m_yrDay
(0)

41 , 
m_mthDay
(0)

42 , 
m_wkDay
(0)

43 , 
m_hour
(0)

44 , 
m_mu
(0)

45 , 
m_cd
(0)

46 , 
m_utcOfft
(0)

47 , 
m_isDST
(0)

51 
le
 
yr
(cڡ {  
	gm_yr
; }

52 
le
 
mth
(cڡ {  
	gm_mth
; }

53 
le
 
yrDay
(cڡ {  
	gm_yrDay
; }

54 
le
 
mthDay
(cڡ {  
	gm_mthDay
; }

55 
le
 
wkDay
(cڡ {  
	gm_wkDay
; }

56 
le
 
hour
(cڡ {  
	gm_hour
; }

57 
le
 
mu
(cڡ {  
	gm_mu
; }

58 
le
 
cd
(cڡ {  
	gm_cd
; }

59 
le
 
utcOfft
(cڡ {  
	gm_utcOfft
; }

60 
le
 
isDST
(cڡ {  
	gm_isDST
; }

62 
le
 
tYr
(
yr
{ 
	gm_yr
 = year; }

63 
le
 
tMth
(
mth
{ 
	gm_mth
 = month; }

64 
le
 
tYrDay
(
yrDay
{ 
	gm_yrDay
 = yearDay; }

65 
le
 
tMthDay
(
mthDay
{ 
	gm_mthDay
 = monthDay; }

66 
le
 
tWkDay
(
wkDay
{ 
	gm_wkDay
 = weekDay; }

67 
le
 
tHour
(
hour
{ 
	gm_hour
 = hour; }

68 
le
 
tMu
(
mu
{ 
	gm_mu
 = minute; }

69 
le
 
tSecd
(
cd
{ 
	gm_cd
 = second; }

70 
le
 
tUtcOfft
(
utcOfft
{ 
	gm_utcOfft
 = utcOffset; }

71 
le
 
tIsDST
(
isDST
{ 
	gm_isDST
 = isDST; }

73 
WTF_EXPORT_PRIVATE
 
tToCutLolTime
();

75 
ݔ
 
tm
() const

77 
tm
 
	gt
;

78 
memt
(&
t
, 0, (ret));

80 
	gt
.
	gtm_yr
 = 
m_yr
 - 1900;

81 
	gt
.
	gtm_m
 = 
m_mth
;

82 
	gt
.
	gtm_yday
 = 
m_yrDay
;

83 
	gt
.
	gtm_mday
 = 
m_mthDay
;

84 
	gt
.
	gtm_wday
 = 
m_wkDay
;

85 
	gt
.
	gtm_hour
 = 
m_hour
;

86 
	gt
.
	gtm_m
 = 
m_mu
;

87 
	gt
.
	gtm_c
 = 
m_cd
;

88 
	gt
.
	gtm_isd
 = 
m_isDST
;

90 #i
HAVE
(
TM_GMTOFF
)

91 
	gt
.
	gtm_gmtoff
 = 
ic_
<>(
m_utcOfft
);

94  
	gt
;

97 
cyFrom
(cڡ 
GgܟnDeTime
& 
h
)

99 
	gm_yr
 = 
h
.
m_yr
;

100 
	gm_mth
 = 
h
.
m_mth
;

101 
	gm_yrDay
 = 
h
.
m_yrDay
;

102 
	gm_mthDay
 = 
h
.
m_mthDay
;

103 
	gm_wkDay
 = 
h
.
m_wkDay
;

104 
	gm_hour
 = 
h
.
m_hour
;

105 
	gm_mu
 = 
h
.
m_mu
;

106 
	gm_cd
 = 
h
.
m_cd
;

107 
	gm_utcOfft
 = 
h
.
m_utcOfft
;

108 
	gm_isDST
 = 
h
.
m_isDST
;

111 
	give
:

112 
m_yr
;

113 
	gm_mth
;

114 
	gm_yrDay
;

115 
	gm_mthDay
;

116 
	gm_wkDay
;

117 
	gm_hour
;

118 
	gm_mu
;

119 
	gm_cd
;

120 
	gm_utcOfft
;

121 
	gm_isDST
;

126 
usg
 
	gWTF
::
GgܟnDeTime
;

	@HashCountedSet.h

21 #ide
WTF_HashCouedS_h


22 
	#WTF_HashCouedS_h


	)

24 
	~<wtf/Asis.h
>

25 
	~<wtf/HashM.h
>

26 
	~<wtf/Ve.h
>

28 
mea
 
	gWTF
 {

30 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
 =ym
DeuHash
<
Vue
>::
Hash
,ym
	gTs
 = 
HashTs
<Value>>

31 as
	cHashCouedS
 
f
 {

32 
WTF_MAKE_FAST_ALLOCATED
;

33 
	give
:

34 
HashM
<
	tVue
, , 
	tHashFunis
, 
	tTs
> 
	tImTy
;

35 
	gpublic
:

36 
Vue
 
	tVueTy
;

37 
tyme
 
	tImTy
::
	t
 iterator;

38 
tyme
 
	tImTy
::
	tcڡ_
 const_iterator;

39 
tyme
 
	tImTy
::
	tAddResu
 AddResult;

41 
sw
(
HashCouedS
&);

43 
size
() const;

44 
cy
() const;

45 
bo
 
isEmy
() const;

48 

 
beg
();

49 

 
d
();

50 
cڡ_
 
beg
() const;

51 
cڡ_
 
d
() const;

53 

 
fd
(cڡ 
VueTy
&);

54 
cڡ_
 
fd
(cڡ 
VueTy
&) const;

55 
bo
 
cڏs
(cڡ 
VueTy
&) const;

56 
cou
(cڡ 
VueTy
&) const;

61 
AddResu
 
add
(cڡ 
VueTy
&);

65 
bo
 
move
(cڡ 
VueTy
&);

66 
bo
 
move
(

);

70 
bo
 
moveA
(

);

71 
bo
 
moveA
(cڡ 
VueTy
&);

74 
r
();

76 
	give
:

77 
ImTy
 
m_im
;

80 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

81 
le
 
	gHashCouedS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::
	$sw
(
HashCouedS
& 
h
)

83 
m_im
.
	`sw
(
h
.m_impl);

84 
	}
}

86 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

87 
le
 
	gHashCouedS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::
	$size
() const

89  
m_im
.
	`size
();

90 
	}
}

92 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

93 
le
 
	gHashCouedS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::
	$cy
() const

95  
m_im
.
	`cy
();

96 
	}
}

98 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

99 
le
 
bo
 
	gHashCouedS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::
	$isEmy
() const

101  
	`size
() == 0;

102 
	}
}

104 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

105 
le
 
tyme
 
	gHashCouedS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::

 
HashCouedS
<
Vue
, HashFunis, Ts>::
	$beg
()

107  
m_im
.
	`beg
();

108 
	}
}

110 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

111 
le
 
tyme
 
	gHashCouedS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::

 
HashCouedS
<
Vue
, HashFunis, Ts>::
	$d
()

113  
m_im
.
	`d
();

114 
	}
}

116 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

117 
le
 
tyme
 
	gHashCouedS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::
cڡ_
 
HashCouedS
<
Vue
, HashFunis, Ts>::
	$beg
() const

119  
m_im
.
	`beg
();

120 
	}
}

122 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

123 
le
 
tyme
 
	gHashCouedS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::
cڡ_
 
HashCouedS
<
Vue
, HashFunis, Ts>::
	$d
() const

125  
m_im
.
	`d
();

126 
	}
}

128 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

129 
le
 
tyme
 
	gHashCouedS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::

 
HashCouedS
<
Vue
, HashFunis, Ts>::
	$fd
(cڡ 
VueTy
& 
vue
)

131  
m_im
.
	`fd
(
vue
);

132 
	}
}

134 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

135 
le
 
tyme
 
	gHashCouedS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::
cڡ_
 
HashCouedS
<
Vue
, HashFunis, Ts>::
	$fd
(cڡ 
VueTy
& 
vue
) const

137  
m_im
.
	`fd
(
vue
);

138 
	}
}

140 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

141 
le
 
bo
 
	gHashCouedS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::
	$cڏs
(cڡ 
VueTy
& 
vue
) const

143  
m_im
.
	`cڏs
(
vue
);

144 
	}
}

146 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

147 
le
 
	gHashCouedS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::
	$cou
(cڡ 
VueTy
& 
vue
) const

149  
m_im
.
	`g
(
vue
);

150 
	}
}

152 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

153 
le
 
tyme
 
	gHashCouedS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::
AddResu
 
HashCouedS
<
Vue
, HashFunis, Ts>::
	$add
(cڡ 
VueTy
 &
vue
)

155 
AddResu
 
su
 = 
m_im
.
	`add
(
vue
, 0);

156 ++
su
.

->
vue
;

157  
su
;

158 
	}
}

160 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

161 
le
 
bo
 
	gHashCouedS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::
	$move
(cڡ 
VueTy
& 
vue
)

163  
	`move
(
	`fd
(
vue
));

164 
	}
}

166 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

167 
le
 
bo
 
	gHashCouedS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::
	$move
(

 

)

169 i(

 =
	`d
())

170  
l
;

172 
dV
 = 

->
vue
;

173 
	`ASSERT
(
dV
);

174 
wV
 = 
dV
 - 1;

175 i(
wV
) {

176 

->
vue
 = 
wV
;

177  
l
;

180 
m_im
.
	`move
(

);

181  
ue
;

182 
	}
}

184 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

185 
le
 
bo
 
	gHashCouedS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::
	$moveA
(cڡ 
VueTy
& 
vue
)

187  
	`moveA
(
	`fd
(
vue
));

188 
	}
}

190 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

191 
le
 
bo
 
	gHashCouedS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::
	$moveA
(

 

)

193 i(

 =
	`d
())

194  
l
;

196 
m_im
.
	`move
(

);

197  
ue
;

198 
	}
}

200 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

201 
le
 
	gHashCouedS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::
	$r
()

203 
m_im
.
	`r
();

204 
	}
}

206 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
,ym
	gVeTy
>

207 
le
 
cyToVe
(cڡ 
HashCouedS
<
Vue
, 
HashFunis
, 
Ts
>& 
ci
, 
VeTy
& 
ve
)

209 
tyme
 
	tHashCouedS
<
	tVue
, 
	tHashFunis
, 
	tTs
>::
	tcڡ_
 
	t
;

211 
	gve
.
size
(
ci
.
size
());

213 

 
	g
 = 
ci
.
beg
();

214 

 
	gd
 = 
ci
.
d
();

215 
	gi
 = 0; 
	g
 !
d
; ++it, ++i)

216 
	gve
[
i
] = *

;

219 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

220 
le
 
cyToVe
(cڡ 
HashCouedS
<
Vue
, 
HashFunis
, 
Ts
>& 
ci
, 
Ve
<Vue>& 
ve
)

222 
tyme
 
	tHashCouedS
<
	tVue
, 
	tHashFunis
, 
	tTs
>::
	tcڡ_
 
	t
;

224 
	gve
.
size
(
ci
.
size
());

226 

 
	g
 = 
ci
.
beg
();

227 

 
	gd
 = 
ci
.
d
();

228 
	gi
 = 0; 
	g
 !
d
; ++it, ++i)

229 
	gve
[
i
] = (*

).
key
;

235 
usg
 
	gWTF
::
HashCouedS
;

	@HashFunctions.h

21 #ide
WTF_HashFunis_h


22 
	#WTF_HashFunis_h


	)

24 
	~<dt.h
>

25 
	~<wtf/GP.h
>

26 
	~<wtf/RefP.h
>

28 
mea
 
	gWTF
 {

30 
	gme
<
size_t
 
	gsize
> 
	gITys
;

31 
	gme
<> 
	gITys
<1> { 
t8_t
 
	tSigdTy
; 
ut8_t
 
	tUnsigdTy
; };

32 
	gme
<> 
	gITys
<2> { 
t16_t
 
	tSigdTy
; 
ut16_t
 
	tUnsigdTy
; };

33 
	gme
<> 
	gITys
<4> { 
t32_t
 
	tSigdTy
; 
ut32_t
 
	tUnsigdTy
; };

34 
	gme
<> 
	gITys
<8> { 
t64_t
 
	tSigdTy
; 
ut64_t
 
	tUnsigdTy
; };

39 
le
 
tHash
(
ut8_t
 
key8
)

41 
	gkey
 = 
key8
;

42 
	gkey
 +~(
key
 << 15);

43 
	gkey
 ^(
key
 >> 10);

44 
	gkey
 +(
key
 << 3);

45 
	gkey
 ^(
key
 >> 6);

46 
	gkey
 +~(
key
 << 11);

47 
	gkey
 ^(
key
 >> 16);

48  
	gkey
;

52 
le
 
tHash
(
ut16_t
 
key16
)

54 
	gkey
 = 
key16
;

55 
	gkey
 +~(
key
 << 15);

56 
	gkey
 ^(
key
 >> 10);

57 
	gkey
 +(
key
 << 3);

58 
	gkey
 ^(
key
 >> 6);

59 
	gkey
 +~(
key
 << 11);

60 
	gkey
 ^(
key
 >> 16);

61  
	gkey
;

65 
le
 
tHash
(
ut32_t
 
key
)

67 
	gkey
 +~(
key
 << 15);

68 
	gkey
 ^(
key
 >> 10);

69 
	gkey
 +(
key
 << 3);

70 
	gkey
 ^(
key
 >> 6);

71 
	gkey
 +~(
key
 << 11);

72 
	gkey
 ^(
key
 >> 16);

73  
	gkey
;

77 
le
 
tHash
(
ut64_t
 
key
)

79 
	gkey
 +~(
key
 << 32);

80 
	gkey
 ^(
key
 >> 22);

81 
	gkey
 +~(
key
 << 13);

82 
	gkey
 ^(
key
 >> 8);

83 
	gkey
 +(
key
 << 3);

84 
	gkey
 ^(
key
 >> 15);

85 
	gkey
 +~(
key
 << 27);

86 
	gkey
 ^(
key
 >> 31);

87  
	gic_
<>(
	gkey
);

91 
le
 
IHash
(
key1
, 
key2
)

93 
	gshtRdom1
 = 277951225;

94 
	gshtRdom2
 = 95187966;

95 
ut64_t
 
	glgRdom
 = 19248658165952622LL;

97 
ut64_t
 
	godu
 = 
lgRdom
 * (
shtRdom1
 * 
key1
 + 
shtRdom2
 * 
key2
);

98 
	ghighBs
 = 
ic_
<>(
odu
 >> ((
ut64_t
) - ()));

99  
	ghighBs
;

102 
	gme
<
tyme
 
	gT
> 
	sIHash
 {

103 
hash
(
T
 
key
{  
tHash
(
ic_
<
tyme
 
ITys
<(T)>::
UnsigdTy
>(key)); }

104 
bo
 
equ
(
T
 
a
, T 
b
{  
	ga
 == b; }

105 cڡ 
bo
 
	gToComToEmyOrDed
 = 
ue
;

108 
	gme
<
tyme
 
	gT
> 
	sFltHash
 {

109 
tyme
 
	tITys
<(
	tT
)>::
	tUnsigdTy
 
	tBs
;

110 
hash
(
T
 
key
)

112  
tHash
(
bwi_
<
Bs
>(
key
));

114 
bo
 
equ
(
T
 
a
, T 
b
)

116  
	gbwi_
<
	gBs
>(
	ga
=
bwi_
<
Bs
>(
b
);

118 cڡ 
bo
 
	gToComToEmyOrDed
 = 
ue
;

123 
	gme
<
tyme
 
	gT
, 
bo
 
	gisSmtPor
>

124 
	gPHashBa
;

126 
	gme
 <
tyme
 
	gT
>

127 
	gPHashBa
<
	gT
, 
	gl
 > {

128 
T
 
	tPTy
;

130 
hash
(
PTy
 
key
{  
	gIHash
<
	gu_t
>::hash(
t_
<
u_t
>(key)); }

131 
bo
 
equ
(
PTy
 
a
, PTy 
b
{  
	ga
 == b; }

132 cڡ 
bo
 
	gToComToEmyOrDed
 = 
ue
;

135 
	gme
 <
tyme
 
	gT
>

136 
	gPHashBa
<
	gT
, 
	gue
 > {

137 
tyme
 
	tGPHr
<
	tT
>::
	tPTy
 PtrType;

139 
hash
(
PTy
 
key
{  
	gIHash
<
	gu_t
>::hash(
t_
<
u_t
>(key)); }

140 
bo
 
equ
(
PTy
 
a
, PTy 
b
{  
	ga
 == b; }

141 cڡ 
bo
 
	gToComToEmyOrDed
 = 
ue
;

143 
hash
(cڡ 
T
& 
key
{  hash(
gP
(key)); }

144 
bo
 
equ
(cڡ 
T
& 
a
, cڡ T& 
b
{  
gP
(a) == getPtr(b); }

145 
bo
 
equ
(
PTy
 
a
, cڡ 
T
& 
b
{  
	ga
 =
gP
(b); }

146 
bo
 
equ
(cڡ 
T
& 
a
, 
PTy
 
b
{  
gP
(a) == b; }

149 
	gme
<
tyme
 
	gT
> 
	gPHash
 : 
PHashBa
<
T
, 
	gIsSmtP
<T>::
vue
> {

154 
	gme
<
tyme
 
	gT
> 
	gDeuHash
;

156 
	gme
<
tyme
 
	gT
,ym
	gU
> 
	sPaHash
 {

157 
hash
(cڡ 
d
::

<
T
, 
U
>& 
p
)

159  
IHash
(
DeuHash
<
T
>::
Hash
::
hash
(
p
.
f
), DeuHash<
U
>::Hash::hash.
cd
));

161 
bo
 
equ
(cڡ 
d
::

<
T
, 
U
>& 
a
, cڡ std::<T, U>& 
b
)

163  
	gDeuHash
<
	gT
>::
Hash
::
equ
(
a
.
f
, 
b
.f&& DeuHash<
	gU
>::Hash::equ.
cd
, b.second);

165 cڡ 
bo
 
	gToComToEmyOrDed
 = 
DeuHash
<
T
>::
Hash
::
ToComToEmyOrDed
 && DeuHash<
U
>::Hash::safeToCompareToEmptyOrDeleted;

168 
	gme
<
tyme
 
	gT
,ym
	gU
> 
	sIPaHash
 {

169 
hash
(cڡ 
d
::

<
T
, 
U
>& 
p
{  
IHash
.
f
,.
cd
); }

170 
bo
 
equ
(cڡ 
d
::

<
T
, 
U
>& 
a
, cڡ std::<T, U>& 
b
{  
	gPaHash
<
	gT
, T>::equal(a, b); }

171 cڡ 
bo
 
	gToComToEmyOrDed
 = 
PaHash
<
T
, 
	gU
>::
ToComToEmyOrDed
;

176 
	gme
<> 
	gDeuHash
<> { 
	gIHash
<> 
	tHash
; };

177 
	gme
<> 
	gDeuHash
<> { 
	gIHash
<> 
	tHash
; };

178 
	gme
<> 
	gDeuHash
<> { 
	gIHash
<> 
	tHash
; };

179 
	gme
<> 
	gDeuHash
<> { 
	gIHash
<> 
	tHash
; };

180 
	gme
<> 
	gDeuHash
<> { 
	gIHash
<> 
	tHash
; };

181 
	gme
<> 
	gDeuHash
<> { 
	gIHash
<> 
	tHash
; };

182 
	gme
<> 
	gDeuHash
<> { 
	gIHash
<> 
	tHash
; };

183 
	gme
<> 
	gDeuHash
<> { 
	gIHash
<> 
	tHash
; };

185 #i
defed
(
_NATIVE_WCHAR_T_DEFINED
)

186 
	gme
<> 
	gDeuHash
<
	gwch_t
> { 
	gIHash
<
	twch_t
> 
	tHash
; };

189 
	gme
<> 
	gDeuHash
<> { 
	gFltHash
<> 
	tHash
; };

190 
	gme
<> 
	gDeuHash
<> { 
	gFltHash
<> 
	tHash
; };

194 
	gme
<
tyme
 
	gP
> 
	gDeuHash
<P*> { 
	gPHash
<
	tP
*> 
	tHash
; };

195 
	gme
<
tyme
 
	gP
> 
	gDeuHash
<
	gRefP
<P>> { 
	gPHash
<
	tRefP
<
	tP
>> 
	tHash
; };

196 
	gme
<
tyme
 
	gP
,ym
	gD
> 
	gDeuHash
<
	gd
::
unique_r
<
P
, D>> { 
	gPHash
<
	td
::
	tunique_r
<
	tP
, 
	tD
>> 
	tHash
; };

200 
	gme
<> 
	gDeuHash
<
	gd
::

<, >> { 
	gIPaHash
<, > 
	tHash
; };

201 
	gme
<> 
	gDeuHash
<
	gd
::

<, >> { 
	gIPaHash
<, > 
	tHash
; };

202 
	gme
<> 
	gDeuHash
<
	gd
::

<, >> { 
	gIPaHash
<, > 
	tHash
; };

203 
	gme
<> 
	gDeuHash
<
	gd
::

<, >> { 
	gIPaHash
<, > 
	tHash
; };

204 
	gme
<> 
	gDeuHash
<
	gd
::

<, >> { 
	gIPaHash
<, > 
	tHash
; };

205 
	gme
<> 
	gDeuHash
<
	gd
::

<, >> { 
	gIPaHash
<, > 
	tHash
; };

206 
	gme
<> 
	gDeuHash
<
	gd
::

<, >> { 
	gIPaHash
<, > 
	tHash
; };

207 
	gme
<> 
	gDeuHash
<
	gd
::

<, >> { 
	gIPaHash
<, > 
	tHash
; };

208 
	gme
<> 
	gDeuHash
<
	gd
::

<, >> { 
	gIPaHash
<, > 
	tHash
; };

209 
	gme
<> 
	gDeuHash
<
	gd
::

<, >> { 
	gIPaHash
<, > 
	tHash
; };

210 
	gme
<> 
	gDeuHash
<
	gd
::

<, >> { 
	gIPaHash
<, > 
	tHash
; };

211 
	gme
<> 
	gDeuHash
<
	gd
::

<, >> { 
	gIPaHash
<, > 
	tHash
; };

212 
	gme
<> 
	gDeuHash
<
	gd
::

<, >> { 
	gIPaHash
<, > 
	tHash
; };

213 
	gme
<> 
	gDeuHash
<
	gd
::

<, >> { 
	gIPaHash
<, > 
	tHash
; };

214 
	gme
<> 
	gDeuHash
<
	gd
::

<, >> { 
	gIPaHash
<, > 
	tHash
; };

215 
	gme
<> 
	gDeuHash
<
	gd
::

<, >> { 
	gIPaHash
<, > 
	tHash
; };

219 
	gme
<
tyme
 
	gT
,ym
	gU
> 
	gDeuHash
<
	gd
::

<
T
, U>> { 
	gPaHash
<
	tT
, 
	tU
> 
	tHash
; };

223 
usg
 
	gWTF
::
DeuHash
;

224 
usg
 
	gWTF
::
IHash
;

225 
usg
 
	gWTF
::
PHash
;

	@HashIterators.h

26 #ide
WTF_HashIts_h


27 
	#WTF_HashIts_h


	)

29 
mea
 
	gWTF
 {

31 
	gme
<
tyme
 
	gHashTabTy
,ym
	gKeyTy
,ym
	gMdTy
> 
	gHashTabCڡKeysIt
;

32 
	gme
<
tyme
 
	gHashTabTy
,ym
	gKeyTy
,ym
	gMdTy
> 
	gHashTabCڡVuesIt
;

33 
	gme
<
tyme
 
	gHashTabTy
,ym
	gKeyTy
,ym
	gMdTy
> 
	gHashTabKeysIt
;

34 
	gme
<
tyme
 
	gHashTabTy
,ym
	gKeyTy
,ym
	gMdTy
> 
	gHashTabVuesIt
;

36 
	gme
<
tyme
 
	gHashTabTy
,ym
	gKeyTy
,ym
	gMdTy
> 
	gHashTabCڡItAdr
<HashTabTy, 
	gKeyVuePa
<KeyType, MappedType>> {

37 
	give
:

38 
KeyVuePa
<
	tKeyTy
, 
	tMdTy
> 
	tVueTy
;

39 
	gpublic
:

40 
HashTabCڡKeysIt
<
	tHashTabTy
, 
	tKeyTy
, 
	tMdTy
> 
	tKeys
;

41 
	gHashTabCڡVuesIt
<
	tHashTabTy
, 
	tKeyTy
, 
	tMdTy
> 
	tVues
;

43 
HashTabCڡItAdr
() {}

44 
HashTabCڡItAdr
(cڡ 
tyme
 
HashTabTy
::
cڡ_
& 
im
: 
m_im
(impl) {}

46 cڡ 
VueTy
* 
g
(cڡ {  (cڡ VueTy*)
m_im
.get(); }

47 cڡ 
	gVueTy
& 
	gݔ
*(cڡ {  *
g
(); }

48 cڡ 
VueTy
* 
	gݔ
->(cڡ {  
g
(); }

50 
	gHashTabCڡItAdr
& 
	gݔ
++({ ++
	gm_im
;  *
	gthis
; }

53 
Keys
 
keys
({  Keys(*
this
); }

54 
Vues
 
vues
({  Vues(*
this
); }

56 
tyme
 
	gHashTabTy
::
cڡ_
 
m_im
;

59 
	gme
<
tyme
 
	gHashTabTy
,ym
	gKeyTy
,ym
	gMdTy
> 
	gHashTabItAdr
<HashTabTy, 
	gKeyVuePa
<KeyType, MappedType>> {

60 
	give
:

61 
KeyVuePa
<
	tKeyTy
, 
	tMdTy
> 
	tVueTy
;

62 
	gpublic
:

63 
HashTabKeysIt
<
	tHashTabTy
, 
	tKeyTy
, 
	tMdTy
> 
	tKeys
;

64 
	gHashTabVuesIt
<
	tHashTabTy
, 
	tKeyTy
, 
	tMdTy
> 
	tVues
;

66 
HashTabItAdr
() {}

67 
HashTabItAdr
(cڡ 
tyme
 
HashTabTy
::

& 
im
: 
m_im
(impl) {}

69 
VueTy
* 
g
(cڡ {  (VueTy*)
m_im
.get(); }

70 
	gVueTy
& 
	gݔ
*(cڡ {  *
g
(); }

71 
VueTy
* 
	gݔ
->(cڡ {  
g
(); }

73 
	gHashTabItAdr
& 
	gݔ
++({ ++
	gm_im
;  *
	gthis
; }

76 
ݔ
 
	gHashTabCڡItAdr
<
	gHashTabTy
, 
	gVueTy
>() {

77 
tyme
 
	gHashTabTy
::
cڡ_
 
i
 = 
m_im
;

78  
	gi
;

81 
Keys
 
keys
({  Keys(*
this
); }

82 
Vues
 
vues
({  Vues(*
this
); }

84 
tyme
 
	gHashTabTy
::

 
m_im
;

87 
	gme
<
tyme
 
	gHashTabTy
,ym
	gKeyTy
,ym
	gMdTy
> 
	sHashTabCڡKeysIt
 {

88 
	give
:

89 
HashTabCڡItAdr
<
	tHashTabTy
, 
	tKeyVuePa
<
	tKeyTy
, 
	tMdTy
>> 
	tCڡIt
;

91 
	gpublic
:

92 
HashTabCڡKeysIt
(cڡ 
CڡIt
& 
im
: 
m_im
(impl) {}

94 cڡ 
KeyTy
* 
g
(cڡ {  &(
m_im
.g()->
key
); }

95 cڡ 
	gKeyTy
& 
	gݔ
*(cڡ {  *
g
(); }

96 cڡ 
KeyTy
* 
	gݔ
->(cڡ {  
g
(); }

98 
	gHashTabCڡKeysIt
& 
	gݔ
++({ ++
	gm_im
;  *
	gthis
; }

101 
CڡIt
 
	gm_im
;

104 
	gme
<
tyme
 
	gHashTabTy
,ym
	gKeyTy
,ym
	gMdTy
> 
	sHashTabCڡVuesIt
 {

105 
	give
:

106 
HashTabCڡItAdr
<
	tHashTabTy
, 
	tKeyVuePa
<
	tKeyTy
, 
	tMdTy
>> 
	tCڡIt
;

108 
	gpublic
:

109 
HashTabCڡVuesIt
(cڡ 
CڡIt
& 
im
: 
m_im
(impl) {}

111 cڡ 
MdTy
* 
g
(cڡ {  &(
m_im
.g()->
vue
); }

112 cڡ 
	gMdTy
& 
	gݔ
*(cڡ {  *
g
(); }

113 cڡ 
MdTy
* 
	gݔ
->(cڡ {  
g
(); }

115 
	gHashTabCڡVuesIt
& 
	gݔ
++({ ++
	gm_im
;  *
	gthis
; }

118 
CڡIt
 
	gm_im
;

121 
	gme
<
tyme
 
	gHashTabTy
,ym
	gKeyTy
,ym
	gMdTy
> 
	sHashTabKeysIt
 {

122 
	give
:

123 
HashTabItAdr
<
	tHashTabTy
, 
	tKeyVuePa
<
	tKeyTy
, 
	tMdTy
>> 
	tIt
;

124 
	gHashTabCڡItAdr
<
	tHashTabTy
, 
	tKeyVuePa
<
	tKeyTy
, 
	tMdTy
>> 
	tCڡIt
;

126 
	gpublic
:

127 
HashTabKeysIt
(cڡ 
It
& 
im
: 
m_im
(impl) {}

129 
KeyTy
* 
g
(cڡ {  &(
m_im
.g()->
key
); }

130 
	gKeyTy
& 
	gݔ
*(cڡ {  *
g
(); }

131 
KeyTy
* 
	gݔ
->(cڡ {  
g
(); }

133 
	gHashTabKeysIt
& 
	gݔ
++({ ++
	gm_im
;  *
	gthis
; }

136 
ݔ
 
	gHashTabCڡKeysIt
<
	gHashTabTy
, 
	gKeyTy
, 
	gMdTy
>() {

137 
CڡIt
 
	gi
 = 
m_im
;

138  
	gi
;

141 
It
 
	gm_im
;

144 
	gme
<
tyme
 
	gHashTabTy
,ym
	gKeyTy
,ym
	gMdTy
> 
	sHashTabVuesIt
 {

145 
	give
:

146 
HashTabItAdr
<
	tHashTabTy
, 
	tKeyVuePa
<
	tKeyTy
, 
	tMdTy
>> 
	tIt
;

147 
	gHashTabCڡItAdr
<
	tHashTabTy
, 
	tKeyVuePa
<
	tKeyTy
, 
	tMdTy
>> 
	tCڡIt
;

149 
	gpublic
:

150 
HashTabVuesIt
(cڡ 
It
& 
im
: 
m_im
(impl) {}

152 
MdTy
* 
g
(cڡ {  &(
m_im
.g()->
vue
); }

153 
	gMdTy
& 
	gݔ
*(cڡ {  *
g
(); }

154 
MdTy
* 
	gݔ
->(cڡ {  
g
(); }

156 
	gHashTabVuesIt
& 
	gݔ
++({ ++
	gm_im
;  *
	gthis
; }

159 
ݔ
 
	gHashTabCڡVuesIt
<
	gHashTabTy
, 
	gKeyTy
, 
	gMdTy
>() {

160 
CڡIt
 
	gi
 = 
m_im
;

161  
	gi
;

164 
It
 
	gm_im
;

167 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

168 
le
 
bo
 
	gݔ
==(cڡ 
HashTabCڡKeysIt
<
T
, 
	gU
, 
	gV
>& 
	ga
, cڡ 
	gHashTabCڡKeysIt
<
	gT
, U, V>& 
	gb
)

170  
	ga
.
	gm_im
 =
b
.
m_im
;

173 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

174 
le
 
bo
 
	gݔ
!=(cڡ 
HashTabCڡKeysIt
<
T
, 
	gU
, 
	gV
>& 
	ga
, cڡ 
	gHashTabCڡKeysIt
<
	gT
, U, V>& 
	gb
)

176  
	ga
.
	gm_im
 !
b
.
m_im
;

179 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

180 
le
 
bo
 
	gݔ
==(cڡ 
HashTabCڡVuesIt
<
T
, 
	gU
, 
	gV
>& 
	ga
, cڡ 
	gHashTabCڡVuesIt
<
	gT
, U, V>& 
	gb
)

182  
	ga
.
	gm_im
 =
b
.
m_im
;

185 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

186 
le
 
bo
 
	gݔ
!=(cڡ 
HashTabCڡVuesIt
<
T
, 
	gU
, 
	gV
>& 
	ga
, cڡ 
	gHashTabCڡVuesIt
<
	gT
, U, V>& 
	gb
)

188  
	ga
.
	gm_im
 !
b
.
m_im
;

191 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

192 
le
 
bo
 
	gݔ
==(cڡ 
HashTabKeysIt
<
T
, 
	gU
, 
	gV
>& 
	ga
, cڡ 
	gHashTabKeysIt
<
	gT
, U, V>& 
	gb
)

194  
	ga
.
	gm_im
 =
b
.
m_im
;

197 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

198 
le
 
bo
 
	gݔ
!=(cڡ 
HashTabKeysIt
<
T
, 
	gU
, 
	gV
>& 
	ga
, cڡ 
	gHashTabKeysIt
<
	gT
, U, V>& 
	gb
)

200  
	ga
.
	gm_im
 !
b
.
m_im
;

203 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

204 
le
 
bo
 
	gݔ
==(cڡ 
HashTabVuesIt
<
T
, 
	gU
, 
	gV
>& 
	ga
, cڡ 
	gHashTabVuesIt
<
	gT
, U, V>& 
	gb
)

206  
	ga
.
	gm_im
 =
b
.
m_im
;

209 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

210 
le
 
bo
 
	gݔ
!=(cڡ 
HashTabVuesIt
<
T
, 
	gU
, 
	gV
>& 
	ga
, cڡ 
	gHashTabVuesIt
<
	gT
, U, V>& 
	gb
)

212  
	ga
.
	gm_im
 !
b
.
m_im
;

	@HashMap.h

21 #ide
WTF_HashM_h


22 
	#WTF_HashM_h


	)

24 
	~<liz_li
>

25 
	~<wtf/HashTab.h
>

26 
	~<wtf/ItRge.h
>

28 
mea
 
	gWTF
 {

30 
	gme
<
tyme
 
	gT
> 
	sKeyVuePaKeyExa
 {

31 cڡ 
tyme
 
	gT
::
KeyTy
& 
exa
(cڡ 
T
& 
p
{ .
key
; }

34 
	gme
<
tyme
 
	gKeyArg
,ym
	gMdArg
,ym
	gHashArg
 =ym
DeuHash
<
KeyArg
>::
Hash
,

35 
tyme
 
	gKeyTsArg
 = 
HashTs
<
KeyArg
>,ym
	gMdTsArg
 = HashTs<
MdArg
>>

36 as
	cHashM
 
f
 {

37 
WTF_MAKE_FAST_ALLOCATED
;

38 
	give
:

39 
KeyTsArg
 
	tKeyTs
;

40 
MdTsArg
 
	tMdTs
;

42 
	gKeyVuePaTs
 : 
KeyVuePaHashTs
<
KeyTs
, 
	gMdTs
> {

43 cڡ 
bo
 
	ghasIsEmyVueFuni
 = 
ue
;

44 
bo
 
isEmyVue
(cڡ 
tyme
 
KeyVuePaHashTs
<
KeyTs
, 
MdTs
>::
TTy
& 
vue
)

46  
isHashTsEmyVue
<
KeyTs
>(
vue
.
key
);

50 
	gpublic
:

51 
tyme
 
	tKeyTs
::
	tTTy
 
	tKeyTy
;

52 
tyme
 
	tMdTs
::
	tTTy
 
	tMdTy
;

53 
tyme
 
	tKeyVuePaTs
::
	tTTy
 
	tKeyVuePaTy
;

55 
	give
:

56 
tyme
 
	tMdTs
::
	tPkTy
 
	tMdPkTy
;

58 
HashArg
 
	tHashFunis
;

60 
	gHashTab
<
	tKeyTy
, 
	tKeyVuePaTy
, 
	tKeyVuePaKeyExa
<KeyValuePairType>,

61 
	tHashFunis
, 
	tKeyVuePaTs
, 
	tKeyTs
> 
	tHashTabTy
;

63 
ass
 
	gHashMKeysProxy
;

64 
ass
 
	gHashMVuesProxy
;

66 
	gpublic
:

67 
HashTabItAdr
<
	tHashTabTy
, 
	tKeyVuePaTy
> 
	t
;

68 
	gHashTabCڡItAdr
<
	tHashTabTy
, 
	tKeyVuePaTy
> 
	tcڡ_
;

69 
tyme
 
	tHashTabTy
::
	tAddResu
 AddResult;

71 
	gpublic
:

72 
HashM
()

76 
HashM
(
d
::
liz_li
<
KeyVuePaTy
> 
lizLi
)

78 cڡuto& 
keyVuePa
 : 
lizLi
)

79 
add
(
keyVuePa
.
key
, keyVuePa.
vue
);

82 
sw
(
HashM
&);

84 
size
() const;

85 
cy
() const;

86 
bo
 
isEmy
() const;

89 

 
beg
();

90 

 
d
();

91 
cڡ_
 
beg
() const;

92 
cڡ_
 
d
() const;

94 
	gItRge
<
tyme
 
	g
::
Keys
> 
keys
({  
makeItRge
(
beg
().keys(), 
d
().keys()); }

95 cڡ 
	gItRge
<
tyme
 
	gcڡ_
::
Keys
> 
keys
(cڡ {  
makeItRge
(
beg
().keys(), 
d
().keys()); }

97 
	gItRge
<
tyme
 
	g
::
Vues
> 
vues
({  
makeItRge
(
beg
().vues(), 
d
().values()); }

98 cڡ 
	gItRge
<
tyme
 
	gcڡ_
::
Vues
> 
vues
(cڡ {  
makeItRge
(
beg
().vues(), 
d
().values()); }

100 

 
fd
(cڡ 
KeyTy
&);

101 
cڡ_
 
fd
(cڡ 
KeyTy
&) const;

102 
bo
 
cڏs
(cڡ 
KeyTy
&) const;

103 
MdPkTy
 
g
(cڡ 
KeyTy
&) const;

108 
	gme
<
tyme
 
	gV
> 
AddResu
 
t
(cڡ 
KeyTy
&, 
V
&&);

109 
	gme
<
tyme
 
	gV
> 
AddResu
 
t
(
KeyTy
&&, 
V
&&);

114 
	gme
<
tyme
 
	gV
> 
AddResu
 
add
(cڡ 
KeyTy
&, 
V
&&);

115 
	gme
<
tyme
 
	gV
> 
AddResu
 
add
(
KeyTy
&&, 
V
&&);

118 
	gme
<
tyme
 
	gV
> 
AddResu
 
Add
(cڡ 
KeyTy
&, 
V
&&);

119 
	gme
<
tyme
 
	gV
> 
AddResu
 
Add
(
KeyTy
&&, 
V
&&);

121 
bo
 
move
(cڡ 
KeyTy
&);

122 
bo
 
move
(

);

123 
	gme
<
tyme
 
	gFun
>

124 
moveIf
(cڡ 
Fun
& 
fun
);

125 
r
();

127 
MdTy
 
ke
(cڡ 
KeyTy
&);

134 
	gme
<
tyme
 
	gHashTn
,ym
	gT
> 

 
fd
(cڡ 
T
&);

135 
	gme
<
tyme
 
	gHashTn
,ym
	gT
> 
cڡ_
 
fd
(cڡ 
T
&) const;

136 
	gme
<
tyme
 
	gHashTn
,ym
	gT
> 
bo
 
cڏs
(cڡ 
T
&) const;

144 
	gme
<
tyme
 
	gHashTn
,ym
	gK
,ym
	gV
> 
AddResu
 
add
(
K
&&, 
V
&&);

147 
	gme
<
tyme
 
	gK
 = 
KeyTy
>ym
d
::
ab_if
<
IsSmtP
<
K
>::
vue
, 
	g
>::
ty
 
fd
ym
GPHr
<K>::
PTy
);

148 
	gme
<
tyme
 
	gK
 = 
KeyTy
>ym
d
::
ab_if
<
IsSmtP
<
K
>::
vue
, 
	gcڡ_
>::
ty
 
fd
ym
GPHr
<K>::
PTy
) const;

149 
	gme
<
tyme
 
	gK
 = 
KeyTy
>ym
d
::
ab_if
<
IsSmtP
<
K
>::
vue
, 
	gbo
>::
ty
 
cڏs
ym
GPHr
<K>::
PTy
) const;

150 
	gme
<
tyme
 
	gK
 = 
KeyTy
>ym
d
::
ab_if
<
IsSmtP
<
K
>::
vue
, 
	gMdPkTy
>::
ty
 
g
ym
GPHr
<K>::
PTy
) const;

151 
	gme
<
tyme
 
	gK
 = 
KeyTy
>ym
d
::
ab_if
<
IsSmtP
<
K
>::
vue
, 
	gbo
>::
ty
 
move
ym
GPHr
<K>::
PTy
);

152 
	gme
<
tyme
 
	gK
 = 
KeyTy
>ym
d
::
ab_if
<
IsSmtP
<
K
>::
vue
, 
	gMdTy
>::
ty
 
ke
ym
GPHr
<K>::
PTy
);

154 
checkCsicy
() const;

156 
bo
 
isVidKey
(cڡ 
KeyTy
&);

158 
	give
:

159 
me
<
tyme
 
K
,ym
	gV
>

160 
AddResu
 
leS
(
K
&&, 
V
&&);

162 
	gme
<
tyme
 
	gK
,ym
	gV
>

163 
AddResu
 
leAdd
(
K
&&, 
V
&&);

165 
HashTabTy
 
	gm_im
;

168 
	gme
<
tyme
 
	gVueTs
,ym
	gHashFunis
>

169 
	sHashMTn
 {

170 
	gme
<
tyme
 
	gT
> 
hash
(cڡ 
T
& 
key
{  
	gHashFunis
::hash(key); }

171 
	gme
<
tyme
 
	gT
,ym
	gU
> 
bo
 
equ
(cڡ 
T
& 
a
, cڡ 
U
& 
b
{  
	gHashFunis
::equal(a, b); }

172 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
> 
e
(
T
& 
loti
, 
U
&& 
key
, 
V
&& 
md
)

174 
	gloti
.
	gkey
 = 
d
::
fwd
<
U
>(
key
);

175 
	gloti
.
	gvue
 = 
d
::
fwd
<
V
>(
md
);

179 
	gme
<
tyme
 
	gVueTs
,ym
	gTn
>

180 
	sHashMTnAdr
 {

181 
	gme
<
tyme
 
	gT
> 
hash
(cڡ 
T
& 
key
{  
	gTn
::hash(key); }

182 
	gme
<
tyme
 
	gT
,ym
	gU
> 
bo
 
equ
(cڡ 
T
& 
a
, cڡ 
U
& 
b
{  
	gTn
::equal(a, b); }

183 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
> 
e
(
T
& 
loti
, 
U
&& 
key
, 
V
&& 
md
, 
hashCode
)

185 
	gTn
::
e
(
loti
.
key
, key, 
hashCode
);

186 
	gloti
.
	gvue
 = 
d
::
fwd
<
V
>(
md
);

190 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

191 
le
 
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
	$sw
(
HashM
& 
h
)

193 
m_im
.
	`sw
(
h
.m_impl);

194 
	}
}

196 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

197 
le
 
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
	$size
() const

199  
m_im
.
	`size
();

200 
	}
}

202 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

203 
le
 
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
	$cy
() const

205  
m_im
.
	`cy
();

206 
	}
}

208 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

209 
le
 
bo
 
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
	$isEmy
() const

211  
m_im
.
	`isEmy
();

212 
	}
}

214 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

215 
le
ut
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
beg
(-> 



217  
m_im
.
beg
();

220 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

221 
le
ut
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
d
(-> 



223  
m_im
.
d
();

226 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

227 
le
ut
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
	$beg
(cڡ -> 
cڡ_


229  
m_im
.
	`beg
();

230 
	}
}

232 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

233 
le
ut
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
	$d
(cڡ -> 
cڡ_


235  
m_im
.
	`d
();

236 
	}
}

238 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

239 
le
ut
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
fd
(cڡ 
KeyTy
& 
key
-> 



241  
m_im
.
fd
(
key
);

244 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

245 
le
ut
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
	$fd
(cڡ 
KeyTy
& 
key
cڡ -> 
cڡ_


247  
m_im
.
	`fd
(
key
);

248 
	}
}

250 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

251 
le
 
bo
 
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
	$cڏs
(cڡ 
KeyTy
& 
key
) const

253  
m_im
.
	`cڏs
(
key
);

254 
	}
}

256 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

257 
	gme
<
tyme
 
	gHashTn
,ym
	gTYPE
>

258 
le
 
tyme
 
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::



259 
HashM
<
T
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
	$fd
(cڡ 
TYPE
& 
vue
)

261  
m_im
.
me
 
fd
<
HashMTnAdr
<
KeyVuePaTs
, 
HashTn
>>(
vue
);

262 
	}
}

264 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

265 
	gme
<
tyme
 
	gHashTn
,ym
	gTYPE
>

266 
le
 
tyme
 
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
cڡ_


267 
HashM
<
T
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
	$fd
(cڡ 
TYPE
& 
vue
) const

269  
m_im
.
me
 
fd
<
HashMTnAdr
<
KeyVuePaTs
, 
HashTn
>>(
vue
);

270 
	}
}

272 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

273 
	gme
<
tyme
 
	gHashTn
,ym
	gTYPE
>

274 
le
 
bo
 
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
	$cڏs
(cڡ 
TYPE
& 
vue
) const

276  
m_im
.
me
 
cڏs
<
HashMTnAdr
<
KeyVuePaTs
, 
HashTn
>>(
vue
);

277 
	}
}

279 
	gme
<
tyme
 
	gKeyArg
,ym
	gMdArg
,ym
	gHashArg
,ym
	gKeyTsArg
,ym
	gMdTsArg
>

280 
	gme
<
tyme
 
	gK
,ym
	gV
>

281 aut
	gHashM
<
	gKeyArg
, 
	gMdArg
, 
	gHashArg
, 
	gKeyTsArg
, 
	gMdTsArg
>::
leS
(
K
&& 
key
, 
V
&& 
vue
-> 
	gAddResu


283 
AddResu
 
	gsu
 = 
leAdd
(
d
::
fwd
<
K
>(
key
), std::fwd<
V
>(
vue
));

284 i(!
	gsu
.
	gisNewEry
) {

286 
	gsu
.
	g
->
	gvue
 = 
d
::
fwd
<
V
>(
vue
);

288  
	gsu
;

291 
	gme
<
tyme
 
	gKeyArg
,ym
	gMdArg
,ym
	gHashArg
,ym
	gKeyTsArg
,ym
	gMdTsArg
>

292 
	gme
<
tyme
 
	gK
,ym
	gV
>

293 
ALWAYS_INLINE
ut
	gHashM
<
	gKeyArg
, 
	gMdArg
, 
	gHashArg
, 
	gKeyTsArg
, 
	gMdTsArg
>::
leAdd
(
K
&& 
key
, 
V
&& 
vue
-> 
	gAddResu


295  
	gm_im
.
me
 
	gadd
<
	gHashMTn
<
	gKeyVuePaTs
, 
	gHashFunis
>>(
	gd
::
fwd
<
K
>(
key
), std::fwd<
V
>(
vue
));

298 
	gme
<
tyme
 
	gKeyArg
,ym
	gMdArg
,ym
	gHashArg
,ym
	gKeyTsArg
,ym
	gMdTsArg
>

299 
	gme
<
tyme
 
	gT
>

300 aut
	gHashM
<
	gKeyArg
, 
	gMdArg
, 
	gHashArg
, 
	gKeyTsArg
, 
	gMdTsArg
>::
t
(cڡ 
KeyTy
& 
key
, 
T
&& 
md
-> 
	gAddResu


302  
leS
(
key
, 
d
::
fwd
<
T
>(
md
));

305 
	gme
<
tyme
 
	gKeyArg
,ym
	gMdArg
,ym
	gHashArg
,ym
	gKeyTsArg
,ym
	gMdTsArg
>

306 
	gme
<
tyme
 
	gT
>

307 aut
	gHashM
<
	gKeyArg
, 
	gMdArg
, 
	gHashArg
, 
	gKeyTsArg
, 
	gMdTsArg
>::
t
(
KeyTy
&& 
key
, 
T
&& 
md
-> 
	gAddResu


309  
leS
(
WTF
::
move
(
key
), 
d
::
fwd
<
T
>(
md
));

312 
	gme
<
tyme
 
	gKeyArg
,ym
	gMdArg
,ym
	gHashArg
,ym
	gKeyTsArg
,ym
	gMdTsArg
>

313 
	gme
<
tyme
 
	gHashTn
,ym
	gK
,ym
	gV
>

314 aut
	gHashM
<
	gKeyArg
, 
	gMdArg
, 
	gHashArg
, 
	gKeyTsArg
, 
	gMdTsArg
>::
add
(
K
&& 
key
, 
V
&& 
vue
-> 
	gAddResu


316  
	gm_im
.
me
 
	gaddPassgHashCode
<
	gHashMTnAdr
<
	gKeyVuePaTs
, 
	gHashTn
>>(
	gd
::
fwd
<
K
>(
key
), std::fwd<
V
>(
vue
));

319 
	gme
<
tyme
 
	gKeyArg
,ym
	gMdArg
,ym
	gHashArg
,ym
	gKeyTsArg
,ym
	gMdTsArg
>

320 
	gme
<
tyme
 
	gT
>

321 aut
	gHashM
<
	gKeyArg
, 
	gMdArg
, 
	gHashArg
, 
	gKeyTsArg
, 
	gMdTsArg
>::
add
(cڡ 
KeyTy
& 
key
, 
T
&& 
md
-> 
	gAddResu


323  
leAdd
(
key
, 
d
::
fwd
<
T
>(
md
));

326 
	gme
<
tyme
 
	gKeyArg
,ym
	gMdArg
,ym
	gHashArg
,ym
	gKeyTsArg
,ym
	gMdTsArg
>

327 
	gme
<
tyme
 
	gT
>

328 aut
	gHashM
<
	gKeyArg
, 
	gMdArg
, 
	gHashArg
, 
	gKeyTsArg
, 
	gMdTsArg
>::
add
(
KeyTy
&& 
key
, 
T
&& 
md
-> 
	gAddResu


330  
leAdd
(
WTF
::
move
(
key
), 
d
::
fwd
<
T
>(
md
));

333 
	gme
<
tyme
 
	gKeyArg
,ym
	gMdArg
,ym
	gHashArg
,ym
	gKeyTsArg
,ym
	gMdTsArg
>

334 
	gme
<
tyme
 
	gT
>

335 
ALWAYS_INLINE
ut
	gHashM
<
	gKeyArg
, 
	gMdArg
, 
	gHashArg
, 
	gKeyTsArg
, 
	gMdTsArg
>::
Add
(cڡ 
KeyTy
& 
key
, 
T
&& 
md
-> 
	gAddResu


337  
leAdd
(
key
, 
d
::
fwd
<
T
>(
md
));

340 
	gme
<
tyme
 
	gKeyArg
,ym
	gMdArg
,ym
	gHashArg
,ym
	gKeyTsArg
,ym
	gMdTsArg
>

341 
	gme
<
tyme
 
	gT
>

342 
ALWAYS_INLINE
ut
	gHashM
<
	gKeyArg
, 
	gMdArg
, 
	gHashArg
, 
	gKeyTsArg
, 
	gMdTsArg
>::
Add
(
KeyTy
&& 
key
, 
T
&& 
md
-> 
	gAddResu


344  
leAdd
(
WTF
::
move
(
key
), 
d
::
fwd
<
T
>(
md
));

347 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gMdTs
>

348 aut
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gMdTs
>::
	$g
(cڡ 
KeyTy
& 
key
cڡ -> 
MdPkTy


350 
KeyVuePaTy
* 
y
 = 
cڡ_
<
HashTabTy
&>(
m_im
).
	`lookup
(
key
);

351 i(!
y
)

352  
MdTs
::
	`ek
(MdTs::
	`emyVue
());

353  
MdTs
::
	`ek
(
y
->
vue
);

354 
	}
}

356 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

357 
le
 
bo
 
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
	$move
(

 

)

359 i(

.
m_im
 =m_im.
	`d
())

360  
l
;

361 
m_im
.
	`CheckTabCsicy
();

362 
m_im
.
	`moveWhoutEryCsicyCheck
(

.m_impl);

363  
ue
;

364 
	}
}

366 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

367 
	gme
<
tyme
 
	gFun
>

368 
le
 
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
	$moveIf
(cڡ 
Fun
& 
fun
)

370 
m_im
.
	`moveIf
(
fun
);

371 
	}
}

373 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

374 
le
 
bo
 
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
	$move
(cڡ 
KeyTy
& 
key
)

376  
	`move
(
	`fd
(
key
));

377 
	}
}

379 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

380 
le
 
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
	$r
()

382 
m_im
.
	`r
();

383 
	}
}

385 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gMdTs
>

386 aut
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gMdTs
>::
ke
(cڡ 
KeyTy
& 
key
-> 
MdTy


388 

 

 = 
fd
(
key
);

389 i(
	g
 =
d
())

390  
MdTs
::
emyVue
();

391 
MdTy
 
	gvue
 = 
WTF
::
move
(

->
vue
);

392 
move
(

);

393  
	gvue
;

396 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

397 
	gme
<
tyme
 
	gK
>

398 
le
ut
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
fd
(
tyme
 
GPHr
<
K
>::
PTy
 
key
->ym
d
::
ab_if
<
IsSmtP
<K>::
vue
, 
	g
>::
ty


400  
m_im
.
me
 
fd
<
HashMTn
<
KeyVuePaTs
, 
	gHashFunis
>>(
	gkey
);

403 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

404 
	gme
<
tyme
 
	gK
>

405 
le
ut
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
fd
(
tyme
 
GPHr
<
K
>::
PTy
 
key
cڡ ->ym
d
::
ab_if
<
IsSmtP
<K>::
vue
, 
	gcڡ_
>::
ty


407  
m_im
.
me
 
fd
<
HashMTn
<
KeyVuePaTs
, 
	gHashFunis
>>(
	gkey
);

410 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

411 
	gme
<
tyme
 
	gK
>

412 
le
ut
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
cڏs
(
tyme
 
GPHr
<
K
>::
PTy
 
key
cڡ ->ym
d
::
ab_if
<
IsSmtP
<K>::
vue
, 
	gbo
>::
ty


414  
m_im
.
me
 
cڏs
<
HashMTn
<
KeyVuePaTs
, 
	gHashFunis
>>(
	gkey
);

417 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

418 
	gme
<
tyme
 
	gK
>

419 
le
ut
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
g
(
tyme
 
GPHr
<
K
>::
PTy
 
key
cڡ ->ym
d
::
ab_if
<
IsSmtP
<K>::
vue
, 
	gMdPkTy
>::
ty


421 
KeyVuePaTy
* 
y
 = 
cڡ_
<
HashTabTy
&>(
m_im
).
me
 
lookup
<
HashMTn
<
KeyVuePaTs
, 
	gHashFunis
>>(
	gkey
);

422 i(!
	gy
)

423  
	gMdTs
::
ek
(
MdTs
::
emyVue
());

424  
	gMdTs
::
ek
(
y
->
vue
);

427 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

428 
	gme
<
tyme
 
	gK
>

429 
le
ut
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
move
(
tyme
 
GPHr
<
K
>::
PTy
 
key
->ym
d
::
ab_if
<
IsSmtP
<K>::
vue
, 
	gbo
>::
ty


431  
move
(
fd
(
key
));

434 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

435 
	gme
<
tyme
 
	gK
>

436 
le
ut
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
ke
(
tyme
 
GPHr
<
K
>::
PTy
 
key
->ym
d
::
ab_if
<
IsSmtP
<K>::
vue
, 
	gMdTy
>::
ty


438 

 

 = 
fd
(
key
);

439 i(
	g
 =
d
())

440  
MdTs
::
emyVue
();

441 
MdTy
 
	gvue
 = 
WTF
::
move
(

->
vue
);

442 
move
(

);

443  
	gvue
;

446 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

447 
le
 
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
	$checkCsicy
() const

449 
m_im
.
	`checkTabCsicy
();

450 
	}
}

452 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

453 
le
 
bo
 
	gHashM
<
	gT
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
	$isVidKey
(cڡ 
KeyTy
& 
key
)

455 i(
KeyTs
::
	`isDedVue
(
key
))

456  
l
;

458 i(
HashFunis
::
ToComToEmyOrDed
) {

459 i(
key
 =
KeyTs
::
	`emyVue
())

460  
l
;

462 i(
isHashTsEmyVue
<
KeyTs
>(
key
))

463  
l
;

466  
ue
;

467 
	}
}

469 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

470 
bo
 
	gݔ
==(cڡ 
HashM
<
T
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>& 
	ga
, cڡ 
	gHashM
<
	gT
, U, V, W, X>& 
	gb
)

472 i(
	ga
.
size
(!
b
.size())

473  
l
;

475 
tyme
 
	tHashM
<
	tT
, 
	tU
, 
	tV
, 
	tW
, 
	tX
>::
	tcڡ_
 const_iterator;

477 
cڡ_
 
	gd
 = 
a
.
d
();

478 
cڡ_
 
	gnFound
 = 
b
.
d
();

479 
cڡ_
 
	g
 = 
a
.
beg
(); i!
d
; ++it) {

480 
cڡ_
 
	gbPos
 = 
b
.
fd
(

->
key
);

481 i(
	gbPos
 =
nFound
 || 

->
vue
 !
bPos
->value)

482  
l
;

485  
	gue
;

488 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

489 
le
 
bo
 
	gݔ
!=(cڡ 
HashM
<
T
, 
	gU
, 
	gV
, 
	gW
, 
	gX
>& 
	ga
, cڡ 
	gHashM
<
	gT
, U, V, W, X>& 
	gb
)

491  !(
	ga
 =
b
);

494 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
,ym
	gY
>

495 
le
 
cyKeysToVe
(cڡ 
HashM
<
T
, 
U
, 
V
, 
W
, 
X
>& 
ci
, 
Y
& 
ve
)

497 
tyme
 
	tHashM
<
	tT
, 
	tU
, 
	tV
, 
	tW
, 
	tX
>::
	tcڡ_
::
	tKeys
 
	t
;

499 
	gve
.
size
(
ci
.
size
());

501 

 
	g
 = 
ci
.
beg
().
keys
();

502 

 
	gd
 = 
ci
.
d
().
keys
();

503 
	gi
 = 0; 
	g
 !
d
; ++it, ++i)

504 
	gve
[
i
] = *

;

507 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
,ym
	gY
>

508 
le
 
cyVuesToVe
(cڡ 
HashM
<
T
, 
U
, 
V
, 
W
, 
X
>& 
ci
, 
Y
& 
ve
)

510 
tyme
 
	tHashM
<
	tT
, 
	tU
, 
	tV
, 
	tW
, 
	tX
>::
	tcڡ_
::
	tVues
 
	t
;

512 
	gve
.
size
(
ci
.
size
());

514 

 
	g
 = 
ci
.
beg
().
vues
();

515 

 
	gd
 = 
ci
.
d
().
vues
();

516 
	gi
 = 0; 
	g
 !
d
; ++it, ++i)

517 
	gve
[
i
] = *

;

522 
usg
 
	gWTF
::
HashM
;

524 
	~<wtf/RefPHashM.h
>

	@HashMethod.h

26 #ide
HashMhod_h


27 
	#HashMhod_h


	)

29 
	~<wtf/StdLibExas.h
>

31 
mea
 
	gWTF
 {

33 
	gme
<
tyme
 
	gT
>

34 
	sHashMhod
 {

35 
size_t
 
ݔ
()(cڡ 
	gT
& 
	gvue
) const

37  
	gvue
.
hash
();

43 
usg
 
	gWTF
::
HashMhod
;

	@HashSet.h

21 #ide
WTF_HashS_h


22 
	#WTF_HashS_h


	)

24 
	~<liz_li
>

25 
	~<wtf/FaMloc.h
>

26 
	~<wtf/GP.h
>

27 
	~<wtf/HashTab.h
>

29 
mea
 
	gWTF
 {

31 
	gIdtyExa
;

33 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
> 
ass
 
	gHashS
;

35 
	gme
<
tyme
 
	gVueArg
,ym
	gHashArg
 =ym
DeuHash
<
VueArg
>::
Hash
,

36 
tyme
 
	gTsArg
 = 
HashTs
<
VueArg
>> cs
	cHashS
 
f
 {

37 
WTF_MAKE_FAST_ALLOCATED
;

38 
	give
:

39 
HashArg
 
	tHashFunis
;

40 
TsArg
 
	tVueTs
;

42 
	gpublic
:

43 
tyme
 
	tVueTs
::
	tTTy
 
	tVueTy
;

45 
	give
:

46 
HashTab
<
	tVueTy
, VueTy, 
	tIdtyExa
,

47 
	tHashFunis
, 
	tVueTs
, VueTs> 
	tHashTabTy
;

49 
	gpublic
:

50 
HashTabCڡItAdr
<
	tHashTabTy
, 
	tVueTy
> 
	t
;

51 
	gHashTabCڡItAdr
<
	tHashTabTy
, 
	tVueTy
> 
	tcڡ_
;

52 
tyme
 
	tHashTabTy
::
	tAddResu
 AddResult;

54 
HashS
()

58 
HashS
(
d
::
liz_li
<
VueArg
> 
lizLi
)

60 cڡuto& 
vue
 : 
lizLi
)

61 
add
(
vue
);

64 
sw
(
HashS
&);

66 
size
() const;

67 
cy
() const;

68 
bo
 
isEmy
() const;

70 

 
beg
() const;

71 

 
d
() const;

73 

 
fd
(cڡ 
VueTy
&) const;

74 
bo
 
cڏs
(cڡ 
VueTy
&) const;

81 
	gme
<
tyme
 
	gHashTn
,ym
	gT
> 

 
fd
(cڡ 
T
&) const;

82 
	gme
<
tyme
 
	gHashTn
,ym
	gT
> 
bo
 
cڏs
(cڡ 
T
&) const;

86 
AddResu
 
add
(cڡ 
VueTy
&);

87 
AddResu
 
add
(
VueTy
&&);

95 
	gme
<
tyme
 
	gHashTn
,ym
	gT
> 
AddResu
 
add
(cڡ 
T
&);

99 
	gme
<
tyme
 
	gItTy
>

100 
bo
 
add
(
ItTy
 
beg
, ItTy 
d
);

102 
bo
 
move
(cڡ 
VueTy
&);

103 
bo
 
move
(

);

104 
r
();

106 
VueTy
 
ke
(const ValueType&);

107 
VueTy
 
ke
(

);

108 
VueTy
 
keAny
();

111 
	gme
<
tyme
 
	gV
 = 
VueTy
>ym
d
::
ab_if
<
IsSmtP
<
V
>::
vue
, 
	g
>::
ty
 
fd
ym
GPHr
<V>::
PTy
) const;

112 
	gme
<
tyme
 
	gV
 = 
VueTy
>ym
d
::
ab_if
<
IsSmtP
<
V
>::
vue
, 
	gbo
>::
ty
 
cڏs
ym
GPHr
<V>::
PTy
) const;

113 
	gme
<
tyme
 
	gV
 = 
VueTy
>ym
d
::
ab_if
<
IsSmtP
<
V
>::
vue
, 
	gbo
>::
ty
 
move
ym
GPHr
<V>::
PTy
);

114 
	gme
<
tyme
 
	gV
 = 
VueTy
>ym
d
::
ab_if
<
IsSmtP
<
V
>::
vue
, 
	gVueTy
>::
ty
 
ke
ym
GPHr
<V>::
PTy
);

116 
bo
 
isVidVue
(cڡ 
VueTy
&);

118 
bo
 
	gݔ
==(cڡ 
HashS
&) const;

120 
	give
:

121 
HashTabTy
 
m_im
;

124 
	sIdtyExa
 {

125 
	gme
<
tyme
 
	gT
> cڡ T& 
exa
(cڡ 
T
& 
t
{  
	gt
; }

128 
	gme
<
tyme
 
	gHashFunis
>

129 
	sHashSTn
 {

130 
	gme
<
tyme
 
	gT
> 
hash
(cڡ 
T
& 
key
{  
	gHashFunis
::hash(key); }

131 
	gme
<
tyme
 
	gT
,ym
	gU
> 
bo
 
equ
(cڡ 
T
& 
a
, cڡ 
U
& 
b
{  
	gHashFunis
::equal(a, b); }

132 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
> 
e
(
T
& 
loti
, 
U
&&, 
V
&& 
vue
{ 
	gloti
 = 
d
::
fwd
<V>(value); }

135 
	gme
<
tyme
 
	gTn
>

136 
	sHashSTnAdr
 {

137 
	gme
<
tyme
 
	gT
> 
hash
(cڡ 
T
& 
key
{  
	gTn
::hash(key); }

138 
	gme
<
tyme
 
	gT
,ym
	gU
> 
bo
 
equ
(cڡ 
T
& 
a
, cڡ 
U
& 
b
{  
	gTn
::equal(a, b); }

139 
	gme
<
tyme
 
	gT
,ym
	gU
> 
e
(
T
& 
loti
, cڡ 
U
& 
key
, cڡ U&, 
hashCode
)

141 
	gTn
::
e
(
loti
, 
key
, 
hashCode
);

145 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

146 
le
 
	gHashS
<
	gT
, 
	gU
, 
	gV
>::
	$sw
(
HashS
& 
h
)

148 
m_im
.
	`sw
(
h
.m_impl);

149 
	}
}

151 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

152 
le
 
	gHashS
<
	gT
, 
	gU
, 
	gV
>::
	$size
() const

154  
m_im
.
	`size
();

155 
	}
}

157 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

158 
le
 
	gHashS
<
	gT
, 
	gU
, 
	gV
>::
	$cy
() const

160  
m_im
.
	`cy
();

161 
	}
}

163 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

164 
le
 
bo
 
	gHashS
<
	gT
, 
	gU
, 
	gV
>::
	$isEmy
() const

166  
m_im
.
	`isEmy
();

167 
	}
}

169 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

170 
le
ut
	gHashS
<
	gT
, 
	gU
, 
	gV
>::
	$beg
(cڡ -> 



172  
m_im
.
	`beg
();

173 
	}
}

175 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

176 
le
ut
	gHashS
<
	gT
, 
	gU
, 
	gV
>::
	$d
(cڡ -> 



178  
m_im
.
	`d
();

179 
	}
}

181 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

182 
le
ut
	gHashS
<
	gT
, 
	gU
, 
	gV
>::
	$fd
(cڡ 
VueTy
& 
vue
cڡ -> 



184  
m_im
.
	`fd
(
vue
);

185 
	}
}

187 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

188 
le
 
bo
 
	gHashS
<
	gT
, 
	gU
, 
	gV
>::
	$cڏs
(cڡ 
VueTy
& 
vue
) const

190  
m_im
.
	`cڏs
(
vue
);

191 
	}
}

193 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

194 
	gme
<
tyme
 
	gHashTn
,ym
	gT
>

195 
le
ut
	gHashS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::
	$fd
(cڡ 
T
& 
vue
cڡ -> 



197  
m_im
.
me
 
fd
<
HashSTnAdr
<
HashTn
>>(
vue
);

198 
	}
}

200 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

201 
	gme
<
tyme
 
	gHashTn
,ym
	gT
>

202 
le
 
bo
 
	gHashS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::
	$cڏs
(cڡ 
T
& 
vue
) const

204  
m_im
.
me
 
cڏs
<
HashSTnAdr
<
HashTn
>>(
vue
);

205 
	}
}

207 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

208 
le
ut
	gHashS
<
	gT
, 
	gU
, 
	gV
>::
add
(cڡ 
VueTy
& 
vue
-> 
AddResu


210  
m_im
.
add
(
vue
);

213 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

214 
le
ut
	gHashS
<
	gT
, 
	gU
, 
	gV
>::
add
(
VueTy
&& 
vue
-> 
AddResu


216  
m_im
.
add
(
WTF
::
move
(
vue
));

219 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

220 
	gme
<
tyme
 
	gHashTn
,ym
	gT
>

221 
le
ut
	gHashS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::
add
(cڡ 
T
& 
vue
-> 
AddResu


223  
m_im
.
me
 
addPassgHashCode
<
HashSTnAdr
<
HashTn
>>(
vue
, 
	gvue
);

226 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

227 
	gme
<
tyme
 
	gItTy
>

228 
le
 
bo
 
	gHashS
<
	gT
, 
	gU
, 
	gV
>::
	$add
(
ItTy
 
beg
, ItTy 
d
)

230 
bo
 
chged
 = 
l
;

231 
ItTy
 

 = 
beg
; i!
d
; ++iter)

232 
chged
 |
	`add
(*

).
isNewEry
;

233  
chged
;

234 
	}
}

236 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

237 
le
 
bo
 
	gHashS
<
	gT
, 
	gU
, 
	gV
>::
	$move
(

 

)

239 i(

.
m_im
 =m_im.
	`d
())

240  
l
;

241 
m_im
.
	`CheckTabCsicy
();

242 
m_im
.
	`moveWhoutEryCsicyCheck
(

.m_impl);

243  
ue
;

244 
	}
}

246 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

247 
le
 
bo
 
	gHashS
<
	gT
, 
	gU
, 
	gV
>::
	$move
(cڡ 
VueTy
& 
vue
)

249  
	`move
(
	`fd
(
vue
));

250 
	}
}

252 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

253 
le
 
	gHashS
<
	gT
, 
	gU
, 
	gV
>::
	$r
()

255 
m_im
.
	`r
();

256 
	}
}

258 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

259 
le
ut
	gHashS
<
	gT
, 
	gU
, 
	gV
>::
ke
(

 

-> 
VueTy


261 i(

 =
d
())

262  
VueTs
::
emyVue
();

264 
VueTy
 
	gsu
 = 
WTF
::
move
(
cڡ_
<VueTy&>(*

));

265 
move
(

);

266  
	gsu
;

269 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

270 
le
ut
	gHashS
<
	gT
, 
	gU
, 
	gV
>::
ke
(cڡ 
VueTy
& 
vue
) -> ValueType

272  
ke
(
fd
(
vue
));

275 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

276 
le
ut
	gHashS
<
	gT
, 
	gU
, 
	gV
>::
keAny
(-> 
VueTy


278  
ke
(
beg
());

281 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

282 
	gme
<
tyme
 
	gV
>

283 
le
ut
	gHashS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::
fd
(
tyme
 
GPHr
<
V
>::
PTy
 
vue
cڡ ->ym
d
::
ab_if
<
IsSmtP
<V>::vue, 
	g
>::
ty


285  
m_im
.
me
 
fd
<
HashSTn
<
HashFunis
>>(
vue
);

288 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

289 
	gme
<
tyme
 
	gV
>

290 
le
ut
	gHashS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::
cڏs
(
tyme
 
GPHr
<
V
>::
PTy
 
vue
cڡ ->ym
d
::
ab_if
<
IsSmtP
<V>::vue, 
	gbo
>::
ty


292  
m_im
.
me
 
cڏs
<
HashSTn
<
HashFunis
>>(
vue
);

295 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

296 
	gme
<
tyme
 
	gV
>

297 
le
ut
	gHashS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::
move
(
tyme
 
GPHr
<
V
>::
PTy
 
vue
->ym
d
::
ab_if
<
IsSmtP
<V>::vue, 
	gbo
>::
ty


299  
move
(
fd
(
vue
));

302 
	gme
<
tyme
 
	gVue
,ym
	gHashFunis
,ym
	gTs
>

303 
	gme
<
tyme
 
	gV
>

304 
le
ut
	gHashS
<
	gVue
, 
	gHashFunis
, 
	gTs
>::
ke
(
tyme
 
GPHr
<
V
>::
PTy
 
vue
->ym
d
::
ab_if
<
IsSmtP
<V>::vue, 
	gVueTy
>::
ty


306  
ke
(
fd
(
vue
));

309 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

310 
le
 
bo
 
	gHashS
<
	gT
, 
	gU
, 
	gV
>::
	$isVidVue
(cڡ 
VueTy
& 
vue
)

312 i(
VueTs
::
	`isDedVue
(
vue
))

313  
l
;

315 i(
HashFunis
::
ToComToEmyOrDed
) {

316 i(
vue
 =
VueTs
::
	`emyVue
())

317  
l
;

319 i(
isHashTsEmyVue
<
VueTs
>(
vue
))

320  
l
;

323  
ue
;

324 
	}
}

326 
	gme
<
tyme
 
	gC
,ym
	gW
>

327 
le
 
	$cyToVe
(cڡ 
C
& 
ci
, 
W
& 
ve
)

329 
tyme
 
	tC
::
	tcڡ_
 
	t
;

331 
ve
.
	`size
(
ci
.
	`size
());

333 

 

 = 
ci
.
	`beg
();

334 

 
d
 = 
ci
.
	`d
();

335 
i
 = 0; 

 !
d
; ++it, ++i)

336 
ve
[
i
] = *

;

337 
	}
}

339 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
>

340 
le
 
bo
 
	gHashS
<
	gT
, 
	gU
, 
	gV
>::
ݔ
==(cڡ 
HashS
& 
h
) const

342 i(
size
(!
h
.size())

343  
l
;

344 
cڡ_
 
	g
 = 
beg
(); i!
d
(); ++iter) {

345 i(!
	gh
.
cڏs
(*

))

346  
	gl
;

348  
	gue
;

353 
usg
 
	gWTF
::
HashS
;

	@HashTable.cpp

20 
	~"cfig.h
"

21 
	~"HashTab.h
"

23 
	~"DaLog.h
"

24 
	~<mux
>

26 
mea
 
	gWTF
 {

28 #i
DUMP_HASHTABLE_STATS


30 
	gd
::
omic
<> 
HashTabSts
::
numAcss
;

31 
	gd
::
omic
<> 
HashTabSts
::
numRehashes
;

32 
	gd
::
omic
<> 
HashTabSts
::
numRemoves
;

33 
	gd
::
omic
<> 
HashTabSts
::
numRes
;

35 
	gHashTabSts
::
numClisis
;

36 
	gHashTabSts
::
clisiGph
[4096];

37 
	gHashTabSts
::
maxClisis
;

39 
	gd
::
mux
& 
hashTabStsMux
()

41 
d
::
_ag
 
Fg
;

42 
	gd
::
mux
* mutex;

43 
	gd
::
_
(
Fg
, []{

44 
mux
 = 
d
::
make_unique
<d::mux>().
a
();

47  *
	gmux
;

50 
	gHashTabSts
::
cdClisiAtCou
(
cou
)

52 
d
::
lock_gud
<d::
mux
> 
lock
(
hashTabStsMux
());

54 i(
	gcou
 > 
	gmaxClisis
)

55 
	gmaxClisis
 = 
cou
;

56 
	gnumClisis
++;

57 
	gclisiGph
[
cou
]++;

60 
	gHashTabSts
::
dumpSts
()

62 
d
::
lock_gud
<d::
mux
> 
lock
(
hashTabStsMux
());

64 
daLogF
("\nWTF::HashTable statistics\n\n");

65 
daLogF
("%ucss\n", 
numAcss
.
ld
());

66 
daLogF
("%dٮ clisis,vag%.2obeacss\n", 
numClisis
, 1.0 * (
numAcss
 +umCollisions) /umAccesses);

67 
daLogF
("lge clisi cha: %d\n", 
maxClisis
);

68 
	gi
 = 1; i <
maxClisis
; i++) {

69 
daLogF
(" %uookupwhxaly %u clisiڠ(%.2f%% , %.2f%% whhimy ome)\n", 
clisiGph
[
i
], i, 100.0 * (clisiGph[i] - clisiGph[i+1]/ 
numAcss
, 100.0 * collisionGraph[i] /umAccesses);

71 
daLogF
("%dehashes\n", 
numRehashes
.
ld
());

72 
daLogF
("%des\n", 
numRes
.
ld
());

	@HashTable.h

22 #ide
WTF_HashTab_h


23 
	#WTF_HashTab_h


	)

25 
	~<omic
>

26 
	~<mux
>

27 
	~<rg.h
>

28 
	~<ty_as
>

29 
	~<uty
>

30 
	~<wtf/Asis.h
>

31 
	~<wtf/FaMloc.h
>

32 
	~<wtf/HashTs.h
>

33 
	~<wtf/StdLibExas.h
>

34 
	~<wtf/VueCheck.h
>

36 
	#DUMP_HASHTABLE_STATS
 0

	)

37 
	#DUMP_HASHTABLE_STATS_PER_TABLE
 0

	)

39 #i
DUMP_HASHTABLE_STATS_PER_TABLE


40 
	~<wtf/DaLog.h
>

43 
mea
 
	gWTF
 {

46 
	#CHECK_HASHTABLE_CONSISTENCY
 0

	)

48 #ifde
NDEBUG


49 
	#CHECK_HASHTABLE_ITERATORS
 0

	)

50 
	#CHECK_HASHTABLE_USE_AFTER_DESTRUCTION
 0

	)

52 
	#CHECK_HASHTABLE_ITERATORS
 1

	)

53 
	#CHECK_HASHTABLE_USE_AFTER_DESTRUCTION
 1

	)

56 #i
DUMP_HASHTABLE_STATS


58 
	sHashTabSts
 {

60 
WTF_EXPORTDATA
 
	gd
::
omic
<> 
numAcss
;

61 
WTF_EXPORTDATA
 
	gd
::
omic
<> 
numRehashes
;

62 
WTF_EXPORTDATA
 
	gd
::
omic
<> 
numRemoves
;

63 
WTF_EXPORTDATA
 
	gd
::
omic
<> 
numRes
;

66 
WTF_EXPORTDATA
 
	gmaxClisis
;

67 
WTF_EXPORTDATA
 
	gnumClisis
;

68 
WTF_EXPORTDATA
 
	gclisiGph
[4096];

70 
WTF_EXPORT_PRIVATE
 
cdClisiAtCou
(
cou
);

71 
WTF_EXPORT_PRIVATE
 
dumpSts
();

76 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

77 
ass
 
	gHashTab
;

78 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

79 
ass
 
	gHashTabIt
;

80 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

81 
ass
 
	gHashTabCڡIt
;

83 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

84 
addIt
(cڡ 
HashTab
<
Key
, 
Vue
, 
Exa
, 
HashFunis
, 
Ts
, 
KeyTs
>*,

85 
HashTabCڡIt
<
Key
, 
Vue
, 
Exa
, 
HashFunis
, 
Ts
, 
KeyTs
>*);

87 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

88 
moveIt
(
HashTabCڡIt
<
Key
, 
Vue
, 
Exa
, 
HashFunis
, 
Ts
, 
KeyTs
>*);

90 #i!
CHECK_HASHTABLE_ITERATORS


92 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

93 
le
 
addIt
(cڡ 
HashTab
<
Key
, 
Vue
, 
Exa
, 
HashFunis
, 
Ts
, 
KeyTs
>*,

94 
HashTabCڡIt
<
Key
, 
Vue
, 
Exa
, 
HashFunis
, 
Ts
, 
KeyTs
>*) { }

96 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

97 
le
 
moveIt
(
HashTabCڡIt
<
Key
, 
Vue
, 
Exa
, 
HashFunis
, 
Ts
, 
KeyTs
>*) { }

101 um { 
	gHashImKnownGood
 } 
	tHashImKnownGoodTag
;

103 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

104 as
	cHashTabCڡIt
 {

105 
	give
:

106 
HashTab
<
	tKey
, 
	tVue
, 
	tExa
, 
	tHashFunis
, 
	tTs
, 
	tKeyTs
> 
	tHashTabTy
;

107 
	gHashTabIt
<
	tKey
, 
	tVue
, 
	tExa
, 
	tHashFunis
, 
	tTs
, 
	tKeyTs
> 
	t
;

108 
	gHashTabCڡIt
<
	tKey
, 
	tVue
, 
	tExa
, 
	tHashFunis
, 
	tTs
, 
	tKeyTs
> 
	tcڡ_
;

109 
Vue
 
	tVueTy
;

110 cڡ 
	tVueTy
& 
	tRenTy
;

111 cڡ 
	tVueTy
* 
	tPorTy
;

113 
nd
 
ass
 
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>;

114 
nd
 
ass
 
	gHashTabIt
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>;

116 
skEmyBucks
()

118 
	gm_posi
 !
m_dPosi
 && 
HashTabTy
::
isEmyOrDedBuck
(*
m_posi
))

119 ++
m_posi
;

122 
HashTabCڡIt
(cڡ 
HashTabTy
* 
b
, 
PorTy
 
posi
, PorTy 
dPosi
)

123 : 
m_posi
(
posi
), 
m_dPosi
(
dPosi
)

125 
addIt
(
b
, 
this
);

126 
skEmyBucks
();

129 
HashTabCڡIt
(cڡ 
HashTabTy
* 
b
, 
PorTy
 
posi
, PorTy 
dPosi
, 
HashImKnownGoodTag
)

130 : 
m_posi
(
posi
), 
m_dPosi
(
dPosi
)

132 
addIt
(
b
, 
this
);

135 
	gpublic
:

136 
HashTabCڡIt
()

138 
addIt
(
ic_
<cڡ 
HashTabTy
*>(0), 
this
);

143 #i
CHECK_HASHTABLE_ITERATORS


144 ~
HashTabCڡIt
()

146 
moveIt
(
this
);

149 
HashTabCڡIt
(cڡ 
cڡ_
& 
h
)

150 : 
m_posi
(
h
.m_posi), 
m_dPosi
(other.m_endPosition)

152 
addIt
(
h
.
m_b
, 
this
);

155 
	gcڡ_
& 
	gݔ
=(cڡ 
cڡ_
& 
h
)

157 
m_posi
 = 
h
.m_position;

158 
	gm_dPosi
 = 
h
.
m_dPosi
;

160 
moveIt
(
this
);

161 
addIt
(
h
.
m_b
, 
this
);

163  *
	gthis
;

167 
PorTy
 
g
() const

169 
checkVidy
();

170  
	gm_posi
;

172 
RenTy
 
	gݔ
*(cڡ {  *
g
(); }

173 
PorTy
 
	gݔ
->(cڡ {  
g
(); }

175 
	gcڡ_
& 
	gݔ
++()

177 
checkVidy
();

178 
ASSERT
(
m_posi
 !
m_dPosi
);

179 ++
	gm_posi
;

180 
skEmyBucks
();

181  *
	gthis
;

187 
bo
 
	gݔ
==(cڡ 
cڡ_
& 
h
) const

189 
checkVidy
(
h
);

190  
	gm_posi
 =
h
.
m_posi
;

192 
bo
 
	gݔ
!=(cڡ 
cڡ_
& 
h
) const

194 
checkVidy
(
h
);

195  
	gm_posi
 !
h
.
m_posi
;

197 
bo
 
	gݔ
==(cڡ 

& 
h
) const

199  *
this
 =
ic_
<
cڡ_
>(
h
);

201 
bo
 
	gݔ
!=(cڡ 

& 
h
) const

203  *
this
 !
ic_
<
cڡ_
>(
h
);

206 
	give
:

207 
checkVidy
() const

209 #i
CHECK_HASHTABLE_ITERATORS


210 
ASSERT
(
m_b
);

215 #i
CHECK_HASHTABLE_ITERATORS


216 
checkVidy
(cڡ 
cڡ_
& 
h
) const

218 
ASSERT
(
m_b
);

219 
ASSERT_UNUSED
(
h
, oth.
m_b
);

220 
ASSERT
(
m_b
 =
h
.m_table);

223 
checkVidy
(cڡ 
cڡ_
&) const { }

226 
PorTy
 
	gm_posi
;

227 
PorTy
 
	gm_dPosi
;

229 #i
CHECK_HASHTABLE_ITERATORS


230 
	gpublic
:

233 
mub
 cڡ 
HashTabTy
* 
m_b
;

234 
mub
 
cڡ_
* 
	gm_xt
;

235 
mub
 
cڡ_
* 
	gm_evious
;

239 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

240 as
	cHashTabIt
 {

241 
	give
:

242 
HashTab
<
	tKey
, 
	tVue
, 
	tExa
, 
	tHashFunis
, 
	tTs
, 
	tKeyTs
> 
	tHashTabTy
;

243 
	gHashTabIt
<
	tKey
, 
	tVue
, 
	tExa
, 
	tHashFunis
, 
	tTs
, 
	tKeyTs
> 
	t
;

244 
	gHashTabCڡIt
<
	tKey
, 
	tVue
, 
	tExa
, 
	tHashFunis
, 
	tTs
, 
	tKeyTs
> 
	tcڡ_
;

245 
Vue
 
	tVueTy
;

246 
	gVueTy
& 
	tRenTy
;

247 
VueTy
* 
	tPorTy
;

249 
nd
 
ass
 
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>;

251 
HashTabIt
(
HashTabTy
* 
b
, 
PorTy
 
pos
, PorTy 
d
: 
m_
(table,os,nd) { }

252 
HashTabIt
(
HashTabTy
* 
b
, 
PorTy
 
pos
, PorTy 
d
, 
HashImKnownGoodTag
 
g
: 
m_
(table,os,nd,ag) { }

254 
	gpublic
:

255 
HashTabIt
() { }

259 
PorTy
 
g
(cڡ {  
cڡ_
<PorTy>(
m_
.get()); }

260 
RenTy
 
	gݔ
*(cڡ {  *
g
(); }

261 
PorTy
 
	gݔ
->(cڡ {  
g
(); }

263 
	g
& 
	gݔ
++({ ++
	gm_
;  *
	gthis
; }

268 
bo
 
	gݔ
==(cڡ 

& 
h
cڡ {  
m_
 == other.m_iterator; }

269 
bo
 
	gݔ
!=(cڡ 

& 
h
cڡ {  
m_
 != other.m_iterator; }

270 
bo
 
	gݔ
==(cڡ 
cڡ_
& 
h
cڡ {  
m_
 == other; }

271 
bo
 
	gݔ
!=(cڡ 
cڡ_
& 
h
cڡ {  
m_
 != other; }

273 
ݔ
 
cڡ_
(cڡ {  
	gm_
; }

275 
	give
:

276 
cڡ_
 
m_
;

279 
	gme
<
tyme
 
	gHashFunis
> cs
	cIdtyHashTn
 {

280 
	gpublic
:

281 
me
<
tyme
 
T
> 
hash
(cڡ T& 
key
{  
HashFunis
::hash(key); }

282 
	gme
<
tyme
 
	gT
,ym
	gU
> 
bo
 
equ
(cڡ 
T
& 
a
, cڡ 
U
& 
b
{  
	gHashFunis
::equal(a, b); }

283 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
> 
e
(
T
& 
loti
, cڡ 
U
&, 
V
&& 
vue
{ 
	gloti
 = 
d
::
fwd
<V>(value); }

286 
	gme
<
tyme
 
	gItTy
> 
	sHashTabAddResu
 {

287 
HashTabAddResu
(
ItTy
 

, 
bo
 
isNewEry
: 

(iter), isNewEntry(isNewEntry) { }

288 
ItTy
 
	g
;

289 
bo
 
	gisNewEry
;

292 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

293 as
	cHashTab
 {

294 
	gpublic
:

295 
HashTabIt
<
	tKey
, 
	tVue
, 
	tExa
, 
	tHashFunis
, 
	tTs
, 
	tKeyTs
> 
	t
;

296 
	gHashTabCڡIt
<
	tKey
, 
	tVue
, 
	tExa
, 
	tHashFunis
, 
	tTs
, 
	tKeyTs
> 
	tcڡ_
;

297 
Ts
 
	tVueTs
;

298 
Key
 
	tKeyTy
;

299 
Vue
 
	tVueTy
;

300 
	gIdtyHashTn
<
	tHashFunis
> 
	tIdtyTnTy
;

301 
	gHashTabAddResu
<
	t
> 
	tAddResu
;

303 #i
DUMP_HASHTABLE_STATS_PER_TABLE


304 
	sSts
 {

305 
Sts
()

306 : 
numAcss
(0)

307 , 
numRehashes
(0)

308 , 
numRemoves
(0)

309 , 
numRes
(0)

310 , 
maxClisis
(0)

311 , 
numClisis
(0)

312 , 
clisiGph
()

316 
	gnumAcss
;

317 
	gnumRehashes
;

318 
	gnumRemoves
;

319 
	gnumRes
;

321 
	gmaxClisis
;

322 
	gnumClisis
;

323 
	gclisiGph
[4096];

325 
cdClisiAtCou
(
cou
)

327 i(
	gcou
 > 
	gmaxClisis
)

328 
	gmaxClisis
 = 
cou
;

329 
	gnumClisis
++;

330 
	gclisiGph
[
cou
]++;

333 
dumpSts
()

335 
daLogF
("\nWTF::HashTable::Stats dump\n\n");

336 
daLogF
("%dcss\n", 
numAcss
);

337 
daLogF
("%dٮ clisis,vag%.2obeacss\n", 
numClisis
, 1.0 * (
numAcss
 +umCollisions) /umAccesses);

338 
daLogF
("lge clisi cha: %d\n", 
maxClisis
);

339 
	gi
 = 1; i <
maxClisis
; i++) {

340 
daLogF
(" %dookupwhxaly %d clisiڠ(%.2f%% , %.2f%% whhimy ome)\n", 
clisiGph
[
i
], i, 100.0 * (clisiGph[i] - clisiGph[i+1]/ 
numAcss
, 100.0 * collisionGraph[i] /umAccesses);

342 
daLogF
("%dehashes\n", 
numRehashes
);

343 
daLogF
("%des\n", 
numRes
);

348 
HashTab
();

349 ~
HashTab
()

351 
videIts
();

352 i(
	gm_b
)

353 
doTab
(
m_b
, 
m_bSize
);

354 #i
CHECK_HASHTABLE_USE_AFTER_DESTRUCTION


355 
	gm_b
 = (
VueTy
*)(
u_t
)0xbbadbeef;

359 
HashTab
(const HashTable&);

360 
sw
(
HashTab
&);

361 
	gHashTab
& 
	gݔ
=(cڡ 
HashTab
&);

363 
HashTab
(HashTable&&);

364 
	gHashTab
& 
	gݔ
=(
HashTab
&&);

369 

 
beg
({  
isEmy
(? 
d
(: 
makeIt
(
m_b
); }

370 

 
d
({  
makeKnownGoodIt
(
m_b
 + 
m_bSize
); }

371 
cڡ_
 
beg
(cڡ {  
isEmy
(? 
d
(: 
makeCڡIt
(
m_b
); }

372 
cڡ_
 
d
(cڡ {  
makeKnownGoodCڡIt
(
m_b
 + 
m_bSize
); }

374 
size
(cڡ {  
	gm_keyCou
; }

375 
cy
(cڡ {  
	gm_bSize
; }

376 
bo
 
isEmy
(cڡ {  !
	gm_keyCou
; }

378 
AddResu
 
add
(cڡ 
VueTy
& 
vue
{  
	gadd
<
	gIdtyTnTy
>(
	gExa
::
exa
(vue), 
	gvue
); }

379 
AddResu
 
add
(
VueTy
&& 
vue
{  
	gadd
<
	gIdtyTnTy
>(
	gExa
::
exa
(vue), 
	gWTF
::
move
(value)); }

384 
	gme
<
tyme
 
	gHashTn
,ym
	gT
,ym
	gExa
> 
AddResu
 
add
(
T
&& 
key
, 
Exa
&&);

385 
	gme
<
tyme
 
	gHashTn
,ym
	gT
,ym
	gExa
> 
AddResu
 
addPassgHashCode
(
T
&& 
key
, 
Exa
&&);

387 

 
fd
(cڡ 
KeyTy
& 
key
{  
	gfd
<
	gIdtyTnTy
>(
	gkey
); }

388 
cڡ_
 
fd
(cڡ 
KeyTy
& 
key
cڡ {  
	gfd
<
	gIdtyTnTy
>(
	gkey
); }

389 
bo
 
cڏs
(cڡ 
KeyTy
& 
key
cڡ {  
	gcڏs
<
	gIdtyTnTy
>(
	gkey
); }

391 
	gme
<
tyme
 
	gHashTn
,ym
	gT
> 

 
fd
(cڡ 
T
&);

392 
	gme
<
tyme
 
	gHashTn
,ym
	gT
> 
cڡ_
 
fd
(cڡ 
T
&) const;

393 
	gme
<
tyme
 
	gHashTn
,ym
	gT
> 
bo
 
cڏs
(cڡ 
T
&) const;

395 
move
(cڡ 
KeyTy
&);

396 
move
(

);

397 
moveWhoutEryCsicyCheck
(

);

398 
moveWhoutEryCsicyCheck
(
cڡ_
);

399 
	gme
<
tyme
 
	gFun
>

400 
moveIf
(cڡ 
Fun
&);

401 
r
();

403 
bo
 
isEmyBuck
(cڡ 
VueTy
& 
vue
{  
	gisHashTsEmyVue
<
	gKeyTs
>(
	gExa
::
exa
(value)); }

404 
bo
 
isDedBuck
(cڡ 
VueTy
& 
vue
{  
	gKeyTs
::
isDedVue
(
Exa
::
exa
(value)); }

405 
bo
 
isEmyOrDedBuck
(cڡ 
VueTy
& 
vue
{  
isEmyBuck
(vue|| 
isDedBuck
(value); }

407 
VueTy
* 
lookup
(cڡ 
Key
& 
key
{  
	glookup
<
	gIdtyTnTy
>(
	gkey
); }

408 
	gme
<
tyme
 
	gHashTn
,ym
	gT
> 
VueTy
* 
lookup
(cڡ 
T
&);

410 #i!
ASSERT_DISABLED


411 
checkTabCsicy
() const;

413 
checkTabCsicy
() { }

415 #i
CHECK_HASHTABLE_CONSISTENCY


416 
CheckTabCsicy
(cڡ { 
checkTabCsicy
(); }

417 
CheckTabCsicyExSize
(cڡ { 
checkTabCsicyExSize
(); }

419 
CheckTabCsicyExSize
() { }

420 
CheckTabCsicy
() { }

423 
	give
:

424 
VueTy
* 
loTab
(
size
);

425 
doTab
(
VueTy
* 
b
, 
size
);

427 
	gd
::
	t
<
	tVueTy
*, 
	tbo
> 
	tLookupTy
;

428 
	gd
::
	t
<
	tLookupTy
, > 
	tFuLookupTy
;

430 
LookupTy
 
lookupFWrg
(cڡ 
Key
& 
key
{  
	glookupFWrg
<
	gIdtyTnTy
>(
	gkey
); };

431 
	gme
<
tyme
 
	gHashTn
,ym
	gT
> 
FuLookupTy
 
fuLookupFWrg
(cڡ 
T
&);

432 
	gme
<
tyme
 
	gHashTn
,ym
	gT
> 
LookupTy
 
lookupFWrg
(cڡ 
T
&);

434 
	gme
<
tyme
 
	gHashTn
,ym
	gT
> 
checkKey
(cڡ 
T
&);

436 
moveAndInvideWhoutEryCsicyCheck
(
VueTy
*);

437 
moveAndInvide
(
VueTy
*);

438 
move
(
VueTy
*);

440 
bo
 
shouldExnd
(cڡ {  (
	gm_keyCou
 + 
	gm_dedCou
* 
	gm_maxLd
 >
m_bSize
; }

441 
bo
 
muRehashInP
(cڡ {  
m_keyCou
 * 
	gm_mLd
 < 
	gm_bSize
 * 2; }

442 
bo
 
shouldShrk
(cڡ {  
m_keyCou
 * 
	gm_mLd
 < 
	gm_bSize
 && m_bSiz> 
	gKeyTs
::
mimumTabSize
; }

443 
VueTy
* 
exnd
(VueTy* 
y
 = 
nuαr
);

444 
shrk
({ 
hash
(
m_bSize
 / 2, 
nuαr
); }

446 
VueTy
* 
hash
(
wTabSize
, VueTy* 
y
);

447 
VueTy
* 

(ValueType&&);

449 
lizeBuck
(
VueTy
& 
buck
);

450 
deBuck
(
VueTy
& 
buck
{ 
	gbuck
.~VueTy(); 
	gTs
::
cڡruDedVue
(bucket); }

452 
FuLookupTy
 
makeLookupResu
(
VueTy
* 
posi
, 
bo
 
found
, 
hash
)

453 {  
FuLookupTy
(
LookupTy
(
posi
, 
found
), 
hash
); }

455 

 
makeIt
(
VueTy
* 
pos
{  it(
this
,os, 
m_b
 + 
m_bSize
); }

456 
cڡ_
 
makeCڡIt
(
VueTy
* 
pos
cڡ {  cڡ_(
this
,os, 
m_b
 + 
m_bSize
); }

457 

 
makeKnownGoodIt
(
VueTy
* 
pos
{  it(
this
,os, 
m_b
 + 
m_bSize
, 
HashImKnownGood
); }

458 
cڡ_
 
makeKnownGoodCڡIt
(
VueTy
* 
pos
cڡ {  cڡ_(
this
,os, 
m_b
 + 
m_bSize
, 
HashImKnownGood
); }

460 #i!
ASSERT_DISABLED


461 
checkTabCsicyExSize
() const;

463 
checkTabCsicyExSize
() { }

466 #i
CHECK_HASHTABLE_ITERATORS


467 
videIts
();

469 
videIts
() { }

472 cڡ 
	gm_maxLd
 = 2;

473 cڡ 
	gm_mLd
 = 6;

475 
VueTy
* 
	gm_b
;

476 
	gm_bSize
;

477 
	gm_bSizeMask
;

478 
	gm_keyCou
;

479 
	gm_dedCou
;

481 #i
CHECK_HASHTABLE_ITERATORS


482 
	gpublic
:

484 
mub
 
cڡ_
* 
m_s
;

486 
mub
 
	gd
::
unique_r
<
d
::
mux
> 
m_mux
;

489 #i
DUMP_HASHTABLE_STATS_PER_TABLE


490 
	gpublic
:

491 
mub
 
d
::
unique_r
<
Sts
> 
m_s
;

496 
	gme
<
	gsize
> 
	gOifyLowBs
;

497 
	gme
<>

498 
	gOifyLowBs
<0> {

499 cڡ 
	gvue
 = 0;

501 
	gme
<
	gnumb
>

502 
	sOifyLowBs
 {

503 cڡ 
	gvue
 = 
numb
 | 
OifyLowBs
<umb >> 1)>::
vue
;

506 
	gme
<
	gnumb
>

507 
	sUPowOfTwoBound
 {

508 cڡ 
	gvue
 = (
OifyLowBs
<
numb
 - 1>::
vue
 + 1) * 2;

513 
	gme
<
	gsize
, 
bo
 
	gisPowOfTwo
> 
	gHashTabCacyFSizeSr
;

514 
	gme
<
	gsize
>

515 
	gHashTabCacyFSizeSr
<
	gsize
, 
	gue
> {

516 cڡ 
	gvue
 = 
size
 * 4;

518 
	gme
<
	gsize
>

519 
	gHashTabCacyFSizeSr
<
	gsize
, 
	gl
> {

520 cڡ 
	gvue
 = 
UPowOfTwoBound
<
size
>::
vue
;

525 
	gme
<
	gsize
>

526 
	sHashTabCacyFSize
 {

527 cڡ 
	gvue
 = 
HashTabCacyFSizeSr
<
size
, !(
	gsize
 & (siz- 1))>::
vue
;

528 
COMPILE_ASSERT
(
size
 > 0, 
HashTabNZoMimumCacy
);

529 
COMPILE_ASSERT
(!
ic_
<>(
vue
 >> 31), 
HashTabNoCacyOvow
);

530 
COMPILE_ASSERT
(
vue
 > (2 * 
size
), 
HashTabCacyHdsCڋSize
);

533 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

534 
le
 
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
	$HashTab
()

535 : 
	`m_b
(0)

536 , 
	`m_bSize
(0)

537 , 
	`m_bSizeMask
(0)

538 , 
	`m_keyCou
(0)

539 , 
	$m_dedCou
(0)

540 #i
CHECK_HASHTABLE_ITERATORS


541 , 
	`m_s
(0)

542 , 
	`m_mux
(
d
::
make_unique
<d::
mux
>())

544 #i
DUMP_HASHTABLE_STATS_PER_TABLE


545 , 
	`m_s
(
d
::
make_unique
<
Sts
>())

548 
	}
}

550 
le
 
	$doubHash
(
key
)

552 
key
 = ~key + (key >> 23);

553 
key
 ^= (key << 12);

554 
key
 ^= (key >> 7);

555 
key
 ^= (key << 2);

556 
key
 ^= (key >> 20);

557  
key
;

558 
	}
}

560 #i
ASSERT_DISABLED


562 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

563 
	gme
<
tyme
 
	gHashTn
,ym
	gT
>

564 
le
 
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
	$checkKey
(cڡ 
T
&)

566 
	}
}

570 
me
<
tyme
 
Key
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

571 
	gme
<
tyme
 
	gHashTn
,ym
	gT
>

572 
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
	$checkKey
(cڡ 
T
& 
key
)

574 i(!
HashFunis
::
ToComToEmyOrDed
)

576 
	`ASSERT
(!
HashTn
::
	`equ
(
KeyTs
::
	`emyVue
(), 
key
));

577 
tyme
 
d
::
igd_age
<(
VueTy
), std::
ignmt_of
<VueTy>::
vue
>::
ty
 
dedVueBufr
;

578 
VueTy
* 
dedVueP
 = 
t__r
<VueTy*>(&
dedVueBufr
);

579 
VueTy
& 
dedVue
 = *
dedVueP
;

580 
Ts
::
	`cڡruDedVue
(
dedVue
);

581 
	`ASSERT
(!
HashTn
::
	`equ
(
Exa
::
	`exa
(
dedVue
), 
key
));

582 
	}
}

586 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

587 
	gme
<
tyme
 
	gHashTn
,ym
	gT
>

588 
le
ut
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
lookup
(cڡ 
T
& 
key
-> 
VueTy
*

590 
checkKey
<
HashTn
>(
key
);

592 
	gk
 = 0;

593 
	gsizeMask
 = 
m_bSizeMask
;

594 
VueTy
* 
	gb
 = 
m_b
;

595 
	gh
 = 
HashTn
::
hash
(
key
);

596 
	gi
 = 
h
 & 
sizeMask
;

598 i(!
	gb
)

601 #i
DUMP_HASHTABLE_STATS


602 ++
	gHashTabSts
::
numAcss
;

603 
	gobeCou
 = 0;

606 #i
DUMP_HASHTABLE_STATS_PER_TABLE


607 ++
	gm_s
->
	gnumAcss
;

611 
VueTy
* 
	gy
 = 
b
 + 
i
;

614 i(
	gHashFunis
::
ToComToEmyOrDed
) {

615 i(
HashTn
::
equ
(
Exa
::
exa
(*
y
), 
key
))

616  
	gy
;

618 i(
isEmyBuck
(*
y
))

621 i(
isEmyBuck
(*
y
))

624 i(!
isDedBuck
(*
y
&& 
	gHashTn
::
equ
(
Exa
::
exa
(*y), 
key
))

625  
	gy
;

627 #i
DUMP_HASHTABLE_STATS


628 ++
	gobeCou
;

629 
	gHashTabSts
::
cdClisiAtCou
(
obeCou
);

632 #i
DUMP_HASHTABLE_STATS_PER_TABLE


633 
	gm_s
->
cdClisiAtCou
(
obeCou
);

636 i(
	gk
 == 0)

637 
k
 = 1 | 
doubHash
(
h
);

638 
	gi
 = (
i
 + 
k
& 
sizeMask
;

642 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

643 
	gme
<
tyme
 
	gHashTn
,ym
	gT
>

644 
le
ut
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
lookupFWrg
(cڡ 
T
& 
key
-> 
LookupTy


646 
ASSERT
(
m_b
);

647 
	gcheckKey
<
	gHashTn
>(
	gkey
);

649 
	gk
 = 0;

650 
VueTy
* 
	gb
 = 
m_b
;

651 
	gsizeMask
 = 
m_bSizeMask
;

652 
	gh
 = 
HashTn
::
hash
(
key
);

653 
	gi
 = 
h
 & 
sizeMask
;

655 #i
DUMP_HASHTABLE_STATS


656 ++
	gHashTabSts
::
numAcss
;

657 
	gobeCou
 = 0;

660 #i
DUMP_HASHTABLE_STATS_PER_TABLE


661 ++
	gm_s
->
	gnumAcss
;

664 
VueTy
* 
	gdedEry
 = 0;

667 
VueTy
* 
	gy
 = 
b
 + 
i
;

670 i(
	gHashFunis
::
ToComToEmyOrDed
) {

671 i(
isEmyBuck
(*
y
))

672  
LookupTy
(
dedEry
 ? dedEry : 
y
, 
l
);

674 i(
	gHashTn
::
equ
(
Exa
::
exa
(*
y
), 
key
))

675  
LookupTy
(
y
, 
ue
);

677 i(
isDedBuck
(*
y
))

678 
	gdedEry
 = 
y
;

680 i(
isEmyBuck
(*
y
))

681  
LookupTy
(
dedEry
 ? dedEry : 
y
, 
l
);

683 i(
isDedBuck
(*
y
))

684 
	gdedEry
 = 
y
;

685 i(
	gHashTn
::
equ
(
Exa
::
exa
(*
y
), 
key
))

686  
LookupTy
(
y
, 
ue
);

688 #i
DUMP_HASHTABLE_STATS


689 ++
	gobeCou
;

690 
	gHashTabSts
::
cdClisiAtCou
(
obeCou
);

693 #i
DUMP_HASHTABLE_STATS_PER_TABLE


694 
	gm_s
->
cdClisiAtCou
(
obeCou
);

697 i(
	gk
 == 0)

698 
k
 = 1 | 
doubHash
(
h
);

699 
	gi
 = (
i
 + 
k
& 
sizeMask
;

703 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

704 
	gme
<
tyme
 
	gHashTn
,ym
	gT
>

705 
le
ut
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
fuLookupFWrg
(cڡ 
T
& 
key
-> 
FuLookupTy


707 
ASSERT
(
m_b
);

708 
	gcheckKey
<
	gHashTn
>(
	gkey
);

710 
	gk
 = 0;

711 
VueTy
* 
	gb
 = 
m_b
;

712 
	gsizeMask
 = 
m_bSizeMask
;

713 
	gh
 = 
HashTn
::
hash
(
key
);

714 
	gi
 = 
h
 & 
sizeMask
;

716 #i
DUMP_HASHTABLE_STATS


717 ++
	gHashTabSts
::
numAcss
;

718 
	gobeCou
 = 0;

721 #i
DUMP_HASHTABLE_STATS_PER_TABLE


722 ++
	gm_s
->
	gnumAcss
;

725 
VueTy
* 
	gdedEry
 = 0;

728 
VueTy
* 
	gy
 = 
b
 + 
i
;

731 i(
	gHashFunis
::
ToComToEmyOrDed
) {

732 i(
isEmyBuck
(*
y
))

733  
makeLookupResu
(
dedEry
 ? dedEry : 
y
, 
l
, 
h
);

735 i(
	gHashTn
::
equ
(
Exa
::
exa
(*
y
), 
key
))

736  
makeLookupResu
(
y
, 
ue
, 
h
);

738 i(
isDedBuck
(*
y
))

739 
	gdedEry
 = 
y
;

741 i(
isEmyBuck
(*
y
))

742  
makeLookupResu
(
dedEry
 ? dedEry : 
y
, 
l
, 
h
);

744 i(
isDedBuck
(*
y
))

745 
	gdedEry
 = 
y
;

746 i(
	gHashTn
::
equ
(
Exa
::
exa
(*
y
), 
key
))

747  
makeLookupResu
(
y
, 
ue
, 
h
);

749 #i
DUMP_HASHTABLE_STATS


750 ++
	gobeCou
;

751 
	gHashTabSts
::
cdClisiAtCou
(
obeCou
);

754 #i
DUMP_HASHTABLE_STATS_PER_TABLE


755 
	gm_s
->
cdClisiAtCou
(
obeCou
);

758 i(
	gk
 == 0)

759 
k
 = 1 | 
doubHash
(
h
);

760 
	gi
 = (
i
 + 
k
& 
sizeMask
;

764 
	gme
<
bo
 
	gemyVueIsZo
> 
	gHashTabBuckInliz
;

766 
	gme
<> 
	gHashTabBuckInliz
<
	gl
> {

767 
	gme
<
tyme
 
	gTs
,ym
	gVue
> 
lize
(
Vue
& 
buck
)

769 
w
 (
NNu
, &
buck

Vue
(
Ts
::
emyVue
());

773 
	gme
<> 
	gHashTabBuckInliz
<
	gue
> {

774 
	gme
<
tyme
 
	gTs
,ym
	gVue
> 
lize
(
Vue
& 
buck
)

779 
memt
(&
buck
, 0, (bucket));

783 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

784 
le
 
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
	$lizeBuck
(
VueTy
& 
buck
)

786 
HashTabBuckInliz
<
Ts
::
emyVueIsZo
>::
me
 
lize
<Ts>(
buck
);

787 
	}
}

789 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

790 
	gme
<
tyme
 
	gHashTn
,ym
	gT
,ym
	gExa
>

791 
ALWAYS_INLINE
ut
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
add
(
T
&& 
key
, 
Exa
&& 
exa
-> 
	gAddResu


793 
	gcheckKey
<
	gHashTn
>(
	gkey
);

795 
videIts
();

797 i(!
	gm_b
)

798 
exnd
(
nuαr
);

800 
CheckTabCsicy
();

802 
ASSERT
(
m_b
);

804 
	gk
 = 0;

805 
VueTy
* 
	gb
 = 
m_b
;

806 
	gsizeMask
 = 
m_bSizeMask
;

807 
	gh
 = 
HashTn
::
hash
(
key
);

808 
	gi
 = 
h
 & 
sizeMask
;

810 #i
DUMP_HASHTABLE_STATS


811 ++
	gHashTabSts
::
numAcss
;

812 
	gobeCou
 = 0;

815 #i
DUMP_HASHTABLE_STATS_PER_TABLE


816 ++
	gm_s
->
	gnumAcss
;

819 
VueTy
* 
	gdedEry
 = 0;

820 
VueTy
* 
	gy
;

822 
	gy
 = 
b
 + 
i
;

825 i(
	gHashFunis
::
ToComToEmyOrDed
) {

826 i(
isEmyBuck
(*
y
))

829 i(
	gHashTn
::
equ
(
Exa
::
exa
(*
y
), 
key
))

830  
AddResu
(
makeKnownGoodIt
(
y
), 
l
);

832 i(
isDedBuck
(*
y
))

833 
	gdedEry
 = 
y
;

835 i(
isEmyBuck
(*
y
))

838 i(
isDedBuck
(*
y
))

839 
	gdedEry
 = 
y
;

840 i(
	gHashTn
::
equ
(
Exa
::
exa
(*
y
), 
key
))

841  
AddResu
(
makeKnownGoodIt
(
y
), 
l
);

843 #i
DUMP_HASHTABLE_STATS


844 ++
	gobeCou
;

845 
	gHashTabSts
::
cdClisiAtCou
(
obeCou
);

848 #i
DUMP_HASHTABLE_STATS_PER_TABLE


849 
	gm_s
->
cdClisiAtCou
(
obeCou
);

852 i(
	gk
 == 0)

853 
k
 = 1 | 
doubHash
(
h
);

854 
	gi
 = (
i
 + 
k
& 
sizeMask
;

857 i(
	gdedEry
) {

858 
lizeBuck
(*
dedEry
);

859 
	gy
 = 
dedEry
;

860 --
	gm_dedCou
;

863 
	gHashTn
::
e
(*
y
, 
d
::
fwd
<
T
>(
key
), std::fwd<
Exa
>(
exa
));

864 ++
	gm_keyCou
;

866 i(
shouldExnd
())

867 
	gy
 = 
exnd
(
y
);

869 
CheckTabCsicy
();

871  
AddResu
(
makeKnownGoodIt
(
y
), 
ue
);

874 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

875 
	gme
<
tyme
 
	gHashTn
,ym
	gT
,ym
	gExa
>

876 
le
ut
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
addPassgHashCode
(
T
&& 
key
, 
Exa
&& 
exa
-> 
	gAddResu


878 
	gcheckKey
<
	gHashTn
>(
	gkey
);

880 
videIts
();

882 i(!
	gm_b
)

883 
exnd
();

885 
CheckTabCsicy
();

887 
FuLookupTy
 
	glookupResu
 = 
fuLookupFWrg
<
HashTn
>(
key
);

889 
VueTy
* 
	gy
 = 
lookupResu
.
f
.first;

890 
bo
 
	gfound
 = 
lookupResu
.
f
.
cd
;

891 
	gh
 = 
lookupResu
.
cd
;

893 i(
	gfound
)

894  
AddResu
(
makeKnownGoodIt
(
y
), 
l
);

896 i(
isDedBuck
(*
y
)) {

897 
lizeBuck
(*
y
);

898 --
	gm_dedCou
;

901 
	gHashTn
::
e
(*
y
, 
d
::
fwd
<
T
>(
key
), std::fwd<
Exa
>(
exa
), 
h
);

902 ++
	gm_keyCou
;

904 i(
shouldExnd
())

905 
	gy
 = 
exnd
(
y
);

907 
CheckTabCsicy
();

909  
AddResu
(
makeKnownGoodIt
(
y
), 
ue
);

912 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

913 
le
ut
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::

(
VueTy
&& 
y
) -> ValueType*

915 
ASSERT
(
m_b
);

916 
ASSERT
(!
lookupFWrg
(
Exa
::
exa
(
y
)).
cd
);

917 
ASSERT
(!
isDedBuck
(*(
lookupFWrg
(
Exa
::
exa
(
y
)).
f
)));

918 #i
DUMP_HASHTABLE_STATS


919 ++
	gHashTabSts
::
numRes
;

921 #i
DUMP_HASHTABLE_STATS_PER_TABLE


922 ++
	gm_s
->
	gnumRes
;

925 
Vue
* 
	gwEry
 = 
lookupFWrg
(
Exa
::
exa
(
y
)).
f
;

926 
	gwEry
->~
Vue
();

927 
w
 (
NNu
, 
wEry

VueTy
(
WTF
::
move
(
y
));

929  
	gwEry
;

932 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

933 
	gme
 <
tyme
 
	gHashTn
,ym
	gT
>

934 aut
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
fd
(cڡ 
T
& 
key
-> 



936 i(!
m_b
)

937  
d
();

939 
VueTy
* 
	gy
 = 
lookup
<
HashTn
>(
key
);

940 i(!
	gy
)

941  
d
();

943  
makeKnownGoodIt
(
y
);

946 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

947 
	gme
 <
tyme
 
	gHashTn
,ym
	gT
>

948 aut
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
	$fd
(cڡ 
T
& 
key
cڡ -> 
cڡ_


950 i(!
m_b
)

951  
	`d
();

953 
VueTy
* 
y
 = 
cڡ_
<
HashTab
*>(
this
)->
lookup
<
HashTn
>(
key
);

954 i(!
y
)

955  
	`d
();

957  
	`makeKnownGoodCڡIt
(
y
);

958 
	}
}

960 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

961 
	gme
 <
tyme
 
	gHashTn
,ym
	gT
>

962 
bo
 
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
	$cڏs
(cڡ 
T
& 
key
) const

964 i(!
m_b
)

965  
l
;

967  
cڡ_
<
HashTab
*>(
this
)->
lookup
<
HashTn
>(
key
);

968 
	}
}

970 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

971 
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
	$moveAndInvideWhoutEryCsicyCheck
(
VueTy
* 
pos
)

973 
	`videIts
();

974 
	`move
(
pos
);

975 
	}
}

977 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

978 
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
	$moveAndInvide
(
VueTy
* 
pos
)

980 
	`videIts
();

981 
	`CheckTabCsicy
();

982 
	`move
(
pos
);

983 
	}
}

985 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

986 
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
	$move
(
VueTy
* 
pos
)

988 #i
DUMP_HASHTABLE_STATS


989 ++
HashTabSts
::
numRemoves
;

991 #i
DUMP_HASHTABLE_STATS_PER_TABLE


992 ++
m_s
->
numRemoves
;

995 
	`deBuck
(*
pos
);

996 ++
m_dedCou
;

997 --
m_keyCou
;

999 i(
	`shouldShrk
())

1000 
	`shrk
();

1002 
	`CheckTabCsicy
();

1003 
	}
}

1005 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

1006 
le
 
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
	$move
(

 

)

1008 i(

 =
	`d
())

1011 
	`moveAndInvide
(
cڡ_
<
VueTy
*>(

.
m_
.
m_posi
));

1012 
	}
}

1014 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

1015 
le
 
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
	$moveWhoutEryCsicyCheck
(

 

)

1017 i(

 =
	`d
())

1020 
	`moveAndInvideWhoutEryCsicyCheck
(
cڡ_
<
VueTy
*>(

.
m_
.
m_posi
));

1021 
	}
}

1023 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

1024 
le
 
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
	$moveWhoutEryCsicyCheck
(
cڡ_
 

)

1026 i(

 =
	`d
())

1029 
	`moveAndInvideWhoutEryCsicyCheck
(
cڡ_
<
VueTy
*>(

.
m_posi
));

1030 
	}
}

1032 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

1033 
le
 
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
	$move
(cڡ 
KeyTy
& 
key
)

1035 
	`move
(
	`fd
(
key
));

1036 
	}
}

1038 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

1039 
	gme
<
tyme
 
	gFun
>

1040 
le
 
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
	$moveIf
(cڡ 
Fun
& 
fun
)

1042 
i
 = 
m_bSize
; i--;) {

1043 i(
	`isEmyOrDedBuck
(
m_b
[
i
]))

1046 i(!
	`fun
(
m_b
[
i
]))

1049 
	`deBuck
(
m_b
[
i
]);

1050 ++
m_dedCou
;

1051 --
m_keyCou
;

1054 i(
	`shouldShrk
())

1055 
	`shrk
();

1057 
	`CheckTabCsicy
();

1058 
	}
}

1060 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

1061 aut
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
loTab
(
size
-> 
VueTy
*

1065 i(
Ts
::
emyVueIsZo
)

1066  
ic_
<
VueTy
*>(
ZdMloc
(
size
 * (ValueType)));

1067 
VueTy
* 
	gsu
 = 
ic_
<VueTy*>(
Mloc
(
size
 * (ValueType)));

1068 
	gi
 = 0; i < 
	gsize
; i++)

1069 
lizeBuck
(
su
[
i
]);

1070  
	gsu
;

1073 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

1074 
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
	$doTab
(
VueTy
* 
b
, 
size
)

1076 
i
 = 0; i < 
size
; ++i) {

1077 i(!
	`isDedBuck
(
b
[
i
]))

1078 
b
[
i
].~
	`VueTy
();

1080 
	`Fe
(
b
);

1081 
	}
}

1083 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

1084 aut
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
exnd
(
VueTy
* 
y
) -> ValueType*

1086 
wSize
;

1087 i(
	gm_bSize
 == 0)

1088 
wSize
 = 
KeyTs
::
mimumTabSize
;

1089 i(
muRehashInP
())

1090 
	gwSize
 = 
m_bSize
;

1092 
	gwSize
 = 
m_bSize
 * 2;

1094  
hash
(
wSize
, 
y
);

1097 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

1098 aut
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
hash
(
wTabSize
, 
VueTy
* 
y
-> 
	gVueTy
*

1100 
CheckTabCsicyExSize
();

1102 
	gdTabSize
 = 
m_bSize
;

1103 
VueTy
* 
	gdTab
 = 
m_b
;

1105 #i
DUMP_HASHTABLE_STATS


1106 i(
	gdTabSize
 != 0)

1107 ++
HashTabSts
::
numRehashes
;

1110 #i
DUMP_HASHTABLE_STATS_PER_TABLE


1111 i(
	gdTabSize
 != 0)

1112 ++
m_s
->
numRehashes
;

1115 
	gm_bSize
 = 
wTabSize
;

1116 
	gm_bSizeMask
 = 
wTabSize
 - 1;

1117 
	gm_b
 = 
loTab
(
wTabSize
);

1119 
Vue
* 
	gwEry
 = 
nuαr
;

1120 
	gi
 = 0; i !
dTabSize
; ++i) {

1121 i(
isEmyOrDedBuck
(
dTab
[
i
])) {

1122 
ASSERT
(&
dTab
[
i
] !
y
);

1126 
Vue
* 
	gedEry
 = 

(
WTF
::
move
(
dTab
[
i
]));

1127 i(&
	gdTab
[
i
] =
y
) {

1128 
ASSERT
(!
wEry
);

1129 
	gwEry
 = 
edEry
;

1133 
	gm_dedCou
 = 0;

1135 
doTab
(
dTab
, 
dTabSize
);

1137 
CheckTabCsicy
();

1138  
	gwEry
;

1141 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

1142 
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
	$r
()

1144 
	`videIts
();

1145 i(!
m_b
)

1148 
	`doTab
(
m_b
, 
m_bSize
);

1149 
m_b
 = 0;

1150 
m_bSize
 = 0;

1151 
m_bSizeMask
 = 0;

1152 
m_keyCou
 = 0;

1153 
	}
}

1155 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

1156 
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
	$HashTab
(cڡ 
HashTab
& 
h
)

1157 : 
	`m_b
(0)

1158 , 
	`m_bSize
(0)

1159 , 
	`m_bSizeMask
(0)

1160 , 
	`m_keyCou
(0)

1161 , 
	$m_dedCou
(0)

1162 #i
CHECK_HASHTABLE_ITERATORS


1163 , 
	`m_s
(0)

1164 , 
	`m_mux
(
d
::
make_unique
<d::
mux
>())

1166 #i
DUMP_HASHTABLE_STATS_PER_TABLE


1167 , 
	`m_s
(
d
::
make_unique
<
Sts
>(*
h
.
m_s
))

1174 
cڡ_
 
d
 = 
h
.
	`d
();

1175 
cڡ_
 

 = 
h
.
	`beg
(); i!
d
; ++it)

1176 
	`add
(*

);

1177 
	}
}

1179 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

1180 
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
	$sw
(
HashTab
& 
h
)

1182 
	`videIts
();

1183 
h
.
	`videIts
();

1185 
d
::
	`sw
(
m_b
, 
h
.m_table);

1186 
d
::
	`sw
(
m_bSize
, 
h
.m_tableSize);

1187 
d
::
	`sw
(
m_bSizeMask
, 
h
.m_tableSizeMask);

1188 
d
::
	`sw
(
m_keyCou
, 
h
.m_keyCount);

1189 
d
::
	`sw
(
m_dedCou
, 
h
.m_deletedCount);

1191 #i
DUMP_HASHTABLE_STATS_PER_TABLE


1192 
m_s
.
	`sw
(
h
.m_stats);

1194 
	}
}

1196 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

1197 aut
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
ݔ
=(cڡ 
HashTab
& 
h
) -> HashTable&

1201 
HashTab
 
tmp
(
h
);

1202 
sw
(
tmp
);

1203  *
	gthis
;

1206 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

1207 
le
 
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
	$HashTab
(
HashTab
&& 
h
)

1208 #i
CHECK_HASHTABLE_ITERATORS


1209 : 
	`m_s
(
nuαr
)

1210 , 
	`m_mux
(
d
::
make_unique
<d::
mux
>())

1213 
h
.
	`videIts
();

1215 
m_b
 = 
h
.m_table;

1216 
m_bSize
 = 
h
.m_tableSize;

1217 
m_bSizeMask
 = 
h
.m_tableSizeMask;

1218 
m_keyCou
 = 
h
.m_keyCount;

1219 
m_dedCou
 = 
h
.m_deletedCount;

1221 
h
.
m_b
 = 
nuαr
;

1222 
h
.
m_bSize
 = 0;

1223 
h
.
m_bSizeMask
 = 0;

1224 
h
.
m_keyCou
 = 0;

1225 
h
.
m_dedCou
 = 0;

1227 #i
DUMP_HASHTABLE_STATS_PER_TABLE


1228 
m_s
 = 
WTF
::
	`move
(
h
.m_stats);

1229 
h
.
m_s
 = 
nuαr
;

1231 
	}
}

1233 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

1234 
le
ut
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
ݔ
=(
HashTab
&& 
h
) -> HashTable&

1236 
HashTab
 
mp
 = 
WTF
::
move
(
h
);

1237 
sw
(
mp
);

1238  *
	gthis
;

1241 #i!
ASSERT_DISABLED


1243 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

1244 
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
	$checkTabCsicy
() const

1246 
	`checkTabCsicyExSize
();

1247 
	`ASSERT
(!
m_b
 || !
	`shouldExnd
());

1248 
	`ASSERT
(!
	`shouldShrk
());

1249 
	}
}

1251 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

1252 
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
	$checkTabCsicyExSize
() const

1254 i(!
m_b
)

1257 
cou
 = 0;

1258 
dedCou
 = 0;

1259 
j
 = 0; j < 
m_bSize
; ++j) {

1260 
VueTy
* 
y
 = 
m_b
 + 
j
;

1261 i(
	`isEmyBuck
(*
y
))

1264 i(
	`isDedBuck
(*
y
)) {

1265 ++
dedCou
;

1269 
cڡ_
 

 = 
	`fd
(
Exa
::
	`exa
(*
y
));

1270 
	`ASSERT
(
y
 =

.
m_posi
);

1271 ++
cou
;

1273 
VueCheck
<
Key
>::
	`checkCsicy
(

->
key
);

1276 
	`ASSERT
(
cou
 =
m_keyCou
);

1277 
	`ASSERT
(
dedCou
 =
m_dedCou
);

1278 
	`ASSERT
(
m_bSize
 >
KeyTs
::
mimumTabSize
);

1279 
	`ASSERT
(
m_bSizeMask
);

1280 
	`ASSERT
(
m_bSize
 =
m_bSizeMask
 + 1);

1281 
	}
}

1285 #i
CHECK_HASHTABLE_ITERATORS


1287 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

1288 
	gHashTab
<
	gKey
, 
	gVue
, 
	gExa
, 
	gHashFunis
, 
	gTs
, 
	gKeyTs
>::
	$videIts
()

1290 
d
::
lock_gud
<d::
mux
> 
	`lock
(*
m_mux
);

1291 
cڡ_
* 
xt
;

1292 
cڡ_
* 
p
 = 
m_s
;; = 
xt
) {

1293 
xt
 = 
p
->
m_xt
;

1294 
p
->
m_b
 = 0;

1295 
p
->
m_xt
 = 0;

1296 
p
->
m_evious
 = 0;

1298 
m_s
 = 0;

1299 
	}
}

1301 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

1302 
addIt
(cڡ 
HashTab
<
Key
, 
Vue
, 
Exa
, 
HashFunis
, 
Ts
, 
KeyTs
>* 
b
,

1303 
HashTabCڡIt
<
Key
, 
Vue
, 
Exa
, 
HashFunis
, 
Ts
, 
KeyTs
>* 

)

1305 
	g
->
	gm_b
 = 
b
;

1306 
	g
->
	gm_evious
 = 0;

1309 i(!
	gb
) {

1310 
	g
->
	gm_xt
 = 0;

1312 
	gd
::
lock_gud
<
d
::
mux
> 
lock
(*
b
->
m_mux
);

1313 
ASSERT
(
b
->
m_s
 !

);

1314 
	g
->
	gm_xt
 = 
b
->
m_s
;

1315 
	gb
->
	gm_s
 = 

;

1316 i(
	g
->
	gm_xt
) {

1317 
ASSERT
(!

->
m_xt
->
m_evious
);

1318 
	g
->
	gm_xt
->
	gm_evious
 = 

;

1323 
	gme
<
tyme
 
	gKey
,ym
	gVue
,ym
	gExa
,ym
	gHashFunis
,ym
	gTs
,ym
	gKeyTs
>

1324 
moveIt
(
HashTabCڡIt
<
Key
, 
Vue
, 
Exa
, 
HashFunis
, 
Ts
, 
KeyTs
>* 

)

1326 
	gHashTab
<
	tKey
, 
	tVue
, 
	tExa
, 
	tHashFunis
, 
	tTs
, 
	tKeyTs
> 
	tHashTabTy
;

1327 
	gHashTabCڡIt
<
	tKey
, 
	tVue
, 
	tExa
, 
	tHashFunis
, 
	tTs
, 
	tKeyTs
> 
	tcڡ_
;

1330 i(!
	g
->
	gm_b
) {

1331 
ASSERT
(!

->
m_xt
);

1332 
ASSERT
(!

->
m_evious
);

1334 
	gd
::
lock_gud
<
d
::
mux
> 
lock
(*

->
m_b
->
m_mux
);

1335 i(
	g
->
	gm_xt
) {

1336 
ASSERT
(

->
m_xt
->
m_evious
 == it);

1337 
	g
->
	gm_xt
->
	gm_evious
 = 

->
m_evious
;

1339 i(
	g
->
	gm_evious
) {

1340 
ASSERT
(

->
m_b
->
m_s
 != it);

1341 
ASSERT
(

->
m_evious
->
m_xt
 == it);

1342 
	g
->
	gm_evious
->
	gm_xt
 = 

->
m_xt
;

1344 
ASSERT
(

->
m_b
->
m_s
 == it);

1345 
	g
->
	gm_b
->
	gm_s
 = 

->
m_xt
;

1349 
	g
->
	gm_b
 = 0;

1350 
	g
->
	gm_xt
 = 0;

1351 
	g
->
	gm_evious
 = 0;

1358 
	gme
<
tyme
 
	gHashTabTy
,ym
	gVueTy
> 
	sHashTabCڡItAdr
 {

1359 
HashTabCڡItAdr
() {}

1360 
HashTabCڡItAdr
(cڡ 
tyme
 
HashTabTy
::
cڡ_
& 
im
: 
m_im
(impl) {}

1362 cڡ 
VueTy
* 
g
(cڡ {  (cڡ VueTy*)
m_im
.get(); }

1363 cڡ 
	gVueTy
& 
	gݔ
*(cڡ {  *
g
(); }

1364 cڡ 
VueTy
* 
	gݔ
->(cڡ {  
g
(); }

1366 
	gHashTabCڡItAdr
& 
	gݔ
++({ ++
	gm_im
;  *
	gthis
; }

1369 
tyme
 
	gHashTabTy
::
cڡ_
 
m_im
;

1372 
	gme
<
tyme
 
	gHashTabTy
,ym
	gVueTy
> 
	sHashTabItAdr
 {

1373 
HashTabItAdr
() {}

1374 
HashTabItAdr
(cڡ 
tyme
 
HashTabTy
::

& 
im
: 
m_im
(impl) {}

1376 
VueTy
* 
g
(cڡ {  (VueTy*)
m_im
.get(); }

1377 
	gVueTy
& 
	gݔ
*(cڡ {  *
g
(); }

1378 
VueTy
* 
	gݔ
->(cڡ {  
g
(); }

1380 
	gHashTabItAdr
& 
	gݔ
++({ ++
	gm_im
;  *
	gthis
; }

1383 
ݔ
 
	gHashTabCڡItAdr
<
	gHashTabTy
, 
	gVueTy
>() {

1384 
tyme
 
	gHashTabTy
::
cڡ_
 
i
 = 
m_im
;

1385  
	gi
;

1388 
tyme
 
	gHashTabTy
::

 
m_im
;

1391 
	gme
<
tyme
 
	gT
,ym
	gU
>

1392 
le
 
bo
 
	gݔ
==(cڡ 
HashTabCڡItAdr
<
T
, 
	gU
>& 
	ga
, cڡ 
	gHashTabCڡItAdr
<
	gT
, U>& 
	gb
)

1394  
	ga
.
	gm_im
 =
b
.
m_im
;

1397 
	gme
<
tyme
 
	gT
,ym
	gU
>

1398 
le
 
bo
 
	gݔ
!=(cڡ 
HashTabCڡItAdr
<
T
, 
	gU
>& 
	ga
, cڡ 
	gHashTabCڡItAdr
<
	gT
, U>& 
	gb
)

1400  
	ga
.
	gm_im
 !
b
.
m_im
;

1403 
	gme
<
tyme
 
	gT
,ym
	gU
>

1404 
le
 
bo
 
	gݔ
==(cڡ 
HashTabItAdr
<
T
, 
	gU
>& 
	ga
, cڡ 
	gHashTabItAdr
<
	gT
, U>& 
	gb
)

1406  
	ga
.
	gm_im
 =
b
.
m_im
;

1409 
	gme
<
tyme
 
	gT
,ym
	gU
>

1410 
le
 
bo
 
	gݔ
!=(cڡ 
HashTabItAdr
<
T
, 
	gU
>& 
	ga
, cڡ 
	gHashTabItAdr
<
	gT
, U>& 
	gb
)

1412  
	ga
.
	gm_im
 !
b
.
m_im
;

1416 
	gme
<
tyme
 
	gT
,ym
	gU
>

1417 
le
 
bo
 
	gݔ
==(cڡ 
HashTabCڡItAdr
<
T
, 
	gU
>& 
	ga
, cڡ 
	gHashTabItAdr
<
	gT
, U>& 
	gb
)

1419  
	ga
.
	gm_im
 =
b
.
m_im
;

1422 
	gme
<
tyme
 
	gT
,ym
	gU
>

1423 
le
 
bo
 
	gݔ
!=(cڡ 
HashTabCڡItAdr
<
T
, 
	gU
>& 
	ga
, cڡ 
	gHashTabItAdr
<
	gT
, U>& 
	gb
)

1425  
	ga
.
	gm_im
 !
b
.
m_im
;

1428 
	gme
<
tyme
 
	gT
,ym
	gU
>

1429 
le
 
bo
 
	gݔ
==(cڡ 
HashTabItAdr
<
T
, 
	gU
>& 
	ga
, cڡ 
	gHashTabCڡItAdr
<
	gT
, U>& 
	gb
)

1431  
	ga
.
	gm_im
 =
b
.
m_im
;

1434 
	gme
<
tyme
 
	gT
,ym
	gU
>

1435 
le
 
bo
 
	gݔ
!=(cڡ 
HashTabItAdr
<
T
, 
	gU
>& 
	ga
, cڡ 
	gHashTabCڡItAdr
<
	gT
, U>& 
	gb
)

1437  
	ga
.
	gm_im
 !
b
.
m_im
;

1442 
	~<wtf/HashIts.h
>

	@HashTraits.h

21 #ide
WTF_HashTs_h


22 
	#WTF_HashTs_h


	)

24 
	~<wtf/HashFunis.h
>

25 
	~<wtf/StdLibExas.h
>

26 
	~<uty
>

27 
	~<lims
>

29 
mea
 
	gWTF
 {

31 
ass
 
	gSg
;

33 
	gme
<
tyme
 
	gT
> 
ass
 
	gOwnP
;

34 
	gme
<
tyme
 
	gT
> 
ass
 
	gPassOwnP
;

36 
	gme
<
tyme
 
	gT
> 
	gHashTs
;

38 
	gme
<
bo
 
	gisIeg
, 
tyme
 
	gT
> 
	gGicHashTsBa
;

40 
	gme
<
tyme
 
	gT
> 
	gGicHashTsBa
<
	gl
, T> {

42 cڡ 
bo
 
	gemyVueIsZo
 = 
l
;

47 cڡ 
bo
 
	ghasIsEmyVueFuni
 = 
l
;

51 cڡ 
	gmimumTabSize
 = 8;

55 
	gme
<
tyme
 
	gT
> 
	gGicHashTsBa
<
	gue
, T> : 
GicHashTsBa
<
l
, T> {

56 cڡ 
bo
 
	gemyVueIsZo
 = 
ue
;

57 
cڡruDedVue
(
T
& 

{ 
	g
 = 
ic_
<T>(-1); }

58 
bo
 
isDedVue
(
T
 
vue
{  
	gvue
 =
ic_
<T>(-1); }

61 
	gme
<
tyme
 
	gT
> 
	gGicHashTs
 : 
GicHashTsBa
<
d
::
is_gl
<
T
>::
vue
, T> {

62 
T
 
	tTTy
;

63 
T
 
	tEmyVueTy
;

65 
T
 
emyVue
() {  T(); }

68 
T
 
	tPkTy
;

69 
	gme
<
tyme
 
	gU
> U&& 
ek
(
U
&& 
vue
{  
	gd
::
fwd
<U>(value); }

72 
	gme
<
tyme
 
	gT
> 
	gHashTs
 : 
GicHashTs
<
T
> { };

74 
	gme
<
tyme
 
	gT
> 
	gFltHashTs
 : 
GicHashTs
<
T
> {

75 
T
 
emyVue
({  
d
::
numic_lims
<T>::
fy
(); }

76 
cڡruDedVue
(
T
& 

{ 
	g
 = -
d
::
numic_lims
<T>::
fy
(); }

77 
bo
 
isDedVue
(
T
 
vue
{  
	gvue
 =-
d
::
numic_lims
<T>::
fy
(); }

80 
	gme
<> 
	gHashTs
<> : 
FltHashTs
<> { };

81 
	gme
<> 
	gHashTs
<> : 
FltHashTs
<> { };

84 
	gme
<
tyme
 
	gT
> 
	gUnsigdWhZoKeyHashTs
 : 
GicHashTs
<
T
> {

85 cڡ 
bo
 
emyVueIsZo
 = 
l
;

86 
T
 
emyVue
({  
	gd
::
numic_lims
<T>::
max
(); }

87 
cڡruDedVue
(
T
& 

{ 
	g
 = 
d
::
numic_lims
<T>::
max
() - 1; }

88 
bo
 
isDedVue
(
T
 
vue
{  
	gvue
 =
d
::
numic_lims
<T>::
max
() - 1; }

91 
	gme
<
tyme
 
	gP
> 
	gHashTs
<P*> : 
GicHashTs
<
P
*> {

92 cڡ 
bo
 
emyVueIsZo
 = 
ue
;

93 
cڡruDedVue
(
P
*& 

{ 
	g
 = 
t_
<P*>(-1); }

94 
bo
 
isDedVue
(
P
* 
vue
{  
	gvue
 =
t_
<P*>(-1); }

97 
	gme
<
tyme
 
	gT
> 
	gSimeCssHashTs
 : 
GicHashTs
<
T
> {

98 cڡ 
bo
 
emyVueIsZo
 = 
ue
;

99 
cڡruDedVue
(
T
& 

{ 
w
 (
NNu
, &T(
HashTabDedVue
); }

100 
bo
 
isDedVue
(cڡ 
T
& 
vue
{  
	gvue
.
isHashTabDedVue
(); }

103 
	gme
<
tyme
 
	gT
,ym
	gD
> 
	gHashTs
<
	gd
::
unique_r
<
T
, D>> : 
SimeCssHashTs
<
d
::unique_ptr<T, Deleter>> {

104 
	gd
::
	tnuαr_t
 
	tEmyVueTy
;

105 
EmyVueTy
 
emyVue
({  
	gnuαr
; }

107 
cڡruDedVue
(
d
::
unique_r
<
T
, 
D
>& 

{ 
w
 (
NNu
, &
	gd
::unique_r<T, 
	gD
> { 
	gt_
<
	gT
*>(-1) }; }

108 
bo
 
isDedVue
(cڡ 
d
::
unique_r
<
T
, 
D
>& 
vue
{  
	gvue
.
g
(=
t_
<T*>(-1); }

110 
T
* 
	tPkTy
;

111 
T
* 
ek
(cڡ 
d
::
unique_r
<T, 
D
>& 
vue
{  
	gvue
.
g
(); }

112 
T
* 
ek
(
d
::
nuαr_t
{  
nuαr
; }

115 
	gme
<
tyme
 
	gT
> 
	gHashTs
<
	gOwnP
<T>> : 
SimeCssHashTs
<
OwnP
<
T
>> {

116 
d
::
	tnuαr_t
 
	tEmyVueTy
;

117 
EmyVueTy
 
emyVue
({  
	gnuαr
; }

119 
T
* 
	tPkTy
;

120 
T
* 
ek
(cڡ 
OwnP
<T>& 
vue
{  
	gvue
.
g
(); }

121 
T
* 
ek
(
d
::
nuαr_t
{  
nuαr
; }

124 
	gme
<
tyme
 
	gP
> 
	gHashTs
<
	gRefP
<P>> : 
SimeCssHashTs
<
RefP
<
P
>> {

125 
P
* 
emyVue
() {  0; }

127 
P
* 
	tPkTy
;

128 
PkTy
 
ek
(cڡ 
RefP
<
P
>& 
vue
{  
	gvue
.
g
(); }

129 
PkTy
 
ek
(
P
* 
vue
{  
	gvue
; }

132 
	gme
<> 
	gHashTs
<
	gSg
> : 
SimeCssHashTs
<
Sg
> {

133 cڡ 
bo
 
hasIsEmyVueFuni
 = 
ue
;

134 
bo
 
isEmyVue
(cڡ 
Sg
&);

139 
	gme
<
tyme
 
	gTs
, 
bo
 
	ghasEmyVueFuni
> 
	gHashTsEmyVueCheck
;

140 
	gme
<
tyme
 
	gTs
> 
	gHashTsEmyVueCheck
<Ts, 
	gue
> {

141 
	gme
<
tyme
 
	gT
> 
bo
 
isEmyVue
(cڡ 
T
& 
vue
{  
	gTs
::isEmptyValue(value); }

143 
	gme
<
tyme
 
	gTs
> 
	gHashTsEmyVueCheck
<Ts, 
	gl
> {

144 
	gme
<
tyme
 
	gT
> 
bo
 
isEmyVue
(cڡ 
T
& 
vue
{  
	gvue
 =
Ts
::
emyVue
(); }

146 
	gme
<
tyme
 
	gTs
,ym
	gT
> 
le
 
bo
 
isHashTsEmyVue
(cڡ 
T
& 
vue
)

148  
	gHashTsEmyVueCheck
<
	gTs
, Ts::
hasIsEmyVueFuni
>::
isEmyVue
(
vue
);

151 
	gme
<
tyme
 
	gFTsArg
,ym
	gSecdTsArg
>

152 
	gPaHashTs
 : 
GicHashTs
<
d
::

<
tyme
 
FTsArg
::
TTy
,ym
	gSecdTsArg
::TraitType>> {

153 
FTsArg
 
	tFTs
;

154 
SecdTsArg
 
	tSecdTs
;

155 
	gd
::
	t
<
	ttyme
 
	tFTs
::
	tTTy
,ym
	tSecdTs
::TraitType> TraitType;

156 
	gd
::
	t
<
	ttyme
 
	tFTs
::
	tEmyVueTy
,ym
	tSecdTs
::EmptyValueType> EmptyValueType;

158 cڡ 
bo
 
	gemyVueIsZo
 = 
FTs
::
emyVueIsZo
 && 
SecdTs
::emptyValueIsZero;

159 
EmyVueTy
 
emyVue
({  
	gd
::
make_
(
FTs
::emyVue(), 
SecdTs
::emptyValue()); }

161 cڡ 
	gmimumTabSize
 = 
FTs
::
mimumTabSize
;

163 
cڡruDedVue
(
TTy
& 

{ 
	gFTs
::cڡruDedVue(.
f
); }

164 
bo
 
isDedVue
(cڡ 
TTy
& 
vue
{  
	gFTs
::isDedVue(vue.
f
); }

167 
	gme
<
tyme
 
	gF
,ym
	gSecd
>

168 
	gHashTs
<
	gd
::

<
F
, 
	gSecd
>> : 
public
 
PaHashTs
<
HashTs
<First>, HashTraits<Second>> { };

170 
	gme
<
tyme
 
	gKeyTyArg
,ym
	gVueTyArg
>

171 
	sKeyVuePa
 {

172 
KeyTyArg
 
	tKeyTy
;

174 
KeyVuePa
()

178 
	gme
<
tyme
 
	gK
,ym
	gV
>

179 
KeyVuePa
(
K
&& 
key
, 
V
&& 
vue
)

180 : 
key
(
d
::
fwd
<
K
>(key))

181 , 
vue
(
d
::
fwd
<
V
>(value))

185 
me
 <
tyme
 
OthKeyTy
,ym
	gOthVueTy
>

186 
KeyVuePa
(KeyVuePa<
OthKeyTy
, 
OthVueTy
>&& 
h
)

187 : 
key
(
d
::
fwd
<
OthKeyTy
>(
h
.key))

188 , 
vue
(
d
::
fwd
<
OthVueTy
>(
h
.value))

192 
KeyTyArg
 
key
;

193 
VueTyArg
 
	gvue
;

196 
	gme
<
tyme
 
	gKeyTsArg
,ym
	gVueTsArg
>

197 
	gKeyVuePaHashTs
 : 
GicHashTs
<
KeyVuePa
<
tyme
 
KeyTsArg
::
TTy
,ym
	gVueTsArg
::TraitType>> {

198 
KeyTsArg
 
	tKeyTs
;

199 
VueTsArg
 
	tVueTs
;

200 
	gKeyVuePa
<
	ttyme
 
	tKeyTs
::
	tTTy
,ym
	tVueTs
::TraitType> TraitType;

201 
	gKeyVuePa
<
	ttyme
 
	tKeyTs
::
	tEmyVueTy
,ym
	tVueTs
::EmptyValueType> EmptyValueType;

203 cڡ 
bo
 
	gemyVueIsZo
 = 
KeyTs
::
emyVueIsZo
 && 
VueTs
::emptyValueIsZero;

204 
EmyVueTy
 
emyVue
({  
	gKeyVuePa
<
tyme
 
	gKeyTs
::EmyVueTy,ym
	gVueTs
::EmyVueTy>(
KeyTs
::emptyValue(), ValueTraits::emptyValue()); }

206 cڡ 
	gmimumTabSize
 = 
KeyTs
::
mimumTabSize
;

208 
cڡruDedVue
(
TTy
& 

{ 
	gKeyTs
::cڡruDedVue(.
key
); }

209 
bo
 
isDedVue
(cڡ 
TTy
& 
vue
{  
	gKeyTs
::isDedVue(vue.
key
); }

212 
	gme
<
tyme
 
	gKey
,ym
	gVue
>

213 
	gHashTs
<
	gKeyVuePa
<
	gKey
, 
	gVue
>> : 
public
 
KeyVuePaHashTs
<
HashTs
<
Key
>, HashTraits<Value>> { };

215 
	gme
<
tyme
 
	gT
>

216 
	gNuabHashTs
 : 
public
 
HashTs
<
T
> {

217 cڡ 
bo
 
emyVueIsZo
 = 
l
;

218 
T
 
emyVue
({  
	gt_
<
	gT
>(1); }

223 
	gme
<
tyme
 
	gT
>

224 
	gCuomHashTs
 : 
public
 
GicHashTs
<
T
> {

225 cڡ 
bo
 
emyVueIsZo
 = 
l
;

226 cڡ 
bo
 
	ghasIsEmyVueFuni
 = 
ue
;

228 
cڡruDedVue
(
T
& 

)

230 
w
 (
NNu
, &


T
(T::
DedVue
);

233 
bo
 
isDedVue
(cڡ 
T
& 
vue
)

235  
	gvue
.
isDedVue
();

238 
T
 
emyVue
()

240  
T
(T::
EmyVue
);

243 
bo
 
isEmyVue
(cڡ 
T
& 
vue
)

245  
	gvue
.
isEmyVue
();

251 
usg
 
	gWTF
::
HashTs
;

252 
usg
 
	gWTF
::
PaHashTs
;

253 
usg
 
	gWTF
::
NuabHashTs
;

254 
usg
 
	gWTF
::
SimeCssHashTs
;

	@HexNumber.h

20 #ide
HexNumb_h


21 
	#HexNumb_h


	)

23 
	~<wtf/xt/SgCǋ.h
>

25 
mea
 
	gWTF
 {

27 
	eHexCvsiMode
 {

28 
	gLow
,

29 
	gU


32 
mea
 
	gIl
 {

34 cڡ 
LCh
 
	glowHexDigs
[17] = "0123456789abcdef";

35 cڡ 
LCh
 
	guHexDigs
[17] = "0123456789ABCDEF";

36 
le
 cڡ 
LCh
* 
hexDigsFMode
(
HexCvsiMode
 
mode
)

38  
	gmode
 =
Low
 ? 
lowHexDigs
 : 
uHexDigs
;

43 
	gme
<
tyme
 
	gT
>

44 
le
 
ndByAsHex
(
by
, 
T
& 
dei
, 
HexCvsiMode
 
mode
 = 
U
)

46 cڡ 
LCh
* 
hexDigs
 = 
Il
::
hexDigsFMode
(
mode
);

47 
	gdei
.
nd
(
hexDigs
[
by
 >> 4]);

48 
	gdei
.
nd
(
hexDigs
[
by
 & 0xF]);

51 
	gme
<
tyme
 
	gT
>

52 
le
 
aByAsHexComessIfPossib
(
by
, 
T
& 
dei
, & 
dex
, 
HexCvsiMode
 
mode
 = 
U
)

54 cڡ 
LCh
* 
hexDigs
 = 
Il
::
hexDigsFMode
(
mode
);

55 i(
	gby
 >= 0x10)

56 
dei
[
dex
++] = 
hexDigs
[
by
 >> 4];

57 
	gdei
[
dex
++] = 
hexDigs
[
by
 & 0xF];

60 
	gme
<
tyme
 
	gT
>

61 
le
 
aByAsHex
(
by
, 
T
& 
dei
, 
HexCvsiMode
 
mode
 = 
U
)

63 cڡ 
LCh
* 
hexDigs
 = 
Il
::
hexDigsFMode
(
mode
);

64 *
	gdei
++ = 
hexDigs
[
by
 >> 4];

65 *
	gdei
++ = 
hexDigs
[
by
 & 0xF];

68 
	gme
<
tyme
 
	gT
>

69 
le
 
ndUnsigdAsHex
(
numb
, 
T
& 
dei
, 
HexCvsiMode
 
mode
 = 
U
)

71 cڡ 
LCh
* 
hexDigs
 = 
Il
::
hexDigsFMode
(
mode
);

72 
	gVe
<
	gLCh
, 8> 
	gsu
;

74 
	gsu
.
nd
(
hexDigs
[
numb
 % 16]);

75 
	gnumb
 >>= 4;

76 } 
	gnumb
 > 0);

78 
	gsu
.
v
();

79 
	gdei
.
nd
(
su
.
da
(),esu.
size
());

82 
	gme
<
tyme
 
	gT
>

83 
le
 
ndUnsigd64AsHex
(
ut64_t
 
numb
, 
T
& 
dei
, 
HexCvsiMode
 
mode
 = 
U
)

85 cڡ 
LCh
* 
hexDigs
 = 
Il
::
hexDigsFMode
(
mode
);

86 
	gVe
<
	gLCh
, 8> 
	gsu
;

88 
	gsu
.
nd
(
hexDigs
[
numb
 % 16]);

89 
	gnumb
 >>= 4;

90 } 
	gnumb
 > 0);

92 
	gsu
.
v
();

93 
	gdei
.
nd
(
su
.
da
(),esu.
size
());

97 
	gme
<
tyme
 
	gT
>

98 
le
 
ndUnsigdAsHexFixedSize
(
numb
, 
T
& 
dei
, 
desedDigs
, 
HexCvsiMode
 
mode
 = 
U
)

100 
ASSERT
(
desedDigs
);

102 cڡ 
LCh
* 
	ghexDigs
 = 
Il
::
hexDigsFMode
(
mode
);

103 
	gVe
<
	gLCh
, 8> 
	gsu
;

105 
	gsu
.
nd
(
hexDigs
[
numb
 % 16]);

106 
	gnumb
 >>= 4;

107 } 
	gsu
.
size
(< 
	gdesedDigs
);

109 
ASSERT
(
su
.
size
(=
desedDigs
);

110 
	gsu
.
v
();

111 
	gdei
.
nd
(
su
.
da
(),esu.
size
());

116 
usg
 
	gWTF
::
ndByAsHex
;

117 
usg
 
	gWTF
::
ndUnsigdAsHex
;

118 
usg
 
	gWTF
::
ndUnsigdAsHexFixedSize
;

119 
usg
 
	gWTF
::
aByAsHex
;

120 
usg
 
	gWTF
::
aByAsHexComessIfPossib
;

121 
usg
 
	gWTF
::
Low
;

	@InlineASM.h

26 #ide
IƚeASM_h


27 
	#IƚeASM_h


	)

31 #i
OS
(
DARWIN
|| (OS(
WINDOWS
&& 
CPU
(
X86
))

32 
	#SYMBOL_STRING
(
me
"_" #me

	)

34 
	#SYMBOL_STRING
(
me
#me

	)

37 #i
OS
(
IOS
)

38 
	#THUMB_FUNC_PARAM
(
me

	`SYMBOL_STRING
ame)

	)

40 
	#THUMB_FUNC_PARAM
(
me
)

	)

43 #i(
OS
(
LINUX
|| OS(
FREEBSD
)&& 
CPU
(
X86_64
)

44 
	#GLOBAL_REFERENCE
(
me
#m"@t"

	)

45 #i
CPU
(
X86
&& 
COMPILER
(
MINGW
)

46 
	#GLOBAL_REFERENCE
(
me
"@" #m"@4"

	)

47 #i
OS
(
LINUX
&& 
CPU
(
X86
&& 
defed
(
__PIC__
)

48 
	#GLOBAL_REFERENCE
(
me

	`SYMBOL_STRING
ame"@t"

	)

50 
	#GLOBAL_REFERENCE
(
me

	`SYMBOL_STRING
ame)

	)

53 #i
HAVE
(
INTERNAL_VISIBILITY
)

54 
	#LOCAL_REFERENCE
(
me

	`SYMBOL_STRING
ame)

	)

56 
	#LOCAL_REFERENCE
(
me

	`GLOBAL_REFERENCE
ame)

	)

59 #i
OS
(
DARWIN
)

61 
	#HIDE_SYMBOL
(
me
".ive_ex _" #me

	)

62 #i
OS
(
AIX
)

64 
	#HIDE_SYMBOL
(
me
".lglob" #me

	)

65 #i 
OS
(
LINUX
) \

66 || 
OS
(
FREEBSD
) \

67 || 
OS
(
OPENBSD
) \

68 || 
OS
(
SOLARIS
) \

69 || (
OS
(
HPUX
&& 
CPU
(
IA64
)) \

70 || 
	$OS
(
NETBSD
)

72 
	#HIDE_SYMBOL
(
me
".hidd " #me

	)

74 
	#HIDE_SYMBOL
(
me
)

	)

80 #i
	`OS
(
DARWIN
)

81 
	#LOCAL_LABEL_STRING
(
me
"L" #me

	)

82 #i 
	`OS
(
LINUX
) \

83 || 
	`OS
(
FREEBSD
) \

84 || 
	`OS
(
OPENBSD
) \

85 || 
	$OS
(
NETBSD
)

87 
	#LOCAL_LABEL_STRING
(
me
".L" #me

	)

90 #i(
	`CPU
(
ARM_TRADITIONAL
&& (
	`defed
(
thumb2
|| defed(
__thumb2__
|| defed(
__thumb
|| defed(
__thumb__
))|| CPU(
ARM_THUMB2
)

91 
	#INLINE_ARM_FUNCTION
(
me
".thumb" "\n" ".thumb_fun" 
	`THUMB_FUNC_PARAM
ame"\n"

	)

93 
	#INLINE_ARM_FUNCTION
(
me
)

	)

	@Insertion.h

26 #ide
Ini_h


27 
	#Ini_h


	)

29 
mea
 
	gWTF
 {

31 
	gme
<
tyme
 
	gT
>

32 as
	cIni
 {

33 
	gpublic
:

34 
Ini
() { }

36 
Ini
(
size_t
 
dex
, 
T
 
emt
)

37 : 
m_dex
(
dex
)

38 , 
m_emt
(
emt
)

42 
size_t
 
dex
(cڡ {  
	gm_dex
; }

43 
T
 
emt
(cڡ {  
	gm_emt
; }

45 
bo
 
	gݔ
<(cڡ 
	gIni
& 
	gh
) const

47  
	gm_dex
 < 
	gh
.m_index;

50 
	give
:

51 
size_t
 
m_dex
;

52 
T
 
	gm_emt
;

55 
	gme
<
tyme
 
	gTgVeTy
,ym
	gIniVeTy
>

56 
	$execuInis
(
TgVeTy
& 
rg
, 
IniVeTy
& 
is
)

58 i(!
is
.
	`size
())

60 
rg
.
	`grow
Ѭg.
	`size
(+ 
is
.size());

61 
size_t
 
ϡIndex
 = 
rg
.
	`size
();

62 
size_t
 
dexInInis
 = 
is
.
	`size
(); indexInInsertions--;) {

63 
	`ASSERT
(!
dexInInis
 || 
is
[dexInInis].
	`dex
() >= insertions[indexInInsertions - 1].index());

64 
size_t
 
fIndex
 = 
is
[
dexInInis
].
	`dex
() + indexInInsertions;

65 
size_t
 
dexOfft
 = 
dexInInis
 + 1;

66 
size_t
 
i
 = 
ϡIndex
; --> 
fIndex
;)

67 
rg
[
i
] =g[- 
dexOfft
];

68 
rg
[
fIndex
] = 
is
[
dexInInis
].
	`emt
();

69 
ϡIndex
 = 
fIndex
;

71 
is
.
	`size
(0);

72 
	}
}

76 
usg
 
	gWTF
::
Ini
;

77 
usg
 
	gWTF
::
execuInis
;

	@IteratorAdaptors.h

26 #ide
WTF_ItAdts_h


27 
	#WTF_ItAdts_h


	)

29 
	~<ty_as
>

31 
mea
 
	gWTF
 {

33 
	gme
<
tyme
 
	gPdi
,ym
	gIt
>

34 as
	cFrIt
 {

35 
	gpublic
:

36 
FrIt
(
Pdi
 
ed
, 
It
 
beg
, It 
d
)

37 : 
m_ed
(
WTF
::
move
(
ed
))

38 , 
m_
(
WTF
::
move
(
beg
))

39 , 
m_d
(
WTF
::
move
(
d
))

41 
m_
 !
m_d
 && !
m_ed
(*m_iter))

42 ++
m_
;

45 
	gFrIt
& 
	gݔ
++()

47 
	gm_
 !
m_d
) {

48 ++
m_
;

49 i(
	gm_
 =
m_d
 || 
m_ed
(*
m_
))

52  *
	gthis
;

55 cڡ 
tyme
 
	gd
::
move_cڡ
<
dety
(*
d
::
dev
<
It
>())>::
ty
 
ݔ
*() const

57 
ASSERT
(
m_
 !
m_d
);

58 
ASSERT
(
m_ed
(*
m_
));

59  *
	gm_
;

62 
le
 
bo
 
	gݔ
==(
FrIt
& 
h
cڡ {  
m_
 == other.m_iter; }

63 
le
 
bo
 
	gݔ
!=(
FrIt
& 
h
cڡ {  
m_
 != other.m_iter; }

65 
	give
:

66 cڡ 
Pdi
 
m_ed
;

67 
It
 
	gm_
;

68 
It
 
	gm_d
;

71 
	gme
<
tyme
 
	gPdi
,ym
	gIt
>

72 
le
 
	gFrIt
<
	gPdi
, 
	gIt
> 
	$makeFrIt
(
Pdi
&& 
ed
, 
It
&& 
beg
, It&& 
d
)

74  
FrIt
<
Pdi
, 
It
>(
d
::
fwd
<Pdi>(
ed
), std::fwd<It>(
beg
), std::fwd<It>(
d
));

75 
	}
}

77 
	gme
<
tyme
 
	gTnsfm
,ym
	gIt
>

78 as
	cTnsfmIt
 {

79 
	gpublic
:

80 
TnsfmIt
(
Tnsfm
&& 
sfm
, 
It
&& 

)

81 : 
m_sfm
(
WTF
::
move
(
sfm
))

82 , 
m_
(
WTF
::
move
(

))

86 
TnsfmIt
& 
ݔ
++()

88 ++
m_
;

89  *
	gthis
;

92 cڡ 
tyme
 
	gd
::
move_cڡ
<
dety
(
d
::
dev
<
Tnsfm
>()(*d::dev<
It
>()))>::
ty
 
ݔ
*() const

94  
m_sfm
(*
m_
);

97 
le
 
bo
 
	gݔ
==(
TnsfmIt
& 
h
cڡ {  
m_
 == other.m_iter; }

98 
le
 
bo
 
	gݔ
!=(
TnsfmIt
& 
h
cڡ {  
m_
 != other.m_iter; }

100 
	give
:

101 cڡ 
Tnsfm
 
m_sfm
;

102 
It
 
	gm_
;

105 
	gme
<
tyme
 
	gTnsfm
,ym
	gIt
>

106 
le
 
	gTnsfmIt
<
	gTnsfm
, 
	gIt
> 
	$makeTnsfmIt
(
Tnsfm
&& 
sfm
, 
It
&& 

)

108  
TnsfmIt
<
Tnsfm
, 
It
>(
WTF
::
	`move
(
sfm
), WTF::move(

));

109 
	}
}

	@IteratorRange.h

26 #ide
WTF_ItRge_h


27 
	#WTF_ItRge_h


	)

29 
mea
 
	gWTF
 {

31 
	gme
<
tyme
 
	gIt
>

32 as
	cItRge
 {

33 
	gpublic
:

34 
ItRge
(
It
 
beg
, It 
d
)

35 : 
m_beg
(
WTF
::
move
(
beg
))

36 , 
m_d
(
WTF
::
move
(
d
))

40 
It
 
beg
(cڡ {  
m_beg
; }

41 
It
 
d
(cڡ {  
	gm_d
; }

43 
	give
:

44 
It
 
m_beg
;

45 
It
 
	gm_d
;

48 
	gme
<
tyme
 
	gIt
>

49 
	gItRge
<
	gIt
> 
	$makeItRge
(
It
&& 
beg
, It&& 
d
)

51  
ItRge
<
It
>(
d
::
fwd
<It>(
beg
), std::fwd<It>(
d
));

52 
	}
}

	@ListDump.h

26 #ide
LiDump_h


27 
	#LiDump_h


	)

29 
	~"CommaPrr.h
"

30 
	~"PrtSm.h
"

31 
	~"SgPrtSm.h
"

33 
mea
 
	gWTF
 {

35 
	gme
<
tyme
 
	gT
>

36 as
	cLiDump
 {

37 
	gpublic
:

38 
LiDump
(cڡ 
T
& 
li
, cڡ * 
comma
)

39 : 
m_li
(
li
)

40 , 
m_comma
(
comma
)

44 
dump
(
PrtSm
& 
out
) const

46 
tyme
 
	gT
::
cڡ_
 

 = 
m_li
.
beg
(); 
	g
 !m_li.
d
(); ++iter)

47 
	gout
.
t
(
m_comma
, *

);

50 
	give
:

51 cڡ 
T
& 
m_li
;

52 
CommaPrr
 
	gm_comma
;

55 
	gme
<
tyme
 
	gT
>

56 as
	cMDump
 {

57 
	gpublic
:

58 
MDump
(cڡ 
T
& 
m
, cڡ * 
row
, cڡ * 
comma
)

59 : 
m_m
(
m
)

60 , 
m_row
(
row
)

61 , 
m_comma
(
comma
)

65 
dump
(
PrtSm
& 
out
) const

67 
tyme
 
	gT
::
cڡ_
 

 = 
m_m
.
beg
(); 
	g
 !m_m.
d
(); ++iter)

68 
	gout
.
t
(
m_comma
, 

->
key
, 
m_row
, ir->
vue
);

71 
	give
:

72 cڡ 
T
& 
m_m
;

73 cڡ * 
	gm_row
;

74 
CommaPrr
 
	gm_comma
;

77 
	gme
<
tyme
 
	gT
>

78 
	gLiDump
<
	gT
> 
liDump
(cڡ 
T
& 
li
, cڡ * 
comma
 = ", ")

80  
LiDump
<
T
>(
li
, 
comma
);

83 
	gme
<
tyme
 
	gT
,ym
	gComt
>

84 
CSg
 
s܋dLiDump
(cڡ 
T
& 
li
, cڡ 
Comt
& 
comt
, cڡ * 
comma
 = ", ")

86 
Ve
<
tyme
 
T
::
VueTy
> 
myLi
;

87 
	gmyLi
.
ndRge
(
li
.
beg
(),i.
d
());

88 
	gd
::
st
(
myLi
.
beg
(), myLi.
d
(), 
comt
);

89 
SgPrtSm
 
	gout
;

90 
CommaPrr
 
commaPrr
(
comma
);

91 
	gi
 = 0; i < 
	gmyLi
.
size
(); ++i)

92 
	gout
.
t
(
commaPrr
, 
myLi
[
i
]);

93  
	gout
.
toCSg
();

96 
	gme
<
tyme
 
	gT
>

97 
CSg
 
s܋dLiDump
(cڡ 
T
& 
li
, cڡ * 
comma
 = ", ")

99  
s܋dLiDump
(
li
, 
d
::
ss
<
tyme
 
T
::
VueTy
>(), 
comma
);

102 
	gme
<
tyme
 
	gT
>

103 
	gMDump
<
	gT
> 
mDump
(cڡ 
T
& 
m
, cڡ * 
row
 = "=>", cڡ * 
comma
 = ", ")

105  
MDump
<
T
>(
m
, 
row
, 
comma
);

108 
	gme
<
tyme
 
	gT
,ym
	gComt
>

109 
CSg
 
s܋dMDump
(cڡ 
T
& 
m
, cڡ 
Comt
& 
comt
, cڡ * 
row
 = "=>", cڡ * 
comma
 = ", ")

111 
Ve
<
tyme
 
T
::
KeyTy
> 
keys
;

112 
tyme
 
	gT
::
cڡ_
 

 = 
m
.
beg
(); 
	g
 !m.
d
(); ++iter)

113 
	gkeys
.
nd
(

->
key
);

114 
	gd
::
st
(
keys
.
beg
(), keys.
d
(), 
comt
);

115 
SgPrtSm
 
	gout
;

116 
CommaPrr
 
commaPrr
(
comma
);

117 
	gi
 = 0; i < 
	gkeys
.
size
(); ++i)

118 
	gout
.
t
(
commaPrr
, 
keys
[
i
], 
row
, 
m
.
g
(keys[i]));

119  
	gout
.
toCSg
();

122 
	gme
<
tyme
 
	gT
,ym
	gU
>

123 as
	cLiDumpInCڋxt
 {

124 
	gpublic
:

125 
LiDumpInCڋxt
(cڡ 
T
& 
li
, 
U
* 
cڋxt
, cڡ * 
comma
)

126 : 
m_li
(
li
)

127 , 
m_cڋxt
(
cڋxt
)

128 , 
m_comma
(
comma
)

132 
dump
(
PrtSm
& 
out
) const

134 
tyme
 
	gT
::
cڡ_
 

 = 
m_li
.
beg
(); 
	g
 !m_li.
d
(); ++iter)

135 
	gout
.
t
(
m_comma
, 
Cڋxt
(*

, 
m_cڋxt
));

138 
	give
:

139 cڡ 
T
& 
m_li
;

140 
U
* 
	gm_cڋxt
;

141 
CommaPrr
 
	gm_comma
;

144 
	gme
<
tyme
 
	gT
,ym
	gU
>

145 
	gLiDumpInCڋxt
<
	gT
, 
	gU
> 
liDumpInCڋxt
(

146 cڡ 
T
& 
li
, 
U
* 
cڋxt
, cڡ * 
comma
 = ", ")

148  
LiDumpInCڋxt
<
T
, 
U
>(
li
, 
cڋxt
, 
comma
);

153 
usg
 
	gWTF
::
liDump
;

154 
usg
 
	gWTF
::
s܋dLiDump
;

155 
usg
 
	gWTF
::
mDump
;

156 
usg
 
	gWTF
::
s܋dMDump
;

157 
usg
 
	gWTF
::
liDumpInCڋxt
;

	@ListHashSet.h

22 #ide
WTF_LiHashS_h


23 
	#WTF_LiHashS_h


	)

25 
	~<wtf/HashS.h
>

26 
	~<wtf/OwnP.h
>

27 
	~<wtf/PassOwnP.h
>

29 
mea
 
	gWTF
 {

41 
	gme
<
tyme
 
	gVue
, 
size_t
 
	gleCacy
,ym
	gHashFunis
> 
ass
 
	gLiHashS
;

43 
	gme
<
tyme
 
	gVueArg
, 
size_t
 
	gleCacy
,ym
	gHashArg
> 
ass
 
	gLiHashSIt
;

44 
	gme
<
tyme
 
	gVueArg
, 
size_t
 
	gleCacy
,ym
	gHashArg
> 
ass
 
	gLiHashSCڡIt
;

46 
	gme
<
tyme
 
	gVueArg
, 
size_t
 
	gleCacy
> 
	gLiHashSNode
;

47 
	gme
<
tyme
 
	gVueArg
, 
size_t
 
	gleCacy
> 
ass
 
	gLiHashSNodeAot
;

49 
	gme
<
tyme
 
	gHashArg
> 
	gLiHashSNodeHashFunis
;

50 
	gme
<
tyme
 
	gHashArg
> 
	gLiHashSTn
;

52 
	gme
<
tyme
 
	gVueArg
, 
size_t
 
	gleCacy
 = 256,ym
	gHashArg
 =ym
DeuHash
<
VueArg
>::
Hash
> cs
	cLiHashS
 {

53 
WTF_MAKE_FAST_ALLOCATED
;

54 
	give
:

55 
LiHashSNode
<
	tVueArg
, 
	tleCacy
> 
	tNode
;

56 
	gLiHashSNodeAot
<
	tVueArg
, 
	tleCacy
> 
	tNodeAot
;

58 
	gHashTs
<
	tNode
*> 
	tNodeTs
;

59 
	gLiHashSNodeHashFunis
<
	tHashArg
> 
	tNodeHash
;

60 
	gLiHashSTn
<
	tHashArg
> 
	tBaTn
;

62 
HashArg
 
	tHashFunis
;

64 
	gpublic
:

65 
VueArg
 
	tVueTy
;

67 
	gLiHashSIt
<
	tVueTy
, 
	tleCacy
, 
	tHashArg
> 
	t
;

68 
	gLiHashSCڡIt
<
	tVueTy
, 
	tleCacy
, 
	tHashArg
> 
	tcڡ_
;

69 
nd
 
ass
 
	gLiHashSCڡIt
<
	gVueTy
, 
	gleCacy
, 
	gHashArg
>;

71 
	gd
::
	tv_
<
	t
>everse_iterator;

72 
	gd
::
	tv_
<
	tcڡ_
> 
	tcڡ_v_
;

74 
	gHashTabAddResu
<
	t
> 
	tAddResu
;

76 
LiHashS
();

77 
LiHashS
(const ListHashSet&);

78 
	gLiHashS
& 
	gݔ
=(cڡ 
LiHashS
&);

79 ~
LiHashS
();

81 
sw
(
LiHashS
&);

83 
size
() const;

84 
cy
() const;

85 
bo
 
isEmy
() const;

87 

 
beg
({  
makeIt
(
m_hd
); }

88 

 
d
({  
makeIt
(
nuαr
); }

89 
cڡ_
 
beg
(cڡ {  
makeCڡIt
(
m_hd
); }

90 
cڡ_
 
d
(cڡ {  
makeCڡIt
(
nuαr
); }

92 
v_
 
rbeg
({ ev_(
d
()); }

93 
v_
 
nd
({ ev_(
beg
()); }

94 
cڡ_v_
 
rbeg
(cڡ {  cڡ_v_(
d
()); }

95 
cڡ_v_
 
nd
(cڡ {  cڡ_v_(
beg
()); }

97 
	gVueTy
& 
f
();

98 cڡ 
	gVueTy
& 
f
() const;

99 
moveF
();

100 
VueTy
 
keF
();

102 
	gVueTy
& 
ϡ
();

103 cڡ 
	gVueTy
& 
ϡ
() const;

104 
moveLa
();

105 
VueTy
 
keLa
();

107 

 
fd
(cڡ 
VueTy
&);

108 
cڡ_
 
fd
(cڡ 
VueTy
&) const;

109 
bo
 
cڏs
(cڡ 
VueTy
&) const;

116 
	gme
<
tyme
 
	gT
,ym
	gHashTn
> 

 
fd
(cڡ 
T
&);

117 
	gme
<
tyme
 
	gT
,ym
	gHashTn
> 
cڡ_
 
fd
(cڡ 
T
&) const;

118 
	gme
<
tyme
 
	gT
,ym
	gHashTn
> 
bo
 
cڏs
(cڡ 
T
&) const;

122 
AddResu
 
add
(cڡ 
VueTy
&);

123 
AddResu
 
add
(
VueTy
&&);

127 
AddResu
 
ndOrMoveToLa
(cڡ 
VueTy
&);

128 
AddResu
 
ndOrMoveToLa
(
VueTy
&&);

132 
AddResu
 
dOrMoveToF
(cڡ 
VueTy
&);

133 
AddResu
 
dOrMoveToF
(
VueTy
&&);

135 
AddResu
 
Befe
(cڡ 
VueTy
& 
befeVue
, cڡ VueTy& 
wVue
);

136 
AddResu
 
Befe
(cڡ 
VueTy
& 
befeVue
, VueTy&& 
wVue
);

137 
AddResu
 
Befe
(

, cڡ 
VueTy
&);

138 
AddResu
 
Befe
(

, 
VueTy
&&);

140 
bo
 
move
(cڡ 
VueTy
&);

141 
bo
 
move
(

);

142 
r
();

144 
	give
:

145 
uƚk
(
Node
*);

146 
uƚkAndDe
(
Node
*);

147 
ndNode
(
Node
*);

148 
dNode
(
Node
*);

149 
NodeBefe
(
Node
* 
befeNode
, Node* 
wNode
);

150 
deANodes
();

152 

 
makeIt
(
Node
*);

153 
cڡ_
 
makeCڡIt
(
Node
*) const;

155 
	gHashTab
<
	gNode
*, Node*, 
	gIdtyExa
, 
	gNodeHash
, 
	gNodeTs
, NodeTs> 
	gm_im
;

156 
Node
* 
	gm_hd
;

157 
Node
* 
	gm_
;

158 
	gd
::
unique_r
<
NodeAot
> 
m_lot
;

161 
	gme
<
tyme
 
	gVueArg
, 
size_t
 
	gleCacy
> cs
	cLiHashSNodeAot
 {

162 
	gWTF_MAKE_FAST_ALLOCATED
;

164 
	gpublic
:

165 
LiHashSNode
<
	tVueArg
, 
	tleCacy
> 
	tNode
;

166 
	gLiHashSNodeAot
<
	tVueArg
, 
	tleCacy
> 
	tNodeAot
;

168 
LiHashSNodeAot
()

169 : 
m_Li
(
po
())

170 , 
m_isDeWhInlFeLi
(
l
)

172 
memt
(
m_po
.
po
, 0, (m_pool.pool));

175 
Node
* 
lo
()

177 
Node
* 
	gsu
 = 
m_Li
;

179 i(!
	gsu
)

180  
	gic_
<
	gNode
*>(
Mloc
((
Node
)));

182 
ASSERT
(!
su
->
m_isAod
);

184 
Node
* 
	gxt
 = 
su
->
m_xt
;

185 
ASSERT
(!
xt
 || !xt->
m_isAod
);

186 i(!
	gxt
 && !
	gm_isDeWhInlFeLi
) {

187 
	gxt
 = 
su
 + 1;

188 i(
	gxt
 =
Po
()) {

189 
m_isDeWhInlFeLi
 = 
ue
;

190 
	gxt
 = 0;

192 
ASSERT
(
Po
(
xt
));

193 
ASSERT
(!
xt
->
m_isAod
);

196 
	gm_Li
 = 
xt
;

198  
	gsu
;

201 
do
(
Node
* 
node
)

203 i(
Po
(
node
)) {

204 #ide
NDEBUG


205 
	gnode
->
	gm_isAod
 = 
l
;

207 
	gnode
->
	gm_xt
 = 
m_Li
;

208 
	gm_Li
 = 
node
;

212 
Fe
(
node
);

215 
	give
:

216 
Node
* 
po
({  
t__r
<Node*>(
m_po
.pool); }

217 
Node
* 
Po
({  
po
(+ 
	gm_poSize
; }

218 
bo
 
Po
(
Node
* 
node
)

220  
	gnode
 >
po
(&& 
node
 < 
Po
();

223 
Node
* 
	gm_Li
;

224 
bo
 
	gm_isDeWhInlFeLi
;

225 cڡ 
size_t
 
	gm_poSize
 = 
leCacy
;

227 
	gpo
[(
Node
* 
m_poSize
];

228 
	gfAlignmt
;

229 } 
	gm_po
;

232 
	gme
<
tyme
 
	gVueArg
, 
size_t
 
	gleCacy
> 
	sLiHashSNode
 {

233 
	gLiHashSNodeAot
<
	tVueArg
, 
	tleCacy
> 
	tNodeAot
;

235 
	gme
<
tyme
 
	gT
>

236 
LiHashSNode
(
T
&& 
vue
)

237 : 
m_vue
(
d
::
fwd
<
T
>(
vue
))

238 , 
m_ev
(0)

239 , 
m_xt
(0)

240 #ide
NDEBUG


241 , 
m_isAod
(
ue
)

246 * 
ݔ
 
w
(
size_t
, 
NodeAot
* 
lot
)

248  
	glot
->
lo
();

250 
deroy
(
NodeAot
* 
lot
)

252 
	gthis
->~
LiHashSNode
();

253 
	glot
->
do
(
this
);

256 
VueArg
 
	gm_vue
;

257 
LiHashSNode
* 
	gm_ev
;

258 
LiHashSNode
* 
	gm_xt
;

260 #ide
NDEBUG


261 
bo
 
	gm_isAod
;

265 
	gme
<
tyme
 
	gHashArg
> 
	sLiHashSNodeHashFunis
 {

266 
	gme
<
tyme
 
	gT
> 
hash
(cڡ 
T
& 
key
{  
	gHashArg
::hash(key->
m_vue
); }

267 
	gme
<
tyme
 
	gT
> 
bo
 
equ
(cڡ 
T
& 
a
, cڡ T& 
b
{  
	gHashArg
::equ->
m_vue
, b->m_value); }

268 cڡ 
bo
 
	gToComToEmyOrDed
 = 
l
;

271 
	gme
<
tyme
 
	gVueArg
, 
size_t
 
	gleCacy
,ym
	gHashArg
> cs
	cLiHashSIt
 {

272 
	give
:

273 
LiHashS
<
	tVueArg
, 
	tleCacy
, 
	tHashArg
> 
	tLiHashSTy
;

274 
	gLiHashSIt
<
	tVueArg
, 
	tleCacy
, 
	tHashArg
> 
	t
;

275 
	gLiHashSCڡIt
<
	tVueArg
, 
	tleCacy
, 
	tHashArg
> 
	tcڡ_
;

276 
	gLiHashSNode
<
	tVueArg
, 
	tleCacy
> 
	tNode
;

277 
VueArg
 
	tVueTy
;

279 
nd
 
ass
 
	gLiHashS
<
	gVueArg
, 
	gleCacy
, 
	gHashArg
>;

281 
LiHashSIt
(cڡ 
LiHashSTy
* 
t
, 
Node
* 
posi
: 
m_
(set,osition) { }

283 
	gpublic
:

284 
rdiff_t
 
	tdifn_ty
;

285 
VueTy
 
	tvue_ty
;

286 
VueTy
* 
	tpor
;

287 
	gVueTy
& 
	tn
;

288 
	gd
::
	tbideiڮ__g
 
	t_gy
;

290 
LiHashSIt
() { }

294 
VueTy
* 
g
(cڡ {  
	gcڡ_
<
	gVueTy
*>(
	gm_
.get()); }

295 
	gVueTy
& 
	gݔ
*(cڡ {  *
g
(); }

296 
VueTy
* 
	gݔ
->(cڡ {  
g
(); }

298 
	g
& 
	gݔ
++({ ++
	gm_
;  *
	gthis
; }

302 
	g
& 
	gݔ
--({ --
	gm_
;  *
	gthis
; }

307 
bo
 
	gݔ
==(cڡ 

& 
h
cڡ {  
m_
 == other.m_iterator; }

308 
bo
 
	gݔ
!=(cڡ 

& 
h
cڡ {  
m_
 != other.m_iterator; }

310 
ݔ
 
cڡ_
(cڡ {  
	gm_
; }

312 
	give
:

313 
Node
* 
node
({  
m_
.node(); }

315 
cڡ_
 
	gm_
;

318 
	gme
<
tyme
 
	gVueArg
, 
size_t
 
	gleCacy
,ym
	gHashArg
> cs
	cLiHashSCڡIt
 {

319 
	give
:

320 
LiHashS
<
	tVueArg
, 
	tleCacy
, 
	tHashArg
> 
	tLiHashSTy
;

321 
	gLiHashSIt
<
	tVueArg
, 
	tleCacy
, 
	tHashArg
> 
	t
;

322 
	gLiHashSCڡIt
<
	tVueArg
, 
	tleCacy
, 
	tHashArg
> 
	tcڡ_
;

323 
	gLiHashSNode
<
	tVueArg
, 
	tleCacy
> 
	tNode
;

324 
VueArg
 
	tVueTy
;

326 
nd
 
ass
 
	gLiHashS
<
	gVueArg
, 
	gleCacy
, 
	gHashArg
>;

327 
nd
 
ass
 
	gLiHashSIt
<
	gVueArg
, 
	gleCacy
, 
	gHashArg
>;

329 
LiHashSCڡIt
(cڡ 
LiHashSTy
* 
t
, 
Node
* 
posi
)

330 : 
m_t
(
t
)

331 , 
m_posi
(
posi
)

335 
	gpublic
:

336 
rdiff_t
 
	tdifn_ty
;

337 cڡ 
	tVueTy
 
	tvue_ty
;

338 cڡ 
	tVueTy
* 
	tpor
;

339 cڡ 
	tVueTy
& 
	tn
;

340 
	gd
::
	tbideiڮ__g
 
	t_gy
;

342 
LiHashSCڡIt
()

346 cڡ 
VueTy
* 
g
() const

348  &
	gm_posi
->
	gm_vue
;

351 cڡ 
	gVueTy
& 
	gݔ
*(cڡ {  *
g
(); }

352 cڡ 
VueTy
* 
	gݔ
->(cڡ {  
g
(); }

354 
	gcڡ_
& 
	gݔ
++()

356 
ASSERT
(
m_posi
 != 0);

357 
	gm_posi
 = 
m_posi
->
m_xt
;

358  *
	gthis
;

363 
	gcڡ_
& 
	gݔ
--()

365 
ASSERT
(
m_posi
 !
m_t
->
m_hd
);

366 i(!
	gm_posi
)

367 
	gm_posi
 = 
m_t
->
m_
;

369 
	gm_posi
 = 
m_posi
->
m_ev
;

370  *
	gthis
;

376 
bo
 
	gݔ
==(cڡ 
cڡ_
& 
h
) const

378  
m_posi
 =
h
.m_position;

380 
bo
 
	gݔ
!=(cڡ 
cڡ_
& 
h
) const

382  
m_posi
 !
h
.m_position;

385 
	give
:

386 
Node
* 
node
({  
m_posi
; }

388 cڡ 
LiHashSTy
* 
	gm_t
;

389 
Node
* 
	gm_posi
;

392 
	gme
<
tyme
 
	gHashFunis
>

393 
	sLiHashSTn
 {

394 
	gme
<
tyme
 
	gT
> 
hash
(cڡ 
T
& 
key
{  
	gHashFunis
::hash(key); }

395 
	gme
<
tyme
 
	gT
,ym
	gU
> 
bo
 
equ
(cڡ 
T
& 
a
, cڡ 
U
& 
b
{  
	gHashFunis
::equ->
m_vue
, b); }

396 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
> 
e
(
T
*& 
loti
, 
U
&& 
key
, cڡ 
V
& 
lot
)

398 
	gloti
 = 
w
 (
lot

T
(
d
::
fwd
<
U
>(
key
));

402 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

403 
le
 
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
	$LiHashS
()

404 : 
	`m_hd
(0)

405 , 
	`m_
(0)

406 , 
	`m_lot
(
d
::
make_unique
<
NodeAot
>())

408 
	}
}

410 
me
<
tyme
 
T
, 
size_t
 
	gleCacy
,ym
	gU
>

411 
le
 
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
	$LiHashS
(cڡ 
LiHashS
& 
h
)

412 : 
	`m_hd
(0)

413 , 
	`m_
(0)

414 , 
	`m_lot
(
d
::
make_unique
<
NodeAot
>())

416 aut

 = 
h
.
	`beg
(), 
d
 = oth.
	`d
(); it !=nd; ++it)

417 
	`add
(*

);

418 
	}
}

420 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

421 
le
 
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>& LiHashS<T, iƚeCacy, U>::
ݔ
=(cڡ 
LiHashS
& 
h
)

423 
LiHashS
 
tmp
(
h
);

424 
sw
(
tmp
);

425  *
	gthis
;

428 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

429 
le
 
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
	$sw
(
LiHashS
& 
h
)

431 
m_im
.
	`sw
(
h
.m_impl);

432 
d
::
	`sw
(
m_hd
, 
h
.m_head);

433 
d
::
	`sw
(
m_
, 
h
.m_tail);

434 
m_lot
.
	`sw
(
h
.m_allocator);

435 
	}
}

437 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

438 
le
 
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::~
	$LiHashS
()

440 
	`deANodes
();

441 
	}
}

443 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

444 
le
 
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
	$size
() const

446  
m_im
.
	`size
();

447 
	}
}

449 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

450 
le
 
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
	$cy
() const

452  
m_im
.
	`cy
();

453 
	}
}

455 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

456 
le
 
bo
 
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
	$isEmy
() const

458  
m_im
.
	`isEmy
();

459 
	}
}

461 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

462 
le
 
	gT
& 
	gLiHashS
<T, 
	gleCacy
, 
	gU
>::
	$f
()

464 
	`ASSERT
(!
	`isEmy
());

465  
m_hd
->
m_vue
;

466 
	}
}

468 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

469 
le
 
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
	$moveF
()

471 
	`keF
();

472 
	}
}

474 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

475 
le
 
T
 
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
	$keF
()

477 
	`ASSERT
(!
	`isEmy
());

478 aut

 = 
m_im
.
	`fd
(
m_hd
);

480 
T
 
su
 = 
WTF
::
	`move
((*

)->
m_vue
);

481 
m_im
.
	`move
(

);

482 
	`uƚkAndDe
(
m_hd
);

484  
su
;

485 
	}
}

487 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

488 
le
 cڡ 
	gT
& 
	gLiHashS
<T, 
	gleCacy
, 
	gU
>::
	$f
() const

490 
	`ASSERT
(!
	`isEmy
());

491  
m_hd
->
m_vue
;

492 
	}
}

494 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

495 
le
 
	gT
& 
	gLiHashS
<T, 
	gleCacy
, 
	gU
>::
	$ϡ
()

497 
	`ASSERT
(!
	`isEmy
());

498  
m_
->
m_vue
;

499 
	}
}

501 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

502 
le
 cڡ 
	gT
& 
	gLiHashS
<T, 
	gleCacy
, 
	gU
>::
	$ϡ
() const

504 
	`ASSERT
(!
	`isEmy
());

505  
m_
->
m_vue
;

506 
	}
}

508 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

509 
le
 
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
	$moveLa
()

511 
	`keLa
();

512 
	}
}

514 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

515 
le
 
T
 
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
	$keLa
()

517 
	`ASSERT
(!
	`isEmy
());

518 aut

 = 
m_im
.
	`fd
(
m_
);

520 
T
 
su
 = 
WTF
::
	`move
((*

)->
m_vue
);

521 
m_im
.
	`move
(

);

522 
	`uƚkAndDe
(
m_
);

524  
su
;

525 
	}
}

527 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

528 
le
ut
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
fd
(cڡ 
VueTy
& 
vue
-> 



530 aut

 = 
m_im
.
me
 
fd
<
BaTn
>(
vue
);

531 i(
	g
 =
m_im
.
d
())

532  
d
();

533  
makeIt
(*

);

536 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

537 
le
ut
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
	$fd
(cڡ 
VueTy
& 
vue
cڡ -> 
cڡ_


539 aut

 = 
m_im
.
me
 
fd
<
BaTn
>(
vue
);

540 i(

 =
m_im
.
	`d
())

541  
	`d
();

542  
	`makeCڡIt
(*

);

543 
	}
}

545 
	gme
<
tyme
 
	gTn
>

546 
	sLiHashSTnAdr
 {

547 
	gme
<
tyme
 
	gT
> 
hash
(cڡ 
T
& 
key
{  
	gTn
::hash(key); }

548 
	gme
<
tyme
 
	gT
,ym
	gU
> 
bo
 
equ
(cڡ 
T
& 
a
, cڡ 
U
& 
b
{  
	gTn
::equ->
m_vue
, b); }

551 
	gme
<
tyme
 
	gVueTy
, 
size_t
 
	gleCacy
,ym
	gU
>

552 
	gme
<
tyme
 
	gT
,ym
	gHashTn
>

553 
le
ut
	gLiHashS
<
	gVueTy
, 
	gleCacy
, 
	gU
>::
fd
(cڡ 
T
& 
vue
-> 



555 aut

 = 
m_im
.
me
 
fd
<
LiHashSTnAdr
<
HashTn
>>(
vue
);

556 i(
	g
 =
m_im
.
d
())

557  
d
();

558  
makeIt
(*

);

561 
	gme
<
tyme
 
	gVueTy
, 
size_t
 
	gleCacy
,ym
	gU
>

562 
	gme
<
tyme
 
	gT
,ym
	gHashTn
>

563 
le
ut
	gLiHashS
<
	gVueTy
, 
	gleCacy
, 
	gU
>::
	$fd
(cڡ 
T
& 
vue
cڡ -> 
cڡ_


565 aut

 = 
m_im
.
me
 
fd
<
LiHashSTnAdr
<
HashTn
>>(
vue
);

566 i(

 =
m_im
.
	`d
())

567  
	`d
();

568  
	`makeCڡIt
(*

);

569 
	}
}

571 
	gme
<
tyme
 
	gVueTy
, 
size_t
 
	gleCacy
,ym
	gU
>

572 
	gme
<
tyme
 
	gT
,ym
	gHashTn
>

573 
le
 
bo
 
	gLiHashS
<
	gVueTy
, 
	gleCacy
, 
	gU
>::
	$cڏs
(cڡ 
T
& 
vue
) const

575  
m_im
.
me
 
cڏs
<
LiHashSTnAdr
<
HashTn
>>(
vue
);

576 
	}
}

578 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

579 
le
 
bo
 
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
	$cڏs
(cڡ 
VueTy
& 
vue
) const

581  
m_im
.
me
 
cڏs
<
BaTn
>(
vue
);

582 
	}
}

584 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

585 aut
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
add
(cڡ 
VueTy
& 
vue
-> 
AddResu


587 aut
su
 = 
m_im
.
me
 
add
<
BaTn
>(
vue
, 
	gm_lot
.
g
());

588 i(
	gsu
.
	gisNewEry
)

589 
ndNode
(*
su
.

);

590  
AddResu
(
makeIt
(*
su
.

),esu.
isNewEry
);

593 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

594 aut
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
add
(
VueTy
&& 
vue
-> 
AddResu


596 aut
su
 = 
m_im
.
me
 
add
<
BaTn
>(
WTF
::
move
(
vue
), 
	gm_lot
.
g
());

597 i(
	gsu
.
	gisNewEry
)

598 
ndNode
(*
su
.

);

599  
AddResu
(
makeIt
(*
su
.

),esu.
isNewEry
);

602 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

603 aut
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
ndOrMoveToLa
(cڡ 
VueTy
& 
vue
-> 
AddResu


605 aut
su
 = 
m_im
.
me
 
add
<
BaTn
>(
vue
, 
	gm_lot
.
g
());

606 
Node
* 
	gnode
 = *
su
.

;

607 i(!
	gsu
.
	gisNewEry
)

608 
uƚk
(
node
);

609 
ndNode
(
node
);

611  
AddResu
(
makeIt
(*
su
.

),esu.
isNewEry
);

614 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

615 aut
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
ndOrMoveToLa
(
VueTy
&& 
vue
-> 
AddResu


617 aut
su
 = 
m_im
.
me
 
add
<
BaTn
>(
WTF
::
move
(
vue
), 
	gm_lot
.
g
());

618 
Node
* 
	gnode
 = *
su
.

;

619 i(!
	gsu
.
	gisNewEry
)

620 
uƚk
(
node
);

621 
ndNode
(
node
);

623  
AddResu
(
makeIt
(*
su
.

),esu.
isNewEry
);

626 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

627 aut
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
dOrMoveToF
(cڡ 
VueTy
& 
vue
-> 
AddResu


629 aut
su
 = 
m_im
.
me
 
add
<
BaTn
>(
vue
, 
	gm_lot
.
g
());

630 
Node
* 
	gnode
 = *
su
.

;

631 i(!
	gsu
.
	gisNewEry
)

632 
uƚk
(
node
);

633 
dNode
(
node
);

635  
AddResu
(
makeIt
(*
su
.

),esu.
isNewEry
);

638 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

639 aut
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
dOrMoveToF
(
VueTy
&& 
vue
-> 
AddResu


641 aut
su
 = 
m_im
.
me
 
add
<
BaTn
>(
WTF
::
move
(
vue
), 
	gm_lot
.
g
());

642 
Node
* 
	gnode
 = *
su
.

;

643 i(!
	gsu
.
	gisNewEry
)

644 
uƚk
(
node
);

645 
dNode
(
node
);

647  
AddResu
(
makeIt
(*
su
.

),esu.
isNewEry
);

650 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

651 aut
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
Befe
(cڡ 
VueTy
& 
befeVue
, cڡ VueTy& 
wVue
-> 
	gAddResu


653  
Befe
(
fd
(
befeVue
), 
wVue
);

656 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

657 aut
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
Befe
(cڡ 
VueTy
& 
befeVue
, VueTy&& 
wVue
-> 
	gAddResu


659  
Befe
(
fd
(
befeVue
), 
WTF
::
move
(
wVue
));

662 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

663 aut
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
Befe
(

 

, cڡ 
VueTy
& 
wVue
-> 
	gAddResu


665 aut
	gsu
 = 
m_im
.
me
 
add
<
BaTn
>(
wVue
, 
	gm_lot
.
g
());

666 i(
	gsu
.
	gisNewEry
)

667 
NodeBefe
(

.
node
(), *
su
.

);

668  
AddResu
(
makeIt
(*
su
.

),esu.
isNewEry
);

671 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

672 aut
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
Befe
(

 

, 
VueTy
&& 
wVue
-> 
	gAddResu


674 aut
	gsu
 = 
m_im
.
me
 
add
<
BaTn
>(
WTF
::
move
(
wVue
), 
	gm_lot
.
g
());

675 i(
	gsu
.
	gisNewEry
)

676 
NodeBefe
(

.
node
(), *
su
.

);

677  
AddResu
(
makeIt
(*
su
.

),esu.
isNewEry
);

680 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

681 
le
 
bo
 
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
	$move
(

 

)

683 i(

 =
	`d
())

684  
l
;

685 
m_im
.
	`move
(

.
	`node
());

686 
	`uƚkAndDe
(

.
	`node
());

687  
ue
;

688 
	}
}

690 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

691 
le
 
bo
 
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
	$move
(cڡ 
VueTy
& 
vue
)

693  
	`move
(
	`fd
(
vue
));

694 
	}
}

696 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

697 
le
 
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
	$r
()

699 
	`deANodes
();

700 
m_im
.
	`r
();

701 
m_hd
 = 0;

702 
m_
 = 0;

703 
	}
}

705 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

706 
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
	$uƚk
(
Node
* 
node
)

708 i(!
node
->
m_ev
) {

709 
	`ASSERT
(
node
 =
m_hd
);

710 
m_hd
 = 
node
->
m_xt
;

712 
	`ASSERT
(
node
 !
m_hd
);

713 
node
->
m_ev
->
m_xt
 =ode->m_next;

716 i(!
node
->
m_xt
) {

717 
	`ASSERT
(
node
 =
m_
);

718 
m_
 = 
node
->
m_ev
;

720 
	`ASSERT
(
node
 !
m_
);

721 
node
->
m_xt
->
m_ev
 =ode->m_prev;

723 
	}
}

725 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

726 
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
	$uƚkAndDe
(
Node
* 
node
)

728 
	`uƚk
(
node
);

729 
node
->
	`deroy
(
m_lot
.
	`g
());

730 
	}
}

732 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

733 
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
	$ndNode
(
Node
* 
node
)

735 
node
->
m_ev
 = 
m_
;

736 
node
->
m_xt
 = 0;

738 i(
m_
) {

739 
	`ASSERT
(
m_hd
);

740 
m_
->
m_xt
 = 
node
;

742 
	`ASSERT
(!
m_hd
);

743 
m_hd
 = 
node
;

746 
m_
 = 
node
;

747 
	}
}

749 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

750 
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
	$dNode
(
Node
* 
node
)

752 
node
->
m_ev
 = 0;

753 
node
->
m_xt
 = 
m_hd
;

755 i(
m_hd
)

756 
m_hd
->
m_ev
 = 
node
;

758 
m_
 = 
node
;

760 
m_hd
 = 
node
;

761 
	}
}

763 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

764 
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
	$NodeBefe
(
Node
* 
befeNode
, Node* 
wNode
)

766 i(!
befeNode
)

767  
	`ndNode
(
wNode
);

769 
wNode
->
m_xt
 = 
befeNode
;

770 
wNode
->
m_ev
 = 
befeNode
->m_prev;

771 i(
befeNode
->
m_ev
)

772 
befeNode
->
m_ev
->
m_xt
 = 
wNode
;

773 
befeNode
->
m_ev
 = 
wNode
;

775 i(!
wNode
->
m_ev
)

776 
m_hd
 = 
wNode
;

777 
	}
}

779 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

780 
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
	$deANodes
()

782 i(!
m_hd
)

785 
Node
* 
node
 = 
m_hd
, *
xt
 = m_hd->
m_xt
;ode;ode =ext,ext =ode ?ode->m_next : 0)

786 
node
->
	`deroy
(
m_lot
.
	`g
());

787 
	}
}

789 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

790 
le
ut
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
makeIt
(
Node
* 
posi
-> 



792  

(
this
, 
posi
);

795 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gU
>

796 
le
ut
	gLiHashS
<
	gT
, 
	gleCacy
, 
	gU
>::
	$makeCڡIt
(
Node
* 
posi
cڡ -> 
cڡ_


798  
	`cڡ_
(
this
, 
posi
);

799 
	}
}

803 
usg
 
	gWTF
::
LiHashS
;

	@Locker.h

28 #ide
Lock_h


29 
	#Lock_h


	)

31 
	~<wtf/Ncyab.h
>

33 
mea
 
	gWTF
 {

35 
	gme
 <
tyme
 
	gT
> cs
	cLock
 {

36 
WTF_MAKE_NONCOPYABLE
(
Lock
);

37 
	gpublic
:

38 
exic
 
Lock
(
T
& 
lockab
: 
m_lockab
(&lockab{ 
lock
(); }

39 
exic
 
Lock
(
T
* 
lockab
: 
m_lockab
ockab{ 
lock
(); }

40 ~
Lock
()

42 i(
	gm_lockab
)

43 
	gm_lockab
->
uock
();

46 
uockEly
()

48 
	gm_lockab
->
uock
();

49 
	gm_lockab
 = 0;

51 
	give
:

52 
lock
()

54 i(
m_lockab
)

55 
m_lockab
->
lock
();

58 
T
* 
	gm_lockab
;

63 
usg
 
	gWTF
::
Lock
;

	@MD5.cpp

49 
	~"cfig.h
"

50 
	~"MD5.h
"

52 
	~"Asis.h
"

53 #ide
NDEBUG


54 
	~"SgExas.h
"

55 
	~"xt/CSg.h
"

57 
	~<wtf/StdLibExas.h
>

59 
mea
 
	gWTF
 {

63 
toLeEndn
(
ut8_t
* 
buf
, 
lgs
)

65 
ASSERT
(
lgs
 > 0);

67 
ut32_t
 
	gt
 = 
ic_
<ut32_t>(
buf
[3] << 8 | buf[2]) << 16 | buf[1] << 8 | buf[0];

68 
ASSERT_WITH_MESSAGE
(!(
t_
<
u_t
>(
buf
% (
t
)), "alignmentrror of buf");

69 
memy
(
buf
, &
t
, (t));

70 
	gbuf
 +(
t
);

71 } --
	glgs
);

76 
	#F1
(
x
, 
y
, 
z
(z ^ (x & (y ^ z)))

	)

77 
	#F2
(
x
, 
y
, 
z

	`F1
(z, x, y)

	)

78 
	#F3
(
x
, 
y
, 
z
(x ^ y ^ z)

	)

79 
	#F4
(
x
, 
y
, 
z
(y ^ (x | ~z))

	)

82 
	#MD5STEP
(
f
, 
w
, 
x
, 
y
, 
z
, 
da
, 
s
) \

83 (
w
 +
	`f
(
x
, 
y
, 
z
+ 
da
, w = w << 
s
 | w >> (32 - s), w +x)

	)

85 
MD5Tnsfm
(
ut32_t
 
buf
[4], cڡ ut32_

[16])

87 
ut32_t
 
	ga
 = 
buf
[0];

88 
ut32_t
 
	gb
 = 
buf
[1];

89 
ut32_t
 
	gc
 = 
buf
[2];

90 
ut32_t
 
	gd
 = 
buf
[3];

92 
MD5STEP
(
F1
, 
a
, 
b
, 
c
, 
d
, 

[ 0]+0xd76aa478, 7);

93 
MD5STEP
(
F1
, 
d
, 
a
, 
b
, 
c
, 

[ 1]+0xe8c7b756, 12);

94 
MD5STEP
(
F1
, 
c
, 
d
, 
a
, 
b
, 

[ 2]+0x242070db, 17);

95 
MD5STEP
(
F1
, 
b
, 
c
, 
d
, 
a
, 

[ 3]+0xc1bdceee, 22);

96 
MD5STEP
(
F1
, 
a
, 
b
, 
c
, 
d
, 

[ 4]+0xf57c0faf, 7);

97 
MD5STEP
(
F1
, 
d
, 
a
, 
b
, 
c
, 

[ 5]+0x4787c62a, 12);

98 
MD5STEP
(
F1
, 
c
, 
d
, 
a
, 
b
, 

[ 6]+0xa8304613, 17);

99 
MD5STEP
(
F1
, 
b
, 
c
, 
d
, 
a
, 

[ 7]+0xfd469501, 22);

100 
MD5STEP
(
F1
, 
a
, 
b
, 
c
, 
d
, 

[ 8]+0x698098d8, 7);

101 
MD5STEP
(
F1
, 
d
, 
a
, 
b
, 
c
, 

[ 9]+0x8b44f7af, 12);

102 
MD5STEP
(
F1
, 
c
, 
d
, 
a
, 
b
, 

[10]+0xffff5bb1, 17);

103 
MD5STEP
(
F1
, 
b
, 
c
, 
d
, 
a
, 

[11]+0x895cd7be, 22);

104 
MD5STEP
(
F1
, 
a
, 
b
, 
c
, 
d
, 

[12]+0x6b901122, 7);

105 
MD5STEP
(
F1
, 
d
, 
a
, 
b
, 
c
, 

[13]+0xfd987193, 12);

106 
MD5STEP
(
F1
, 
c
, 
d
, 
a
, 
b
, 

[14]+0xa679438e, 17);

107 
MD5STEP
(
F1
, 
b
, 
c
, 
d
, 
a
, 

[15]+0x49b40821, 22);

109 
MD5STEP
(
F2
, 
a
, 
b
, 
c
, 
d
, 

[ 1]+0xf61e2562, 5);

110 
MD5STEP
(
F2
, 
d
, 
a
, 
b
, 
c
, 

[ 6]+0xc040b340, 9);

111 
MD5STEP
(
F2
, 
c
, 
d
, 
a
, 
b
, 

[11]+0x265e5a51, 14);

112 
MD5STEP
(
F2
, 
b
, 
c
, 
d
, 
a
, 

[ 0]+0xe9b6c7aa, 20);

113 
MD5STEP
(
F2
, 
a
, 
b
, 
c
, 
d
, 

[ 5]+0xd62f105d, 5);

114 
MD5STEP
(
F2
, 
d
, 
a
, 
b
, 
c
, 

[10]+0x02441453, 9);

115 
MD5STEP
(
F2
, 
c
, 
d
, 
a
, 
b
, 

[15]+0xd8a1e681, 14);

116 
MD5STEP
(
F2
, 
b
, 
c
, 
d
, 
a
, 

[ 4]+0xe7d3fbc8, 20);

117 
MD5STEP
(
F2
, 
a
, 
b
, 
c
, 
d
, 

[ 9]+0x21e1cde6, 5);

118 
MD5STEP
(
F2
, 
d
, 
a
, 
b
, 
c
, 

[14]+0xc33707d6, 9);

119 
MD5STEP
(
F2
, 
c
, 
d
, 
a
, 
b
, 

[ 3]+0xf4d50d87, 14);

120 
MD5STEP
(
F2
, 
b
, 
c
, 
d
, 
a
, 

[ 8]+0x455a14ed, 20);

121 
MD5STEP
(
F2
, 
a
, 
b
, 
c
, 
d
, 

[13]+0xa9e3e905, 5);

122 
MD5STEP
(
F2
, 
d
, 
a
, 
b
, 
c
, 

[ 2]+0xfcefa3f8, 9);

123 
MD5STEP
(
F2
, 
c
, 
d
, 
a
, 
b
, 

[ 7]+0x676f02d9, 14);

124 
MD5STEP
(
F2
, 
b
, 
c
, 
d
, 
a
, 

[12]+0x8d2a4c8a, 20);

126 
MD5STEP
(
F3
, 
a
, 
b
, 
c
, 
d
, 

[ 5]+0xfffa3942, 4);

127 
MD5STEP
(
F3
, 
d
, 
a
, 
b
, 
c
, 

[ 8]+0x8771f681, 11);

128 
MD5STEP
(
F3
, 
c
, 
d
, 
a
, 
b
, 

[11]+0x6d9d6122, 16);

129 
MD5STEP
(
F3
, 
b
, 
c
, 
d
, 
a
, 

[14]+0xfde5380c, 23);

130 
MD5STEP
(
F3
, 
a
, 
b
, 
c
, 
d
, 

[ 1]+0xa4beea44, 4);

131 
MD5STEP
(
F3
, 
d
, 
a
, 
b
, 
c
, 

[ 4]+0x4bdecfa9, 11);

132 
MD5STEP
(
F3
, 
c
, 
d
, 
a
, 
b
, 

[ 7]+0xf6bb4b60, 16);

133 
MD5STEP
(
F3
, 
b
, 
c
, 
d
, 
a
, 

[10]+0xbebfbc70, 23);

134 
MD5STEP
(
F3
, 
a
, 
b
, 
c
, 
d
, 

[13]+0x289b7ec6, 4);

135 
MD5STEP
(
F3
, 
d
, 
a
, 
b
, 
c
, 

[ 0]+0xeaa127fa, 11);

136 
MD5STEP
(
F3
, 
c
, 
d
, 
a
, 
b
, 

[ 3]+0xd4ef3085, 16);

137 
MD5STEP
(
F3
, 
b
, 
c
, 
d
, 
a
, 

[ 6]+0x04881d05, 23);

138 
MD5STEP
(
F3
, 
a
, 
b
, 
c
, 
d
, 

[ 9]+0xd9d4d039, 4);

139 
MD5STEP
(
F3
, 
d
, 
a
, 
b
, 
c
, 

[12]+0xe6db99e5, 11);

140 
MD5STEP
(
F3
, 
c
, 
d
, 
a
, 
b
, 

[15]+0x1fa27cf8, 16);

141 
MD5STEP
(
F3
, 
b
, 
c
, 
d
, 
a
, 

[ 2]+0xc4ac5665, 23);

143 
MD5STEP
(
F4
, 
a
, 
b
, 
c
, 
d
, 

[ 0]+0xf4292244, 6);

144 
MD5STEP
(
F4
, 
d
, 
a
, 
b
, 
c
, 

[ 7]+0x432aff97, 10);

145 
MD5STEP
(
F4
, 
c
, 
d
, 
a
, 
b
, 

[14]+0xab9423a7, 15);

146 
MD5STEP
(
F4
, 
b
, 
c
, 
d
, 
a
, 

[ 5]+0xfc93a039, 21);

147 
MD5STEP
(
F4
, 
a
, 
b
, 
c
, 
d
, 

[12]+0x655b59c3, 6);

148 
MD5STEP
(
F4
, 
d
, 
a
, 
b
, 
c
, 

[ 3]+0x8f0ccc92, 10);

149 
MD5STEP
(
F4
, 
c
, 
d
, 
a
, 
b
, 

[10]+0xffeff47d, 15);

150 
MD5STEP
(
F4
, 
b
, 
c
, 
d
, 
a
, 

[ 1]+0x85845dd1, 21);

151 
MD5STEP
(
F4
, 
a
, 
b
, 
c
, 
d
, 

[ 8]+0x6fa87e4f, 6);

152 
MD5STEP
(
F4
, 
d
, 
a
, 
b
, 
c
, 

[15]+0xfe2ce6e0, 10);

153 
MD5STEP
(
F4
, 
c
, 
d
, 
a
, 
b
, 

[ 6]+0xa3014314, 15);

154 
MD5STEP
(
F4
, 
b
, 
c
, 
d
, 
a
, 

[13]+0x4e0811a1, 21);

155 
MD5STEP
(
F4
, 
a
, 
b
, 
c
, 
d
, 

[ 4]+0xf7537e82, 6);

156 
MD5STEP
(
F4
, 
d
, 
a
, 
b
, 
c
, 

[11]+0xbd3af235, 10);

157 
MD5STEP
(
F4
, 
c
, 
d
, 
a
, 
b
, 

[ 2]+0x2ad7d2bb, 15);

158 
MD5STEP
(
F4
, 
b
, 
c
, 
d
, 
a
, 

[ 9]+0xeb86d391, 21);

160 
	gbuf
[0] +
a
;

161 
	gbuf
[1] +
b
;

162 
	gbuf
[2] +
c
;

163 
	gbuf
[3] +
d
;

166 
	gMD5
::
MD5
()

168 
m_buf
[0] = 0x67452301;

169 
	gm_buf
[1] = 0xefcdab89;

170 
	gm_buf
[2] = 0x98badcfe;

171 
	gm_buf
[3] = 0x10325476;

172 
	gm_bs
[0] = 0;

173 
	gm_bs
[1] = 0;

174 
memt
(
m_
, 0, (m_in));

175 
ASSERT_WITH_MESSAGE
(!(
t_
<
u_t
>(
m_
% (
ut32_t
)), "alignmentrror of m_in");

178 
	gMD5
::
addBys
(cڡ 
ut8_t
* 
put
, 
size_t
 
ngth
)

180 cڡ 
ut8_t
* 
	gbuf
 = 
put
;

183 
ut32_t
 
	gt
 = 
m_bs
[0];

184 
	gm_bs
[0] = 
t
 + (
ngth
 << 3);

185 i(
	gm_bs
[0] < 
	gt
)

186 
	gm_bs
[1]++;

187 
	gm_bs
[1] +
ngth
 >> 29;

189 
	gt
 = (
t
 >> 3) & 0x3f;

193 i(
	gt
) {

194 
ut8_t
* 
	gp
 = 
m_
 + 
t
;

196 
	gt
 = 64 - 
t
;

197 i(
	gngth
 < 
	gt
) {

198 
memy
(
p
, 
buf
, 
ngth
);

201 
memy
(
p
, 
buf
, 
t
);

202 
toLeEndn
(
m_
, 16);

203 
MD5Tnsfm
(
m_buf
, 
t__r
<
ut32_t
*>(
m_
));

204 
	gbuf
 +
t
;

205 
	gngth
 -
t
;

210 
	gngth
 >= 64) {

211 
memy
(
m_
, 
buf
, 64);

212 
toLeEndn
(
m_
, 16);

213 
MD5Tnsfm
(
m_buf
, 
t__r
<
ut32_t
*>(
m_
));

214 
	gbuf
 += 64;

215 
	gngth
 -= 64;

219 
memy
(
m_
, 
buf
, 
ngth
);

222 
	gMD5
::
checksum
(
Dige
& 
dige
)

225 
cou
 = (
m_bs
[0] >> 3) & 0x3F;

229 
ut8_t
* 
	gp
 = 
m_
 + 
cou
;

230 *
	gp
++ = 0x80;

233 
	gcou
 = 64 - 1 - 
cou
;

236 i(
	gcou
 < 8) {

238 
memt
(
p
, 0, 
cou
);

239 
toLeEndn
(
m_
, 16);

240 
MD5Tnsfm
(
m_buf
, 
t__r
<
ut32_t
 *>(
m_
));

243 
memt
(
m_
, 0, 56);

246 
memt
(
p
, 0, 
cou
 - 8);

248 
toLeEndn
(
m_
, 14);

251 
memy
(
m_
 + 56, 
m_bs
, (m_bits));

253 
MD5Tnsfm
(
m_buf
, 
t__r
<
ut32_t
*>(
m_
));

254 
toLeEndn
(
t_
<
ut8_t
*>(
m_buf
), 4);

257 
ut8_t
* 
	gmBufUI8
 = 
t_
<ut8_t*>(
m_buf
);

258 
size_t
 
	gi
 = 0; i < 
	ghashSize
; ++i)

259 
	gdige
[
i
] = 
mBufUI8
[i];

262 
memt
(
m_buf
, 0, (m_buf));

263 
memt
(
m_bs
, 0, (m_bits));

264 
memt
(
m_
, 0, (m_in));

	@MD5.h

31 #ide
WTF_MD5_h


32 
	#WTF_MD5_h


	)

34 
	~<y
>

35 
	~<wtf/Ve.h
>

37 
mea
 
	gWTF
 {

39 as
	cMD5
 {

40 
	gpublic
:

41 
WTF_EXPORT_PRIVATE
 
MD5
();

43 
addBys
(cڡ 
Ve
<
ut8_t
>& 
put
)

45 
addBys
(
put
.
da
(), iut.
size
());

47 
WTF_EXPORT_PRIVATE
 
addBys
(cڡ 
ut8_t
* 
put
, 
size_t
 
ngth
);

50 
WTF_EXPORT_PRIVATE
 cڡ 
size_t
 
	ghashSize
 = 16;

53 
	gd
::
	ty
<
	tut8_t
, 
	thashSize
> 
	tDige
;

56 
WTF_EXPORT_PRIVATE
 
checksum
(
Dige
&);

58 
	give
:

59 
ut32_t
 
m_buf
[4];

60 
ut32_t
 
	gm_bs
[2];

61 
ut8_t
 
	gm_
[64];

66 
usg
 
	gWTF
::
MD5
;

	@MainThread.cpp

29 
	~"cfig.h
"

30 
	~"MaThad.h
"

32 
	~"CutTime.h
"

33 
	~"Deque.h
"

34 
	~"Funiڮ.h
"

35 
	~"StdLibExas.h
"

36 
	~<mux
>

37 
	~<wtf/NevDeroyed.h
>

38 
	~<wtf/ThadScific.h
>

40 
mea
 
	gWTF
 {

42 
	sFuniWhCڋxt
 {

43 
MaThadFuni
* 
	gfuni
;

44 * 
	gcڋxt
;

46 
FuniWhCڋxt
(
MaThadFuni
* 
funi
 = 
nuαr
, * 
cڋxt
 =ullptr)

47 : 
funi
(function)

48 , 
cڋxt
(context)

51 
bo
 
	gݔ
 =(cڡ 
FuniWhCڋxt
& 
o
)

53  
funi
 =
o
.funi && 
cڋxt
 == o.context;

57 as
	cFuniWhCڋxtFd
 {

58 
	gpublic
:

59 
FuniWhCڋxtFd
(cڡ 
FuniWhCڋxt
& 
m
) : m(m) {}

60 
bo
 
ݔ
((
FuniWhCڋxt
& 
o
{  o =
m
; }

61 
FuniWhCڋxt
 
	gm
;

65 
	gDeque
<
	tFuniWhCڋxt
> 
	tFuniQueue
;

67 
bo
 
	gbacksPaud
;

68 #i!
OS
(
DARWIN
|| 
PLATFORM
(
EFL
|| 
	$PLATFORM
(
GTK
)

69 
ThadIdtifr
 
maThadIdtifr
;

72 
d
::
mux
& 
	$maThadFuniQueueMux
()

74 
NevDeroyed
<
d
::
mux
> mutex;

76  
mux
;

77 
	}
}

79 
	gFuniQueue
& 
	$funiQueue
()

81 
NevDeroyed
<
FuniQueue
> 
funiQueue
;

82  
funiQueue
;

83 
	}
}

86 #i!
OS
(
DARWIN
|| 
PLATFORM
(
EFL
|| 
	$PLATFORM
(
GTK
)

88 
	$lizeMaThad
()

90 
bo
 
lizedMaThad
;

91 i(
lizedMaThad
)

93 
lizedMaThad
 = 
ue
;

95 
maThadIdtifr
 = 
	`cutThad
();

97 
	`maThadFuniQueueMux
();

98 
	`lizeMaThadPtfm
();

99 
	`lizeGCThads
();

100 
	}
}

104 
had__t
 
	glizeMaThadKeyOn
 = 
PTHREAD_ONCE_INIT
;

106 
	$lizeMaThadOn
()

108 
	`maThadFuniQueueMux
();

109 
	`lizeMaThadPtfm
();

110 
	}
}

112 
	$lizeMaThad
()

114 
	`had_
(&
lizeMaThadKeyOn
, 
lizeMaThadOn
);

115 
	}
}

117 #i!
	$USE
(
WEB_THREAD
)

118 
	$lizeMaThadToProssMaThadOn
()

120 
	`maThadFuniQueueMux
();

121 
	`lizeMaThadToProssMaThadPtfm
();

122 
	}
}

124 
	$lizeMaThadToProssMaThad
()

126 
	`had_
(&
lizeMaThadKeyOn
, 
lizeMaThadToProssMaThadOn
);

127 
	}
}

129 
had__t
 
	glizeWebThadKeyOn
 = 
PTHREAD_ONCE_INIT
;

131 
	$lizeWebThadOn
()

133 
	`lizeWebThadPtfm
();

134 
	}
}

136 
	$lizeWebThad
()

138 
	`had_
(&
lizeWebThadKeyOn
, 
lizeWebThadOn
);

139 
	}
}

145 cڡut
	gmaxRunLoSusiTime
 = 
d
::
chro
::
mlicds
(50);

147 
	$dichFunisFromMaThad
()

149 
	`ASSERT
(
	`isMaThad
());

151 i(
backsPaud
)

154 aut
tTime
 = 
d
::
chro
::
dy_ock
::
	`now
();

156 
FuniWhCڋxt
 
voti
;

157 
ue
) {

159 
d
::
lock_gud
<d::
mux
> 
	`lock
(
	`maThadFuniQueueMux
());

160 i(!
	`funiQueue
().
	`size
())

162 
voti
 = 
	`funiQueue
().
	`keF
();

165 
voti
.
	`funi
(voti.
cڋxt
);

171 i(
d
::
chro
::
dy_ock
::
	`now
(- 
tTime
 > 
maxRunLoSusiTime
) {

172 
	`scheduDichFunisOnMaThad
();

176 
	}
}

178 
	$OnMaThad
(
MaThadFuni
* 
funi
, * 
cڋxt
)

180 
	`ASSERT
(
funi
);

181 
bo
 
edToSchedu
 = 
l
;

183 
d
::
lock_gud
<d::
mux
> 
	`lock
(
	`maThadFuniQueueMux
());

184 
edToSchedu
 = 
	`funiQueue
().
	`size
() == 0;

185 
	`funiQueue
().
	`nd
(
	`FuniWhCڋxt
(
funi
, 
cڋxt
));

187 i(
edToSchedu
)

188 
	`scheduDichFunisOnMaThad
();

189 
	}
}

191 
	$nlClOnMaThad
(
MaThadFuni
* 
funi
, * 
cڋxt
)

193 
	`ASSERT
(
funi
);

195 
d
::
lock_gud
<d::
mux
> 
	`lock
(
	`maThadFuniQueueMux
());

197 
FuniWhCڋxtFd
 
	`ed
(
	`FuniWhCڋxt
(
funi
, 
cڋxt
));

199 
ue
) {

202 
FuniQueue
::

 
	`i
(
	`funiQueue
().
	`fdIf
(
ed
));

203 i(
i
 =
	`funiQueue
().
	`d
())

205 
	`funiQueue
().
	`move
(
i
);

207 
	}
}

209 
	$FuniObje
(* 
cڋxt
)

211 aut
funi
 = 
d
::
unique_r
<d::funi<()>>(
ic_
<d::funi<()>*>(
cڋxt
));

212 (*
funi
)();

213 
	}
}

215 
OnMaThad
(
d
::
funi
<()> function)

217 
OnMaThad
(
FuniObje
, 
d
::
make_unique
<d::
funi
<()>>(
WTF
::
move
(funi)).
a
());

220 
	$tMaThadClbacksPaud
(
bo
 
ud
)

222 
	`ASSERT
(
	`isMaThad
());

224 i(
backsPaud
 =
ud
)

227 
backsPaud
 = 
ud
;

229 i(!
backsPaud
)

230 
	`scheduDichFunisOnMaThad
();

231 
	}
}

233 #i!
OS
(
DARWIN
|| 
PLATFORM
(
EFL
|| 
	$PLATFORM
(
GTK
)

234 
bo
 
	$isMaThad
()

236  
	`cutThad
(=
maThadIdtifr
;

237 
	}
}

240 #i!
	$USE
(
WEB_THREAD
)

241 
bo
 
	$nAcssThadLolDaFThad
(
ThadIdtifr
 
thadId
)

243  
thadId
 =
	`cutThad
();

244 
	}
}

247 #i
	$ENABLE
(
PARALLEL_GC
)

248 
ThadScific
<
bo
>* 
isGCThad
;

251 
	$lizeGCThads
()

253 #i
	`ENABLE
(
PARALLEL_GC
)

254 
isGCThad
 = 
w
 
ThadScific
<
bo
>();

256 
	}
}

258 #i
	$ENABLE
(
PARALLEL_GC
)

259 
	$giGCThad
()

261 i(!
isGCThad
) {

267 **
isGCThad
 = 
ue
;

268 
	}
}

270 
bo
 
	$isMaThadOrGCThad
()

272 i(
isGCThad
->
	`isS
() && **isGCThread)

273  
ue
;

275  
	`isMaThad
();

276 
	}
}

277 #i
OS
(
DARWIN
&& !
PLATFORM
(
EFL
&& !
	$PLATFORM
(
GTK
)

279 
bo
 
	$isMaThadOrGCThad
()

281  
	`isMaThad
();

282 
	}
}

	@MainThread.h

30 #ide
MaThad_h


31 
	#MaThad_h


	)

33 
	~<funiڮ
>

34 
	~<dt.h
>

36 
mea
 
	gWTF
 {

38 
ut32_t
 
	tThadIdtifr
;

39 
	tMaThadFuni
(*);

42 
WTF_EXPORT_PRIVATE
 
lizeMaThad
();

44 
WTF_EXPORT_PRIVATE
 
OnMaThad
(
MaThadFuni
*, * 
cڋxt
);

45 
WTF_EXPORT_PRIVATE
 
nlClOnMaThad
(
MaThadFuni
*, * 
cڋxt
);

47 
WTF_EXPORT_PRIVATE
 
OnMaThad
(
d
::
funi
<()>);

49 
WTF_EXPORT_PRIVATE
 
tMaThadClbacksPaud
(
bo
 
ud
);

51 
WTF_EXPORT_PRIVATE
 
bo
 
isMaThad
();

53 
WTF_EXPORT_PRIVATE
 
bo
 
nAcssThadLolDaFThad
(
ThadIdtifr
);

55 #i
USE
(
WEB_THREAD
)

56 
WTF_EXPORT_PRIVATE
 
bo
 
isWebThad
();

57 
WTF_EXPORT_PRIVATE
 
bo
 
isUIThad
();

58 
WTF_EXPORT_PRIVATE
 
lizeWebThad
();

59 
WTF_EXPORT_PRIVATE
 
lizeAlitiUIThadIdtifr
();

60 
WTF_EXPORT_PRIVATE
 
lizeWebThadIdtifr
();

61 
lizeWebThadPtfm
();

63 
le
 
bo
 
isWebThad
({  
isMaThad
(); }

64 
le
 
bo
 
isUIThad
({  
isMaThad
(); }

67 
lizeGCThads
();

69 #i
ENABLE
(
PARALLEL_GC
)

70 
giGCThad
();

71 
WTF_EXPORT_PRIVATE
 
bo
 
isMaThadOrGCThad
();

72 #i
OS
(
DARWIN
&& !
PLATFORM
(
EFL
&& !PLATFORM(
GTK
)

73 
WTF_EXPORT_PRIVATE
 
bo
 
isMaThadOrGCThad
();

75 
le
 
bo
 
isMaThadOrGCThad
({  
isMaThad
(); }

79 
lizeMaThadPtfm
();

80 
scheduDichFunisOnMaThad
();

81 
dichFunisFromMaThad
();

83 #i
OS
(
DARWIN
&& !
PLATFORM
(
EFL
&& !PLATFORM(
GTK
)

84 #i!
USE
(
WEB_THREAD
)

88 
WTF_EXPORT_PRIVATE
 
lizeMaThadToProssMaThad
();

90 
lizeMaThadToProssMaThadPtfm
();

95 
usg
 
	gWTF
::
OnMaThad
;

96 
usg
 
	gWTF
::
nlClOnMaThad
;

97 
usg
 
	gWTF
::
tMaThadClbacksPaud
;

98 
usg
 
	gWTF
::
isMaThad
;

99 
usg
 
	gWTF
::
isMaThadOrGCThad
;

100 
usg
 
	gWTF
::
nAcssThadLolDaFThad
;

101 
usg
 
	gWTF
::
isUIThad
;

102 
usg
 
	gWTF
::
isWebThad
;

103 #i
USE
(
WEB_THREAD
)

104 
usg
 
	gWTF
::
lizeWebThad
;

105 
usg
 
	gWTF
::
lizeAlitiUIThadIdtifr
;

106 
usg
 
	gWTF
::
lizeWebThadIdtifr
;

	@MallocPtr.h

26 #ide
MlocP_h


27 
	#MlocP_h


	)

33 
mea
 
	gWTF
 {

35 
	gme
<
tyme
 
	gT
> cs
	cMlocP
 {

36 
	gpublic
:

37 
MlocP
()

38 : 
m_r
(
nuαr
)

42 
MlocP
(
d
::
nuαr_t
)

43 : 
m_r
(
nuαr
)

47 
MlocP
(MlocP&& 
h
)

48 : 
m_r
(
h
.
akP
())

52 ~
MlocP
()

54 
Fe
(
m_r
);

57 
T
* 
g
() const

59  
	gm_r
;

62 
T
 *
akP
(
	gWARN_UNUSED_RETURN


64 
T
* 
	gr
 = 
m_r
;

65 
	gm_r
 = 
nuαr
;

66  
	gr
;

69 
bo
 
	gݔ
!() const

71  !
	gm_r
;

74 
	gMlocP
& 
	gݔ
=(
MlocP
&& 
h
)

76 
MlocP
 
r
 = 
WTF
::
move
(
h
);

77 
sw
(
r
);

79  *
	gthis
;

82 
sw
(
MlocP
& 
h
)

84 
	gd
::
sw
(
m_r
, 
h
.m_ptr);

87 
	gme
<
tyme
 
	gU
> 
nd
 
	gMlocP
<U> 
adtMlocP
(
U
*);

89 
MlocP
 
mloc
(
size_t
 
size
)

91 
MlocP
 
	gmlocP
;

92 
	gmlocP
.
	gm_r
 = 
ic_
<
T
*>(
Mloc
(
size
));

94  
	gmlocP
;

97 
loc
(
size_t
 
wSize
)

99 
	gm_r
 = 
ic_
<
T
*>(
Roc
(
m_r
, 
wSize
));

102 
	give
:

103 
exic
 
MlocP
(
T
* 
r
)

104 : 
m_r
(
r
)

108 
T
* 
m_r
;

111 
	gme
<
tyme
 
	gU
> 
	gMlocP
<U> 
	$adtMlocP
(
U
* 
r
)

113  
MlocP
<
U
>(
r
);

114 
	}
}

118 
usg
 
	gWTF
::
MlocP
;

119 
usg
 
	gWTF
::
adtMlocP
;

	@MathExtras.h

26 #ide
WTF_MhExas_h


27 
	#WTF_MhExas_h


	)

29 
	~<gܙhm
>

30 
	~<cmh
>

31 
	~<t.h
>

32 
	~<lims
>

33 
	~<dt.h
>

34 
	~<dlib.h
>

35 
	~<wtf/StdLibExas.h
>

37 #i
OS
(
SOLARIS
)

38 
	~<.h
>

41 #i
OS
(
OPENBSD
)

42 
	~<sys/tys.h
>

43 
	~<mache/.h
>

46 #ide
M_PI


47 cڡ 
	gpiDoub
 = 3.14159265358979323846;

48 cڡ 
	gpiFlt
 = 3.14159265358979323846f;

50 cڡ 
	gpiDoub
 = 
M_PI
;

51 cڡ 
	gpiFlt
 = 
ic_
<>(
M_PI
);

54 #ide
M_PI_2


55 cڡ 
	gpiOvTwoDoub
 = 1.57079632679489661923;

56 cڡ 
	gpiOvTwoFlt
 = 1.57079632679489661923f;

58 cڡ 
	gpiOvTwoDoub
 = 
M_PI_2
;

59 cڡ 
	gpiOvTwoFlt
 = 
ic_
<>(
M_PI_2
);

62 #ide
M_PI_4


63 cڡ 
	gpiOvFourDoub
 = 0.785398163397448309616;

64 cڡ 
	gpiOvFourFlt
 = 0.785398163397448309616f;

66 cڡ 
	gpiOvFourDoub
 = 
M_PI_4
;

67 cڡ 
	gpiOvFourFlt
 = 
ic_
<>(
M_PI_4
);

70 #i
OS
(
DARWIN
)

73 
le
 
	$wtf_
(
x
{  
	`cysign
(
	`
(x), x); 
	}
}

75 
	#
(
x

	`wtf_
(x)

	)

79 #i
OS
(
SOLARIS
)

81 
mea
 
	gd
 {

83 #ide
isfe


84 
le
 
bo
 
isfe
(
x
{  
fe
(x&& !
id
(x); }

86 #ide
signb


87 
le
 
bo
 
signb
(
x
{  
cysign
(1.0, x) < 0; }

89 #ide
isf


90 
le
 
bo
 
isf
(
x
{  !
fe
(x&& !
id
(x); }

97 #i
OS
(
OPENBSD
)

99 
mea
 
	gd
 {

101 #ide
isfe


102 
le
 
bo
 
isfe
(
x
{  
fe
(x); }

104 #ide
signb


105 
le
 
bo
 
signb
(
x
{ 
_doub
 *
	gp
 = (_doub *)&x; ->
	gdbl_sign
; }

112 #i
COMPILER
(
MSVC
)

115 "C" 
le
 
	$wtf_2
(
x
, 
y
)

117 
posInf
 = 
d
::
numic_lims
<>::
	`fy
();

118 
gInf
 = -
d
::
numic_lims
<>::
	`fy
();

119 
n
 = 
d
::
numic_lims
<>::
	`qut_NaN
();

121 
su
 = 
n
;

123 i(
x
 =
posInf
 && 
y
 ==osInf)

124 
su
 = 
piOvFourDoub
;

125 i(
x
 =
posInf
 && 
y
 =
gInf
)

126 
su
 = 3 * 
piOvFourDoub
;

127 i(
x
 =
gInf
 && 
y
 =
posInf
)

128 
su
 = -
piOvFourDoub
;

129 i(
x
 =
gInf
 && 
y
 ==egInf)

130 
su
 = -3 * 
piOvFourDoub
;

132 
su
 = ::
	`2
(
x
, 
y
);

134  
su
;

135 
	}
}

138 "C" 
le
 
	$wtf_fmod
(
x
, 
y
{  (!
d
::
	`isf
(x&& std::isf(y)? x : 
	`fmod
(x, y); 
	}
}

141 "C" 
le
 
	$wtf_pow
(
x
, 
y
{  y =0 ? 1 : 
	`pow
(x, y); 
	}
}

143 
	#2
(
x
, 
y

	`wtf_2
(x, y)

	)

144 
	#fmod
(
x
, 
y

	`wtf_fmod
(x, y)

	)

145 
	#pow
(
x
, 
y

	`wtf_pow
(x, y)

	)

149 
le
 
	$deg2d
(
d
{  d * 
piDoub
 / 180.0; 
	}
}

150 
le
 
	$d2deg
(
r
{  * 180.0 / 
piDoub
; 
	}
}

151 
le
 
	$deg2gd
(
d
{  d * 400.0 / 360.0; 
	}
}

152 
le
 
	$gd2deg
(
g
{  g * 360.0 / 400.0; 
	}
}

153 
le
 
	$tu2deg
(
t
{  * 360.0; 
	}
}

154 
le
 
	$deg2tu
(
d
{  d / 360.0; 
	}
}

155 
le
 
	$d2gd
(
r
{  * 200.0 / 
piDoub
; 
	}
}

156 
le
 
	$gd2d
(
g
{  g * 
piDoub
 / 200.0; 
	}
}

158 
le
 
	$deg2d
(
d
{  d * 
piFlt
 / 180.0f; 
	}
}

159 
le
 
	$d2deg
(
r
{  * 180.0/ 
piFlt
; 
	}
}

160 
le
 
	$deg2gd
(
d
{  d * 400.0/ 360.0f; 
	}
}

161 
le
 
	$gd2deg
(
g
{  g * 360.0/ 400.0f; 
	}
}

162 
le
 
	$tu2deg
(
t
{  * 360.0f; 
	}
}

163 
le
 
	$deg2tu
(
d
{  d / 360.0f; 
	}
}

164 
le
 
	$d2gd
(
r
{  * 200.0/ 
piFlt
; 
	}
}

165 
le
 
	$gd2d
(
g
{  g * 
piFlt
 / 200.0f; 
	}
}

168 
me
<
tyme
 
T
> 
le
 T 
	$deuMimumFCmp
({  
d
::
numic_lims
<
T
>::
	`m
(); 
	}
}

169 
me
<> 
le
 
	$deuMimumFCmp
({  -
d
::
numic_lims
<>::
	`max
(); 
	}
}

170 
me
<> 
le
 
	$deuMimumFCmp
({  -
d
::
numic_lims
<>::
	`max
(); 
	}
}

171 
me
<
tyme
 
T
> 
le
 T 
	$deuMaximumFCmp
({  
d
::
numic_lims
<
T
>::
	`max
(); 
	}
}

173 
me
<
tyme
 
T
> 
le
 T 
ampTo
(
vue
, T 
m
 = 
deuMimumFCmp
<T>(), T 
max
 = 
deuMaximumFCmp
<T>())

175 i(
vue
 >
ic_
<>(
max
))

176  
max
;

177 i(
vue
 <
ic_
<>(
m
))

178  
m
;

179  
ic_
<
T
>(
vue
);

181 
me
<> 
le
 
ampTo
(, , );

183 
le
 
	$ampToIeg
(
vue
)

185  
ampTo
<>(
vue
);

186 
	}
}

188 
le
 
	$ampToUnsigd
(
vue
)

190  
ampTo
<>(
vue
);

191 
	}
}

193 
le
 
	$ampToFlt
(
vue
)

195  
ampTo
<>(
vue
);

196 
	}
}

198 
le
 
	$ampToPosiveIeg
(
vue
)

200  
ampTo
<>(
vue
, 0);

201 
	}
}

203 
le
 
	$ampToIeg
(
vue
)

205  
ampTo
<>(
vue
);

206 
	}
}

208 
le
 
	$ampToIeg
(
x
)

210 cڡ 
tMax
 = 
ic_
<>(
d
::
numic_lims
<>::
	`max
());

212 i(
x
 >
tMax
)

213  
d
::
numic_lims
<>::
	`max
();

214  
ic_
<>(
x
);

215 
	}
}

217 
le
 
bo
 
	$isWhIRge
(
x
)

219  
x
 > 
ic_
<>(
d
::
numic_lims
<>::
	`m
()&& x < stic_<>(d::numic_lims<>::
	`max
());

220 
	}
}

222 
	gme
<
tyme
 
	gT
> 
le
 
bo
 
	$hasOBS
(
T
 
vue
)

224  !((
vue
 - 1) & value) && value;

225 
	}
}

227 
	gme
<
tyme
 
	gT
> 
le
 
bo
 
	$hasZoOrOBsS
(
T
 
vue
)

229  !((
vue
 - 1) & value);

230 
	}
}

232 
	gme
<
tyme
 
	gT
> 
le
 
bo
 
	$hasTwoOrMeBsS
(
T
 
vue
)

234  !
	`hasZoOrOBsS
(
vue
);

235 
	}
}

237 
	gme
 <
tyme
 
	gT
> 
le
 
	$gLSBS
(
T
 
vue
)

239 
su
 = 0;

241 
vue
 >>= 1)

242 ++
su
;

244  
su
;

245 
	}
}

247 
	gme
<
tyme
 
	gT
> 
le
 
T
 
	$divideRoundedUp
(
T
 
a
, T 
b
)

249  (
a
 + 
b
 - 1) / b;

250 
	}
}

252 
	gme
<
tyme
 
	gT
> 
le
 
T
 
	$timesThePlusODividedByTwo
(
T
 
vue
)

259  
vue
 + (value >> 1) + (value & 1);

260 
	}
}

262 
	gme
<
tyme
 
	gT
> 
le
 
bo
 
	$isNZoAndOrded
(
T
 
vue
)

264  
vue
 > 0.0 || value < 0.0;

265 
	}
}

267 
	gme
<
tyme
 
	gT
> 
le
 
bo
 
	$isZoOrUnded
(
T
 
vue
)

269  !
	`isNZoAndOrded
(
vue
);

270 
	}
}

272 
	gme
<
tyme
 
	gT
> 
le
 
bo
 
	$isGThNZoPowOfTwo
(
T
 
vue
, 
pow
)

276  !!((
vue
 >> 1>> (
pow
 - 1));

277 
	}
}

279 #ide
UINT64_C


280 #i
COMPILER
(
MSVC
)

281 
	#UINT64_C
(
c
## 
ui64


	)

283 
	#UINT64_C
(
c
## 
u


	)

287 #i
COMPILER
(
MINGW64
&& (!
defed
(
__MINGW64_VERSION_RC
) || __MINGW64_VERSION_RC < 1)

288 
le
 
	$wtf_pow
(
x
, 
y
)

292 i((
x
 =0.0 || 
d
::
	`isf
(x)&& std::
	`isfe
(
y
)) {

293 
f
;

294 i(
	`modf
(
y
, &
f
) != 0.0)

295  ((
x
 =0.0^ (
y
 > 0.0)? 
d
::
numic_lims
<>::
	`fy
() : 0.0;

298 i(
x
 == 2.0) {

299 
yI
 = 
ic_
<>(
y
);

300 i(
y
 =
yI
)

301  
	`ldexp
(1.0, 
yI
);

304  
	`pow
(
x
, 
y
);

305 
	}
}

306 
	#pow
(
x
, 
y

	`wtf_pow
(x, y)

	)

313 
le
 
	$decompoDoub
(
numb
, 
bo
& 
sign
, 
t32_t
& 
expڒt
, 
ut64_t
& 
mtis
)

315 
	`ASSERT
(
d
::
	`isfe
(
numb
));

317 
sign
 = 
d
::
	`signb
(
numb
);

319 
ut64_t
 
bs
 = 
WTF
::
bwi_
<ut64_t>(
numb
);

320 
expڒt
 = (
ic_
<
t32_t
>(
bs
 >> 52) & 0x7ff) - 0x3ff;

321 
mtis
 = 
bs
 & 0xFFFFFFFFFFFFFull;

325 i(
expڒt
 == -0x3ff)

326 
expڒt
 = 
mtis
 ? -0x3fe : 0;

328 
mtis
 |= 0x10000000000000ull;

329 
	}
}

332 
le
 
	$doubToIeg
(
d
, & 
vue
)

334 i(
d
::
	`i
(
d
|| std::
	`isf
(d))

335 
vue
 = 0;

338 
fmodVue
 = 
	`fmod
(
	`unc
(
d
), 
d
::
numic_lims
<>::
	`max
() + 1.0);

339 i(
fmodVue
 >= 0) {

342 
vue
 = 
ic_
<>(
fmodVue
);

346 
fmodVueInUnsigdLgLg
 = 
ic_
<>(-
fmodVue
);

349 
vue
 = 
d
::
numic_lims
<>::
	`max
(- 
fmodVueInUnsigdLgLg
 + 1;

352 
	}
}

354 
mea
 
	gWTF
 {

357 
le
 
ut32_t
 
roundUpToPowOfTwo
(ut32_
v
)

359 
	gv
--;

360 
	gv
 |
v
 >> 1;

361 
	gv
 |
v
 >> 2;

362 
	gv
 |
v
 >> 4;

363 
	gv
 |
v
 >> 8;

364 
	gv
 |
v
 >> 16;

365 
	gv
++;

366  
	gv
;

369 
le
 
Log2
(
i
)

371 
	glog2
 = 0;

372 i(
	gi
 & (i - 1))

373 
	glog2
 += 1;

374 i(
	gi
 >> 16)

375 
	glog2
 +16, 
	gi
 >>= 16;

376 i(
	gi
 >> 8)

377 
	glog2
 +8, 
	gi
 >>= 8;

378 i(
	gi
 >> 4)

379 
	glog2
 +4, 
	gi
 >>= 4;

380 i(
	gi
 >> 2)

381 
	glog2
 +2, 
	gi
 >>= 2;

382 i(
	gi
 >> 1)

383 
	glog2
 += 1;

384  
	glog2
;

	@MediaTime.cpp

29 
	~"cfig.h
"

30 
	~"MedTime.h
"

32 
	~<gܙhm
>

33 
	~<wtf/CheckedArhmic.h
>

34 
	~<wtf/MhExas.h
>

35 
	~<wtf/PrtSm.h
>

37 
mea
 
	gWTF
 {

39 
t32_t
 
geCommDivis
(t32_
a
, i32_
b
)

42 
t32_t
 
	gmp
 = 0;

43 
	gb
) {

44 
	gmp
 = 
b
;

45 
	gb
 = 
a
 % 
b
;

46 
	ga
 = 
mp
;

48  
	ga
;

51 
t32_t
 
aCommMuɝ
(t32_
a
, i32_
b
, i32_&
su
)

53  
Muɝly
(
a
, 
b
 / 
geCommDivis
, b), 
su
);

56 
t32_t
 
signum
(
t64_t
 
v
)

58  (0 < 
	gv
) - (val < 0);

61 cڡ 
t32_t
 
	gMedTime
::
MaximumTimeS
 = 0x7fffffffL;

63 
	gMedTime
::
MedTime
()

64 : 
m_timeVue
(0)

65 , 
m_timeS
(
DeuTimeS
)

66 , 
m_timeFgs
(
Vid
)

70 
	gMedTime
::
MedTime
(
t64_t
 
vue
, 
t32_t
 
s
, 
ut32_t
 
ags
)

71 : 
m_timeVue
(
vue
)

72 , 
m_timeS
(
s
)

73 , 
m_timeFgs
(
ags
)

77 
	gMedTime
::~
MedTime
()

81 
MedTime
::MedTime(cڡ MedTime& 
rhs
)

83 *
this
 = 
rhs
;

86 
MedTime
 
	gMedTime
::
WhFlt
(
tTime
, 
t32_t
 
timeS
)

88 i(
	gtTime
 !
tTime
)

89  
vidTime
();

90 i(
	gd
::
isf
(
tTime
))

91  
d
::
signb
(
tTime
? 
giveInfeTime
(: 
posiveInfeTime
();

92 i(
	gtTime
 > 
	gd
::
numic_lims
<
t64_t
>::
max
())

93  
posiveInfeTime
();

94 i(
	gtTime
 < 
	gd
::
numic_lims
<
t64_t
>::
m
())

95  
giveInfeTime
();

97 
tTime
 * 
	gtimeS
 > 
	gd
::
numic_lims
<
t64_t
>::
max
())

98 
timeS
 /= 2;

99  
MedTime
(
ic_
<
t64_t
>(
tTime
 * 
timeS
),imeS, 
Vid
);

102 
MedTime
 
	gMedTime
::
WhDoub
(
doubTime
, 
t32_t
 
timeS
)

104 i(
	gdoubTime
 !
doubTime
)

105  
vidTime
();

106 i(
	gd
::
isf
(
doubTime
))

107  
d
::
signb
(
doubTime
? 
giveInfeTime
(: 
posiveInfeTime
();

108 i(
	gdoubTime
 > 
	gd
::
numic_lims
<
t64_t
>::
max
())

109  
posiveInfeTime
();

110 i(
	gdoubTime
 < 
	gd
::
numic_lims
<
t64_t
>::
m
())

111  
giveInfeTime
();

113 
doubTime
 * 
	gtimeS
 > 
	gd
::
numic_lims
<
t64_t
>::
max
())

114 
timeS
 /= 2;

115  
MedTime
(
ic_
<
t64_t
>(
doubTime
 * 
timeS
),imeS, 
Vid
);

118 
	gMedTime
::
toFlt
() const

120 i(
isInvid
(|| 
isIndefe
())

121  
d
::
numic_lims
<>::
qut_NaN
();

122 i(
isPosiveInfe
())

123  
	gd
::
numic_lims
<>::
fy
();

124 i(
isNegiveInfe
())

125  -
	gd
::
numic_lims
<>::
fy
();

126  
	gic_
<>(
	gm_timeVue
/ 
	gm_timeS
;

129 
	gMedTime
::
toDoub
() const

131 i(
isInvid
(|| 
isIndefe
())

132  
d
::
numic_lims
<>::
qut_NaN
();

133 i(
isPosiveInfe
())

134  
	gd
::
numic_lims
<>::
fy
();

135 i(
isNegiveInfe
())

136  -
	gd
::
numic_lims
<>::
fy
();

137  
	gic_
<>(
	gm_timeVue
/ 
	gm_timeS
;

140 
	gMedTime
& MedTime::
ݔ
=(cڡ 
MedTime
& 
rhs
)

142 
m_timeVue
 = 
rhs
.m_timeValue;

143 
	gm_timeS
 = 
rhs
.
m_timeS
;

144 
	gm_timeFgs
 = 
rhs
.
m_timeFgs
;

145  *
	gthis
;

148 
MedTime
 
	gMedTime
::
ݔ
+(cڡ MedTime& 
rhs
) const

150 i(
rhs
.
isInvid
() || isInvalid())

151  
vidTime
();

153 i(
	grhs
.
isIndefe
() || isIndefinite())

154  
defeTime
();

156 i(
isPosiveInfe
(&& 
	grhs
.
isNegiveInfe
())

157  
vidTime
();

159 i(
isNegiveInfe
(&& 
	grhs
.
isPosiveInfe
())

160  
vidTime
();

162 i(
isPosiveInfe
(|| 
	grhs
.isPositiveInfinite())

163  
posiveInfeTime
();

165 i(
isNegiveInfe
(|| 
	grhs
.isNegativeInfinite())

166  
giveInfeTime
();

168 
t32_t
 
	gcommTimeS
;

169 i(!
aCommMuɝ
(
this
->
m_timeS
, 
rhs
.m_timeS, 
commTimeS
|| 
	gcommTimeS
 > 
	gMaximumTimeS
)

170 
	gcommTimeS
 = 
MaximumTimeS
;

171 
MedTime
 
	ga
 = *
this
;

172 
MedTime
 
	gb
 = 
rhs
;

173 
	ga
.
tTimeS
(
commTimeS
);

174 
	gb
.
tTimeS
(
commTimeS
);

175 !
Add
(
a
.
m_timeVue
, 
b
.m_timeValue,.m_timeValue)) {

176 i(
	gcommTimeS
 == 1)

177  
a
.
m_timeVue
 > 0 ? 
posiveInfeTime
(: 
giveInfeTime
();

178 
	gcommTimeS
 /= 2;

179 
	ga
.
tTimeS
(
commTimeS
);

180 
	gb
.
tTimeS
(
commTimeS
);

182  
	ga
;

185 
MedTime
 
	gMedTime
::
ݔ
-(cڡ MedTime& 
rhs
) const

187 i(
rhs
.
isInvid
() || isInvalid())

188  
vidTime
();

190 i(
	grhs
.
isIndefe
() || isIndefinite())

191  
defeTime
();

193 i(
isPosiveInfe
(&& 
	grhs
.isPositiveInfinite())

194  
vidTime
();

196 i(
isNegiveInfe
(&& 
	grhs
.isNegativeInfinite())

197  
vidTime
();

199 i(
isPosiveInfe
(|| 
	grhs
.
isNegiveInfe
())

200  
posiveInfeTime
();

202 i(
isNegiveInfe
(|| 
	grhs
.
isPosiveInfe
())

203  
giveInfeTime
();

205 
t32_t
 
	gcommTimeS
;

206 i(!
aCommMuɝ
(
this
->
m_timeS
, 
rhs
.m_timeS, 
commTimeS
|| 
	gcommTimeS
 > 
	gMaximumTimeS
)

207 
	gcommTimeS
 = 
MaximumTimeS
;

208 
MedTime
 
	ga
 = *
this
;

209 
MedTime
 
	gb
 = 
rhs
;

210 
	ga
.
tTimeS
(
commTimeS
);

211 
	gb
.
tTimeS
(
commTimeS
);

212 !
Sub
(
a
.
m_timeVue
, 
b
.m_timeValue,.m_timeValue)) {

213 i(
	gcommTimeS
 == 1)

214  
a
.
m_timeVue
 > 0 ? 
posiveInfeTime
(: 
giveInfeTime
();

215 
	gcommTimeS
 /= 2;

216 
	ga
.
tTimeS
(
commTimeS
);

217 
	gb
.
tTimeS
(
commTimeS
);

219  
	ga
;

222 
MedTime
 
	gMedTime
::
ݔ
-() const

224 i(
isInvid
())

225  
vidTime
();

227 i(
isIndefe
())

228  
defeTime
();

230 i(
isPosiveInfe
())

231  
giveInfeTime
();

233 i(
isNegiveInfe
())

234  
posiveInfeTime
();

236 
MedTime
 
	ggiveTime
 = *
this
;

237 
	ggiveTime
.
	gm_timeVue
 = -
giveTime
.
m_timeVue
;

238  
	ggiveTime
;

241 
MedTime
 
	gMedTime
::
ݔ
*(
t32_t
 
rhs
) const

243 i(
isInvid
())

244  
vidTime
();

246 i(
isIndefe
())

247  
defeTime
();

249 i(!
	grhs
)

250  
zoTime
();

252 i(
isPosiveInfe
()) {

253 i(
	grhs
 > 0)

254  
posiveInfeTime
();

255  
giveInfeTime
();

258 i(
isNegiveInfe
()) {

259 i(
	grhs
 > 0)

260  
giveInfeTime
();

261  
posiveInfeTime
();

264 
MedTime
 
	ga
 = *
this
;

266 !
Muɝly
(
a
.
m_timeVue
, 
rhs
,.m_timeValue)) {

267 i(
	ga
.
	gm_timeS
 == 1)

268  
signum
(
a
.
m_timeVue
=signum(
rhs
? 
posiveInfeTime
(: 
giveInfeTime
();

269 
	ga
.
tTimeS
(
a
.
m_timeS
 / 2);

272  
	ga
;

275 
bo
 
	gMedTime
::
ݔ
<(cڡ 
MedTime
& 
rhs
) const

277  
com
(
rhs
=
LessTh
;

280 
bo
 
	gMedTime
::
ݔ
>(cڡ 
MedTime
& 
rhs
) const

282  
com
(
rhs
=
GTh
;

285 
bo
 
	gMedTime
::
ݔ
!=(cڡ 
MedTime
& 
rhs
) const

287  
com
(
rhs
!
EquTo
;

290 
bo
 
	gMedTime
::
ݔ
==(cڡ 
MedTime
& 
rhs
) const

292  
com
(
rhs
=
EquTo
;

295 
bo
 
	gMedTime
::
ݔ
>=(cڡ 
MedTime
& 
rhs
) const

297  
com
(
rhs
>
EquTo
;

300 
bo
 
	gMedTime
::
ݔ
<=(cڡ 
MedTime
& 
rhs
) const

302  
com
(
rhs
<
EquTo
;

305 
bo
 
	gMedTime
::
ݔ
!() const

307  
com
(
zoTime
()=
EquTo
;

310 
	gMedTime
::
ݔ
 
bo
() const

312  
com
(
zoTime
()!
EquTo
;

315 
	gMedTime
::
ComrisFgs
 
MedTime
::
com
(cڡ MedTime& 
rhs
) const

317 i((
isPosiveInfe
(&& 
rhs
.isPositiveInfinite())

318 || (
isNegiveInfe
(&& 
rhs
.isNegativeInfinite())

319 || (
isInvid
(&& 
rhs
.isInvalid())

320 || (
isIndefe
(&& 
rhs
.isIndefinite()))

321  
EquTo
;

323 i(
isInvid
())

324  
	gGTh
;

326 i(
	grhs
.
isInvid
())

327  
	gLessTh
;

329 i(
	grhs
.
isNegiveInfe
(|| 
isPosiveInfe
())

330  
	gGTh
;

332 i(
	grhs
.
isPosiveInfe
(|| 
isNegiveInfe
())

333  
	gLessTh
;

335 i(
isIndefe
())

336  
	gGTh
;

338 i(
	grhs
.
isIndefe
())

339  
	gLessTh
;

341 
t64_t
 
	grhsWhe
 = 
rhs
.
m_timeVue
 /hs.
m_timeS
;

342 
t64_t
 
	glhsWhe
 = 
m_timeVue
 / 
m_timeS
;

343 i(
	glhsWhe
 > 
	grhsWhe
)

344  
	gGTh
;

345 i(
	glhsWhe
 < 
	grhsWhe
)

346  
	gLessTh
;

348 
t64_t
 
	grhsRema
 = 
rhs
.
m_timeVue
 %hs.
m_timeS
;

349 
t64_t
 
	glhsRema
 = 
m_timeVue
 % 
m_timeS
;

350 
t64_t
 
	glhsFa
 = 
lhsRema
 * 
rhs
.
m_timeS
;

351 
t64_t
 
	grhsFa
 = 
rhsRema
 * 
m_timeS
;

353 i(
	glhsFa
 =
rhsFa
)

354  
EquTo
;

355  
	glhsFa
 > 
	grhsFa
 ? 
	gGTh
 : 
LessTh
;

358 cڡ 
	gMedTime
& MedTime::
zoTime
()

360 cڡ 
MedTime
* 
time
 = 
w
 MedTime(0, 1, 
Vid
);

361  *
	gtime
;

364 cڡ 
	gMedTime
& MedTime::
vidTime
()

366 cڡ 
MedTime
* 
time
 = 
w
 MediaTime(-1, 1, 0);

367  *
	gtime
;

370 cڡ 
	gMedTime
& MedTime::
posiveInfeTime
()

372 cڡ 
MedTime
* 
time
 = 
w
 MedTime(0, 1, 
PosiveInfe
 | 
Vid
);

373  *
	gtime
;

376 cڡ 
	gMedTime
& MedTime::
giveInfeTime
()

378 cڡ 
MedTime
* 
time
 = 
w
 MedTime(-1, 1, 
NegiveInfe
 | 
Vid
);

379  *
	gtime
;

382 cڡ 
	gMedTime
& MedTime::
defeTime
()

384 cڡ 
MedTime
* 
time
 = 
w
 MedTime(0, 1, 
Indefe
 | 
Vid
);

385  *
	gtime
;

388 
	gMedTime
::
tTimeS
(
t32_t
 
timeS
)

390 i(
timeS
 =
m_timeS
)

392 
	gtimeS
 = 
d
::
m
(
MaximumTimeS
, 
timeS
);

393 
t64_t
 
	gwhePt
 = 
m_timeVue
 / 
m_timeS
;

398 
t64_t
 
	gwWhePt
;

399 !
Muɝly
(
whePt
, 
timeS
, 
wWhePt
))

400 
	gtimeS
 /= 2;

402 
t64_t
 
	gmad
 = 
m_timeVue
 % 
m_timeS
;

403 
	gm_timeVue
 = 
wWhePt
 + (
mad
 * 
timeS
/ 
m_timeS
;

404 
	gm_timeS
 = 
timeS
;

407 
	gMedTime
::
dump
(
PrtSm
 &
out
) const

409 
out
.
t
("{", 
m_timeVue
, "/", 
m_timeS
, ", ", 
toDoub
(), "}");

412 
MedTime
 
abs
(cڡ MedTime& 
rhs
)

414 i(
	grhs
.
isInvid
())

415  
	gMedTime
::
vidTime
();

416 i(
	grhs
.
isNegiveInfe
(||hs.
isPosiveInfe
())

417  
	gMedTime
::
posiveInfeTime
();

418 
MedTime
 
	gv
 = 
rhs
;

419 
	gv
.
	gm_timeVue
 *
signum
(
rhs
.
m_timeS
* signumhs.
m_timeVue
);

420  
	gv
;

	@MediaTime.h

29 #ide
WTF_MedTime_h


30 
	#WTF_MedTime_h


	)

32 
	~<wtf/FaMloc.h
>

34 
	~<cmh
>

35 
	~<lims
>

36 
	~<mh.h
>

37 
	~<dt.h
>

39 
mea
 
	gWTF
 {

41 
ass
 
	gPrtSm
;

43 as
	cWTF_EXPORT_PRIVATE
 
	gMedTime
 {

44 
	gWTF_MAKE_FAST_ALLOCATED
;

45 
	gpublic
:

47 
Vid
 = 1 << 0,

48 
	gHasBnRounded
 = 1 << 1,

49 
	gPosiveInfe
 = 1 << 2,

50 
	gNegiveInfe
 = 1 << 3,

51 
	gIndefe
 = 1 << 4,

54 
MedTime
();

55 
MedTime
(
t64_t
 
vue
, 
t32_t
 
s
, 
ut32_t
 
ags
 = 
Vid
);

56 
MedTime
(cڡ MedTime& 
rhs
);

57 ~
MedTime
();

59 
MedTime
 
WhFlt
(
tTime
, 
t32_t
 
timeS
 = 
DeuTimeS
);

60 
MedTime
 
WhDoub
(
doubTime
, 
t32_t
 
timeS
 = 
DeuTimeS
);

62 
toFlt
() const;

63 
toDoub
() const;

65 
	gMedTime
& 
	gݔ
=(cڡ 
MedTime
& 
rhs
);

66 
	gMedTime
& 
	gݔ
+=(cڡ 
MedTime
& 
rhs
{  *
this
 = *this +hs; }

67 
	gMedTime
& 
	gݔ
-=(cڡ 
MedTime
& 
rhs
{  *
this
 = *this -hs; }

68 
MedTime
 
	gݔ
+(cڡ 
	gMedTime
& 
	grhs
) const;

69 
MedTime
 
	gݔ
-(cڡ 
	gMedTime
& 
	grhs
) const;

70 
MedTime
 
	gݔ
-() const;

71 
MedTime
 
	gݔ
*(
	gt32_t
) const;

72 
bo
 
	gݔ
<(cڡ 
	gMedTime
& 
	grhs
) const;

73 
bo
 
	gݔ
>(cڡ 
	gMedTime
& 
	grhs
) const;

74 
bo
 
	gݔ
!=(cڡ 
MedTime
& 
rhs
) const;

75 
bo
 
	gݔ
==(cڡ 
MedTime
& 
rhs
) const;

76 
bo
 
	gݔ
>=(cڡ 
MedTime
& 
rhs
) const;

77 
bo
 
	gݔ
<=(cڡ 
MedTime
& 
rhs
) const;

78 
bo
 
	gݔ
!() const;

79 
exic
 
ݔ
 
bo
() const;

82 
	gLessTh
 = -1,

83 
	gEquTo
 = 0,

84 
	gGTh
 = 1,

85 } 
	tComrisFgs
;

87 
ComrisFgs
 
com
(cڡ 
MedTime
& 
rhs
) const;

89 
bo
 
isVid
(cڡ {  
	gm_timeFgs
 & 
	gVid
; }

90 
bo
 
isInvid
(cڡ {  !
isVid
(); }

91 
bo
 
hasBnRounded
(cڡ {  
	gm_timeFgs
 & 
	gHasBnRounded
; }

92 
bo
 
isPosiveInfe
(cڡ {  
	gm_timeFgs
 & 
	gPosiveInfe
; }

93 
bo
 
isNegiveInfe
(cڡ {  
	gm_timeFgs
 & 
	gNegiveInfe
; }

94 
bo
 
isIndefe
(cڡ {  
	gm_timeFgs
 & 
	gIndefe
; }

96 cڡ 
	gMedTime
& 
zoTime
();

97 cڡ 
	gMedTime
& 
vidTime
();

98 cڡ 
	gMedTime
& 
posiveInfeTime
();

99 cڡ 
	gMedTime
& 
giveInfeTime
();

100 cڡ 
	gMedTime
& 
defeTime
();

102 cڡ 
	gt64_t
& 
timeVue
(cڡ {  
	gm_timeVue
; }

103 cڡ 
	gt32_t
& 
timeS
(cڡ {  
	gm_timeS
; }

105 
dump
(
PrtSm
& 
out
) const;

108 
ݔ
 (cڡ = 
de
;

109 
MedTime
(
de
;

110 
ݔ
 (cڡ = 
de
;

111 
MedTime
(
de
;

113 
nd
 
WTF_EXPORT_PRIVATE
 
MedTime
 
abs
(cڡ MedTime& 
rhs
);

114 
	give
:

115 cڡ 
t32_t
 
DeuTimeS
 = 10000000;

116 cڡ 
t32_t
 
	gMaximumTimeS
;

118 
tTimeS
(
t32_t
);

120 
t64_t
 
	gm_timeVue
;

121 
t32_t
 
	gm_timeS
;

122 
ut32_t
 
	gm_timeFgs
;

125 
le
 
MedTime
 
	gݔ
*(
t32_t
 
	glhs
, cڡ 
	gMedTime
& 
	grhs
) { hs.operator*(lhs); }

127 
WTF_EXPORT_PRIVATE
 
MedTime
 
abs
(cڡ MedTime& 
rhs
);

130 
usg
 
	gWTF
::
MedTime
;

131 
usg
 
	gWTF
::
abs
;

	@MessageQueue.h

30 #ide
MesgeQueue_h


31 
	#MesgeQueue_h


	)

33 
	~<lims
>

34 
	~<wtf/Asis.h
>

35 
	~<wtf/Deque.h
>

36 
	~<wtf/Ncyab.h
>

37 
	~<wtf/Thadg.h
>

39 
mea
 
	gWTF
 {

41 
	eMesgeQueueWaResu
 {

42 
	gMesgeQueueTmed
,

43 
	gMesgeQueueTimeout
,

44 
	gMesgeQueueMesgeReived


50 
	gme
<
tyme
 
	gDaTy
>

51 as
	cMesgeQueue
 {

52 
WTF_MAKE_NONCOPYABLE
(
MesgeQueue
);

53 
	gpublic
:

54 
MesgeQueue
(: 
m_kd
(
l
) { }

55 ~
MesgeQueue
();

57 
nd
(
d
::
unique_r
<
DaTy
>);

58 
ndAndKl
(
d
::
unique_r
<
DaTy
>);

59 
bo
 
ndAndCheckEmy
(
d
::
unique_r
<
DaTy
>);

60 
d
(
d
::
unique_r
<
DaTy
>);

62 
	gd
::
unique_r
<
DaTy
> 
waFMesge
();

63 
	gd
::
unique_r
<
DaTy
> 
yGMesge
();

64 
	gd
::
unique_r
<
DaTy
> 
yGMesgeIgnܚgKd
();

65 
	gme
<
tyme
 
	gPdi
>

66 
	gd
::
unique_r
<
DaTy
> 
waFMesgeFdWhTimeout
(
MesgeQueueWaResu
&, 
Pdi
&&, 
absuTime
);

68 
	gme
<
tyme
 
	gPdi
>

69 
moveIf
(
Pdi
&&);

71 
kl
();

72 
bo
 
kd
() const;

75 
bo
 
isEmy
();

77 
feTime
({  
	gd
::
numic_lims
<>::
max
(); }

79 
	give
:

80 
mub
 
Mux
 
m_mux
;

81 
ThadCdi
 
	gm_cdi
;

82 
	gDeque
<
	gd
::
unique_r
<
DaTy
>> 
m_queue
;

83 
bo
 
	gm_kd
;

86 
	gme
<
tyme
 
	gDaTy
>

87 
	gMesgeQueue
<
	gDaTy
>::~
	$MesgeQueue
()

89 
	}
}

91 
me
<
tyme
 
DaTy
>

92 
le
 
MesgeQueue
<
DaTy
>::
nd
(
d
::
unique_r
<DaTy> 
mesge
)

94 
MuxLock
 
lock
(
m_mux
);

95 
	gm_queue
.
nd
(
WTF
::
move
(
mesge
));

96 
	gm_cdi
.
sigl
();

99 
	gme
<
tyme
 
	gDaTy
>

100 
le
 
	gMesgeQueue
<
	gDaTy
>::
ndAndKl
(
d
::
unique_r
<
DaTy
> 
mesge
)

102 
MuxLock
 
lock
(
m_mux
);

103 
	gm_queue
.
nd
(
WTF
::
move
(
mesge
));

104 
	gm_kd
 = 
ue
;

105 
	gm_cdi
.
brd
();

109 
	gme
<
tyme
 
	gDaTy
>

110 
le
 
bo
 
	gMesgeQueue
<
	gDaTy
>::
ndAndCheckEmy
(
d
::
unique_r
<
DaTy
> 
mesge
)

112 
MuxLock
 
lock
(
m_mux
);

113 
bo
 
	gwasEmy
 = 
m_queue
.
isEmy
();

114 
	gm_queue
.
nd
(
WTF
::
move
(
mesge
));

115 
	gm_cdi
.
sigl
();

116  
	gwasEmy
;

119 
	gme
<
tyme
 
	gDaTy
>

120 
le
 
	gMesgeQueue
<
	gDaTy
>::
d
(
d
::
unique_r
<
DaTy
> 
mesge
)

122 
MuxLock
 
lock
(
m_mux
);

123 
	gm_queue
.
d
(
WTF
::
move
(
mesge
));

124 
	gm_cdi
.
sigl
();

127 
	gme
<
tyme
 
	gDaTy
>

128 
le
ut
	gMesgeQueue
<
	gDaTy
>::
waFMesge
(-> 
d
::
unique_r
<
DaTy
>

130 
MesgeQueueWaResu
 
exRs
;

131 
	gd
::
unique_r
<
DaTy
> 
su
 = 
waFMesgeFdWhTimeout
(
exRs
, [](cڡ DaTy&{  
ue
; }, 
feTime
());

132 
ASSERT
(
exRs
 =
MesgeQueueTmed
 ||xRs =
MesgeQueueMesgeReived
);

133  
	gsu
;

136 
	gme
<
tyme
 
	gDaTy
>

137 
	gme
<
tyme
 
	gPdi
>

138 
le
ut
	gMesgeQueue
<
	gDaTy
>::
waFMesgeFdWhTimeout
(
MesgeQueueWaResu
& 
su
, 
Pdi
&& 
edi
, 
absuTime
-> 
	gd
::
unique_r
<
DaTy
>

140 
MuxLock
 
lock
(
m_mux
);

141 
bo
 
	gtimedOut
 = 
l
;

143 aut
	gfound
 = 
m_queue
.
d
();

144 !
	gm_kd
 && !
	gtimedOut
) {

145 
	gfound
 = 
m_queue
.
fdIf
([&
edi
](cڡ 
d
::
unique_r
<
DaTy
>& 
r
-> 
bo
 {

146 
ASSERT
(
r
);

147  
edi
(*
r
);

149 i(
	gfound
 !
m_queue
.
d
())

152 
	gtimedOut
 = !
m_cdi
.
timedWa
(
m_mux
, 
absuTime
);

155 
ASSERT
(!
timedOut
 || 
absuTime
 !
feTime
());

157 i(
	gm_kd
) {

158 
	gsu
 = 
MesgeQueueTmed
;

159  
	gnuαr
;

162 i(
	gtimedOut
) {

163 
	gsu
 = 
MesgeQueueTimeout
;

164  
	gnuαr
;

167 
ASSERT
(
found
 !
m_queue
.
d
());

168 
	gd
::
unique_r
<
DaTy
> 
mesge
 = 
WTF
::
move
(*
found
);

169 
	gm_queue
.
move
(
found
);

170 
	gsu
 = 
MesgeQueueMesgeReived
;

171  
	gmesge
;

174 
	gme
<
tyme
 
	gDaTy
>

175 
le
ut
	gMesgeQueue
<
	gDaTy
>::
yGMesge
(-> 
d
::
unique_r
<
DaTy
>

177 
MuxLock
 
lock
(
m_mux
);

178 i(
	gm_kd
)

179  
	gnuαr
;

180 i(
	gm_queue
.
isEmy
())

181  
	gnuαr
;

183  
	gm_queue
.
keF
();

186 
	gme
<
tyme
 
	gDaTy
>

187 
le
ut
	gMesgeQueue
<
	gDaTy
>::
yGMesgeIgnܚgKd
(-> 
d
::
unique_r
<
DaTy
>

189 
MuxLock
 
lock
(
m_mux
);

190 i(
	gm_queue
.
isEmy
())

191  
	gnuαr
;

193  
	gm_queue
.
keF
();

196 
	gme
<
tyme
 
	gDaTy
>

197 
	gme
<
tyme
 
	gPdi
>

198 
le
 
	gMesgeQueue
<
	gDaTy
>::
	$moveIf
(
Pdi
&& 
edi
)

200 
MuxLock
 
	`lock
(
m_mux
);

201 
ue
) {

202 aut
found
 = 
m_queue
.
	`fdIf
([&
edi
](cڡ 
d
::
unique_r
<
DaTy
>& 
r
-> 
bo
 {

203 
	`ASSERT
(
r
);

204  
	`edi
(*
r
);

207 i(
found
 =
m_queue
.
	`d
())

210 
m_queue
.
	`move
(
found
);

212 
	}
}

214 
	gme
<
tyme
 
	gDaTy
>

215 
le
 
bo
 
	gMesgeQueue
<
	gDaTy
>::
	$isEmy
()

217 
MuxLock
 
	`lock
(
m_mux
);

218 i(
m_kd
)

219  
ue
;

220  
m_queue
.
	`isEmy
();

221 
	}
}

223 
	gme
<
tyme
 
	gDaTy
>

224 
le
 
	gMesgeQueue
<
	gDaTy
>::
	$kl
()

226 
MuxLock
 
	`lock
(
m_mux
);

227 
m_kd
 = 
ue
;

228 
m_cdi
.
	`brd
();

229 
	}
}

231 
	gme
<
tyme
 
	gDaTy
>

232 
le
 
bo
 
	gMesgeQueue
<
	gDaTy
>::
	$kd
() const

234 
MuxLock
 
	`lock
(
m_mux
);

235  
m_kd
;

236 
	}
}

239 
usg
 
	gWTF
::
MesgeQueue
;

241 
usg
 
	gWTF
::
MesgeQueueWaResu
;

242 
usg
 
	gWTF
::
MesgeQueueTmed
;

243 
usg
 
	gWTF
::
MesgeQueueTimeout
;

244 
usg
 
	gWTF
::
MesgeQueueMesgeReived
;

	@MetaAllocator.cpp

29 
	~"cfig.h
"

30 
	~"MaAot.h
"

32 
	~<wtf/DaLog.h
>

33 
	~<wtf/FaMloc.h
>

34 
	~<wtf/ProssID.h
>

36 
mea
 
	gWTF
 {

38 
	gMaAot
::~
MaAot
()

40 
FeSNode
* 
node
 = 
m_SSizeM
.
f
(); 
	gnode
;) {

41 
FeSNode
* 
	gxt
 = 
node
->
sucss
();

42 
	gm_SSizeM
.
move
(
node
);

43 
FeSNode
(
node
);

44 
	gnode
 = 
xt
;

46 
	gm_lock
.
Fize
();

47 #ide
NDEBUG


48 
ASSERT
(!
m_mlocB
);

52 
	gMaAotTck
::
nify
(
MaAotHd
* 
hd
)

54 
m_lotis
.

(
hd
);

57 
	gMaAotTck
::
a
(
MaAotHd
* 
hd
)

59 
m_lotis
.
move
(
hd
);

62 
ALWAYS_INLINE
 
	gMaAot
::
a
(
MaAotHd
* 
hd
)

64 
SpLockHd
 
lock
(&
m_lock
);

65 i(
	ghd
->
sizeInBys
()) {

66 
deemtPageOccuncy
(
hd
->
t
(), hd->
sizeInBys
());

67 
addFeSFromRdHd
(
hd
->
t
(), hd->
sizeInBys
());

70 i(
UNLIKELY
(!!
m_ack
))

71 
	gm_ack
->
a
(
hd
);

74 
	gMaAotHd
::
MaAotHd
(
MaAot
* 
lot
, * 
t
, 
size_t
 
sizeInBys
, * 
owrUID
)

75 : 
m_lot
(
lot
)

76 , 
m_t
(
t
)

77 , 
m_sizeInBys
(
sizeInBys
)

78 , 
m_owrUID
(
owrUID
)

80 
ASSERT
(
lot
);

81 
ASSERT
(
t
);

82 
ASSERT
(
sizeInBys
);

85 
	gMaAotHd
::~
MaAotHd
()

87 
ASSERT
(
m_lot
);

88 
	gm_lot
->
a
(
this
);

91 
	gMaAotHd
::
shrk
(
size_t
 
wSizeInBys
)

93 
ASSERT
(
wSizeInBys
 <
m_sizeInBys
);

95 
SpLockHd
 
lock
(&
m_lot
->
m_lock
);

97 
	gwSizeInBys
 = 
m_lot
->
roundUp
(
wSizeInBys
);

99 
ASSERT
(
wSizeInBys
 <
m_sizeInBys
);

101 i(
	gwSizeInBys
 =
m_sizeInBys
)

104 
u_t
 
	gS
 = 
t_
<u_t>(
m_t
+ 
wSizeInBys
;

105 
size_t
 
	gSize
 = 
m_sizeInBys
 - 
wSizeInBys
;

106 
u_t
 
	gEnd
 = 
S
 + 
Size
;

108 
u_t
 
	gfComyFePage
 = (
S
 + 
m_lot
->
m_geSize
 - 1) & ~(m_allocator->m_pageSize - 1);

109 i(
	gfComyFePage
 < 
	gEnd
)

110 
	gm_lot
->
deemtPageOccuncy
(
t_
<*>(
fComyFePage
), 
Size
 - (fComyFePag- 
S
));

112 
	gm_lot
->
addFeSFromRdHd
(
t_
<*>(
S
), 
Size
);

114 
	gm_sizeInBys
 = 
wSizeInBys
;

117 
	gMaAot
::
MaAot
(
size_t
 
lotiGnu
, size_
geSize
)

118 : 
m_lotiGnu
(
lotiGnu
)

119 , 
m_geSize
(
geSize
)

120 , 
m_bysAod
(0)

121 , 
m_bysRerved
(0)

122 , 
m_bysCommd
(0)

123 , 
m_ack
(0)

124 #ide
NDEBUG


125 , 
m_mlocB
(0)

127 #i
ENABLE
(
META_ALLOCATOR_PROFILE
)

128 , 
m_numAotis
(0)

129 , 
m_numFes
(0)

132 
	gm_lock
.
In
();

134 
	gm_logPageSize
 = 0; m_logPageSize < 32; ++m_logPageSize) {

135 i(
	gic_
<
	gsize_t
>(1<< 
	gm_logPageSize
 =
m_geSize
)

139 
ASSERT
(
ic_
<
size_t
>(1<< 
m_logPageSize
 =
m_geSize
);

141 
	gm_logAotiGnu
 = 0; m_logAllocationGranule < 32; ++m_logAllocationGranule) {

142 i(
	gic_
<
	gsize_t
>(1<< 
	gm_logAotiGnu
 =
m_lotiGnu
)

146 
ASSERT
(
ic_
<
size_t
>(1<< 
m_logAotiGnu
 =
m_lotiGnu
);

149 
	gPassRefP
<
	gMaAotHd
> 
	gMaAot
::
lo
(
size_t
 
sizeInBys
, * 
owrUID
)

151 
SpLockHd
 
lock
(&
m_lock
);

153 i(!
	gsizeInBys
)

156 
	gsizeInBys
 = 
roundUp
(
sizeInBys
);

158 * 
	gt
 = 
fdAndRemoveFeS
(
sizeInBys
);

159 i(!
	gt
) {

160 
size_t
 
	gqueedNumbOfPages
 = (
sizeInBys
 + 
m_geSize
 - 1>> 
m_logPageSize
;

161 
size_t
 
	gnumbOfPages
 = 
queedNumbOfPages
;

163 
	gt
 = 
loNewS
(
numbOfPages
);

164 i(!
	gt
)

167 
ASSERT
(
numbOfPages
 >
queedNumbOfPages
);

169 
size_t
 
	groundedUpSize
 = 
numbOfPages
 << 
m_logPageSize
;

171 
ASSERT
(
roundedUpSize
 >
sizeInBys
);

173 
	gm_bysRerved
 +
roundedUpSize
;

175 i(
	groundedUpSize
 > 
	gsizeInBys
) {

176 * 
	gSS
 = 
t_
<*>et_<
u_t
>(
t
+ 
sizeInBys
);

177 
size_t
 
	gSSize
 = 
roundedUpSize
 - 
sizeInBys
;

178 
addFeS
(
SS
, 
SSize
);

181 
emtPageOccuncy
(
t
, 
sizeInBys
);

182 
	gm_bysAod
 +
sizeInBys
;

183 #i
ENABLE
(
META_ALLOCATOR_PROFILE
)

184 
	gm_numAotis
++;

187 
MaAotHd
* 
	ghd
 = 
w
 MaAotHd(
this
, 
t
, 
sizeInBys
, 
owrUID
);

189 i(
UNLIKELY
(!!
m_ack
))

190 
	gm_ack
->
nify
(
hd
);

192  
adtRef
(
hd
);

195 
	gMaAot
::
Stiics
 
MaAot
::
cutStiics
()

197 
SpLockHd
 
lock
(&
m_lock
);

198 
Stiics
 
	gsu
;

199 
	gsu
.
	gbysAod
 = 
m_bysAod
;

200 
	gsu
.
	gbysRerved
 = 
m_bysRerved
;

201 
	gsu
.
	gbysCommd
 = 
m_bysCommd
;

202  
	gsu
;

205 * 
	gMaAot
::
fdAndRemoveFeS
(
size_t
 
sizeInBys
)

207 
FeSNode
* 
node
 = 
m_SSizeM
.
fdLGThOrEqu
(
sizeInBys
);

209 i(!
	gnode
)

212 
ASSERT
(
node
->
m_sizeInBys
 >
sizeInBys
);

214 
	gm_SSizeM
.
move
(
node
);

216 * 
	gsu
;

218 i(
	gnode
->
	gm_sizeInBys
 =
sizeInBys
) {

220 
su
 = 
node
->
m_t
;

222 
	gm_SSAddssM
.
move
(
node
->
m_t
);

223 
	gm_SEndAddssM
.
move
(
t_
<*>et_<
u_t
>(
node
->
m_t
+ode->
m_sizeInBys
));

224 
FeSNode
(
node
);

233 
u_t
 
	gfPage
 = 
t_
<u_t>(
node
->
m_t
>> 
m_logPageSize
;

234 
u_t
 
	gϡPage
 = (
t_
<u_t>(
node
->
m_t
+ode->
m_sizeInBys
 - 1>> 
m_logPageSize
;

236 
u_t
 
	gϡPageFLeAoti
 = (
t_
<u_t>(
node
->
m_t
+ 
sizeInBys
 - 1>> 
m_logPageSize
;

237 
u_t
 
	gfPageFRightAoti
 = (
t_
<u_t>(
node
->
m_t
+ode->
m_sizeInBys
 - 
sizeInBys
>> 
m_logPageSize
;

239 i(
	gϡPageFLeAoti
 - 
	gfPage
 + 1 <
ϡPage
 - 
fPageFRightAoti
 + 1) {

241 
su
 = 
node
->
m_t
;

243 
	gm_SSAddssM
.
move
(
node
->
m_t
);

245 
	gnode
->
	gm_sizeInBys
 -
sizeInBys
;

246 
	gnode
->
	gm_t
 = 
t_
<*>et_<
u_t
>(
node
->
m_t
+ 
sizeInBys
);

248 
	gm_SSizeM
.

(
node
);

249 
	gm_SSAddssM
.
add
(
node
->
m_t
,ode);

253 
	gsu
 = 
t_
<*>et_<
u_t
>(
node
->
m_t
+ode->
m_sizeInBys
 - 
sizeInBys
);

255 
	gm_SEndAddssM
.
move
(
t_
<*>et_<
u_t
>(
node
->
m_t
+ode->
m_sizeInBys
));

257 
	gnode
->
	gm_sizeInBys
 -
sizeInBys
;

259 
	gm_SSizeM
.

(
node
);

260 
	gm_SEndAddssM
.
add
(
su
, 
node
);

264 #i
ENABLE
(
META_ALLOCATOR_PROFILE
)

265 
dumpProfe
();

268  
	gsu
;

271 
	gMaAot
::
addFeSFromRdHd
(* 
t
, 
size_t
 
sizeInBys
)

273 #i
ENABLE
(
META_ALLOCATOR_PROFILE
)

274 
	gm_numFes
++;

276 
	gm_bysAod
 -
sizeInBys
;

277 
addFeS
(
t
, 
sizeInBys
);

280 
	gMaAot
::
addFshFeS
(* 
t
, 
size_t
 
sizeInBys
)

282 
SpLockHd
 
lock
(&
m_lock
);

283 
	gm_bysRerved
 +
sizeInBys
;

284 
addFeS
(
t
, 
sizeInBys
);

287 
size_t
 
	gMaAot
::
debugFeSSize
()

289 #ide
NDEBUG


290 
SpLockHd
 
lock
(&
m_lock
);

291 
size_t
 
	gsu
 = 0;

292 
FeSNode
* 
	gnode
 = 
m_SSizeM
.
f
();ode;od
node
->
sucss
())

293 
su
 +
node
->
m_sizeInBys
;

294  
	gsu
;

296 
CRASH
();

301 
	gMaAot
::
addFeS
(* 
t
, 
size_t
 
sizeInBys
)

303 * 
	gd
 = 
t_
<*>et_<
u_t
>(
t
+ 
sizeInBys
);

305 
	gHashM
<*, 
	gFeSNode
*>::

 
Neighb
 = 
m_SEndAddssM
.
fd
(
t
);

306 
	gHashM
<*, 
	gFeSNode
*>::

 
rightNeighb
 = 
m_SSAddssM
.
fd
(
d
);

308 i(
	gNeighb
 !
m_SEndAddssM
.
d
()) {

312 
ASSERT
(
t_
<*>et_<
u_t
>(
Neighb
->
vue
->
m_t
+eNeighb->vue->
m_sizeInBys
=Neighb->
key
);

314 
FeSNode
* 
	gNode
 = 
Neighb
->
vue
;

316 * 
	gS
 = 
Node
->
m_t
;

317 
size_t
 
	gSize
 = 
Node
->
m_sizeInBys
;

318 * 
	gEnd
 = 
t_
<*>et_<
u_t
>(
S
+ 
Size
);

320 
ASSERT
(
End
 =
t
);

322 
	gm_SSizeM
.
move
(
Node
);

323 
	gm_SEndAddssM
.
move
(
End
);

326 i(
	grightNeighb
 !
m_SSAddssM
.
d
()) {

330 
ASSERT
(
rightNeighb
->
vue
->
m_t
 =rightNeighb->
key
);

332 
FeSNode
* 
	grightNode
 = 
rightNeighb
->
vue
;

333 * 
	grightS
 = 
rightNeighb
->
key
;

334 
size_t
 
	grightSize
 = 
rightNode
->
m_sizeInBys
;

335 * 
	grightEnd
 = 
t_
<*>et_<
u_t
>(
rightS
+ 
rightSize
);

337 
ASSERT
(
rightS
 =
d
);

338 
ASSERT
(
t_
<*>et_<
u_t
>(
S
+ 
Size
 + 
sizeInBys
 + 
rightSize
=
rightEnd
);

340 
	gm_SSizeM
.
move
(
rightNode
);

341 
	gm_SSAddssM
.
move
(
rightS
);

342 
	gm_SEndAddssM
.
move
(
rightEnd
);

344 
FeSNode
(
rightNode
);

346 
	gNode
->
	gm_sizeInBys
 +
sizeInBys
 + 
rightSize
;

348 
	gm_SSizeM
.

(
Node
);

349 
	gm_SEndAddssM
.
add
(
rightEnd
, 
Node
);

351 
	gNode
->
	gm_sizeInBys
 +
sizeInBys
;

353 
	gm_SSizeM
.

(
Node
);

354 
	gm_SEndAddssM
.
add
(
d
, 
Node
);

359 i(
	grightNeighb
 !
m_SSAddssM
.
d
()) {

360 
FeSNode
* 
rightNode
 = 
rightNeighb
->
vue
;

361 * 
	grightS
 = 
rightNeighb
->
key
;

362 
size_t
 
	grightSize
 = 
rightNode
->
m_sizeInBys
;

363 * 
	grightEnd
 = 
t_
<*>et_<
u_t
>(
rightS
+ 
rightSize
);

365 
ASSERT
(
rightS
 =
d
);

366 
ASSERT_UNUSED
(
rightEnd
, 
t_
<*>et_<
u_t
>(
t
+ 
sizeInBys
 + 
rightSize
) ==ightEnd);

368 
	gm_SSizeM
.
move
(
rightNode
);

369 
	gm_SSAddssM
.
move
(
rightS
);

371 
	grightNode
->
	gm_sizeInBys
 +
sizeInBys
;

372 
	grightNode
->
	gm_t
 = 
t
;

374 
	gm_SSizeM
.

(
rightNode
);

375 
	gm_SSAddssM
.
add
(
t
, 
rightNode
);

379 
FeSNode
* 
	gnode
 = 
locFeSNode
();

381 
	gnode
->
	gm_sizeInBys
 = 
sizeInBys
;

382 
	gnode
->
	gm_t
 = 
t
;

384 
	gm_SSizeM
.

(
node
);

385 
	gm_SSAddssM
.
add
(
t
, 
node
);

386 
	gm_SEndAddssM
.
add
(
d
, 
node
);

390 #i
ENABLE
(
META_ALLOCATOR_PROFILE
)

391 
dumpProfe
();

395 
	gMaAot
::
emtPageOccuncy
(* 
addss
, 
size_t
 
sizeInBys
)

397 
u_t
 
	gfPage
 = 
t_
<u_t>(
addss
>> 
m_logPageSize
;

398 
u_t
 
	gϡPage
 = (
t_
<u_t>(
addss
+ 
sizeInBys
 - 1>> 
m_logPageSize
;

400 
u_t
 
	gge
 = 
fPage
;ag<
ϡPage
; ++page) {

401 
	gHashM
<
	gu_t
, 
	gsize_t
>::

 

 = 
m_geOccuncyM
.
fd
(
ge
);

402 i(
	g
 =
m_geOccuncyM
.
d
()) {

403 
m_geOccuncyM
.
add
(
ge
, 1);

404 
	gm_bysCommd
 +
m_geSize
;

405 
nifyNdPage
(
t_
<*>(
ge
 << 
m_logPageSize
));

407 
	g
->
	gvue
++;

411 
	gMaAot
::
deemtPageOccuncy
(* 
addss
, 
size_t
 
sizeInBys
)

413 
u_t
 
	gfPage
 = 
t_
<u_t>(
addss
>> 
m_logPageSize
;

414 
u_t
 
	gϡPage
 = (
t_
<u_t>(
addss
+ 
sizeInBys
 - 1>> 
m_logPageSize
;

416 
u_t
 
	gge
 = 
fPage
;ag<
ϡPage
; ++page) {

417 
	gHashM
<
	gu_t
, 
	gsize_t
>::

 

 = 
m_geOccuncyM
.
fd
(
ge
);

418 
ASSERT
(

 !
m_geOccuncyM
.
d
());

419 i(!--(
	g
->
	gvue
)) {

420 
	gm_geOccuncyM
.
move
(

);

421 
	gm_bysCommd
 -
m_geSize
;

422 
nifyPageIsFe
(
t_
<*>(
ge
 << 
m_logPageSize
));

427 
size_t
 
	gMaAot
::
roundUp
(size_
sizeInBys
)

429 i(
d
::
numic_lims
<
size_t
>::
max
(- 
m_lotiGnu
 <
sizeInBys
)

430 
CRASH
();

431  (
	gsizeInBys
 + 
	gm_lotiGnu
 - 1) & ~(m_allocationGranule - 1);

434 
	gMaAot
::
FeSNode
* 
MaAot
::
locFeSNode
()

436 #ide
NDEBUG


437 
m_mlocB
++;

439  
w
 (
NNu
, 
Mloc
((
FeSNode
))) FreeSpaceNode(0, 0);

442 
	gMaAot
::
FeSNode
(
FeSNode
* 
node
)

444 #ide
NDEBUG


445 
m_mlocB
--;

447 
Fe
(
node
);

450 #i
ENABLE
(
META_ALLOCATOR_PROFILE
)

451 
	gMaAot
::
dumpProfe
()

453 
daLogF
(

455 
gCutProssID
(), 
this
, 
m_numAotis
, 
m_numFes
, 
m_bysAod
, 
m_bysRerved
, 
m_bysCommd
);

	@MetaAllocator.h

29 #ide
WTF_MaAot_h


30 
	#WTF_MaAot_h


	)

32 
	~<wtf/Asis.h
>

33 
	~<wtf/HashM.h
>

34 
	~<wtf/MaAotHd.h
>

35 
	~<wtf/Ncyab.h
>

36 
	~<wtf/PageBlock.h
>

37 
	~<wtf/RedBckTe.h
>

38 
	~<wtf/RefCoued.h
>

39 
	~<wtf/RefP.h
>

40 
	~<wtf/TCSpLock.h
>

42 
mea
 
	gWTF
 {

44 
	#ENABLE_META_ALLOCATOR_PROFILE
 0

	)

46 as
	cMaAotTck
 {

47 
	gWTF_MAKE_FAST_ALLOCATED
;

48 
	gpublic
:

49 
nify
(
MaAotHd
*);

50 
a
(
MaAotHd
*);

52 
MaAotHd
* 
fd
(* 
addss
)

54 
MaAotHd
* 
	ghd
 = 
m_lotis
.
fdGeLessThOrEqu
(
addss
);

55 i(
	ghd
 && 
	gaddss
 < hd->
d
())

56  
	ghd
;

60 
	gRedBckTe
<
	gMaAotHd
, *> 
	gm_lotis
;

63 as
	cMaAot
 {

64 
WTF_MAKE_NONCOPYABLE
(
MaAot
);

66 
	gpublic
:

67 
WTF_EXPORT_PRIVATE
 
MaAot
(
size_t
 
lotiGnu
, size_
geSize
 = 
WTF
::pageSize());

69 
WTF_EXPORT_PRIVATE
 
	gvtu
 ~
MaAot
();

71 
WTF_EXPORT_PRIVATE
 
	gPassRefP
<
	gMaAotHd
> 
lo
(
size_t
 
sizeInBys
, * 
owrUID
);

73 
ackAotis
(
MaAotTck
* 
ack
)

75 
	gm_ack
 = 
ack
;

79 
size_t
 
bysAod
({  
	gm_bysAod
; }

80 
size_t
 
bysRerved
({  
	gm_bysRerved
; }

81 
size_t
 
bysCommd
({  
	gm_bysCommd
; }

84 
	sStiics
 {

85 
size_t
 
	gbysAod
;

86 
size_t
 
	gbysRerved
;

87 
size_t
 
	gbysCommd
;

89 
Stiics
 
cutStiics
();

94 
WTF_EXPORT_PRIVATE
 
addFshFeS
(* 
t
, 
size_t
 
sizeInBys
);

98 
WTF_EXPORT_PRIVATE
 
size_t
 
debugFeSSize
();

100 #i
ENABLE
(
META_ALLOCATOR_PROFILE
)

101 
dumpProfe
();

103 
dumpProfe
() { }

106 
	geed
:

110 
vtu
 * 
loNewS
(
size_t
& 
numPages
) = 0;

113 
vtu
 
nifyNdPage
(* 
ge
) = 0;

116 
vtu
 
nifyPageIsFe
(* 
ge
) = 0;

122 
	give
:

124 
nd
 
ass
 
MaAotHd
;

126 
ass
 
	gFeSNode
 : 
public
 
RedBckTe
<
FeSNode
, 
	gsize_t
>::
Node
 {

127 
public
:

128 
FeSNode
(* 
t
, 
size_t
 
sizeInBys
)

129 : 
m_t
(
t
)

130 , 
m_sizeInBys
(
sizeInBys
)

134 
size_t
 
key
()

136  
	gm_sizeInBys
;

139 * 
	gm_t
;

140 
size_t
 
	gm_sizeInBys
;

142 
	gRedBckTe
<
	tFeSNode
, 
	tsize_t
> 
	tTe
;

145 
a
(
MaAotHd
*);

150 * 
fdAndRemoveFeS
(
size_t
 
sizeInBys
);

153 
addFeSFromRdHd
(* 
t
, 
size_t
 
sizeInBys
);

158 
addFeS
(* 
t
, 
size_t
 
sizeInBys
);

162 
emtPageOccuncy
(* 
addss
, 
size_t
 
sizeInBys
);

163 
deemtPageOccuncy
(* 
addss
, 
size_t
 
sizeInBys
);

167 
size_t
 
roundUp
(size_
sizeInBys
);

169 
FeSNode
* 
locFeSNode
();

170 
WTF_EXPORT_PRIVATE
 
FeSNode
(
FeSNode
*);

172 
size_t
 
	gm_lotiGnu
;

173 
	gm_logAotiGnu
;

174 
size_t
 
	gm_geSize
;

175 
	gm_logPageSize
;

177 
Te
 
	gm_SSizeM
;

178 
	gHashM
<*, 
	gFeSNode
*> 
	gm_SSAddssM
;

179 
	gHashM
<*, 
	gFeSNode
*> 
	gm_SEndAddssM
;

180 
	gHashM
<
	gu_t
, 
	gsize_t
> 
	gm_geOccuncyM
;

182 
size_t
 
	gm_bysAod
;

183 
size_t
 
	gm_bysRerved
;

184 
size_t
 
	gm_bysCommd
;

186 
SpLock
 
	gm_lock
;

188 
MaAotTck
* 
	gm_ack
;

190 #ide
NDEBUG


191 
size_t
 
	gm_mlocB
;

194 #i
ENABLE
(
META_ALLOCATOR_PROFILE
)

195 
	gm_numAotis
;

196 
	gm_numFes
;

	@MetaAllocatorHandle.h

29 #ide
WTF_MaAotHd_h


30 
	#WTF_MaAotHd_h


	)

32 
	~<wtf/Asis.h
>

33 
	~<wtf/RedBckTe.h
>

34 
	~<wtf/ThadSaRefCoued.h
>

35 
	~<wtf/RefP.h
>

37 
mea
 
	gWTF
 {

39 
ass
 
	gMaAot
;

41 
ass
 
	gMaAotHd
 : 
public
 
ThadSaRefCoued
<
MaAotHd
>,ubli
	gRedBckTe
<MaAotHd, *>::
Node
 {

42 
ive
:

43 
MaAotHd
(
MaAot
*, * 
t
, 
size_t
 
sizeInBys
, * 
owrUID
);

45 
	gpublic
:

46 
WTF_EXPORT_PRIVATE
 ~
MaAotHd
();

48 * 
t
() const

50  
	gm_t
;

53 * 
d
() const

55  
	gt_
<*>(
dAsIeg
());

58 
u_t
 
tAsIeg
() const

60  
	gt_
<
	gu_t
>(
	gm_t
);

63 
u_t
 
dAsIeg
() const

65  
tAsIeg
(+ 
	gm_sizeInBys
;

68 
size_t
 
sizeInBys
() const

70  
	gm_sizeInBys
;

73 
bo
 
cڏsIegAddss
(
u_t
 
addss
) const

75  
	gaddss
 - 
tAsIeg
(< 
sizeInBys
();

78 
bo
 
cڏs
(* 
addss
) const

80  
cڏsIegAddss
(
t_
<
u_t
>(
addss
));

83 
WTF_EXPORT_PRIVATE
 
shrk
(
size_t
 
wSizeInBys
);

85 
bo
 
isMaged
()

87  !!
	gm_lot
;

90 
MaAot
* 
lot
()

92 
ASSERT
(
m_lot
);

93  
	gm_lot
;

96 * 
owrUID
()

98  
	gm_owrUID
;

101 * 
key
()

103  
	gm_t
;

106 
	give
:

107 
nd
 
ass
 
MaAot
;

109 
MaAot
* 
	gm_lot
;

110 * 
	gm_t
;

111 
size_t
 
	gm_sizeInBys
;

112 * 
	gm_owrUID
;

	@NeverDestroyed.h

26 #ide
NevDeroyed_h


27 
	#NevDeroyed_h


	)

29 
	~<ty_as
>

30 
	~<uty
>

31 
	~<wtf/Ncyab.h
>

32 
	~<wtf/RefCoued.h
>

44 
mea
 
	gWTF
 {

46 
	gme
<
tyme
 
	gT
> cs
	cNevDeroyed
 {

47 
WTF_MAKE_NONCOPYABLE
(
NevDeroyed
);

49 
	gpublic
:

50 
me
<
tyme
... 
Args
>

51 
NevDeroyed
(
Args
&&... 
gs
)

53 
MaybeRax
<
T
>(
w
 (
asP
()T(
d
::
fwd
<
Args
>(
gs
)...));

56 
ݔ
 
	gT
&({  *
asP
(); }

57 
	gT
& 
g
({  *
asP
(); }

59 
	give
:

60 
tyme
 
	td
::
	tmove_cڡ
<
	tT
>::
	tty
* 
	tPorTy
;

62 
PorTy
 
asP
({  
	gt_
<
	gPorTy
>(&
	gm_age
); }

66 
tyme
 
	gd
::
igd_age
<(
T
), std::
ignmt_of
<T>::
vue
>::
ty
 
m_age
;

68 
	gme
 <
tyme
 
	gPTy
, 
bo
 
	gShouldRax
 = 
d
::
is_ba_of
<
RefCoued
<
PTy
>, PTy>::
vue
> 
	sMaybeRax
 {

69 
exic
 
MaybeRax
(
PTy
*) { }

71 
	gme
 <
tyme
 
	gPTy
> 
	gMaybeRax
<PTy, 
	gue
> {

72 
exic
 
MaybeRax
(
PTy
* 
r
{ 
	gr
->
xAdtiRequemt
(); }

76 
	gme
<
tyme
 
	gT
> cs
	cLazyNevDeroyed
 {

77 
WTF_MAKE_NONCOPYABLE
(
LazyNevDeroyed
);

79 
	gpublic
:

80 
LazyNevDeroyed
() = ;

82 
	gme
<
	gtyme
... 
	gArgs
>

83 
cڡru
(
Args
&&... 
gs
)

85 
ASSERT
(!
m_isCڡrued
);

87 #i!
ASSERT_DISABLED


88 
	gm_isCڡrued
 = 
ue
;

91 
	gMaybeRax
<
	gT
>(
w
 (
asP
()
T
(
d
::
fwd
<
Args
>(
gs
)...));

94 
ݔ
 
	gT
&({  *
asP
(); }

95 
	gT
& 
g
({  *
asP
(); }

97 
	give
:

98 
tyme
 
	td
::
	tmove_cڡ
<
	tT
>::
	tty
* 
	tPorTy
;

100 
PorTy
 
asP
()

102 
ASSERT
(
m_isCڡrued
);

104  
	gt_
<
	gPorTy
>(&
	gm_age
);

109 
tyme
 
	gd
::
igd_age
<(
T
), std::
ignmt_of
<T>::
vue
>::
ty
 
m_age
;

111 
	gme
 <
tyme
 
	gPTy
, 
bo
 
	gShouldRax
 = 
d
::
is_ba_of
<
RefCoued
<
PTy
>, PTy>::
vue
> 
	sMaybeRax
 {

112 
exic
 
MaybeRax
(
PTy
*) { }

114 
	gme
 <
tyme
 
	gPTy
> 
	gMaybeRax
<PTy, 
	gue
> {

115 
exic
 
MaybeRax
(
PTy
* 
r
{ 
	gr
->
xAdtiRequemt
(); }

118 #i!
ASSERT_DISABLED


119 
bo
 
	gm_isCڡrued
 = 
l
;

125 
usg
 
	gWTF
::
LazyNevDeroyed
;

126 
usg
 
	gWTF
::
NevDeroyed
;

	@NoLock.h

26 #ide
NoLock_h


27 
	#NoLock_h


	)

29 
	~<wtf/Lock.h
>

31 
mea
 
	gWTF
 {

33 as
	cNoLock
 {

34 
	gpublic
:

35 
lock
() { }

36 
uock
() { }

37 
bo
 
isHd
({  
l
; }

40 
	gLock
<
	tNoLock
> 
	tNoLockLock
;

44 
usg
 
	gWTF
::
NoLock
;

45 
usg
 
	gWTF
::
NoLockLock
;

	@Noncopyable.h

21 #ide
WTF_Ncyab_h


22 
	#WTF_Ncyab_h


	)

24 
	#WTF_MAKE_NONCOPYABLE
(
CssName
) \

25 
ive
: \

26 
	`CssName
(cڡ 
CssName
&
de
; \

27 
CssName
& 
ݔ
=(cڡ CssName&
de
; \

28 

	)

	@NumberOfCores.cpp

26 
	~"cfig.h
"

27 
	~"NumbOfCes.h
"

29 #i
OS
(
DARWIN
)

30 
	~<sys/m.h
>

33 
	~<sys/tys.h
>

34 
	~<sys/sysl.h
>

35 #i
OS
(
LINUX
|| OS(
AIX
|| OS(
SOLARIS
|| OS(
OPENBSD
|| OS(
NETBSD
|| OS(
FREEBSD
)

36 
	~<unid.h
>

37 #i
OS
(
WINDOWS
)

38 
	~<wdows.h
>

41 
mea
 
	gWTF
 {

43 
numbOfProssCes
()

45 cڡ 
	gdeuIfUvaab
 = 1;

46 
	gs_numbOfCes
 = -1;

48 i(
	gs_numbOfCes
 > 0)

49  
	gs_numbOfCes
;

51 #i
OS
(
DARWIN
)

52 
	gsu
;

53 
size_t
 
	gngth
 = (
su
);

54 
	gme
[] = {

55 
CTL_HW
,

56 
HW_AVAILCPU


58 
	gsyslResu
 = 
sysl
(
me
, ame/ (), &
su
, &
ngth
, 0, 0);

60 
	gs_numbOfCes
 = 
syslResu
 < 0 ? 
deuIfUvaab
 : 
su
;

61 #i
OS
(
LINUX
|| OS(
AIX
|| OS(
SOLARIS
|| OS(
OPENBSD
|| OS(
NETBSD
|| OS(
FREEBSD
)

62 
	gsyscfResu
 = 
syscf
(
_SC_NPROCESSORS_ONLN
);

64 
	gs_numbOfCes
 = 
syscfResu
 < 0 ? 
deuIfUvaab
 : 
ic_
<>(sysconfResult);

65 #i
OS
(
WINDOWS
)

66 
UNUSED_PARAM
(
deuIfUvaab
);

67 
SYSTEM_INFO
 
	gsysInfo
;

68 
GSyemInfo
(&
sysInfo
);

70 
	gs_numbOfCes
 = 
sysInfo
.
dwNumbOfProsss
;

72 
	gs_numbOfCes
 = 
deuIfUvaab
;

74  
	gs_numbOfCes
;

	@NumberOfCores.h

21 #ide
NumbOfCes_h


22 
	#NumbOfCes_h


	)

24 
mea
 
	gWTF
 {

26 
WTF_EXPORT_PRIVATE
 
numbOfProssCes
();

	@OSAllocator.h

26 #ide
OSAot_h


27 
	#OSAot_h


	)

29 
	~<gܙhm
>

30 
	~<wtf/VMTags.h
>

32 
mea
 
	gWTF
 {

34 as
	cOSAot
 {

35 
	gpublic
:

36 
	eUge
 {

37 
UnknownUge
 = -1,

38 
	gFaMlocPages
 = 
VM_TAG_FOR_TCMALLOC_MEMORY
,

39 
	gJSGCHpPages
 = 
VM_TAG_FOR_COLLECTOR_MEMORY
,

40 
	gJSVMSckPages
 = 
VM_TAG_FOR_REGISTERFILE_MEMORY
,

41 
	gJSJITCodePages
 = 
VM_TAG_FOR_EXECUTABLEALLOCATOR_MEMORY
,

47 
WTF_EXPORT_PRIVATE
 * 
rveUncommd
(
size_t
, 
Uge
 = 
UnknownUge
, 
bo
 
wrab
 = 
ue
, bo 
execub
 = 
l
, bo 
udesGudPages
 = false);

48 
WTF_EXPORT_PRIVATE
 
aDecommd
(*, 
size_t
);

53 
WTF_EXPORT_PRIVATE
 
comm
(*, 
size_t
, 
bo
 
wrab
, bo 
execub
);

54 
WTF_EXPORT_PRIVATE
 
decomm
(*, 
size_t
);

59 
WTF_EXPORT_PRIVATE
 * 
rveAndComm
(
size_t
, 
Uge
 = 
UnknownUge
, 
bo
 
wrab
 = 
ue
, bo 
execub
 = 
l
, bo 
udesGudPages
 = false);

60 
decommAndR
(* 
ba
, 
size_t
 
size
);

65 
WTF_EXPORT_PRIVATE
 * 
rveAndComm
(
size_t
 
rveSize
, size_
commSize
, 
Uge
 = 
UnknownUge
, 
bo
 
wrab
 = 
ue
, bo 
execub
 = 
l
);

70 
	gme
<
tyme
 
	gT
>

71 
T
* 
loCommd
(T*, 
size_t
 
dSize
, size_
wSize
, 
Uge
 = 
UnknownUge
, 
bo
 
wrab
 = 
ue
, bo 
execub
 = 
l
);

74 
le
 * 
	gOSAot
::
	$rveAndComm
(
size_t
 
rveSize
, size_
commSize
, 
Uge
 
uge
, 
bo
 
wrab
, bo 
execub
)

76 * 
ba
 = 
	`rveUncommd
(
rveSize
, 
uge
, 
wrab
, 
execub
);

77 
	`comm
(
ba
, 
commSize
, 
wrab
, 
execub
);

78  
ba
;

79 
	}
}

81 
le
 
	gOSAot
::
	$decommAndR
(* 
aBa
, 
size_t
 
aSize
)

83 
	`aDecommd
(
aBa
, 
aSize
);

84 
	}
}

86 
	gme
<
tyme
 
	gT
>

87 
le
 
T
* 
	gOSAot
::
	$loCommd
(
T
* 
dBa
, 
size_t
 
dSize
, size_
wSize
, 
Uge
 
uge
, 
bo
 
wrab
, bo 
execub
)

89 * 
wBa
 = 
	`rveAndComm
(
wSize
, 
uge
, 
wrab
, 
execub
);

90 
	`memy
(
wBa
, 
dBa
, 
d
::
	`m
(
dSize
, 
wSize
));

91 
	`decommAndR
(
dBa
, 
dSize
);

92  
ic_
<
T
*>(
wBa
);

93 
	}
}

97 
usg
 
	gWTF
::
OSAot
;

	@OSAllocatorPosix.cpp

26 
	~"cfig.h
"

27 
	~"OSAot.h
"

29 #i
OS
(
UNIX
)

31 
	~"PageAoti.h
"

32 
	~<o.h
>

33 
	~<sys/mm.h
>

34 
	~<wtf/Asis.h
>

36 
mea
 
	gWTF
 {

38 * 
	gOSAot
::
rveUncommd
(
size_t
 
bys
, 
Uge
 
uge
, 
bo
 
wrab
, bo 
execub
, bo 
udesGudPages
)

40 #i
OS
(
LINUX
)

41 
UNUSED_PARAM
(
uge
);

42 
UNUSED_PARAM
(
wrab
);

43 
UNUSED_PARAM
(
execub
);

44 
UNUSED_PARAM
(
udesGudPages
);

46 * 
	gsu
 = 
mm
(0, 
bys
, 
PROT_NONE
, 
MAP_NORESERVE
 | 
MAP_PRIVATE
 | 
MAP_ANON
, -1, 0);

47 i(
	gsu
 =
MAP_FAILED
)

48 
CRASH
();

49 
madvi
(
su
, 
bys
, 
MADV_DONTNEED
);

51 * 
	gsu
 = 
rveAndComm
(
bys
, 
uge
, 
wrab
, 
execub
, 
udesGudPages
);

52 #i
HAVE
(
MADV_FREE_REUSE
)

54 
madvi
(
su
, 
bys
, 
MADV_FREE_REUSABLE
=-1 && 
o
 =
EAGAIN
) { }

59  
su
;

62 * 
	gOSAot
::
rveAndComm
(
size_t
 
bys
, 
Uge
 
uge
, 
bo
 
wrab
, bo 
execub
, bo 
udesGudPages
)

65 
	gei
 = 
PROT_READ
;

66 i(
	gwrab
)

67 
	gei
 |
PROT_WRITE
;

68 i(
	gexecub
)

69 
	gei
 |
PROT_EXEC
;

71 
	gags
 = 
MAP_PRIVATE
 | 
MAP_ANON
;

72 #i
PLATFORM
(
IOS
)

73 i(
	gexecub
)

74 
	gags
 |
MAP_JIT
;

77 #i
OS
(
DARWIN
)

78 
	gfd
 = 
uge
;

80 
UNUSED_PARAM
(
uge
);

81 
	gfd
 = -1;

84 * 
	gsu
 = 0;

85 #i(
OS
(
DARWIN
&& 
CPU
(
X86_64
))

86 i(
	gexecub
) {

87 
ASSERT
(
udesGudPages
);

97 
_t
 
	gndomLoti
 = 0;

98 
	gndomLoti
 = 
c4ndom
() & ((1 << 25) - 1);

99 
	gndomLoti
 += (1 << 24);

100 
	gndomLoti
 <<= 21;

101 
	gsu
 = 
t_
<*>(
ndomLoti
);

105 
	gsu
 = 
mm
(
su
, 
bys
, 
ei
, 
ags
, 
fd
, 0);

106 i(
	gsu
 =
MAP_FAILED
) {

107 i(
execub
)

108 
su
 = 0;

110 
CRASH
();

112 i(
	gsu
 && 
	gudesGudPages
) {

117 
mm
(
su
, 
geSize
(), 
PROT_NONE
, 
MAP_FIXED
 | 
MAP_PRIVATE
 | 
MAP_ANON
, 
fd
, 0);

118 
mm
(
ic_
<*>(
su
+ 
bys
 - 
geSize
(),ageSize(), 
PROT_NONE
, 
MAP_FIXED
 | 
MAP_PRIVATE
 | 
MAP_ANON
, 
fd
, 0);

120  
	gsu
;

123 
	gOSAot
::
comm
(* 
addss
, 
size_t
 
bys
, 
bo
 
wrab
, bo 
execub
)

125 #i
OS
(
LINUX
)

126 
	gei
 = 
PROT_READ
;

127 i(
	gwrab
)

128 
	gei
 |
PROT_WRITE
;

129 i(
	gexecub
)

130 
	gei
 |
PROT_EXEC
;

131 i(
me
(
addss
, 
bys
, 
ei
))

132 
CRASH
();

133 
madvi
(
addss
, 
bys
, 
MADV_WILLNEED
);

134 #i
HAVE
(
MADV_FREE_REUSE
)

135 
UNUSED_PARAM
(
wrab
);

136 
UNUSED_PARAM
(
execub
);

137 
madvi
(
addss
, 
bys
, 
MADV_FREE_REUSE
=-1 && 
o
 =
EAGAIN
) { }

140 
UNUSED_PARAM
(
addss
);

141 
UNUSED_PARAM
(
bys
);

142 
UNUSED_PARAM
(
wrab
);

143 
UNUSED_PARAM
(
execub
);

147 
	gOSAot
::
decomm
(* 
addss
, 
size_t
 
bys
)

149 #i
OS
(
LINUX
)

150 
madvi
(
addss
, 
bys
, 
MADV_DONTNEED
);

151 i(
me
(
addss
, 
bys
, 
PROT_NONE
))

152 
CRASH
();

153 #i
HAVE
(
MADV_FREE_REUSE
)

154 
madvi
(
addss
, 
bys
, 
MADV_FREE_REUSABLE
=-1 && 
o
 =
EAGAIN
) { }

155 #i
HAVE
(
MADV_FREE
)

156 
madvi
(
addss
, 
bys
, 
MADV_FREE
=-1 && 
o
 =
EAGAIN
) { }

157 #i
HAVE
(
MADV_DONTNEED
)

158 
madvi
(
addss
, 
bys
, 
MADV_DONTNEED
=-1 && 
o
 =
EAGAIN
) { }

160 
UNUSED_PARAM
(
addss
);

161 
UNUSED_PARAM
(
bys
);

165 
	gOSAot
::
aDecommd
(* 
addss
, 
size_t
 
bys
)

167 
	gsu
 = 
munm
(
addss
, 
bys
);

168 i(
	gsu
 == -1)

169 
CRASH
();

	@OSAllocatorWin.cpp

26 
	~"cfig.h
"

27 
	~"OSAot.h
"

29 #i
OS
(
WINDOWS
)

31 
	~"wdows.h
"

32 
	~<wtf/Asis.h
>

34 
mea
 
	gWTF
 {

36 
le
 
DWORD
 
ei
(
bo
 
wrab
, bo 
execub
)

38  
	gexecub
 ?

39 (
	gwrab
 ? 
	gPAGE_EXECUTE_READWRITE
 : 
PAGE_EXECUTE_READ
) :

40 (
wrab
 ? 
PAGE_READWRITE
 : 
PAGE_READONLY
);

43 * 
	gOSAot
::
rveUncommd
(
size_t
 
bys
, 
Uge
, 
bo
 
wrab
, bo 
execub
, bool)

45 * 
	gsu
 = 
VtuAoc
(0, 
bys
, 
MEM_RESERVE
, 
ei
(
wrab
, 
execub
));

46 i(!
	gsu
)

47 
CRASH
();

48  
	gsu
;

51 * 
	gOSAot
::
rveAndComm
(
size_t
 
bys
, 
Uge
, 
bo
 
wrab
, bo 
execub
, bool)

53 * 
	gsu
 = 
VtuAoc
(0, 
bys
, 
MEM_RESERVE
 | 
MEM_COMMIT
, 
ei
(
wrab
, 
execub
));

54 i(!
	gsu
)

55 
CRASH
();

56  
	gsu
;

59 
	gOSAot
::
comm
(* 
addss
, 
size_t
 
bys
, 
bo
 
wrab
, bo 
execub
)

61 * 
	gsu
 = 
VtuAoc
(
addss
, 
bys
, 
MEM_COMMIT
, 
ei
(
wrab
, 
execub
));

62 i(!
	gsu
)

63 
CRASH
();

66 
	gOSAot
::
decomm
(* 
addss
, 
size_t
 
bys
)

74 i(!
	gbys
)

76 
bo
 
	gsu
 = 
VtuFe
(
addss
, 
bys
, 
MEM_DECOMMIT
);

77 i(!
	gsu
)

78 
CRASH
();

81 
	gOSAot
::
aDecommd
(* 
addss
, 
size_t
 
bys
)

85 i(!
	gbys
)

89 
bo
 
	gsu
 = 
VtuFe
(
addss
, 0, 
MEM_RELEASE
);

90 i(!
	gsu
)

91 
CRASH
();

	@OSRandomSource.cpp

26 
	~"cfig.h
"

27 
	~"OSRdomSour.h
"

29 
	~<dt.h
>

30 
	~<dlib.h
>

32 #i
OS
(
UNIX
)

33 
	~<f.h
>

34 
	~<unid.h
>

37 #i
OS
(
WINDOWS
)

38 
	~<wdows.h
>

39 
	~<wy.h
>

42 
mea
 
	gWTF
 {

44 
yogphiyRdomVuesFromOS
(* 
bufr
, 
size_t
 
ngth
)

46 #i
OS
(
UNIX
)

47 
	gfd
 = 
ݒ
("/dev/undom", 
O_RDONLY
, 0);

48 i(
	gfd
 < 0)

49 
CRASH
();

51 i(
ad
(
fd
, 
bufr
, 
ngth
!
ic_
<
ssize_t
>(length))

52 
CRASH
();

54 
o
(
fd
);

55 #i
OS
(
WINDOWS
)

56 
HCRYPTPROV
 
	ghCryProv
 = 0;

57 i(!
CryAcqueCڋxt
(&
hCryProv
, 0, 
MS_DEF_PROV
, 
PROV_RSA_FULL
, 
CRYPT_VERIFYCONTEXT
))

58 
CRASH
();

59 i(!
CryGRdom
(
hCryProv
, 
ngth
, 
bufr
))

60 
CRASH
();

61 
CryRCڋxt
(
hCryProv
, 0);

	@OSRandomSource.h

26 #ide
WTF_OSRdomSour_h


27 
	#WTF_OSRdomSour_h


	)

29 
mea
 
	gWTF
 {

35 
yogphiyRdomVuesFromOS
(* 
bufr
, 
size_t
 
ngth
);

	@ObjcRuntimeExtras.h

25 #ide
WTF_ObjcRuimeExas_h


26 
	#WTF_ObjcRuimeExas_h


	)

31 
	~<objc/mesge.h
>

33 #ifde
__lulus


35 
	gme
<
tyme
 
	gRuTy
, 
	gtyme
... 
	gArgumtTys
>

36 
le
 
RuTy
 
	$wtfObjcMsgSd
(
id
 
rg
, 
SEL
 

, 
ArgumtTys
... 
gumts
)

38  
t_
<
	`RuTy
 (*)(
id
, 
SEL
, 
ArgumtTys
...)>(
objc_msgSd
)(
rg
, 

, 
gumts
...);

39 
	}
}

41 
	gme
<
tyme
 
	gRuTy
, 
	gtyme
... 
	gArgumtTys
>

42 
le
 
RuTy
 
	$wtfClIMP
(
IMP
 
imemti
, 
id
 
rg
, 
SEL
 

, 
ArgumtTys
... 
gumts
)

44  
t_
<
	`RuTy
 (*)(
id
, 
SEL
, 
ArgumtTys
...)>(
imemti
)(
rg
, 

, 
gumts
...);

45 
	}
}

	@Optional.h

26 #ide
Oiڮ_h


27 
	#Oiڮ_h


	)

29 
	~<ty_as
>

30 
	~<wtf/Asis.h
>

31 
	~<wtf/StdLibExas.h
>

37 
mea
 
	gWTF
 {

39 
	eInPTag
 { 
	gInP
 };

40 
	eNutTag
 { 
	gNut
 };

42 
	gme
<
tyme
 
	gT
>

43 as
	cOiڮ
 {

44 
	gpublic
:

45 
Oiڮ
()

46 : 
m_isEngaged
(
l
)

50 
Oiڮ
(
NutTag
)

51 : 
m_isEngaged
(
l
)

55 
Oiڮ
(cڡ 
T
& 
vue
)

56 : 
m_isEngaged
(
ue
)

57 , 
m_vue
(
vue
)

61 
Oiڮ
(cڡ Oiڮ& 
h
)

62 : 
m_isEngaged
(
h
.m_isEngaged)

64 i(
m_isEngaged
)

65 
w
 (
NNu
, 
d
::
addssof
(
m_vue
)
T
(
h
.m_value);

68 
Oiڮ
(Oiڮ&& 
h
)

69 : 
m_isEngaged
(
h
.m_isEngaged)

71 i(
m_isEngaged
)

72 
w
 (
NNu
, 
d
::
addssof
(
m_vue
)
T
(
WTF
::
move
(
h
.m_value));

75 
Oiڮ
(
T
&& 
vue
)

76 : 
m_isEngaged
(
ue
)

77 , 
m_vue
(
WTF
::
move
(
vue
))

81 
me
<
tyme
... 
Args
>

82 
Oiڮ
(
InPTag
, 
Args
&&... 
gs
)

83 : 
m_isEngaged
(
ue
)

84 , 
m_vue
(
d
::
fwd
<
Args
>(
gs
)...)

88 ~
Oiڮ
()

90 i(
m_isEngaged
)

91 
m_vue
.~
T
();

94 
	gOiڮ
& 
	gݔ
=(
NutTag
)

96 i(
m_isEngaged
) {

97 
m_vue
.~
T
();

98 
	gm_isEngaged
 = 
l
;

100  *
	gthis
;

103 
	gOiڮ
& 
	gݔ
=(cڡ 
Oiڮ
& 
h
)

105 i(
m_isEngaged
 =
h
.m_isEngaged) {

106 i(
m_isEngaged
)

107 
m_vue
 = 
h
.m_value;

108  *
	gthis
;

111 i(
	gm_isEngaged
)

112 
	gm_vue
.~
T
();

114 
w
 (
NNu
, 
d
::
addssof
(
m_vue
)
T
(
h
.m_value);

115 
	gm_isEngaged
 = 
h
.
m_isEngaged
;

117  *
	gthis
;

120 
	gOiڮ
& 
	gݔ
=(
Oiڮ
&& 
h
)

122 i(
m_isEngaged
 =
h
.m_isEngaged) {

123 i(
m_isEngaged
)

124 
m_vue
 = 
WTF
::
move
(
h
.m_value);

125  *
	gthis
;

128 i(
	gm_isEngaged
)

129 
	gm_vue
.~
T
();

131 
w
 (
NNu
, 
d
::
addssof
(
m_vue
)
T
(
WTF
::
move
(
h
.m_value));

132 
	gm_isEngaged
 = 
h
.
m_isEngaged
;

134  *
	gthis
;

137 
	gme
<
tyme
 
	gU
>

138 
	gOiڮ
& 
	gݔ
=(
U
&& 
u
)

140 i(
m_isEngaged
) {

141 
m_vue
 = 
d
::
fwd
<
U
>(
u
);

142  *
	gthis
;

145 
w
 (
NNu
, 
d
::
addssof
(
m_vue
)
T
(d::
fwd
<
U
>(
u
));

146 
	gm_isEngaged
 = 
ue
;

147  *
	gthis
;

150 
exic
 
ݔ
 
bo
(cڡ {  
	gm_isEngaged
; }

152 
	gT
& 
vue
()

154 
ASSERT
(
m_isEngaged
);

155  
	gm_vue
;

158 cڡ 
	gT
& 
vue
() const

160 
ASSERT
(
m_isEngaged
);

161  
	gm_vue
;

164 
	gme
<
tyme
 
	gU
>

165 
T
 
vueOr
(
U
&& 
vue
) const

167 i(
	gm_isEngaged
)

168  
	gm_vue
;

170  
	gd
::
fwd
<
U
>(
vue
);

173 
	give
:

174 
bo
 
m_isEngaged
;

176 
T
 
	gm_vue
;

182 
usg
 
	gWTF
::
InP
;

183 
usg
 
	gWTF
::
Nut
;

184 
usg
 
	gWTF
::
Oiڮ
;

	@OwnPtr.h

21 #ide
WTF_OwnP_h


22 
	#WTF_OwnP_h


	)

24 
	~<gܙhm
>

25 
	~<cddef
>

26 
	~<memy
>

27 
	~<wtf/Asis.h
>

28 
	~<wtf/Atomics.h
>

29 
	~<wtf/GP.h
>

30 
	~<wtf/HashTs.h
>

31 
	~<wtf/Ncyab.h
>

32 
	~<wtf/OwnPComm.h
>

34 
mea
 
	gWTF
 {

36 
	gme
<
tyme
 
	gT
> 
ass
 
	gPassOwnP
;

37 
	gme
<
tyme
 
	gT
> 
	gPassOwnP
<T> 
adtP
(
T
*);

39 
	gme
<
tyme
 
	gT
> cs
	cOwnP
 {

40 
	gpublic
:

41 
T
 
	tVueTy
;

42 
VueTy
* 
	tPTy
;

44 
OwnP
(: 
m_r
(0) { }

45 
OwnP
(
d
::
nuαr_t
: 
m_r
(0) { }

48 
me
<
tyme
 
U
> 
OwnP
(cڡ 
PassOwnP
<U>& 
o
);

50 ~
OwnP
({ 
deOwdP
(
m_r
); }

52 
PTy
 
g
(cڡ {  
	gm_r
; }

54 
r
();

55 
	gPassOwnP
<
	gT
> 
a
();

56 
PTy
 
akP
(
	gWARN_UNUSED_RETURN
;

58 
	gVueTy
& 
	gݔ
*(cڡ { 
ASSERT
(
m_r
);  *
	gm_r
; }

59 
PTy
 
	gݔ
->(cڡ { 
ASSERT
(
m_r
);  
	gm_r
; }

61 
bo
 
	gݔ
!(cڡ {  !
	gm_r
; }

64 
PTy
 
	tOwnP
::*
	tUnecifdBoTy
;

65 
ݔ
 
UnecifdBoTy
(cڡ {  
	gm_r
 ? &
	gOwnP
::
m_r
 : 0; }

67 
	gOwnP
& 
	gݔ
=(cڡ 
PassOwnP
<
T
>&);

68 
	gOwnP
& 
	gݔ
=(
d
::
nuαr_t
{ 
r
();  *
	gthis
; }

69 
	gme
<
tyme
 
	gU
> 
	gOwnP
& 
	gݔ
=(cڡ 
PassOwnP
<
U
>&);

71 
OwnP
(OwnPtr&&);

72 
	gme
<
tyme
 
	gU
> 
OwnP
(OwnP<
U
>&&);

74 
	gOwnP
& 
	gݔ
=(
OwnP
&&);

75 
	gme
<
tyme
 
	gU
> 
	gOwnP
& 
	gݔ
=(
OwnP
<
U
>&&);

78 
OwnP
(
HashTabDedVueTy
: 
m_r
(
hashTabDedVue
()) { }

79 
bo
 
isHashTabDedVue
(cڡ {  
m_r
 =
hashTabDedVue
(); }

81 
sw
(
OwnP
& 
o
{ 
	gd
::sw(
m_r
, o.m_ptr); }

91 
	gme
<
	gtyme
... 
	gArgs
>

92 
Tniڮly
(
Args
...);

94 
	give
:

95 
exic
 
OwnP
(
PTy
 
r
: 
m_r
(ptr) { }

97 
PTy
 
hashTabDedVue
({  
t_
<PtrType>(-1); }

101 
	gme
<
tyme
 
	gU
> 
bo
 
	gݔ
==(cڡ 
OwnP
<
U
>&{ 
COMPILE_ASSERT
(!(U*), 
OwnPs_should_v_be_equ
);  
	gl
; }

102 
	gme
<
tyme
 
	gU
> 
bo
 
	gݔ
!=(cڡ 
OwnP
<
U
>&{ 
COMPILE_ASSERT
(!(U*), 
OwnPs_should_v_be_equ
);  
	gl
; }

103 
	gme
<
tyme
 
	gU
> 
bo
 
	gݔ
==(cڡ 
PassOwnP
<
U
>&{ 
COMPILE_ASSERT
(!(U*), 
OwnPs_should_v_be_equ
);  
	gl
; }

104 
	gme
<
tyme
 
	gU
> 
bo
 
	gݔ
!=(cڡ 
PassOwnP
<
U
>&{ 
COMPILE_ASSERT
(!(U*), 
OwnPs_should_v_be_equ
);  
	gl
; }

106 
PTy
 
	gm_r
;

109 
	gme
<
tyme
 
	gT
>eme<tym
	gU
> 
le
 
	gOwnP
<T>::
OwnP
(cڡ 
PassOwnP
<
U
>& 
o
)

110 : 
m_r
(
o
.
	$akP
())

112 
	}
}

114 
me
<
tyme
 
T
> 
le
 
OwnP
<T>::
	$r
()

116 
PTy
 
r
 = 
m_r
;

117 
m_r
 = 0;

118 
	`deOwdP
(
r
);

119 
	}
}

121 
	gme
<
tyme
 
	gT
> 
le
 
	gPassOwnP
<T> 
	gOwnP
<T>::
	$a
()

123 
PTy
 
r
 = 
m_r
;

124 
m_r
 = 0;

125  
	`adtP
(
r
);

126 
	}
}

128 
	gme
<
tyme
 
	gT
> 
le
ym
	gOwnP
<T>::
PTy
 
OwnP
<
T
>::
	$akP
()

130 
PTy
 
r
 = 
m_r
;

131 
m_r
 = 0;

132  
r
;

133 
	}
}

135 
	gme
<
tyme
 
	gT
> 
le
 
	gOwnP
<T>& OwnP<T>::
ݔ
=(cڡ 
PassOwnP
<
T
>& 
o
)

137 
PTy
 
r
 = 
m_r
;

138 
	gm_r
 = 
o
.
akP
();

139 
ASSERT
(!
r
 || 
m_r
 !=tr);

140 
deOwdP
(
r
);

141  *
	gthis
;

144 
	gme
<
tyme
 
	gT
>eme<tym
	gU
> 
le
 
	gOwnP
<T>& OwnP<T>::
ݔ
=(cڡ 
PassOwnP
<
U
>& 
o
)

146 
PTy
 
r
 = 
m_r
;

147 
	gm_r
 = 
o
.
akP
();

148 
ASSERT
(!
r
 || 
m_r
 !=tr);

149 
deOwdP
(
r
);

150  *
	gthis
;

153 
	gme
<
tyme
 
	gT
> 
le
 
	gOwnP
<T>::
OwnP
(OwnP<
T
>&& 
o
)

154 : 
m_r
(
o
.
	$akP
())

156 
	}
}

158 
me
<
tyme
 
T
>eme<tym
U
> 
le
 
OwnP
<T>::OwnP(OwnP<U>&& 
o
)

159 : 
m_r
(
o
.
	$akP
())

161 
	}
}

163 
me
<
tyme
 
T
> 
le
ut
OwnP
<T>::
ݔ
=(OwnP&& 
o
) -> OwnPtr&

165 
ASSERT
(!
o
 || o !
m_r
);

166 
OwnP
 
	gr
 = 
WTF
::
move
(
o
);

167 
sw
(
r
);

168  *
	gthis
;

171 
	gme
<
tyme
 
	gT
>eme<tym
	gU
> 
le
ut
	gOwnP
<T>::
ݔ
=(
OwnP
<
U
>&& 
o
) -> OwnPtr&

173 
ASSERT
(!
o
 || o !
m_r
);

174 
OwnP
 
	gr
 = 
WTF
::
move
(
o
);

175 
sw
(
r
);

176  *
	gthis
;

179 
	gme
<
tyme
 
	gT
> 
le
 
sw
(
OwnP
<
T
>& 
a
, OwnP<T>& 
b
)

181 
	ga
.
sw
(
b
);

184 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
==(cڡ 
OwnP
<
T
>& 
a
, 
U
* 
	gb
)

186  
	ga
.
g
(=
b
;

189 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
==(
T
* 
a
, cڡ 
	gOwnP
<U>& 
	gb
)

191  
	ga
 =
b
.
g
();

194 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
!=(cڡ 
OwnP
<
T
>& 
a
, 
U
* 
	gb
)

196  
	ga
.
g
(!
b
;

199 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
!=(
T
* 
a
, cڡ 
	gOwnP
<U>& 
	gb
)

201  
	ga
 !
b
.
g
();

204 
	gme
<
tyme
 
	gT
>eme<
	gtyme
... 
	gArgs
> 
le
 
	gOwnP
<T>::
	$Tniڮly
(
Args
... 
gs
)

206 i(
m_r
) {

207 
WTF
::
	`ldLdF
();

211 
T
* 
wObje
 = 
w
 
	`T
(
gs
...);

212 
WTF
::
	`eSteF
();

213 #i
	`ENABLE
(
COMPARE_AND_SWAP
)

215 i(
m_r
) {

216 
de
 
wObje
;

217 
WTF
::
	`ldLdF
();

220 } !
WTF
::
	`wkComAndSw
(
bwi_
<*vީe*>(&
m_r
), 
nuαr
, 
wObje
));

222 
m_r
 = 
wObje
;

224 
	}
}

226 
	gme
 <
tyme
 
	gT
> 
	gIsSmtP
<
	gOwnP
<T>> {

227 cڡ 
bo
 
	gvue
 = 
ue
;

230 
	gme
<
tyme
 
	gP
> 
	gDeuHash
<
	gOwnP
<P>> {

231 
	gPHash
<
	tOwnP
<
	tP
>> 
	tHash
;

236 
usg
 
	gWTF
::
OwnP
;

	@OwnPtrCommon.h

28 #ide
WTF_OwnPComm_h


29 
	#WTF_OwnPComm_h


	)

31 
mea
 
	gWTF
 {

33 
	gme
 <
tyme
 
	gT
> 
le
 
deOwdP
(
T
* 
r
)

35 
	tknown
[(
T
) ? 1 : -1];

36 i((
	gknown
))

37 
de
 
	gr
;

	@PackedIntVector.h

26 #ide
PackedIVe_h


27 
	#PackedIVe_h


	)

29 
	~<wtf/BVe.h
>

31 
mea
 
	gWTF
 {

40 
	gme
<
tyme
 
	gT
, 
	gbCou
>

41 as
	cPackedIVe
 {

42 
	gpublic
:

43 
ic_as
(
bCou
, "bitCount mustot be zero!");

44 
ic_as
(
bCou
 < (*) * 8, "bitCount mustotxceedheddress spaceimit!");

46 
PackedIVe
()

50 
PackedIVe
(cڡ PackedIVe& 
h
)

51 : 
m_bs
(
h
.m_bits)

55 
PackedIVe
& 
ݔ
=(cڡ PackedIVe& 
h
)

57 
m_bs
 = 
h
.m_bits;

58  *
	gthis
;

61 
size_t
 
size
() const

63  
	gm_bs
.
size
(/ 
	gbCou
;

66 
suSize
(
size_t
 
numIs
)

68 
	gm_bs
.
suSize
(
numIs
 * 
bCou
);

71 
size
(
size_t
 
numIs
)

73 
	gm_bs
.
size
(
numIs
 * 
bCou
);

76 
rA
()

78 
	gm_bs
.
rA
();

81 
T
 
g
(
size_t
 
dex
) const

83 
u_t
 
	gsu
 = 0;

84 
	gsubIndex
 = 0; subIndex < 
	gbCou
; ++subIndex) {

85 
	gsu
 <<= 1;

86 
	gsu
 |(
m_bs
.
quickG
(
dex
 * 
bCou
 + 
subIndex
) ? 1 : 0);

88  
	gic_
<
	gT
>(
	gsu
);

91 
t
(
size_t
 
dex
, 
T
 
vue
)

96 
u_t
 
	gmyVue
 = 
ic_
<u_t>(
vue
);

99 
ASSERT
((
myVue
 & 
mask
()) == myValue);

101 
	gsubIndex
 = 
bCou
; subIndex-- > 0;) {

102 
	gm_bs
.
quickS
(
dex
 * 
bCou
 + 
subIndex
, !!(
myVue
 & 1));

103 
	gmyVue
 >>= 1;

108 
ASSERT
(
g
(
dex
=
vue
);

110 
	give
:

116 
u_t
 
mask
({  (
ic_
<u_t>(2<< (
bCou
 - 1)) - 1; }

119 
BVe
 
	gm_bs
;

124 
usg
 
	gWTF
::
PackedIVe
;

	@PageAllocation.h

26 #ide
PageAoti_h


27 
	#PageAoti_h


	)

29 
	~<wtf/Asis.h
>

30 
	~<wtf/OSAot.h
>

31 
	~<wtf/PageBlock.h
>

32 
	~<wtf/VMTags.h
>

33 
	~<gܙhm
>

35 #i
OS
(
DARWIN
)

36 
	~<mach/mach_.h
>

37 
	~<mach/vm_m.h
>

40 #i
OS
(
WINDOWS
)

41 
	~<mloc.h
>

42 
	~<wdows.h
>

45 #i
HAVE
(
ERRNO_H
)

46 
	~<o.h
>

49 #i
HAVE
(
MMAP
)

50 
	~<sys/mm.h
>

51 
	~<unid.h
>

54 
mea
 
	gWTF
 {

72 as
	cPageAoti
 : 
ive
 
PageBlock
 {

73 
public
:

74 
PageAoti
()

78 
usg
 
PageBlock
::
size
;

79 
usg
 
	gPageBlock
::
ba
;

81 #ide
__g__


82 
usg
 
	gPageBlock
::
ݔ
 
bo
;

86 
ݔ
 
bo
(cڡ {  
	gPageBlock
::operator bool(); }

89 
PageAoti
 
lo
(
size_t
 
size
, 
OSAot
::
Uge
 
uge
 = OSAot::
UnknownUge
, 
bo
 
wrab
 = 
ue
, bo 
execub
 = 
l
)

91 
ASSERT
(
isPageAligd
(
size
));

92  
PageAoti
(
OSAot
::
rveAndComm
(
size
, 
uge
, 
wrab
, 
execub
), size);

95 
do
()

99 
PageAoti
 
	gtmp
;

100 
	gd
::
sw
(
tmp
, *
this
);

102 
ASSERT
(
tmp
);

103 
ASSERT
(!*
this
);

105 
	gOSAot
::
decommAndR
(
tmp
.
ba
(),mp.
size
());

108 
	give
:

109 
PageAoti
(* 
ba
, 
size_t
 
size
)

110 : 
PageBlock
(
ba
, 
size
, 
l
)

117 
usg
 
	gWTF
::
PageAoti
;

	@PageAllocationAligned.cpp

26 
	~"cfig.h
"

27 
	~"PageAotiAligd.h
"

29 
mea
 
	gWTF
 {

31 
PageAotiAligd
 
	gPageAotiAligd
::
lo
(
size_t
 
size
, size_
ignmt
, 
OSAot
::
Uge
 
uge
, 
bo
 
wrab
)

33 
ASSERT
(
isPageAligd
(
size
));

34 
ASSERT
(
isPageAligd
(
ignmt
));

35 
ASSERT
(
isPowOfTwo
(
ignmt
));

36 
ASSERT
(
size
 >
ignmt
);

37 
size_t
 
	gignmtMask
 = 
ignmt
 - 1;

39 #i
OS
(
DARWIN
)

40 
	gags
 = 
VM_FLAGS_ANYWHERE
;

41 i(
	guge
 !
OSAot
::
UnknownUge
)

42 
ags
 |
uge
;

43 
	gei
 = 
PROT_READ
;

44 i(
	gwrab
)

45 
	gei
 |
PROT_WRITE
;

47 
vm_addss_t
 
	gaddss
 = 0;

48 
vm_m
(
cut_sk
(), &
addss
, 
size
, 
ignmtMask
, 
ags
, 
MEMORY_OBJECT_NULL
, 0, 
FALSE
, 
ei
, 
PROT_READ
 | 
PROT_WRITE
, 
VM_INHERIT_DEFAULT
);

49  
PageAotiAligd
(
t_
<*>(
addss
), 
size
);

51 
size_t
 
	gignmtD
 = 
ignmt
 - 
geSize
();

54 
size_t
 
	grviSize
 = 
size
 + 
ignmtD
;

55 * 
	grviBa
 = 
OSAot
::
rveUncommd
(
rviSize
, 
uge
, 
wrab
, 
l
);

58 * 
	gigdBa
 = 
t_
<
u_t
>(
rviBa
& 
ignmtMask


59 ? 
t_
<*>(et_<
u_t
>(
rviBa
& ~
ignmtMask
+ 
ignmt
)

60 : 
rviBa
;

61 
	gOSAot
::
comm
(
igdBa
, 
size
, 
wrab
, 
l
);

63  
PageAotiAligd
(
igdBa
, 
size
, 
rviBa
, 
rviSize
);

67 
	gPageAotiAligd
::
do
()

71 
PageAotiAligd
 
tmp
;

72 
	gd
::
sw
(
tmp
, *
this
);

74 
ASSERT
(
tmp
);

75 
ASSERT
(!*
this
);

77 #i
OS
(
DARWIN
)

78 
vm_do
(
cut_sk
(), 
t_
<
vm_addss_t
>(
tmp
.
ba
()),mp.
size
());

80 
ASSERT
(
tmp
.
m_rvi
.
cڏs
mp.
ba
(),mp.
size
()));

81 
	gOSAot
::
decommAndR
(
tmp
.
m_rvi
.
ba
(),mp.m_rvi.
size
());

	@PageAllocationAligned.h

26 #ide
PageAotiAligd_h


27 
	#PageAotiAligd_h


	)

29 
	~<wtf/OSAot.h
>

30 
	~<wtf/PageRervi.h
>

32 
mea
 
	gWTF
 {

34 as
	cPageAotiAligd
 : 
ive
 
PageBlock
 {

35 
public
:

36 
PageAotiAligd
()

40 
usg
 
PageBlock
::
ݔ
 
bo
;

41 
usg
 
	gPageBlock
::
size
;

42 
usg
 
	gPageBlock
::
ba
;

44 
WTF_EXPORT_PRIVATE
 
PageAotiAligd
 
lo
(
size_t
 
size
, size_
ignmt
, 
OSAot
::
Uge
 
uge
 = OSAot::
UnknownUge
, 
bo
 
wrab
 = 
ue
);

46 
WTF_EXPORT_PRIVATE
 
do
();

48 
	give
:

49 #i
OS
(
DARWIN
)

50 
PageAotiAligd
(* 
ba
, 
size_t
 
size
)

51 : 
PageBlock
(
ba
, 
size
, 
l
)

55 
PageAotiAligd
(* 
ba
, 
size_t
 
size
, * 
rviBa
, size_
rviSize
)

56 : 
PageBlock
(
ba
, 
size
, 
l
)

57 , 
m_rvi
(
rviBa
, 
rviSize
, 
l
)

61 
PageBlock
 
	gm_rvi
;

68 
usg
 
	gWTF
::
PageAotiAligd
;

	@PageBlock.cpp

26 
	~"cfig.h
"

27 
	~"PageBlock.h
"

29 #i
OS
(
UNIX
)

30 
	~<unid.h
>

33 #i
OS
(
WINDOWS
)

34 
	~<mloc.h
>

35 
	~<wdows.h
>

38 
mea
 
	gWTF
 {

40 
size_t
 
	gs_geSize
;

41 
size_t
 
	gs_geMask
;

43 #i
OS
(
UNIX
)

45 
le
 
size_t
 
syemPageSize
()

47  
ggesize
();

50 #i
OS
(
WINDOWS
)

52 
le
 
size_t
 
syemPageSize
()

54 
size_t
 
	gsize
 = 0;

55 
SYSTEM_INFO
 
	gsyem_fo
;

56 
GSyemInfo
(&
syem_fo
);

57 
	gsize
 = 
syem_fo
.
dwPageSize
;

58  
	gsize
;

63 
size_t
 
geSize
()

65 i(!
	gs_geSize
)

66 
	gs_geSize
 = 
syemPageSize
();

67 
ASSERT
(
isPowOfTwo
(
s_geSize
));

68  
	gs_geSize
;

71 
size_t
 
geMask
()

73 i(!
	gs_geMask
)

74 
	gs_geMask
 = ~(
geSize
() - 1);

75  
	gs_geMask
;

	@PageBlock.h

26 #ide
PageBlock_h


27 
	#PageBlock_h


	)

29 
mea
 
	gWTF
 {

31 
WTF_EXPORT_PRIVATE
 
size_t
 
geSize
();

32 
WTF_EXPORT_PRIVATE
 
size_t
 
geMask
();

33 
le
 
bo
 
isPageAligd
(* 
addss
{  !(
	gt_
<
	g_t
>(
	gaddss
& (
geSize
() - 1)); }

34 
le
 
bo
 
isPageAligd
(
size_t
 
size
{  !(
	gsize
 & (
geSize
() - 1)); }

35 
le
 
bo
 
isPowOfTwo
(
size_t
 
size
{  !(
	gsize
 & (size - 1)); }

37 as
	cPageBlock
 {

38 
	gpublic
:

39 
PageBlock
();

40 
PageBlock
(const PageBlock&);

41 
PageBlock
(*, 
size_t
, 
bo
 
hasGudPages
);

43 * 
ba
(cڡ {  
	gm_ba
; }

44 
size_t
 
size
(cڡ {  
	gm_size
; }

46 
ݔ
 
bo
(cڡ {  !!
	gm_Ba
; }

48 
bo
 
cڏs
(* 
cڏedBa
, 
size_t
 
cڏedSize
)

50  
	gcڏedBa
 >
m_ba


51 && (
ic_
<*>(
cڏedBa
+ 
cڏedSize
<(ic_<*>(
m_ba
+ 
m_size
);

54 
	give
:

55 * 
m_Ba
;

56 * 
	gm_ba
;

57 
size_t
 
	gm_size
;

60 
le
 
	gPageBlock
::
	$PageBlock
()

61 : 
	`m_Ba
(0)

62 , 
	`m_ba
(0)

63 , 
	$m_size
(0)

65 
	}
}

67 
le
 
	gPageBlock
::
	$PageBlock
(cڡ 
PageBlock
& 
h
)

68 : 
	`m_Ba
(
h
.
m_Ba
)

69 , 
	`m_ba
(
h
.
m_ba
)

70 , 
	$m_size
(
h
.
m_size
)

72 
	}
}

74 
le
 
	gPageBlock
::
	$PageBlock
(* 
ba
, 
size_t
 
size
, 
bo
 
hasGudPages
)

75 : 
	`m_Ba
(
ba
)

76 , 
	`m_ba
(
ic_
<*>(
ba
+ ((ba && 
hasGudPages
? 
	$geSize
() : 0))

77 , 
	$m_size
(
size
)

79 
	}
}

83 
usg
 
	gWTF
::
geSize
;

84 
usg
 
	gWTF
::
isPageAligd
;

85 
usg
 
	gWTF
::
isPageAligd
;

86 
usg
 
	gWTF
::
isPowOfTwo
;

	@PageReservation.h

26 #ide
PageRervi_h


27 
	#PageRervi_h


	)

29 
	~<wtf/PageAoti.h
>

31 
mea
 
	gWTF
 {

57 as
	cPageRervi
 : 
ive
 
PageBlock
 {

58 
public
:

59 
PageRervi
()

60 : 
m_commd
(0)

61 , 
m_wrab
(
l
)

62 , 
m_execub
(
l
)

66 
usg
 
	gPageBlock
::
ba
;

67 
usg
 
	gPageBlock
::
size
;

69 #ide
__g__


70 
usg
 
	gPageBlock
::
ݔ
 
bo
;

74 
ݔ
 
bo
(cڡ {  
	gPageBlock
::operator bool(); }

77 
comm
(* 
t
, 
size_t
 
size
)

79 
ASSERT
(*
this
);

80 
ASSERT
(
isPageAligd
(
t
));

81 
ASSERT
(
isPageAligd
(
size
));

82 
ASSERT
(
cڏs
(
t
, 
size
));

84 
	gm_commd
 +
size
;

85 
	gOSAot
::
comm
(
t
, 
size
, 
m_wrab
, 
m_execub
);

88 
decomm
(* 
t
, 
size_t
 
size
)

90 
ASSERT
(*
this
);

91 
ASSERT
(
isPageAligd
(
t
));

92 
ASSERT
(
isPageAligd
(
size
));

93 
ASSERT
(
cڏs
(
t
, 
size
));

95 
	gm_commd
 -
size
;

96 
	gOSAot
::
decomm
(
t
, 
size
);

99 
size_t
 
commd
()

101  
	gm_commd
;

104 
PageRervi
 
rve
(
size_t
 
size
, 
OSAot
::
Uge
 
uge
 = OSAot::
UnknownUge
, 
bo
 
wrab
 = 
ue
, bo 
execub
 = 
l
)

106 
ASSERT
(
isPageAligd
(
size
));

107  
PageRervi
(
OSAot
::
rveUncommd
(
size
, 
uge
, 
wrab
, 
execub
), size, wrab,xecub, 
l
);

110 
PageRervi
 
rveWhGudPages
(
size_t
 
size
, 
OSAot
::
Uge
 
uge
 = OSAot::
UnknownUge
, 
bo
 
wrab
 = 
ue
, bo 
execub
 = 
l
)

112 
ASSERT
(
isPageAligd
(
size
));

113  
PageRervi
(
OSAot
::
rveUncommd
(
size
 + 
geSize
(* 2, 
uge
, 
wrab
, 
execub
, 
ue
), size, writable,xecutable,rue);

116 
do
()

118 
ASSERT
(!
m_commd
);

122 
PageRervi
 
	gtmp
;

123 
	gd
::
sw
(
tmp
, *
this
);

125 
ASSERT
(
tmp
);

126 
ASSERT
(!*
this
);

128 
	gOSAot
::
aDecommd
(
tmp
.
ba
(),mp.
size
());

131 
	give
:

132 
PageRervi
(* 
ba
, 
size_t
 
size
, 
bo
 
wrab
, bo 
execub
, bo 
hasGudPages
)

133 : 
PageBlock
(
ba
, 
size
, 
hasGudPages
)

134 , 
m_commd
(0)

135 , 
m_wrab
(
wrab
)

136 , 
m_execub
(
execub
)

140 
size_t
 
	gm_commd
;

141 
bo
 
	gm_wrab
;

142 
bo
 
	gm_execub
;

147 
usg
 
	gWTF
::
PageRervi
;

	@ParallelJobs.h

28 #ide
PlJobs_h


29 
	#PlJobs_h


	)

31 
	~<wtf/Asis.h
>

32 
	~<wtf/Ncyab.h
>

33 
	~<wtf/RefP.h
>

34 
	~<wtf/Ve.h
>

52 #i
ENABLE
(
THREADING_GENERIC
)

53 
	~<wtf/PlJobsGic.h
>

55 #i
ENABLE
(
THREADING_OPENMP
)

56 
	~<wtf/PlJobsOnMP.h
>

58 #i
ENABLE
(
THREADING_LIBDISPATCH
)

59 
	~<wtf/PlJobsLibdich.h
>

66 
mea
 
	gWTF
 {

68 
	gme
<
tyme
 
	gTy
>

69 as
	cPlJobs
 {

70 
	gWTF_MAKE_FAST_ALLOCATED
;

71 
	gpublic
:

72 (*
WkFuni
)(
	tTy
*);

74 
PlJobs
(
WkFuni
 
func
, 
queedJobNumb
) :

75 
m_ΖEnvmt
(
t_
<
PlEnvmt
::
ThadFuni
>(
func
), (
Ty
), 
queedJobNumb
)

77 
	gm_ms
.
grow
(
m_ΖEnvmt
.
numbOfJobs
());

78 
ASSERT
(
numbOfJobs
(=
m_ms
.
size
());

81 
size_t
 
numbOfJobs
()

83  
	gm_ms
.
size
();

86 
	gTy
& 
m
(
size_t
 
i
)

88  
	gm_ms
[
i
];

91 
execu
()

93 
	gm_ΖEnvmt
.
execu
(
t_
<*>(
m_ms
.
da
()));

96 
	give
:

97 
PlEnvmt
 
m_ΖEnvmt
;

98 
	gVe
<
	gTy
> 
	gm_ms
;

103 
usg
 
	gWTF
::
PlJobs
;

	@ParallelJobsGeneric.cpp

28 
	~"cfig.h
"

30 #i
ENABLE
(
THREADING_GENERIC
)

32 
	~"PlJobs.h
"

33 
	~<wtf/NumbOfCes.h
>

35 
mea
 
	gWTF
 {

37 
	gVe
< 
	gRefP
<
	gPlEnvmt
::
ThadPrive
> >* 
PlEnvmt
::
s_thadPo
 = 0;

39 
	gPlEnvmt
::
PlEnvmt
(
ThadFuni
 
thadFuni
, 
size_t
 
sizeOfPam
, 
queedJobNumb
) :

40 
m_thadFuni
(
thadFuni
),

41 
m_sizeOfPam
(
sizeOfPam
)

43 
ASSERT_ARG
(
queedJobNumb
,equestedJobNumber >= 1);

45 
	gmaxNumbOfCes
 = 
numbOfProssCes
();

47 i(!
	gqueedJobNumb
 ||equeedJobNumb > 
	gmaxNumbOfCes
)

48 
	gqueedJobNumb
 = 
ic_
<>(
maxNumbOfCes
);

50 i(!
	gs_thadPo
)

51 
	gs_thadPo
 = 
w
 
Ve
< 
RefP
<
ThadPrive
> >();

54 
	gmaxNumbOfNewThads
 = 
queedJobNumb
 - 1;

56 
	gi
 = 0; i < 
	gmaxNumbOfCes
 && 
	gm_thads
.
size
(< 
	gic_
<>(
	gmaxNumbOfNewThads
); ++i) {

57 i(
	gs_thadPo
->
size
(< 
	gic_
<>(
	gi
) + 1U)

58 
	gs_thadPo
->
nd
(
ThadPrive
::

());

60 i((*
	gs_thadPo
)[
i
]->
yLockF
(
this
))

61 
	gm_thads
.
nd
((*
s_thadPo
)[
i
]);

64 
	gm_numbOfJobs
 = 
m_thads
.
size
() + 1;

67 
	gPlEnvmt
::
execu
(* 
ms
)

69 * 
cutPam
 = 
ic_
<*>(
ms
);

70 
size_t
 
	gi
;

71 
	gi
 = 0; i < 
	gm_thads
.
size
(); ++i) {

72 
	gm_thads
[
i
]->
execu
(
m_thadFuni
, 
cutPam
);

73 
	gcutPam
 +
m_sizeOfPam
;

77 (*
	gm_thadFuni
)(
	gcutPam
);

80 
	gi
 = 0; i < 
	gm_thads
.
size
(); ++i)

81 
	gm_thads
[
i
]->
waFFish
();

84 
bo
 
	gPlEnvmt
::
ThadPrive
::
yLockF
(
PlEnvmt
* 

)

86 
bo
 
locked
 = 
m_mux
.
yLock
();

88 i(!
	glocked
)

89  
	gl
;

91 i(
	gm_
) {

92 
	gm_mux
.
uock
();

93  
	gl
;

96 i(!
	gm_thadID
)

97 
	gm_thadID
 = 
Thad
(&
PlEnvmt
::
ThadPrive
::
wkThad
, 
this
, "Parallel worker");

99 i(
	gm_thadID
)

100 
	gm_
 = 

;

102 
	gm_mux
.
uock
();

103  
	gm_thadID
;

106 
	gPlEnvmt
::
ThadPrive
::
execu
(
ThadFuni
 
thadFuni
, * 
ms
)

108 
MuxLock
 
lock
(
m_mux
);

110 
	gm_thadFuni
 = 
thadFuni
;

111 
	gm_ms
 = 
ms
;

112 
	gm_rug
 = 
ue
;

113 
	gm_thadCdi
.
sigl
();

116 
	gPlEnvmt
::
ThadPrive
::
waFFish
()

118 
MuxLock
 
lock
(
m_mux
);

120 
	gm_rug
)

121 
	gm_thadCdi
.
wa
(
m_mux
);

124 
	gPlEnvmt
::
ThadPrive
::
wkThad
(* 
thadDa
)

126 
ThadPrive
* 
shedThad
 = 
t_
<ThadPrive*>(
thadDa
);

127 
MuxLock
 
lock
(
shedThad
->
m_mux
);

129 
	gshedThad
->
	gm_thadID
) {

130 i(
	gshedThad
->
	gm_rug
) {

131 (*
	gshedThad
->
	gm_thadFuni
)(shedThad->
	gm_ms
);

132 
	gshedThad
->
	gm_rug
 = 
l
;

133 
	gshedThad
->
	gm_
 = 0;

134 
	gshedThad
->
	gm_thadCdi
.
sigl
();

137 
	gshedThad
->
	gm_thadCdi
.
wa
(
shedThad
->
m_mux
);

	@ParallelJobsGeneric.h

28 #ide
PlJobsGic_h


29 
	#PlJobsGic_h


	)

31 #i
ENABLE
(
THREADING_GENERIC
)

33 
	~<wtf/RefCoued.h
>

34 
	~<wtf/Thadg.h
>

36 
mea
 
	gWTF
 {

38 as
	cPlEnvmt
 {

39 
	gWTF_MAKE_FAST_ALLOCATED
;

40 
	gpublic
:

41 (*
ThadFuni
)(*);

43 
WTF_EXPORT_PRIVATE
 
PlEnvmt
(
ThadFuni
, 
size_t
 
sizeOfPam
, 
queedJobNumb
);

45 
numbOfJobs
()

47  
	gm_numbOfJobs
;

50 
WTF_EXPORT_PRIVATE
 
execu
(* 
ms
);

52 
ass
 
	gThadPrive
 : 
public
 
RefCoued
<
ThadPrive
> {

53 
public
:

54 
ThadPrive
()

55 : 
m_thadID
(0)

56 , 
m_rug
(
l
)

57 , 
m_
(0)

61 
bo
 
yLockF
(
PlEnvmt
*);

63 
execu
(
ThadFuni
, *);

65 
waFFish
();

67 
	gPassRefP
<
	gThadPrive
> 

()

69  
adtRef
(
w
 
ThadPrive
());

72 
wkThad
(*);

74 
	give
:

75 
ThadIdtifr
 
m_thadID
;

76 
bo
 
	gm_rug
;

77 
PlEnvmt
* 
	gm_
;

79 
mub
 
Mux
 
	gm_mux
;

80 
ThadCdi
 
	gm_thadCdi
;

82 
ThadFuni
 
	gm_thadFuni
;

83 * 
	gm_ms
;

86 
	give
:

87 
ThadFuni
 
m_thadFuni
;

88 
size_t
 
	gm_sizeOfPam
;

89 
	gm_numbOfJobs
;

91 
	gVe
< 
	gRefP
<
	gThadPrive
> > 
	gm_thads
;

92 
	gVe
< 
	gRefP
<
	gThadPrive
> >* 
	gs_thadPo
;

	@ParallelJobsLibdispatch.h

28 #ide
PlJobsLibdich_h


29 
	#PlJobsLibdich_h


	)

31 #i
ENABLE
(
THREADING_LIBDISPATCH
)

33 
	~<dich/dich.h
>

35 
mea
 
	gWTF
 {

37 as
	cPlEnvmt
 {

38 
	gWTF_MAKE_FAST_ALLOCATED
;

39 
	gpublic
:

40 (*
ThadFuni
)(*);

42 
PlEnvmt
(
ThadFuni
 
thadFuni
, 
size_t
 
sizeOfPam
, 
queedJobNumb
)

43 : 
m_thadFuni
(
thadFuni
)

44 , 
m_sizeOfPam
(
sizeOfPam
)

45 , 
m_numbOfJobs
(
queedJobNumb
)

48 
ASSERT_ARG
(
queedJobNumb
,equestedJobNumber > 0);

51 
numbOfJobs
()

53  
	gm_numbOfJobs
;

56 
execu
(* 
ms
)

58 
dich_queue_t
 
	gglobQueue
 = 
dich_g_glob_queue
(
DISPATCH_QUEUE_PRIORITY_DEFAULT
, 0);

60 
dich_y
(
m_numbOfJobs
, 
globQueue
, ^(
size_t
 
i
{ (*
m_thadFuni
)(
ms
 + (
m_sizeOfPam
 * i)); });

63 
	give
:

64 
ThadFuni
 
m_thadFuni
;

65 
size_t
 
	gm_sizeOfPam
;

66 
	gm_numbOfJobs
;

	@ParallelJobsOpenMP.h

28 #ide
PlJobsOnMP_h


29 
	#PlJobsOnMP_h


	)

31 #i
ENABLE
(
THREADING_OPENMP
)

33 
	~<omp.h
>

35 
mea
 
	gWTF
 {

37 as
	cPlEnvmt
 {

38 
WTF_MAKE_NONCOPYABLE
(
PlEnvmt
);

39 
	gpublic
:

40 (*
ThadFuni
)(*);

42 
PlEnvmt
(
ThadFuni
 
thadFuni
, 
size_t
 
sizeOfPam
, 
queedJobNumb
) :

43 
m_thadFuni
(
thadFuni
),

44 
m_sizeOfPam
(
sizeOfPam
)

46 
	gmaxNumbOfThads
 = 
omp_g_max_thads
();

48 i(!
	gqueedJobNumb
 ||equeedJobNumb > 
	gmaxNumbOfThads
)

49 
	gqueedJobNumb
 = 
maxNumbOfThads
;

51 
ASSERT
(
queedJobNumb
 > 0);

53 
	gm_numbOfJobs
 = 
queedJobNumb
;

57 
numbOfJobs
()

59  
	gm_numbOfJobs
;

62 
execu
(* 
ms
)

64 
omp_t_num_thads
(
m_numbOfJobs
);

66 #agm
omp
 
Ζ
 

67 
	gi
 = 0; i < 
	gm_numbOfJobs
; ++i)

68 (*
	gm_thadFuni
)(
	gms
 + 
i
 * 
	gm_sizeOfPam
);

71 
	give
:

72 
ThadFuni
 
m_thadFuni
;

73 
size_t
 
	gm_sizeOfPam
;

74 
	gm_numbOfJobs
;

	@PassOwnPtr.h

26 #ide
WTF_PassOwnP_h


27 
	#WTF_PassOwnP_h


	)

29 
	~<cddef
>

30 
	~<wtf/Asis.h
>

31 
	~<wtf/GP.h
>

32 
	~<wtf/OwnPComm.h
>

33 
	~<ty_as
>

35 
mea
 
	gWTF
 {

37 
	gme
<
tyme
 
	gT
> 
ass
 
	gOwnP
;

38 
	gme
<
tyme
 
	gT
> 
ass
 
	gPassOwnP
;

39 
	gme
<
tyme
 
	gT
> 
	gPassOwnP
<T> 
adtP
(
T
*);

41 
ass
 
	gRefCouedBa
;

42 
ass
 
	gThadSaRefCouedBa
;

44 
	gme
<
tyme
 
	gT
> cs
	cPassOwnP
 {

45 
	gpublic
:

46 
T
 
	tVueTy
;

47 
VueTy
* 
	tPTy
;

49 
PassOwnP
(: 
m_r
(0) { }

50 
PassOwnP
(
d
::
nuαr_t
: 
m_r
(0) { }

55 
PassOwnP
(cڡ PassOwnP& 
o
: 
m_r
(o.
akP
()) { }

56 
me
<
tyme
 
U
> 
PassOwnP
(cڡ PassOwnP<U>& 
o
: 
m_r
(o.
akP
()) { }

58 ~
PassOwnP
({ 
deOwdP
(
m_r
); }

60 
PTy
 
g
(cڡ {  
	gm_r
; }

62 
PTy
 
akP
(cڡ 
	gWARN_UNUSED_RETURN
;

64 
	gVueTy
& 
	gݔ
*(cڡ { 
ASSERT
(
m_r
);  *
	gm_r
; }

65 
PTy
 
	gݔ
->(cڡ { 
ASSERT
(
m_r
);  
	gm_r
; }

67 
bo
 
	gݔ
!(cڡ {  !
	gm_r
; }

70 
PTy
 
	tPassOwnP
::*
	tUnecifdBoTy
;

71 
ݔ
 
UnecifdBoTy
(cڡ {  
	gm_r
 ? &
	gPassOwnP
::
m_r
 : 0; }

73 
	gPassOwnP
& 
	gݔ
=(cڡ 
PassOwnP
&{ 
COMPILE_ASSERT
(!(
T
*), 
PassOwnP_should_v_be_assigd_to
);  *
	gthis
; }

75 
	gme
<
tyme
 
	gU
> 
nd
 
	gPassOwnP
<U> 
adtP
(
U
*);

77 
	give
:

78 
exic
 
PassOwnP
(
PTy
 
r
: 
m_r
(ptr) { }

82 
me
<
tyme
 
U
> 
bo
 
ݔ
==(cڡ 
PassOwnP
<U>&{ 
COMPILE_ASSERT
(!(U*), 
OwnPs_should_v_be_equ
);  
	gl
; }

83 
	gme
<
tyme
 
	gU
> 
bo
 
	gݔ
!=(cڡ 
PassOwnP
<
U
>&{ 
COMPILE_ASSERT
(!(U*), 
OwnPs_should_v_be_equ
);  
	gl
; }

84 
	gme
<
tyme
 
	gU
> 
bo
 
	gݔ
==(cڡ 
OwnP
<
U
>&{ 
COMPILE_ASSERT
(!(U*), 
OwnPs_should_v_be_equ
);  
	gl
; }

85 
	gme
<
tyme
 
	gU
> 
bo
 
	gݔ
!=(cڡ 
OwnP
<
U
>&{ 
COMPILE_ASSERT
(!(U*), 
OwnPs_should_v_be_equ
);  
	gl
; }

87 
mub
 
PTy
 
	gm_r
;

90 
	gme
<
tyme
 
	gT
> 
le
ym
	gPassOwnP
<T>::
PTy
 
PassOwnP
<
T
>::
	$akP
() const

92 
PTy
 
r
 = 
m_r
;

93 
m_r
 = 0;

94  
r
;

95 
	}
}

97 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
==(cڡ 
PassOwnP
<
T
>& 
a
, cڡ 
	gPassOwnP
<U>& 
	gb
)

99  
	ga
.
g
(=
b
.get();

102 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
==(cڡ 
PassOwnP
<
T
>& 
a
, cڡ 
	gOwnP
<U>& 
	gb
)

104  
	ga
.
g
(=
b
.get();

107 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
==(cڡ 
OwnP
<
T
>& 
a
, cڡ 
	gPassOwnP
<U>& 
	gb
)

109  
	ga
.
g
(=
b
.get();

112 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
==(cڡ 
PassOwnP
<
T
>& 
a
, 
U
* 
	gb
)

114  
	ga
.
g
(=
b
;

117 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
==(
T
* 
a
, cڡ 
	gPassOwnP
<U>& 
	gb
)

119  
	ga
 =
b
.
g
();

122 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
!=(cڡ 
PassOwnP
<
T
>& 
a
, cڡ 
	gPassOwnP
<U>& 
	gb
)

124  
	ga
.
g
(!
b
.get();

127 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
!=(cڡ 
PassOwnP
<
T
>& 
a
, cڡ 
	gOwnP
<U>& 
	gb
)

129  
	ga
.
g
(!
b
.get();

132 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
!=(cڡ 
OwnP
<
T
>& 
a
, cڡ 
	gPassOwnP
<U>& 
	gb
)

134  
	ga
.
g
(!
b
.get();

137 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
!=(cڡ 
PassOwnP
<
T
>& 
a
, 
U
* 
	gb
)

139  
	ga
.
g
(!
b
;

142 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
!=(
T
* 
a
, cڡ 
	gPassOwnP
<U>& 
	gb
)

144  
	ga
 !
b
.
g
();

147 
	gme
<
tyme
 
	gT
> 
le
 
	gPassOwnP
<T> 
	$adtP
(
T
* 
r
)

149 
	`ic_as
(!
d
::
is_cvtib
<
T
*, 
RefCouedBa
*>::
vue
, "Doot usedoptPtr with RefCounted, usedoptRef!");

150 
	`ic_as
(!
d
::
is_cvtib
<
T
*, 
ThadSaRefCouedBa
*>::
vue
, "Doot usedoptPtr with ThreadSafeRefCounted, usedoptRef!");

152  
PassOwnP
<
T
>(
r
);

153 
	}
}

155 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
	gPassOwnP
<T> 
ic_por_
(cڡ 
PassOwnP
<
U
>& 
p
)

157  
adtP
(
ic_
<
T
*>(
p
.
akP
()));

160 
	gme
 <
tyme
 
	gT
> 
	gIsSmtP
<
	gPassOwnP
<T>> {

161 cڡ 
bo
 
	gvue
 = 
ue
;

166 
usg
 
	gWTF
::
PassOwnP
;

167 
usg
 
	gWTF
::
adtP
;

168 
usg
 
	gWTF
::
ic_por_
;

	@PassRef.h

21 #ide
WTF_PassRef_h


22 
	#WTF_PassRef_h


	)

24 
	~"Asis.h
"

25 
	~<cddef
>

26 
	~<uty
>

28 
mea
 
	gWTF
 {

30 
	gme
<
tyme
 
	gT
> 
ass
 
	gPassRef
;

31 
	gme
<
tyme
 
	gT
> 
ass
 
	gPassRefP
;

32 
	gme
<
tyme
 
	gT
> 
ass
 
	gRef
;

33 
	gme
<
tyme
 
	gT
> 
ass
 
	gRefP
;

35 
	gme
<
tyme
 
	gT
> 
	gPassRef
<T> 
adtRef
(
T
&);

37 
le
 
ad݋d
(const *) { }

39 
	gme
<
tyme
 
	gT
> cs
	cPassRef
 {

40 
	gpublic
:

41 
PassRef
(
T
&);

42 
PassRef
(PassRef&&);

43 
	gme
<
tyme
 
	gU
> 
PassRef
(PassRef<
U
>);

45 cڡ 
	gT
& 
g
() const;

46 
	gT
& 
g
();

48 
drRef
();

49 
	gT
& 
akRef
(
	gWARN_UNUSED_RETURN
;

51 #ide
NDEBUG


52 ~
PassRef
();

55 
	give
:

56 
nd
 
PassRef
 
adtRef
<
T
>(T&);

58 
	gme
<
tyme
 
	gU
> 
nd
 
ass
 
	gPassRef
;

59 
	gme
<
tyme
 
	gU
> 
nd
 
ass
 
	gPassRefP
;

60 
	gme
<
tyme
 
	gU
> 
nd
 
ass
 
	gRef
;

61 
	gme
<
tyme
 
	gU
> 
nd
 
ass
 
	gRefP
;

63 
	eAdtTag
 { 
	gAdt
 };

64 
PassRef
(
T
&, 
AdtTag
);

66 
	gT
& 
	gm_n
;

68 #ide
NDEBUG


69 
bo
 
	gm_gaveUpRen
;

73 
	gme
<
tyme
 
	gT
> 
le
 
	gPassRef
<T>::
	$PassRef
(
T
& 
n
)

74 : 
	$m_n
(
n
)

75 #ide
NDEBUG


76 , 
	$m_gaveUpRen
(
l
)

79 
n
.
	`f
();

80 
	}
}

82 
	gme
<
tyme
 
	gT
> 
le
 
	gPassRef
<T>::
	$PassRef
(
PassRef
&& 
h
)

83 : 
	`m_n
(
h
.
	$akRef
())

84 #ide
NDEBUG


85 , 
	$m_gaveUpRen
(
l
)

88 
	}
}

90 
	gme
<
tyme
 
	gT
>eme<tym
	gU
> 
le
 
	gPassRef
<T>::
PassRef
(PassRef<
U
> 
h
)

91 : 
m_n
(
h
.
	$akRef
())

92 #ide
NDEBUG


93 , 
	$m_gaveUpRen
(
l
)

96 
	}
}

98 #ide
NDEBUG


100 
	gme
<
tyme
 
	gT
> 
	gPassRef
<T>::~
	$PassRef
()

102 
	`ASSERT
(
m_gaveUpRen
);

103 
	}
}

107 
	gme
<
tyme
 
	gT
> 
le
 
	gPassRef
<T>::
	$drRef
()

109 
	`ASSERT
(!
m_gaveUpRen
);

110 
m_n
.
	`def
();

111 #ide
NDEBUG


112 
m_gaveUpRen
 = 
ue
;

114 
	}
}

116 
	gme
<
tyme
 
	gT
> 
le
 cڡ T& 
	gPassRef
<T>::
	$g
() const

118 
	`ASSERT
(!
m_gaveUpRen
);

119  
m_n
;

120 
	}
}

122 
	gme
<
tyme
 
	gT
> 
le
 T& 
	gPassRef
<T>::
	$g
()

124 
	`ASSERT
(!
m_gaveUpRen
);

125  
m_n
;

126 
	}
}

128 
	gme
<
tyme
 
	gT
> 
le
 T& 
	gPassRef
<T>::
	$akRef
()

130 #ide
NDEBUG


131 
	`ASSERT
(!
m_gaveUpRen
);

132 
m_gaveUpRen
 = 
ue
;

134  
m_n
;

135 
	}
}

137 
	gme
<
tyme
 
	gT
> 
le
 
	gPassRef
<T>::
	$PassRef
(
T
& 
n
, 
AdtTag
)

138 : 
	$m_n
(
n
)

139 #ide
NDEBUG


140 , 
	$m_gaveUpRen
(
l
)

143 
	}
}

145 
	gme
<
tyme
 
	gT
> 
le
 
	gPassRef
<T> 
	$adtRef
(
T
& 
n
)

147 
	`ad݋d
(&
n
);

148  
PassRef
<
T
>(
n
, PassRef<T>::
Adt
);

149 
	}
}

151 
	gme
<
tyme
 
	gT
, 
	gtyme
... 
	gArgs
> 
le
 
	gPassRef
<T> 
	$RefCoued
(
Args
&&... 
gs
)

153  
	`adtRef
(*
w
 
	`T
(
d
::
fwd
<
Args
>(
gs
)...));

154 
	}
}

158 
usg
 
	gWTF
::
PassRef
;

159 
usg
 
	gWTF
::
adtRef
;

160 
usg
 
	gWTF
::
RefCoued
;

	@PassRefPtr.h

21 #ide
WTF_PassRefP_h


22 
	#WTF_PassRefP_h


	)

24 
	~<wtf/GP.h
>

25 
	~<wtf/PassRef.h
>

27 
mea
 
	gWTF
 {

29 
	gme
<
tyme
 
	gT
> 
	gPassRefP
<T> 
adtRef
(
T
*);

31 
	gme
<
tyme
 
	gT
> 
ALWAYS_INLINE
 
fIfNNu
(
T
* 
r
)

33 i(
LIKELY
(
r
 !
nuαr
))

34 
r
->
f
();

37 
	gme
<
tyme
 
	gT
> 
ALWAYS_INLINE
 
defIfNNu
(
T
* 
r
)

39 i(
LIKELY
(
r
 !
nuαr
))

40 
r
->
def
();

43 
	gme
<
tyme
 
	gT
> cs
	cPassRefP
 {

44 
	gpublic
:

45 
T
 
	tVueTy
;

46 
VueTy
* 
	tPTy
;

48 
PassRefP
(: 
m_r
(
nuαr
) { }

49 
PassRefP
(
T
* 
r
: 
m_r
Ռ{ 
fIfNNu
(ptr); }

53 
PassRefP
(cڡ PassRefP& 
o
: 
m_r
(o.
akRef
()) { }

54 
me
<
tyme
 
U
> 
PassRefP
(cڡ PassRefP<U>& 
o
: 
m_r
(o.
akRef
()) { }

56 
ALWAYS_INLINE
 ~
PassRefP
({ 
defIfNNu
(
m_r
); }

58 
	gme
<
tyme
 
	gU
> 
PassRefP
(cڡ 
RefP
<
U
>&);

59 
	gme
<
tyme
 
	gU
> 
PassRefP
(
PassRef
<
U
> 
n
: 
m_r
(&n.
akRef
()) { }

61 
T
* 
g
(cڡ {  
m_r
; }

63 
T
* 
akRef
(cڡ 
	gWARN_UNUSED_RETURN
;

65 
	gT
& 
	gݔ
*(cڡ {  *
	gm_r
; }

66 
T
* 
	gݔ
->(cڡ {  
	gm_r
; }

68 
bo
 
	gݔ
!(cڡ {  !
	gm_r
; }

71 
	gT
* (
	tPassRefP
::*
	tUnecifdBoTy
);

72 
ݔ
 
UnecifdBoTy
(cڡ {  
	gm_r
 ? &
	gPassRefP
::
m_r
 : 
nuαr
; }

74 
nd
 
PassRefP
 
	gadtRef
<
	gT
>(T*);

76 
	give
:

77 
PassRefP
& 
ݔ
=(cڡ PassRefP&
de
;

79 
	eAdtTag
 { 
	gAdt
 };

80 
PassRefP
(
T
* 
r
, 
AdtTag
: 
m_r
(ptr) { }

82 
mub
 
T
* 
m_r
;

85 
	gme
<
tyme
 
	gT
>eme<tym
	gU
> 
le
 
	gPassRefP
<T>::
PassRefP
(cڡ 
RefP
<
U
>& 
o
)

86 : 
m_r
(
o
.
	$g
())

88 
T
* 
r
 = 
m_r
;

89 
	`fIfNNu
(
r
);

90 
	}
}

92 
	gme
<
tyme
 
	gT
> 
le
 
T
* 
	gPassRefP
<T>::
	$akRef
() const

94 
T
* 
r
 = 
m_r
;

95 
m_r
 = 
nuαr
;

96  
r
;

97 
	}
}

99 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
==(cڡ 
PassRefP
<
T
>& 
a
, cڡ 
	gPassRefP
<U>& 
	gb
)

101  
	ga
.
g
(=
b
.get();

104 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
==(cڡ 
PassRefP
<
T
>& 
a
, cڡ 
	gRefP
<U>& 
	gb
)

106  
	ga
.
g
(=
b
.get();

109 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
==(cڡ 
RefP
<
T
>& 
a
, cڡ 
	gPassRefP
<U>& 
	gb
)

111  
	ga
.
g
(=
b
.get();

114 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
==(cڡ 
PassRefP
<
T
>& 
a
, 
U
* 
	gb
)

116  
	ga
.
g
(=
b
;

119 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
==(
T
* 
a
, cڡ 
	gPassRefP
<U>& 
	gb
)

121  
	ga
 =
b
.
g
();

124 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
!=(cڡ 
PassRefP
<
T
>& 
a
, cڡ 
	gPassRefP
<U>& 
	gb
)

126  
	ga
.
g
(!
b
.get();

129 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
!=(cڡ 
PassRefP
<
T
>& 
a
, cڡ 
	gRefP
<U>& 
	gb
)

131  
	ga
.
g
(!
b
.get();

134 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
!=(cڡ 
RefP
<
T
>& 
a
, cڡ 
	gPassRefP
<U>& 
	gb
)

136  
	ga
.
g
(!
b
.get();

139 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
!=(cڡ 
PassRefP
<
T
>& 
a
, 
U
* 
	gb
)

141  
	ga
.
g
(!
b
;

144 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
!=(
T
* 
a
, cڡ 
	gPassRefP
<U>& 
	gb
)

146  
	ga
 !
b
.
g
();

149 
	gme
<
tyme
 
	gT
> 
le
 
	gPassRefP
<T> 
	$adtRef
(
T
* 
p
)

151 
	`ad݋d
(
p
);

152  
PassRefP
<
T
>(
p
, PassRefP<T>::
Adt
);

153 
	}
}

155 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
	gPassRefP
<T> 
ic_por_
(cڡ 
PassRefP
<
U
>& 
p
)

157  
adtRef
(
ic_
<
T
*>(
p
.
akRef
()));

160 
	gme
 <
tyme
 
	gT
> 
	gIsSmtP
<
	gPassRefP
<T>> {

161 cڡ 
bo
 
	gvue
 = 
ue
;

166 
usg
 
	gWTF
::
PassRefP
;

167 
usg
 
	gWTF
::
adtRef
;

168 
usg
 
	gWTF
::
ic_por_
;

	@Platform.h

28 #ide
WTF_Ptfm_h


29 
	#WTF_Ptfm_h


	)

32 
	#ENABLE_VMOLAB
 1

	)

33 
	#ENABLE_VMOLAB_TIME
 1

	)

36 
	~<wtf/Comp.h
>

41 
	#PLATFORM
(
WTF_FEATURE
(
defed
 
WTF_PLATFORM_
##WTF_FEATURE && WTF_PLATFORM_##WTF_FEATURE)

	)

47 
	#CPU
(
WTF_FEATURE
(
defed
 
WTF_CPU_
##WTF_FEATURE && WTF_CPU_##WTF_FEATURE)

	)

49 
	#HAVE
(
WTF_FEATURE
(
defed
 
HAVE_
##WTF_FEATURE && HAVE_##WTF_FEATURE)

	)

52 
	#OS
(
WTF_FEATURE
(
defed
 
WTF_OS_
##WTF_FEATURE && WTF_OS_##WTF_FEATURE)

	)

58 
	#USE
(
WTF_FEATURE
(
defed
 
WTF_USE_
##WTF_FEATURE && WTF_USE_##WTF_FEATURE)

	)

60 
	#ENABLE
(
WTF_FEATURE
(
defed
 
ENABLE_
##WTF_FEATURE && ENABLE_##WTF_FEATURE)

	)

68 #i
defed
(
__pha__
)

69 
	#WTF_CPU_ALPHA
 1

	)

73 #i
defed
(
__ha__
|| defed(
__ha64__
)

74 
	#WTF_CPU_HPPA
 1

	)

75 
	#WTF_CPU_BIG_ENDIAN
 1

	)

79 #i
defed
(
__64__
)

80 
	#WTF_CPU_IA64
 1

	)

82 #i!
defed
(
__LP64__
)

83 
	#WTF_CPU_IA64_32
 1

	)

89 #i(
defed
(
ms
|| defed(
__ms__
|| defed(
MIPS
|| defed(
_MIPS_
)) \

90 && 
	$defed
(
_ABIO32
)

91 
	#WTF_CPU_MIPS
 1

	)

92 #i
	`defed
(
__MIPSEB__
)

93 
	#WTF_CPU_BIG_ENDIAN
 1

	)

95 
	#WTF_MIPS_PIC
 (
defed
 
__PIC__
)

	)

96 
	#WTF_MIPS_ARCH
 
__ms


	)

97 
	#WTF_MIPS_ISA
(
v
(
defed
 
WTF_MIPS_ARCH
 && WTF_MIPS_ARCH =v)

	)

98 
	#WTF_MIPS_ISA_AT_LEAST
(
v
(
defed
 
WTF_MIPS_ARCH
 && WTF_MIPS_ARCH >v)

	)

99 
	#WTF_MIPS_ARCH_REV
 
__ms_i_v


	)

100 
	#WTF_MIPS_ISA_REV
(
v
(
defed
 
WTF_MIPS_ARCH_REV
 && WTF_MIPS_ARCH_REV =v)

	)

101 
	#WTF_MIPS_DOUBLE_FLOAT
 (
defed
 
__ms_hd_t
 && !defed 
__ms_sg_t
)

	)

102 
	#WTF_MIPS_FP64
 (
defed
 
__ms_r
 && __ms_=64)

	)

104 
	#WTF_USE_ARENA_ALLOC_ALIGNMENT_INTEGER
 1

	)

108 #i
	`defed
(
__c__
) \

109 || 
	`defed
(
__PPC__
) \

110 || 
	`defed
(
__powpc__
) \

111 || 
	`defed
(
__powpc
) \

112 || 
	`defed
(
__POWERPC__
) \

113 || 
	`defed
(
_M_PPC
) \

114 || 
	`defed
(
__PPC
)) \

115 && 
	`defed
(
__BYTE_ORDER__
) \

116 && (
__BYTE_ORDER__
 =
__ORDER_BIG_ENDIAN__
)

117 
	#WTF_CPU_PPC
 1

	)

118 
	#WTF_CPU_BIG_ENDIAN
 1

	)

122 #i
	`defed
(
__c64__
) \

123 || 
	`defed
(
__PPC64__
)) \

124 && 
	`defed
(
__BYTE_ORDER__
) \

125 && (
__BYTE_ORDER__
 =
__ORDER_BIG_ENDIAN__
)

126 
	#WTF_CPU_PPC64
 1

	)

127 
	#WTF_CPU_BIG_ENDIAN
 1

	)

131 #i
	`defed
(
__c64__
) \

132 || 
	`defed
(
__PPC64__
) \

133 || 
	`defed
(
__c64__
) \

134 || 
	`defed
(
__PPC64LE__
)) \

135 && 
	`defed
(
__BYTE_ORDER__
) \

136 && (
__BYTE_ORDER__
 =
__ORDER_LITTLE_ENDIAN__
)

137 
	#WTF_CPU_PPC64LE
 1

	)

141 #i
	`defed
(
__SH4__
)

142 
	#WTF_CPU_SH4
 1

	)

146 #i
	`defed
(
__s390x__
)

147 
	#WTF_CPU_S390X
 1

	)

148 
	#WTF_CPU_BIG_ENDIAN
 1

	)

152 #i
	`defed
(
__s390__
)

153 
	#WTF_CPU_S390
 1

	)

154 
	#WTF_CPU_BIG_ENDIAN
 1

	)

158 #i 
	`defed
(
__i386__
) \

159 || 
	`defed
(
i386
) \

160 || 
	`defed
(
_M_IX86
) \

161 || 
	`defed
(
_X86_
) \

162 || 
	$defed
(
__THW_INTEL
)

163 
	#WTF_CPU_X86
 1

	)

167 #i 
	`defed
(
__x86_64__
) \

168 || 
	$defed
(
_M_X64
)

169 
	#WTF_CPU_X86_64
 1

	)

173 #i(
	`defed
(
__m64__
&& defed(
__APPLE__
)|| defed(
__rch64__
)

174 
	#WTF_CPU_ARM64
 1

	)

178 
	#WTF_ARM_ARCH_AT_LEAST
(
N
(
	`CPU
(
ARM
&& 
WTF_ARM_ARCH_VERSION
 >N)

	)

180 #i 
	`defed
(
m
) \

181 || 
	`defed
(
__m__
) \

182 || 
	`defed
(
ARM
) \

183 || 
	$defed
(
_ARM_
)

184 
	#WTF_CPU_ARM
 1

	)

186 #i
	`defed
(
__ARM_PCS_VFP
)

187 
	#WTF_CPU_ARM_HARDFP
 1

	)

190 #i
	`defed
(
__ARMEB__
)

191 
	#WTF_CPU_BIG_ENDIAN
 1

	)

193 #i!
	`defed
(
__ARM_EABI__
) \

194 && !
	`defed
(
__EABI__
) \

195 && !
	`defed
(
__VFP_FP__
) \

196 && !
	$defed
(
_WIN32_WCE
)

197 
	#WTF_CPU_MIDDLE_ENDIAN
 1

	)

202 #i 
	`defed
(
__ARM_ARCH_4__
) \

203 || 
	`defed
(
__ARM_ARCH_4T__
) \

204 || 
	$defed
(
__MARM_ARMV4__
)

205 
	#WTF_ARM_ARCH_VERSION
 4

	)

207 #i
	`defed
(
__ARM_ARCH_5__
) \

208 || 
	`defed
(
__ARM_ARCH_5T__
) \

209 || 
	$defed
(
__MARM_ARMV5__
)

210 
	#WTF_ARM_ARCH_VERSION
 5

	)

212 #i
	`defed
(
__ARM_ARCH_5E__
) \

213 || 
	`defed
(
__ARM_ARCH_5TE__
) \

214 || 
	$defed
(
__ARM_ARCH_5TEJ__
)

215 
	#WTF_ARM_ARCH_VERSION
 5

	)

217 
	#WTF_USE_ARENA_ALLOC_ALIGNMENT_INTEGER
 1

	)

219 #i
	`defed
(
__ARM_ARCH_6__
) \

220 || 
	`defed
(
__ARM_ARCH_6J__
) \

221 || 
	`defed
(
__ARM_ARCH_6K__
) \

222 || 
	`defed
(
__ARM_ARCH_6Z__
) \

223 || 
	`defed
(
__ARM_ARCH_6ZK__
) \

224 || 
	`defed
(
__ARM_ARCH_6T2__
) \

225 || 
	$defed
(
__ARMV6__
)

226 
	#WTF_ARM_ARCH_VERSION
 6

	)

228 #i
	`defed
(
__ARM_ARCH_7A__
) \

229 || 
	`defed
(
__ARM_ARCH_7K__
) \

230 || 
	`defed
(
__ARM_ARCH_7R__
) \

231 || 
	$defed
(
__ARM_ARCH_7S__
)

232 
	#WTF_ARM_ARCH_VERSION
 7

	)

234 #i
	`defed
(
__ARM_ARCH_8__
)

235 
	#WTF_ARM_ARCH_VERSION
 8

	)

238 #i
	`defed
(
_M_ARM
)

239 
	#WTF_ARM_ARCH_VERSION
 
_M_ARM


	)

242 #i
	`defed
(
__TARGET_ARCH_ARM
)

243 
	#WTF_ARM_ARCH_VERSION
 
__TARGET_ARCH_ARM


	)

245 #i
	`defed
(
__TARGET_ARCH_5E
) \

246 || 
	`defed
(
__TARGET_ARCH_5TE
) \

247 || 
	$defed
(
__TARGET_ARCH_5TEJ
)

249 
	#WTF_USE_ARENA_ALLOC_ALIGNMENT_INTEGER
 1

	)

253 
	#WTF_ARM_ARCH_VERSION
 0

	)

258 #i 
	`defed
(
__ARM_ARCH_4T__
)

259 
	#WTF_THUMB_ARCH_VERSION
 1

	)

261 #i
	`defed
(
__ARM_ARCH_5T__
) \

262 || 
	`defed
(
__ARM_ARCH_5TE__
) \

263 || 
	$defed
(
__ARM_ARCH_5TEJ__
)

264 
	#WTF_THUMB_ARCH_VERSION
 2

	)

266 #i
	`defed
(
__ARM_ARCH_6J__
) \

267 || 
	`defed
(
__ARM_ARCH_6K__
) \

268 || 
	`defed
(
__ARM_ARCH_6Z__
) \

269 || 
	`defed
(
__ARM_ARCH_6ZK__
) \

270 || 
	$defed
(
__ARM_ARCH_6M__
)

271 
	#WTF_THUMB_ARCH_VERSION
 3

	)

273 #i
	`defed
(
__ARM_ARCH_6T2__
) \

274 || 
	`defed
(
__ARM_ARCH_7__
) \

275 || 
	`defed
(
__ARM_ARCH_7A__
) \

276 || 
	`defed
(
__ARM_ARCH_7K__
) \

277 || 
	`defed
(
__ARM_ARCH_7M__
) \

278 || 
	`defed
(
__ARM_ARCH_7R__
) \

279 || 
	$defed
(
__ARM_ARCH_7S__
)

280 
	#WTF_THUMB_ARCH_VERSION
 4

	)

283 #i
	`defed
(
__TARGET_ARCH_THUMB
)

284 
	#WTF_THUMB_ARCH_VERSION
 
__TARGET_ARCH_THUMB


	)

287 
	#WTF_THUMB_ARCH_VERSION
 0

	)

294 #i!
	`defed
(
ARMV5_OR_LOWER
&& !
	`WTF_ARM_ARCH_AT_LEAST
(6)

295 
	#WTF_CPU_ARMV5_OR_LOWER
 1

	)

302 #i!
	`defed
(
WTF_CPU_ARM_TRADITIONAL
&& !defed(
WTF_CPU_ARM_THUMB2
)

303 #i
	`defed
(
thumb2
|| defed(
__thumb2__
) \

304 || ((
	`defed
(
__thumb
|| defed(
__thumb__
)&& 
WTF_THUMB_ARCH_VERSION
 == 4)

305 
	#WTF_CPU_ARM_TRADITIONAL
 0

	)

306 
	#WTF_CPU_ARM_THUMB2
 1

	)

307 #i
	`WTF_ARM_ARCH_AT_LEAST
(4)

308 
	#WTF_CPU_ARM_TRADITIONAL
 1

	)

309 
	#WTF_CPU_ARM_THUMB2
 0

	)

313 #i
	`CPU
(
ARM_TRADITIONAL
&& CPU(
ARM_THUMB2
)

317 #i
	`defed
(
__ARM_NEON__
&& !defed(
WTF_CPU_ARM_NEON
)

318 
	#WTF_CPU_ARM_NEON
 1

	)

321 #i
	`CPU
(
ARM_NEON
)

323 
	#HAVE_ARM_NEON_INTRINSICS
 1

	)

326 #i(
	`defed
(
__VFP_FP__
&& !defed(
__SOFTFP__
))

327 
	#WTF_CPU_ARM_VFP
 1

	)

330 #i
	`defed
(
__ARM_ARCH_7K__
)

331 
	#WTF_CPU_APPLE_ARMV7K
 1

	)

334 #i
	`defed
(
__ARM_ARCH_7S__
)

335 
	#WTF_CPU_APPLE_ARMV7S
 1

	)

340 #i
	`CPU
(
ARM
|| CPU(
MIPS
|| CPU(
SH4
)

341 
	#WTF_CPU_NEEDS_ALIGNED_ACCESS
 1

	)

348 #ifde
_AIX


349 
	#WTF_OS_AIX
 1

	)

353 #ifde
__APPLE__


354 
	#WTF_OS_DARWIN
 1

	)

356 
	~<Avaaby.h
>

357 
	~<AvaabyMaos.h
>

358 
	~<TgCdiڮs.h
>

363 #i
	`OS
(
DARWIN
&& ((
	`defed
(
TARGET_OS_EMBEDDED
) && TARGET_OS_EMBEDDED) \

364 || (
	`defed
(
TARGET_OS_IPHONE
) && TARGET_OS_IPHONE) \

365 || (
	`defed
(
TARGET_IPHONE_SIMULATOR
) && TARGET_IPHONE_SIMULATOR))

366 
	#WTF_OS_IOS
 1

	)

367 #i
	`OS
(
DARWIN
&& 
	`defed
(
TARGET_OS_MAC
) && TARGET_OS_MAC

368 
	#WTF_OS_MAC_OS_X
 1

	)

372 #i
	`defed
(
__FeBSD__
|| defed(
__DgFly__
|| defed(
__FeBSD_kl__
)

373 
	#WTF_OS_FREEBSD
 1

	)

377 #ifde
__GNU__


378 
	#WTF_OS_HURD
 1

	)

382 #ifde
__lux__


383 
	#WTF_OS_LINUX
 1

	)

387 #i
	`defed
(
__NBSD__
)

388 
	#WTF_OS_NETBSD
 1

	)

392 #ifde
__OnBSD__


393 
	#WTF_OS_OPENBSD
 1

	)

397 #i
	`defed
(
sun
|| defed(
__sun
)

398 
	#WTF_OS_SOLARIS
 1

	)

402 #i
	`defed
(
WIN32
|| defed(
_WIN32
)

403 
	#WTF_OS_WINDOWS
 1

	)

406 
	#WTF_OS_WIN
 
ERROR
 "USE WINDOWS WITH OS NOT WIN"

	)

407 
	#WTF_OS_MAC
 
ERROR
 "USE MAC_OS_X WITH OS NOT MAC"

	)

410 #i 
	`OS
(
AIX
) \

411 || 
	`OS
(
DARWIN
) \

412 || 
	`OS
(
FREEBSD
) \

413 || 
	`OS
(
HURD
) \

414 || 
	`OS
(
LINUX
) \

415 || 
	`OS
(
NETBSD
) \

416 || 
	`OS
(
OPENBSD
) \

417 || 
	`OS
(
SOLARIS
) \

418 || 
	`defed
(
unix
) \

419 || 
	`defed
(
__unix
) \

420 || 
	$defed
(
__unix__
)

421 
	#WTF_OS_UNIX
 1

	)

433 #i
	`defed
(
BUILDING_EFL__
)

434 
	#WTF_PLATFORM_EFL
 1

	)

435 #i
	`defed
(
BUILDING_GTK__
)

436 
	#WTF_PLATFORM_GTK
 1

	)

437 #i
	`OS
(
MAC_OS_X
)

438 
	#WTF_PLATFORM_MAC
 1

	)

439 #i
	`OS
(
IOS
)

440 
	#WTF_PLATFORM_IOS
 1

	)

441 #i
	`defed
(
TARGET_IPHONE_SIMULATOR
) && TARGET_IPHONE_SIMULATOR

442 
	#WTF_PLATFORM_IOS_SIMULATOR
 1

	)

444 #i
	`OS
(
WINDOWS
)

445 
	#WTF_PLATFORM_WIN
 1

	)

449 #i
	`PLATFORM
(
MAC
|| PLATFORM(
IOS
)

450 
	#WTF_PLATFORM_COCOA
 1

	)

453 #i
	`PLATFORM
(
COCOA
)

454 #i
defed
 
__has_ude
 && 
	`__has_ude
(<
CeFoundi
/
CFPriv
.
h
>)

455 
	#WTF_USE_APPLE_INTERNAL_SDK
 1

	)

462 #i
	`PLATFORM
(
COCOA
|| (PLATFORM(
WIN
&& !
	`USE
(
WINGDI
&& !PLATFORM(
WIN_CAIRO
))

463 
	#WTF_USE_CG
 1

	)

465 #i
	`PLATFORM
(
COCOA
|| (PLATFORM(
WIN
&& 
	`USE
(
CG
))

466 
	#WTF_USE_CA
 1

	)

469 #i
	`PLATFORM
(
GTK
)

470 
	#WTF_USE_CAIRO
 1

	)

471 
	#WTF_USE_GLIB
 1

	)

472 
	#WTF_USE_FREETYPE
 1

	)

473 
	#WTF_USE_HARFBUZZ
 1

	)

474 
	#WTF_USE_SOUP
 1

	)

475 
	#WTF_USE_WEBP
 1

	)

479 #i
	`OS
(
WINDOWS
)

480 
	#WTF_USE_QUERY_PERFORMANCE_COUNTER
 1

	)

483 #i
	`PLATFORM
(
COCOA
)

485 
	#WTF_USE_CF
 1

	)

486 
	#WTF_USE_FOUNDATION
 1

	)

487 
	#WTF_USE_NETWORK_CFDATA_ARRAY_CALLBACK
 1

	)

488 
	#ENABLE_USER_MESSAGE_HANDLERS
 1

	)

489 
	#HAVE_OUT_OF_PROCESS_LAYER_HOSTING
 1

	)

493 #i
	`PLATFORM
(
MAC
)

495 
	#WTF_USE_APPKIT
 1

	)

496 
	#HAVE_RUNLOOP_TIMER
 1

	)

497 
	#HAVE_SEC_IDENTITY
 1

	)

498 
	#HAVE_SEC_KEYCHAIN
 1

	)

500 #i
	`CPU
(
X86_64
)

501 
	#WTF_USE_PLUGIN_HOST_PROCESS
 1

	)

507 #unde
__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES


508 
	#__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES
 0

	)

512 #i
	`PLATFORM
(
IOS
)

514 
	#DONT_FINALIZE_ON_MAIN_THREAD
 1

	)

515 
	#HAVE_READLINE
 1

	)

516 #i
	`USE
(
APPLE_INTERNAL_SDK
)

517 
	#WTF_USE_CFNETWORK
 1

	)

519 
	#WTF_USE_UIKIT_EDITING
 1

	)

520 
	#WTF_USE_WEB_THREAD
 1

	)

521 
	#WTF_USE_QUICK_LOOK
 1

	)

523 #i
	`CPU
(
ARM64
)

524 
	#ENABLE_JIT_CONSTANT_BLINDING
 0

	)

527 #i
	`CPU
(
ARM_NEON
)

528 #unde
HAVE_ARM_NEON_INTRINSICS


529 
	#HAVE_ARM_NEON_INTRINSICS
 0

	)

534 #i
	`PLATFORM
(
WIN
&& !
	`USE
(
WINGDI
)

535 
	#WTF_USE_CF
 1

	)

538 #i
	`PLATFORM
(
WIN
&& !
	`USE
(
WINGDI
&& !PLATFORM(
WIN_CAIRO
)

539 
	#WTF_USE_CFNETWORK
 1

	)

542 #i
	`USE
(
CFNETWORK
|| 
	`PLATFORM
(
COCOA
)

543 
	#WTF_USE_CFURLCACHE
 1

	)

546 #i!
	`defed
(
HAVE_ACCESSIBILITY
)

547 #i
	`PLATFORM
(
COCOA
|| PLATFORM(
WIN
|| PLATFORM(
GTK
|| PLATFORM(
EFL
)

548 
	#HAVE_ACCESSIBILITY
 1

	)

552 #i
	`OS
(
UNIX
)

553 
	#HAVE_ERRNO_H
 1

	)

554 
	#HAVE_LANGINFO_H
 1

	)

555 
	#HAVE_MMAP
 1

	)

556 
	#HAVE_SIGNAL_H
 1

	)

557 
	#HAVE_STRINGS_H
 1

	)

558 
	#HAVE_SYS_PARAM_H
 1

	)

559 
	#HAVE_SYS_TIME_H
 1

	)

560 
	#WTF_USE_PTHREADS
 1

	)

563 #i(
	`OS
(
FREEBSD
|| OS(
OPENBSD
)&& !
	`defed
(
__GLIBC__
)

564 
	#HAVE_PTHREAD_NP_H
 1

	)

567 #i!
	`defed
(
HAVE_VASPRINTF
)

568 #i!
	`COMPILER
(
MSVC
&& !COMPILER(
MINGW
)

569 
	#HAVE_VASPRINTF
 1

	)

573 #i!
	`defed
(
HAVE_STRNSTR
)

574 #i
	`OS
(
DARWIN
|| (OS(
FREEBSD
&& !
	`defed
(
__GLIBC__
))

575 
	#HAVE_STRNSTR
 1

	)

579 #i!
	`OS
(
WINDOWS
&& !OS(
SOLARIS
)

580 
	#HAVE_TM_GMTOFF
 1

	)

581 
	#HAVE_TM_ZONE
 1

	)

582 
	#HAVE_TIMEGM
 1

	)

585 #i
	`OS
(
DARWIN
)

587 
	#HAVE_DISPATCH_H
 1

	)

588 
	#HAVE_MADV_FREE
 1

	)

589 
	#HAVE_MADV_FREE_REUSE
 1

	)

590 
	#HAVE_MERGESORT
 1

	)

591 
	#HAVE_PTHREAD_SETNAME_NP
 1

	)

592 
	#HAVE_READLINE
 1

	)

593 
	#HAVE_SYS_TIMEB_H
 1

	)

594 
	#WTF_USE_ACCELERATE
 1

	)

596 #i!
	`PLATFORM
(
IOS
)

597 
	#HAVE_HOSTED_CORE_ANIMATION
 1

	)

602 #i
	`OS
(
WINDOWS
)

604 
	#HAVE_SYS_TIMEB_H
 1

	)

605 
	#HAVE_ALIGNED_MALLOC
 1

	)

606 
	#HAVE_ISDEBUGGERPRESENT
 1

	)

608 
	~<WTF/WTFHdDei.h
>

612 #i
	`OS
(
WINDOWS
)

613 
	#HAVE_VIRTUALALLOC
 1

	)

621 
	~<wtf/FtuDefes.h
>

623 #i
	`OS
(
WINDOWS
)

624 
	#USE_SYSTEM_MALLOC
 1

	)

627 
	#ENABLE_DEBUG_WITH_BREAKPOINT
 0

	)

628 
	#ENABLE_SAMPLING_COUNTERS
 0

	)

629 
	#ENABLE_SAMPLING_FLAGS
 0

	)

630 
	#ENABLE_SAMPLING_REGIONS
 0

	)

631 
	#ENABLE_OPCODE_SAMPLING
 0

	)

632 
	#ENABLE_CODEBLOCK_SAMPLING
 0

	)

633 #i
	`ENABLE
(
CODEBLOCK_SAMPLING
&& !ENABLE(
OPCODE_SAMPLING
)

636 #i
	`ENABLE
(
OPCODE_SAMPLING
|| ENABLE(
SAMPLING_FLAGS
|| ENABLE(
SAMPLING_REGIONS
)

637 
	#ENABLE_SAMPLING_THREAD
 1

	)

640 #i!
	`defed
(
WTF_USE_JSVALUE64
&& !defed(
WTF_USE_JSVALUE32_64
)

641 #i(
	`CPU
(
X86_64
&& (
	`OS
(
UNIX
|| OS(
WINDOWS
))) \

642 || (
	`CPU
(
IA64
&& !CPU(
IA64_32
)) \

643 || 
	`CPU
(
ALPHA
) \

644 || 
	`CPU
(
ARM64
) \

645 || 
	`CPU
(
S390X
) \

646 || 
	`CPU
(
PPC64
) \

647 || 
	$CPU
(
PPC64LE
)

648 
	#WTF_USE_JSVALUE64
 1

	)

650 
	#WTF_USE_JSVALUE32_64
 1

	)

655 #i!
	`defed
(
ENABLE_JIT
) \

656 && (
	`CPU
(
X86
|| CPU(
X86_64
|| CPU(
ARM
|| CPU(
ARM64
|| CPU(
MIPS
)) \

657 && !
	$CPU
(
APPLE_ARMV7K
)

658 
	#ENABLE_JIT
 1

	)

662 #i!
	`defed
(
HAVE_LLVM
&& 
	`OS
(
DARWIN
&& !
	`PLATFORM
(
EFL
&& !PLATFORM(
GTK
&& 
	`ENABLE
(
FTL_JIT
&& (
	`CPU
(
X86_64
|| CPU(
ARM64
))

663 
	#HAVE_LLVM
 1

	)

666 #i
	`PLATFORM
(
GTK
&& 
	`HAVE
(
LLVM
&& 
	`ENABLE
(
JIT
&& !
	`defed
(
ENABLE_FTL_JIT
&& 
	`CPU
(
X86_64
)

667 
	#ENABLE_FTL_JIT
 1

	)

671 #i
	`USE
(
JSVALUE32_64
)

672 #unde
ENABLE_FTL_JIT


673 
	#ENABLE_FTL_JIT
 0

	)

677 #i
	`PLATFORM
(
IOS_SIMULATOR
)

678 #unde
ENABLE_FTL_JIT


679 
	#ENABLE_FTL_JIT
 0

	)

684 #i!
	`defed
(
WTF_USE_LLVM_DISASSEMBLER
&& 
	`HAVE
(
LLVM
&& (
	`CPU
(
X86_64
|| CPU(
X86
|| CPU(
ARM64
))

685 
	#WTF_USE_LLVM_DISASSEMBLER
 1

	)

691 #i!
	`defed
(
WTF_USE_UDIS86
&& 
	`ENABLE
(
JIT
&& ((
	`OS
(
DARWIN
&& !
	`PLATFORM
(
EFL
&& !PLATFORM(
GTK
)|| (OS(
LINUX
) && (PLATFORM(EFL) || PLATFORM(GTK)))) \

692 && (
	`CPU
(
X86
|| 
	$CPU
(
X86_64
))

693 
	#WTF_USE_UDIS86
 1

	)

696 #i!
	`defed
(
ENABLE_DISASSEMBLER
&& (
	`USE
(
UDIS86
|| USE(
LLVM_DISASSEMBLER
))

697 
	#ENABLE_DISASSEMBLER
 1

	)

700 #i!
	`defed
(
WTF_USE_ARM64_DISASSEMBLER
&& 
	`ENABLE
(
JIT
&& (
	`PLATFORM
(
IOS
|| PLATFORM(
EFL
)&& 
	`CPU
(
ARM64
&& !
	`USE
(
LLVM_DISASSEMBLER
)

701 
	#WTF_USE_ARM64_DISASSEMBLER
 1

	)

704 #i!
	`defed
(
WTF_USE_ARMV7_DISASSEMBLER
&& 
	`ENABLE
(
JIT
&& (
	`PLATFORM
(
IOS
|| PLATFORM(
GTK
)&& 
	`CPU
(
ARM_THUMB2
)

705 
	#WTF_USE_ARMV7_DISASSEMBLER
 1

	)

708 #i!
	`defed
(
ENABLE_DISASSEMBLER
&& (
	`USE
(
UDIS86
|| USE(
ARMV7_DISASSEMBLER
|| USE(
ARM64_DISASSEMBLER
))

709 
	#ENABLE_DISASSEMBLER
 1

	)

712 #i!
	`defed
(
ENABLE_DFG_JIT
&& 
	`ENABLE
(
JIT
)

714 #i(
	`CPU
(
X86
|| CPU(
X86_64
)&& (
	`OS
(
DARWIN
|| OS(
LINUX
|| OS(
FREEBSD
|| OS(
WINDOWS
))

715 
	#ENABLE_DFG_JIT
 1

	)

718 #i(
	`CPU
(
ARM_THUMB2
|| CPU(
ARM64
)&& (
	`PLATFORM
(
IOS
|| PLATFORM(
GTK
|| PLATFORM(
EFL
))

719 
	#ENABLE_DFG_JIT
 1

	)

722 #i
	`CPU
(
ARM_TRADITIONAL
|| CPU(
MIPS
|| CPU(
SH4
)

723 
	#ENABLE_DFG_JIT
 1

	)

731 #i(
	`OS
(
DARWIN
|| 
	`PLATFORM
(
EFL
)&& !PLATFORM(
GTK
&& 
	`ENABLE
(
DFG_JIT
&& 
	`USE
(
JSVALUE64
)

732 
	#ENABLE_CONCURRENT_JIT
 1

	)

736 #i
	`defed
(
ENABLE_LLINT_C_LOOP
) && ENABLE_LLINT_C_LOOP

737 #unde
ENABLE_JIT


738 
	#ENABLE_JIT
 0

	)

742 #i!
	`ENABLE
(
JIT
)

743 #unde
ENABLE_DFG_JIT


744 #unde
ENABLE_FTL_JIT


745 
	#ENABLE_DFG_JIT
 0

	)

746 
	#ENABLE_FTL_JIT
 0

	)

749 
	#ENABLE_FTL_NATIVE_CALL_INLINING
 0

	)

751 #i!
	`defed
(
ENABLE_FTL_NATIVE_CALL_INLINING
)

752 #i
	`COMPILER
(
CLANG
)

753 
	#ENABLE_FTL_NATIVE_CALL_INLINING
 1

	)

755 
	#ENABLE_FTL_NATIVE_CALL_INLINING
 0

	)

760 #i!
	`defed
(
ENABLE_GGC
)

761 #i
	`CPU
(
X86_64
|| CPU(
X86
|| CPU(
ARM64
|| CPU(
ARM
)

762 
	#ENABLE_GGC
 1

	)

764 
	#ENABLE_GGC
 0

	)

770 #i!
	`defed
(
ENABLE_WRITE_BARRIER_PROFILING
)

771 
	#ENABLE_WRITE_BARRIER_PROFILING
 0

	)

780 #i!
	`defed
(
ENABLE_ALLOCATION_LOGGING
)

781 
	#ENABLE_ALLOCATION_LOGGING
 0

	)

786 #i!
	`defed
(
ENABLE_DFG_REGISTER_ALLOCATION_VALIDATION
&& 
	`ENABLE
(
DFG_JIT
)

787 #i!
	`defed
(
NDEBUG
)

788 
	#ENABLE_DFG_REGISTER_ALLOCATION_VALIDATION
 1

	)

790 
	#ENABLE_DFG_REGISTER_ALLOCATION_VALIDATION
 0

	)

795 #i
	`CPU
(
X86
&& 
	`COMPILER
(
MSVC
)

796 
	#JSC_HOST_CALL
 
__


	)

797 #i
	`CPU
(
X86
&& 
	`COMPILER
(
GCC
)

798 
	#JSC_HOST_CALL
 
	`__ibu__
 ((

))

	)

800 
	#JSC_HOST_CALL


	)

804 #i
	`COMPILER
(
GCC
)

805 
	#HAVE_COMPUTED_GOTO
 1

	)

809 #i
	`HAVE
(
COMPUTED_GOTO
|| 
	`ENABLE
(
JIT
)

810 
	#ENABLE_COMPUTED_GOTO_OPCODES
 1

	)

814 
	#ENABLE_REGEXP_TRACING
 0

	)

817 #i!
	`defed
(
ENABLE_YARR_JIT
)

818 
	#ENABLE_YARR_JIT
 1

	)

821 
	#ENABLE_YARR_JIT_DEBUG
 0

	)

826 #i
	`ENABLE
(
JIT
|| ENABLE(
YARR_JIT
)

827 #i
	`defed
(
ENABLE_ASSEMBLER
) && !ENABLE_ASSEMBLER

830 #unde
ENABLE_ASSEMBLER


831 
	#ENABLE_ASSEMBLER
 1

	)

836 #i
	`ENABLE
(
DISASSEMBLER
)

837 #i
	`defed
(
ENABLE_ASSEMBLER
) && !ENABLE_ASSEMBLER

840 #unde
ENABLE_ASSEMBLER


841 
	#ENABLE_ASSEMBLER
 1

	)

847 #i
	`ENABLE
(
ASSEMBLER
)

848 #i
	`CPU
(
X86_64
&& !
	`OS
(
WINDOWS
|| 
	`PLATFORM
(
IOS
|| CPU(
ARM64
)

849 
	#ENABLE_EXECUTABLE_ALLOCATOR_FIXED
 1

	)

851 
	#ENABLE_EXECUTABLE_ALLOCATOR_DEMAND
 1

	)

856 #i!
	`defed
(
ENABLE_CSS_SELECTOR_JIT
)

857 #i(
	`CPU
(
X86_64
|| CPU(
ARM64
|| (CPU(
ARM_THUMB2
&& 
	`PLATFORM
(
IOS
))&& 
	`ENABLE
(
JIT
&& (
	`OS
(
DARWIN
|| PLATFORM(
GTK
|| PLATFORM(
EFL
))

858 
	#ENABLE_CSS_SELECTOR_JIT
 1

	)

860 
	#ENABLE_CSS_SELECTOR_JIT
 0

	)

864 #i
	`ENABLE
(
WEBGL
&& !
	`defed
(
WTF_USE_3D_GRAPHICS
)

865 
	#WTF_USE_3D_GRAPHICS
 1

	)

868 #i
	`ENABLE
(
WEBGL
&& 
	`PLATFORM
(
WIN
)

869 
	#WTF_USE_OPENGL
 1

	)

870 
	#WTF_USE_OPENGL_ES_2
 1

	)

871 
	#WTF_USE_EGL
 1

	)

874 #i
	`ENABLE
(
VIDEO
&& 
	`PLATFORM
(
WIN_CAIRO
)

875 #i
	`ENABLE
(
GSTREAMER_WINCAIRO
)

876 
	#WTF_USE_MEDIA_FOUNDATION
 0

	)

877 
	#WTF_USE_GLIB
 1

	)

878 
	#WTF_USE_GSTREAMER
 1

	)

880 
	#WTF_USE_MEDIA_FOUNDATION
 1

	)

884 #i
	`PLATFORM
(
WIN_CAIRO
)

885 
	#WTF_USE_TEXTURE_MAPPER
 1

	)

888 #i
	`USE
(
TEXTURE_MAPPER
&& USE(3D
_GRAPHICS
&& !
	`defed
(
WTF_USE_TEXTURE_MAPPER_GL
)

889 
	#WTF_USE_TEXTURE_MAPPER_GL
 1

	)

893 #i
	`PLATFORM
(
COCOA
)

894 
	#WTF_USE_PROTECTION_SPACE_AUTH_CALLBACK
 1

	)

898 
	#WTF_PLATFORM_CFNETWORK
 
E
 
USE_mao_should_be_ud_wh_CFNETWORK


	)

900 #i
	`PLATFORM
(
WIN
)

901 
	#WTF_USE_CROSS_PLATFORM_CONTEXT_MENUS
 1

	)

904 #i
	`PLATFORM
(
COCOA
&& 
	`HAVE
(
ACCESSIBILITY
)

905 
	#WTF_USE_ACCESSIBILITY_CONTEXT_MENUS
 1

	)

908 #i
	`CPU
(
ARM_THUMB2
|| CPU(
ARM64
)

909 
	#ENABLE_BRANCH_COMPACTION
 1

	)

912 #i!
	`defed
(
ENABLE_THREADING_LIBDISPATCH
&& 
	`HAVE
(
DISPATCH_H
)

913 
	#ENABLE_THREADING_LIBDISPATCH
 1

	)

914 #i!
	`defed
(
ENABLE_THREADING_OPENMP
&& defed(
_OPENMP
)

915 
	#ENABLE_THREADING_OPENMP
 1

	)

916 #i!
	`defed
(
THREADING_GENERIC
)

917 
	#ENABLE_THREADING_GENERIC
 1

	)

920 #i
	`USE
(
GLIB
)

921 
	~<wtf/gobje/GTydefs.h
>

924 #i
	`PLATFORM
(
EFL
)

925 
	~<wtf/e/ETydefs.h
>

932 #i!
	`defed
(
WTF_USE_EXPORT_MACROS
&& (
	`PLATFORM
(
COCOA
|| PLATFORM(
WIN
))

933 
	#WTF_USE_EXPORT_MACROS
 1

	)

936 #i!
	`defed
(
WTF_USE_EXPORT_MACROS_FOR_TESTING
&& (
	`PLATFORM
(
GTK
|| PLATFORM(
WIN
))

937 
	#WTF_USE_EXPORT_MACROS_FOR_TESTING
 1

	)

940 #i
	`PLATFORM
(
GTK
|| PLATFORM(
EFL
)

941 
	#WTF_USE_UNIX_DOMAIN_SOCKETS
 1

	)

944 #i!
	`defed
(
WTF_USE_IMLANG_FONT_LINK2
)

945 
	#WTF_USE_IMLANG_FONT_LINK2
 1

	)

948 #i!
	`defed
(
ENABLE_COMPARE_AND_SWAP
&& (
	`OS
(
WINDOWS
|| (
	`COMPILER
(
GCC
&& (
	`CPU
(
X86
|| CPU(
X86_64
|| CPU(
ARM_THUMB2
|| CPU(
ARM64
))))

949 
	#ENABLE_COMPARE_AND_SWAP
 1

	)

952 #i!
	`defed
(
ENABLE_PARALLEL_GC
&& (
	`OS
(
DARWIN
|| 
	`PLATFORM
(
EFL
|| PLATFORM(
GTK
)&& 
	`ENABLE
(
COMPARE_AND_SWAP
)

953 
	#ENABLE_PARALLEL_GC
 1

	)

956 #i!
	`defed
(
ENABLE_GC_VALIDATION
&& !defed(
NDEBUG
)

957 
	#ENABLE_GC_VALIDATION
 1

	)

960 #i!
	`defed
(
ENABLE_BINDING_INTEGRITY
&& !
	`OS
(
WINDOWS
)

961 
	#ENABLE_BINDING_INTEGRITY
 1

	)

964 #i
	`PLATFORM
(
COCOA
)

965 
	#WTF_USE_AVFOUNDATION
 1

	)

968 #i(
	`PLATFORM
(
IOS
&& 
__IPHONE_OS_VERSION_MIN_REQUIRED
 >60000|| (PLATFORM(
MAC
&& 
__MAC_OS_X_VERSION_MIN_REQUIRED
 >= 1080)

969 
	#WTF_USE_COREMEDIA
 1

	)

970 
	#HAVE_AVFOUNDATION_VIDEO_OUTPUT
 1

	)

973 #i(
	`PLATFORM
(
IOS
&& 
__IPHONE_OS_VERSION_MIN_REQUIRED
 >50000|| (PLATFORM(
MAC
|| (
	`OS
(
WINDOWS
&& 
	`USE
(
CG
)&& 
__MAC_OS_X_VERSION_MIN_REQUIRED
 >= 1080)

974 
	#HAVE_AVFOUNDATION_MEDIA_SELECTION_GROUP
 1

	)

977 #i(
	`PLATFORM
(
IOS
&& 
__IPHONE_OS_VERSION_MIN_REQUIRED
 >70000|| ((PLATFORM(
MAC
|| (
	`OS
(
WINDOWS
&& 
	`USE
(
CG
))&& 
__MAC_OS_X_VERSION_MIN_REQUIRED
 >= 1090)

978 
	#HAVE_AVFOUNDATION_LEGIBLE_OUTPUT_SUPPORT
 1

	)

979 
	#HAVE_MEDIA_ACCESSIBILITY_FRAMEWORK
 1

	)

982 #i(
	`PLATFORM
(
IOS
&& 
__IPHONE_OS_VERSION_MIN_REQUIRED
 >60000|| (PLATFORM(
MAC
&& 
__MAC_OS_X_VERSION_MIN_REQUIRED
 >= 1090)

983 
	#HAVE_AVFOUNDATION_LOADER_DELEGATE
 1

	)

986 #i
	`PLATFORM
(
MAC
&& 
__MAC_OS_X_VERSION_MIN_REQUIRED
 >= 1080

987 
	#WTF_USE_VIDEOTOOLBOX
 1

	)

990 #i
	`PLATFORM
(
COCOA
|| PLATFORM(
GTK
|| (PLATFORM(
WIN
&& !
	`USE
(
WINGDI
))

991 
	#WTF_USE_REQUEST_ANIMATION_FRAME_TIMER
 1

	)

994 #i
	`PLATFORM
(
COCOA
)

995 
	#WTF_USE_REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR
 1

	)

998 #i
	`PLATFORM
(
MAC
)

999 
	#WTF_USE_COREAUDIO
 1

	)

1002 #i!
	`defed
(
WTF_USE_ZLIB
)

1003 
	#WTF_USE_ZLIB
 1

	)

1006 #ide
HAVE_QOS_CLASSES


1007 #i
	`PLATFORM
(
IOS
|| (PLATFORM(
MAC
&& 
__MAC_OS_X_VERSION_MIN_REQUIRED
 >= 101000)

1008 
	#HAVE_QOS_CLASSES
 1

	)

1012 #ide
HAVE_VOUCHERS


1013 #i
	`PLATFORM
(
IOS
|| (PLATFORM(
MAC
&& 
__MAC_OS_X_VERSION_MIN_REQUIRED
 >= 101000)

1014 
	#HAVE_VOUCHERS
 1

	)

1018 
	#WTF_USE_GRAMMAR_CHECKING
 1

	)

1020 #i
	`PLATFORM
(
COCOA
|| PLATFORM(
EFL
)

1021 
	#WTF_USE_UNIFIED_TEXT_CHECKING
 1

	)

1023 #i
	`PLATFORM
(
MAC
)

1024 
	#WTF_USE_AUTOMATIC_TEXT_REPLACEMENT
 1

	)

1027 #i
	`PLATFORM
(
MAC
)

1029 
	#WTF_USE_AUTOCORRECTION_PANEL
 1

	)

1032 #i
	`PLATFORM
(
COCOA
)

1034 
	#WTF_USE_MARKER_REMOVAL_UPON_EDITING
 1

	)

1037 #i
	`PLATFORM
(
MAC
&& 
__MAC_OS_X_VERSION_MIN_REQUIRED
 >= 101000

1038 
	#WTF_USE_INSERTION_UNDO_GROUPING
 1

	)

1041 #i
	`PLATFORM
(
IOS
)

1042 
	#WTF_USE_PLATFORM_TEXT_TRACK_MENU
 1

	)

1045 #i
	`PLATFORM
(
COCOA
)

1046 
	#WTF_USE_AUDIO_SESSION
 1

	)

1049 #i
	`PLATFORM
(
COCOA
&& !PLATFORM(
IOS_SIMULATOR
)

1050 
	#WTF_USE_IOSURFACE
 1

	)

1053 #i
	`PLATFORM
(
GTK
|| PLATFORM(
EFL
)

1054 #unde
ENABLE_OPENTYPE_VERTICAL


1055 
	#ENABLE_OPENTYPE_VERTICAL
 1

	)

1058 #i
	`PLATFORM
(
COCOA
)

1059 
	#ENABLE_CSS3_TEXT_DECORATION_SKIP_INK
 1

	)

1062 #i
	`COMPILER
(
MSVC
)

1063 #unde
__STDC_LIMIT_MACROS


1064 
	#__STDC_LIMIT_MACROS


	)

1065 #unde
_HAS_EXCEPTIONS


1066 
	#_HAS_EXCEPTIONS
 1

	)

1069 #i
	`PLATFORM
(
MAC
&& 
__MAC_OS_X_VERSION_MIN_REQUIRED
 >= 1090

1070 
	#HAVE_NS_ACTIVITY
 1

	)

1073 #i
	`PLATFORM
(
MAC
&& 
__MAC_OS_X_VERSION_MIN_REQUIRED
 >= 101000

1074 
	#WTF_USE_ASYNC_NSTEXTINPUTCLIENT
 1

	)

1077 #i(
	`OS
(
DARWIN
&& 
	`USE
(
CG
)|| USE(
FREETYPE
|| (
	`PLATFORM
(
WIN
&& (USE(CG|| USE(
CAIRO
)))

1078 #unde
ENABLE_OPENTYPE_MATH


1079 
	#ENABLE_OPENTYPE_MATH
 1

	)

1084 #i!
	`defed
(
TARGET_OS_IPHONE
&& !
	`OS
(
DARWIN
)

1085 
	#TARGET_OS_IPHONE
 0

	)

1088 #i
	`PLATFORM
(
IOS
|| (PLATFORM(
COCOA
&& 
__MAC_OS_X_VERSION_MIN_REQUIRED
 >= 1090)

1089 
	#WTF_USE_MEDIATOOLBOX
 1

	)

	@PossiblyNull.h

26 #ide
PossiblyNu_h


27 
	#PossiblyNu_h


	)

29 
	~<wtf/Asis.h
>

31 
mea
 
	gWTF
 {

33 
	gme
 <
tyme
 
	gT
> 
	sPossiblyNu
 {

34 
PossiblyNu
(
T
 
da
)

35 : 
m_da
(
da
)

38 
PossiblyNu
(cڡ PossiblyNu<
T
>& 
sour
)

39 : 
m_da
(
sour
.m_data)

41 
sour
.
m_da
 = 0;

43 ~
PossiblyNu
({ 
ASSERT
(!
m_da
); }

44 
bo
 
gVue
(
T
& 
out

	gWARN_UNUSED_RETURN
;

45 
	give
:

46 
mub
 
T
 
m_da
;

49 
	gme
 <
tyme
 
	gT
> 
bo
 
	gPossiblyNu
<T>::
gVue
(
T
& 
out
)

51 
out
 = 
m_da
;

52 
bo
 
	gsu
 = !!
m_da
;

53 
	gm_da
 = 0;

54  
	gsu
;

	@PrintStream.cpp

26 
	~"cfig.h
"

27 
	~"PrtSm.h
"

29 
	~<dio.h
>

30 
	~<wtf/xt/CSg.h
>

31 
	~<wtf/xt/WTFSg.h
>

33 
mea
 
	gWTF
 {

35 
	gPrtSm
::
PrtSm
() { }

36 
PrtSm
::~PrintStream() { }

38 
PrtSm
::
tf
(cڡ * 
fm
, ...)

40 
va_li
 
	ggLi
;

41 
va_t
(
gLi
, 
fm
);

42 
vtf
(
fm
, 
gLi
);

43 
va_d
(
gLi
);

46 
	gPrtSm
::
ush
()

50 
tIl
(
PrtSm
& 
out
, cڡ * 
rg
)

52 
	gout
.
tf
("%s", 
rg
);

55 
tIl
(
PrtSm
& 
out
, cڡ 
CSg
& 
rg
)

57 
	gout
.
t
(
rg
.
da
());

60 
tIl
(
PrtSm
& 
out
, cڡ 
Sg
& 
rg
)

62 
	gout
.
t
(
rg
.
utf8
());

65 
tIl
(
PrtSm
& 
out
, cڡ 
SgIm
* 
rg
)

67 i(!
	grg
) {

68 
	gout
.
t
("(null StringImpl*)");

71 
	gout
.
t
(
rg
->
utf8
());

74 
tIl
(
PrtSm
& 
out
, 
bo
 
vue
)

76 i(
	gvue
)

77 
	gout
.
t
("true");

79 
	gout
.
t
("false");

82 
tIl
(
PrtSm
& 
out
, 
vue
)

84 
	gout
.
tf
("%d", 
vue
);

87 
tIl
(
PrtSm
& 
out
, 
vue
)

89 
	gout
.
tf
("%u", 
vue
);

92 
tIl
(
PrtSm
& 
out
, sigd 
vue
)

94 
	gout
.
tf
("%d", 
ic_
<>(
vue
));

97 
tIl
(
PrtSm
& 
out
, 
vue
)

99 
	gout
.
tf
("%u", 
ic_
<>(
vue
));

102 
tIl
(
PrtSm
& 
out
, 
vue
)

104 
	gout
.
tf
("%d", 
ic_
<>(
vue
));

107 
tIl
(
PrtSm
& 
out
, 
vue
)

109 
	gout
.
tf
("%u", 
ic_
<>(
vue
));

112 
tIl
(
PrtSm
& 
out
, 
vue
)

114 
	gout
.
tf
("%ld", 
vue
);

117 
tIl
(
PrtSm
& 
out
, 
vue
)

119 
	gout
.
tf
("%lu", 
vue
);

122 
tIl
(
PrtSm
& 
out
, 
vue
)

124 
	gout
.
tf
("%d", 
vue
);

127 
tIl
(
PrtSm
& 
out
, 
vue
)

129 
	gout
.
tf
("%u", 
vue
);

132 
tIl
(
PrtSm
& 
out
, 
vue
)

134 
	gout
.
t
(
ic_
<>(
vue
));

137 
tIl
(
PrtSm
& 
out
, 
vue
)

139 
	gout
.
tf
("%lf", 
vue
);

142 
tIl
(
PrtSm
& 
out
, 
RawPor
 
vue
)

144 
	gout
.
tf
("%p", 
vue
.value());

147 
dumpCha
(
PrtSm
& 
out
, 
vue
)

149 
	gout
.
tf
("%c", 
vue
);

	@PrintStream.h

26 #ide
PrtSm_h


27 
	#PrtSm_h


	)

29 
	~<dg.h
>

30 
	~<wtf/FaMloc.h
>

31 
	~<wtf/Ncyab.h
>

32 
	~<wtf/RawPor.h
>

33 
	~<wtf/StdLibExas.h
>

35 
mea
 
	gWTF
 {

37 
ass
 
	gAtomicSgIm
;

38 
ass
 
	gCSg
;

39 
ass
 
	gSg
;

40 
ass
 
	gSgIm
;

42 as
	cPrtSm
 {

43 
	gWTF_MAKE_FAST_ALLOCATED
; 
WTF_MAKE_NONCOPYABLE
(
PrtSm
);

44 
	gpublic
:

45 
PrtSm
();

46 
	gvtu
 ~
PrtSm
();

48 
WTF_EXPORT_PRIVATE
 
tf
(cڡ * 
fm
, ...
WTF_ATTRIBUTE_PRINTF
(2, 3);

49 
vtu
 
vtf
(cڡ * 
fm
, 
va_li

WTF_ATTRIBUTE_PRINTF
(2, 0) = 0;

53 
vtu
 
ush
();

55 
	gme
<
tyme
 
	gT
>

56 
t
(cڡ 
T
& 
vue
)

58 
tIl
(*
this
, 
vue
);

61 
	gme
<
tyme
 
	gT
, 
	gtyme
... 
	gTys
>

62 
t
(cڡ 
T
& 
vue
, cڡ 
Tys
&... 
magVues
)

64 
tIl
(*
this
, 
vue
);

65 
t
(
magVues
...);

69 
WTF_EXPORT_PRIVATE
 
tIl
(
PrtSm
&, const *);

70 
WTF_EXPORT_PRIVATE
 
tIl
(
PrtSm
&, cڡ 
CSg
&);

71 
WTF_EXPORT_PRIVATE
 
tIl
(
PrtSm
&, cڡ 
Sg
&);

72 
WTF_EXPORT_PRIVATE
 
tIl
(
PrtSm
&, cڡ 
SgIm
*);

73 
le
 
	$tIl
(
PrtSm
& 
out
, cڡ 
AtomicSgIm
* 
vue
{ 
	`tIl
(out, 
bwi_
<cڡ 
SgIm
*>(vue)); 
	}
}

74 
le
 
	$tIl
(
PrtSm
& 
out
, * 
vue
{ 
	`tIl
(out, 
ic_
<cڡ *>(vue)); 
	}
}

75 
le
 
	$tIl
(
PrtSm
& 
out
, 
CSg
& 
vue
{ 
	`tIl
(out, 
ic_
<cڡ CSg&>(vue)); 
	}
}

76 
le
 
	$tIl
(
PrtSm
& 
out
, 
Sg
& 
vue
{ 
	`tIl
(out, 
ic_
<cڡ Sg&>(vue)); 
	}
}

77 
le
 
	$tIl
(
PrtSm
& 
out
, 
SgIm
* 
vue
{ 
	`tIl
(out, 
ic_
<cڡ SgIm*>(vue)); 
	}
}

78 
le
 
	$tIl
(
PrtSm
& 
out
, 
AtomicSgIm
* 
vue
{ 
	`tIl
(out, 
ic_
<cڡ AtomicSgIm*>(vue)); 
	}
}

79 
WTF_EXPORT_PRIVATE
 
tIl
(
PrtSm
&, 
bo
);

80 
WTF_EXPORT_PRIVATE
 
tIl
(
PrtSm
&, signed );

81 
WTF_EXPORT_PRIVATE
 
tIl
(
PrtSm
&, );

82 
WTF_EXPORT_PRIVATE
 
tIl
(
PrtSm
&, );

83 
WTF_EXPORT_PRIVATE
 
tIl
(
PrtSm
&, );

84 
WTF_EXPORT_PRIVATE
 
tIl
(
PrtSm
&, );

85 
WTF_EXPORT_PRIVATE
 
tIl
(
PrtSm
&, );

86 
WTF_EXPORT_PRIVATE
 
tIl
(
PrtSm
&, );

87 
WTF_EXPORT_PRIVATE
 
tIl
(
PrtSm
&, );

88 
WTF_EXPORT_PRIVATE
 
tIl
(
PrtSm
&, );

89 
WTF_EXPORT_PRIVATE
 
tIl
(
PrtSm
&, );

90 
WTF_EXPORT_PRIVATE
 
tIl
(
PrtSm
&, );

91 
WTF_EXPORT_PRIVATE
 
tIl
(
PrtSm
&, );

92 
WTF_EXPORT_PRIVATE
 
tIl
(
PrtSm
&, 
RawPor
);

94 
	gme
<
tyme
 
	gT
>

95 
	$tIl
(
PrtSm
& 
out
, cڡ 
T
& 
vue
)

97 
vue
.
	`dump
(
out
);

98 
	}
}

100 
	#MAKE_PRINT_ADAPTOR
(
Name
, 
Ty
, 
funi
) \

101 as
	cName
 { \

102 
public
: \

103 
	`Name
(cڡ 
Ty
& 
vue
) \

104 : 
	`m_vue
(
vue
) \

107 
	`dump
(
PrtSm
& 
out
) const \

109 
	`funi
(
out
, 
m_vue
); \

111 
ive
: \

112 
Ty
 
m_vue
; \

113 }

	)

115 
	#MAKE_PRINT_METHOD_ADAPTOR
(
Name
, 
Ty
, 
mhod
) \

116 as
	cName
 { \

117 
public
: \

118 
	`Name
(cڡ 
Ty
& 
vue
) \

119 : 
	`m_vue
(
vue
) \

122 
	`dump
(
PrtSm
& 
out
) const \

124 
m_vue
.
	`mhod
(
out
); \

126 
ive
: \

127 cڡ 
Ty
& 
m_vue
; \

128 }

	)

130 
	#MAKE_PRINT_METHOD
(
Ty
, 
dumpMhod
, 
mhod
) \

131 
	`MAKE_PRINT_METHOD_ADAPTOR
(
DumrF_
##
mhod
, 
Ty
, 
dumpMhod
); \

132 
DumrF_
##
mhod
 
	$mhod
(cڡ {  
DumrF_
##
	`mhod
(*
this
); 
	}

	)
}

137 
WTF_EXPORT_PRIVATE
 
dumpCha
(
PrtSm
&, );

138 
MAKE_PRINT_ADAPTOR
(
ChaDump
, , 
dumpCha
);

140 
	gme
<
tyme
 
	gT
>

141 as
	cPorDump
 {

142 
	gpublic
:

143 
PorDump
(cڡ 
T
* 
r
)

144 : 
m_r
(
r
)

148 
dump
(
PrtSm
& 
out
) const

150 i(
m_r
)

151 
tIl
(
out
, *
m_r
);

153 
	gout
.
t
("(null)");

155 
	give
:

156 cڡ 
T
* 
m_r
;

159 
	gme
<
tyme
 
	gT
>

160 
	gPorDump
<
	gT
> 
	$porDump
(cڡ 
T
* 
r
{  
PorDump
<T>Ռ); 
	}
}

162 
	gme
<
tyme
 
	gT
,ym
	gU
>

163 as
	cVueInCڋxt
 {

164 
	gpublic
:

165 
VueInCڋxt
(cڡ 
T
& 
vue
, 
U
* 
cڋxt
)

166 : 
m_vue
(&
vue
)

167 , 
m_cڋxt
(
cڋxt
)

171 
dump
(
PrtSm
& 
out
) const

173 
	gm_vue
->
dumpInCڋxt
(
out
, 
m_cڋxt
);

176 
	give
:

177 cڡ 
T
* 
m_vue
;

178 
U
* 
	gm_cڋxt
;

181 
	gme
<
tyme
 
	gT
,ym
	gU
>

182 
	gVueInCڋxt
<
	gT
, 
	gU
> 
	$Cڋxt
(cڡ 
T
& 
vue
, 
U
* 
cڋxt
)

184  
VueInCڋxt
<
T
, 
U
>(
vue
, 
cڋxt
);

185 
	}
}

187 
	gme
<
tyme
 
	gT
,ym
	gU
>

188 as
	cPorDumpInCڋxt
 {

189 
	gpublic
:

190 
PorDumpInCڋxt
(cڡ 
T
* 
r
, 
U
* 
cڋxt
)

191 : 
m_r
(
r
)

192 , 
m_cڋxt
(
cڋxt
)

196 
dump
(
PrtSm
& 
out
) const

198 i(
	gm_r
)

199 
	gm_r
->
dumpInCڋxt
(
out
, 
m_cڋxt
);

201 
	gout
.
t
("(null)");

204 
	give
:

205 cڡ 
T
* 
m_r
;

206 
U
* 
	gm_cڋxt
;

209 
	gme
<
tyme
 
	gT
,ym
	gU
>

210 
	gPorDumpInCڋxt
<
	gT
, 
	gU
> 
	$porDumpInCڋxt
(cڡ 
T
* 
r
, 
U
* 
cڋxt
)

212  
PorDumpInCڋxt
<
T
, 
U
>(
r
, 
cڋxt
);

213 
	}
}

215 
	gme
<
tyme
 
	gT
,ym
	gU
>

216 as
	cVueIgnܚgCڋxt
 {

217 
	gpublic
:

218 
VueIgnܚgCڋxt
(cڡ 
U
& 
vue
)

219 : 
m_vue
(&
vue
)

223 
dump
(
PrtSm
& 
out
) const

225 
T
 
cڋxt
;

226 
	gm_vue
->
dumpInCڋxt
(
out
, &
cڋxt
);

229 
	give
:

230 cڡ 
U
* 
m_vue
;

233 
	gme
<
tyme
 
	gT
,ym
	gU
>

234 
	gVueIgnܚgCڋxt
<
	gT
, 
	gU
> 
	$ignܚgCڋxt
(cڡ 
U
& 
vue
)

236  
VueIgnܚgCڋxt
<
T
, 
U
>(
vue
);

237 
	}
}

241 
usg
 
	gWTF
::
ChaDump
;

242 
usg
 
	gWTF
::
PorDump
;

243 
usg
 
	gWTF
::
PrtSm
;

244 
usg
 
	gWTF
::
ignܚgCڋxt
;

245 
usg
 
	gWTF
::
Cڋxt
;

246 
usg
 
	gWTF
::
porDump
;

247 
usg
 
	gWTF
::
porDumpInCڋxt
;

	@ProcessID.h

26 #ide
ProssID_h


27 
	#ProssID_h


	)

29 #i
OS
(
UNIX
)

30 
	~<unid.h
>

33 #i
OS
(
WINDOWS
)

34 
	~<wdows.h
>

37 
mea
 
	gWTF
 {

39 
le
 
gCutProssID
()

41 #i
OS
(
WINDOWS
)

42  
GCutProssId
();

44  
gpid
();

50 
usg
 
	gWTF
::
gCutProssID
;

	@RAMSize.cpp

26 
	~"cfig.h
"

27 
	~"RAMSize.h
"

29 
	~"StdLibExas.h
"

30 #i
OS
(
DARWIN
)

31 
	~<sys/m.h
>

32 
	~<sys/tys.h
>

33 
	~<sys/sysl.h
>

34 #i
OS
(
UNIX
)

35 
	~<unid.h
>

36 #i
OS
(
WINDOWS
)

37 
	~<wdows.h
>

40 
mea
 
	gWTF
 {

42 cڡ 
size_t
 
	gmSizeGuess
 = 128 * 
MB
;

44 
size_t
 
compuRAMSize
()

46 #i
OS
(
DARWIN
)

47 
	gmib
[2];

48 
ut64_t
 
	gmSize
;

49 
size_t
 
	gngth
;

51 
	gmib
[0] = 
CTL_HW
;

52 
	gmib
[1] = 
HW_MEMSIZE
;

53 
	gngth
 = (
t64_t
);

54 
	gsyslResu
 = 
sysl
(
mib
, 2, &
mSize
, &
ngth
, 0, 0);

55 i(
	gsyslResu
 == -1)

56  
mSizeGuess
;

57  
	gmSize
 > 
	gd
::
numic_lims
<
size_t
>::
max
(? 
d
::numic_lims<size_t>::max(: 
ic_
<size_t>(
mSize
);

58 #i
OS
(
UNIX
)

59 
	gges
 = 
syscf
(
_SC_PHYS_PAGES
);

60 
	ggeSize
 = 
syscf
(
_SC_PAGE_SIZE
);

61 i(
	gges
 =-1 || 
geSize
 == -1)

62  
mSizeGuess
;

63  
ges
 * 
	ggeSize
;

64 #i
OS
(
WINDOWS
)

65 
MEMORYSTATUSEX
 
	gus
;

66 
	gus
.
	gdwLgth
 = (
us
);

67 
bo
 
	gsu
 = 
GlobMemyStusEx
(&
us
);

68 i(!
	gsu
)

69  
	gmSizeGuess
;

70  
	gus
.
	guTٮPhys
;

74 
size_t
 
mSize
()

76 cڡ 
size_t
 
	gmSize
 = 
compuRAMSize
();

77  
	gmSize
;

	@RAMSize.h

26 #ide
RAMSize_h


27 
	#RAMSize_h


	)

29 
mea
 
	gWTF
 {

31 
WTF_EXPORT_PRIVATE
 
size_t
 
mSize
();

35 
usg
 
	gWTF
::
mSize
;

	@RandomNumber.cpp

28 
	~"cfig.h
"

29 
	~"RdomNumb.h
"

31 
	~"CryogphiyRdomNumb.h
"

32 
	~"RdomNumbSd.h
"

34 
	~<lims
>

35 
	~<lims.h
>

36 
	~<dt.h
>

37 
	~<dlib.h
>

39 
mea
 
	gWTF
 {

41 
ndomNumb
()

43 
ut32_t
 
	gbs
 = 
yogphiyRdomNumb
();

44  
	gic_
<>(
	gbs
/ (ic_<>(
	gd
::
numic_lims
<
ut32_t
>::
max
()) + 1.0);

	@RandomNumber.h

26 #ide
WTF_RdomNumb_h


27 
	#WTF_RdomNumb_h


	)

29 
mea
 
	gWTF
 {

33 
WTF_EXPORT_PRIVATE
 
ndomNumb
();

37 
usg
 
	gWTF
::
ndomNumb
;

	@RandomNumberSeed.h

26 #ide
WTF_RdomNumbSd_h


27 
	#WTF_RdomNumbSd_h


	)

29 
	~"RdomNumb.h
"

30 
	~<dlib.h
>

31 
	~<time.h
>

33 #i
HAVE
(
SYS_TIME_H
)

34 
	~<sys/time.h
>

37 #i
OS
(
UNIX
)

38 
	~<sys/tys.h
>

39 
	~<unid.h
>

42 
mea
 
	gWTF
 {

44 
le
 
lizeRdomNumbG
()

46 #i
OS
(
DARWIN
)

48 #i
COMPILER
(
MSVC
&& 
defed
(
_CRT_RAND_S
)

50 #i
OS
(
UNIX
)

52 
timev
 
	gtime
;

53 
gtimeofday
(&
time
, 0);

54 
dom
(
ic_
<>(
time
.
tv_uc
 * 
gpid
()));

56 
d
(
ic_
<>(
time
(0)));

	@RawPointer.h

26 #ide
RawPor_h


27 
	#RawPor_h


	)

29 
mea
 
	gWTF
 {

31 as
	cRawPor
 {

32 
	gpublic
:

33 
RawPor
()

34 : 
m_vue
(0)

38 
exic
 
RawPor
(* 
vue
)

39 : 
m_vue
(
vue
)

43 
exic
 
RawPor
(cڡ * 
vue
)

44 : 
m_vue
(
vue
)

48 cڡ * 
vue
(cڡ {  
m_vue
; }

50 
	give
:

51 cڡ * 
m_vue
;

56 
usg
 
	gWTF
::
RawPor
;

	@RedBlackTree.h

29 #ide
RedBckTe_h


30 
	#RedBckTe_h


	)

32 
	~<wtf/Asis.h
>

33 
	~<wtf/Ncyab.h
>

35 
mea
 
	gWTF
 {

44 
	gme
<
ass
 
	gNodeTy
, 
tyme
 
	gKeyTy
>

45 as
	cRedBckTe
 {

46 
WTF_MAKE_NONCOPYABLE
(
RedBckTe
);

47 
	give
:

48 
	eC
 {

49 
Red
 = 1,

50 
	gBck


53 
	gpublic
:

54 as
	cNode
 {

55 
nd
 
ass
 
RedBckTe
;

57 
	gpublic
:

58 cڡ 
NodeTy
* 
sucss
() const

60 cڡ 
Node
* 
x
 = 
this
;

61 i(
	gx
->
right
())

62  
Mimum
(
x
->
right
());

63 cڡ 
NodeTy
* 
	gy
 = 
x
->

();

64 
	gy
 && 
	gx
 =
y
->
right
()) {

65 
x
 = 
y
;

66 
	gy
 = 
y
->

();

68  
	gy
;

71 cڡ 
NodeTy
* 
edess
() const

73 cڡ 
Node
* 
	gx
 = 
this
;

74 i(
	gx
->

())

75  
Maximum
(
x
->

());

76 cڡ 
NodeTy
* 
	gy
 = 
x
->

();

77 
	gy
 && 
	gx
 =
y
->

()) {

78 
x
 = 
y
;

79 
	gy
 = 
y
->

();

81  
	gy
;

84 
NodeTy
* 
sucss
()

86  
	gcڡ_
<
	gNodeTy
*>(cڡ_<cڡ 
	gNode
*>(
	gthis
)->
sucss
());

89 
NodeTy
* 
edess
()

91  
	gcڡ_
<
	gNodeTy
*>(cڡ_<cڡ 
	gNode
*>(
	gthis
)->
edess
());

94 
	give
:

95 
t
()

97 
m_
 = 0;

98 
	gm_right
 = 0;

99 
	gm_AndRed
 = 1;

104 
NodeTy
* 

() const

106  
	gt_
<
	gNodeTy
*>(
	gm_AndRed
 & ~
	gic_
<
	gu_t
>(1));

109 
tPt
(
NodeTy
* 
wPt
)

111 
	gm_AndRed
 = 
t_
<
u_t
>(
wPt
| (
m_AndRed
 & 1);

114 
NodeTy
* 

() const

116  
	gm_
;

119 
tLe
(
NodeTy
* 
node
)

121 
	gm_
 = 
node
;

124 
NodeTy
* 
right
() const

126  
	gm_right
;

129 
tRight
(
NodeTy
* 
node
)

131 
	gm_right
 = 
node
;

134 
C
 
c
() const

136 i(
	gm_AndRed
 & 1)

137  
	gRed
;

138  
	gBck
;

141 
tC
(
C
 
vue
)

143 i(
	gvue
 =
Red
)

144 
m_AndRed
 |= 1;

146 
	gm_AndRed
 &~
ic_
<
u_t
>(1);

149 
NodeTy
* 
	gm_
;

150 
NodeTy
* 
	gm_right
;

151 
u_t
 
	gm_AndRed
;

154 
RedBckTe
()

155 : 
m_ro
(0)

159 

(
NodeTy
* 
x
)

161 
x
->
t
();

162 
In
(
x
);

163 
	gx
->
tC
(
Red
);

165 
	gx
 !
m_ro
 && 
x
->

()->
c
(=
Red
) {

166 i(
x
->

(=x->()->()->

()) {

167 
NodeTy
* 
y
 = 
x
->

()->()->
right
();

168 i(
	gy
 && y->
c
(=
Red
) {

170 
x
->

()->
tC
(
Bck
);

171 
	gy
->
tC
(
Bck
);

172 
	gx
->

()->()->
tC
(
Red
);

173 
	gx
 = 
x
->

()->parent();

175 i(
	gx
 =
x
->

()->
right
()) {

177 
x
 = x->

();

178 
R٩e
(
x
);

181 
	gx
->

()->
tC
(
Bck
);

182 
	gx
->

()->()->
tC
(
Red
);

183 
rightR٩e
(
x
->

()->parent());

187 
NodeTy
* 
	gy
 = 
x
->

()->()->

();

188 i(
	gy
 && y->
c
(=
Red
) {

190 
x
->

()->
tC
(
Bck
);

191 
	gy
->
tC
(
Bck
);

192 
	gx
->

()->()->
tC
(
Red
);

193 
	gx
 = 
x
->

()->parent();

195 i(
	gx
 =
x
->

()->

()) {

197 
x
 = x->

();

198 
rightR٩e
(
x
);

201 
	gx
->

()->
tC
(
Bck
);

202 
	gx
->

()->()->
tC
(
Red
);

203 
R٩e
(
x
->

()->parent());

208 
	gm_ro
->
tC
(
Bck
);

211 
NodeTy
* 
move
(NodeTy* 
z
)

213 
ASSERT
(
z
);

214 
ASSERT
(
z
->

(|| z =
m_ro
);

217 
NodeTy
* 
	gy
;

218 i(!
	gz
->

(|| !z->
right
())

219 
	gy
 = 
z
;

221 
	gy
 = 
z
->
sucss
();

224 
NodeTy
* 
	gx
;

225 i(
	gy
->

())

226 
	gx
 = 
y
->

();

228 
	gx
 = 
y
->
right
();

232 
NodeTy
* 
	gxPt
;

233 i(
	gx
) {

234 
	gx
->
tPt
(
y
->

());

235 
	gxPt
 = 
x
->

();

237 
	gxPt
 = 
y
->

();

238 i(!
	gy
->

())

239 
	gm_ro
 = 
x
;

241 i(
	gy
 =
y
->

()->

())

242 
y
->

()->
tLe
(
x
);

244 
	gy
->

()->
tRight
(
x
);

247 i(
	gy
 !
z
) {

248 i(
y
->
c
(=
Bck
)

249 
moveFixup
(
x
, 
xPt
);

251 
	gy
->
tPt
(
z
->

());

252 
	gy
->
tC
(
z
->
c
());

253 
	gy
->
tLe
(
z
->

());

254 
	gy
->
tRight
(
z
->
right
());

256 i(
	gz
->

())

257 
	gz
->

()->
tPt
(
y
);

258 i(
	gz
->
right
())

259 
	gz
->
right
()->
tPt
(
y
);

260 i(
	gz
->

()) {

261 i(
	gz
->

()->

(=
z
)

262 
z
->

()->
tLe
(
y
);

264 
	gz
->

()->
tRight
(
y
);

266 
ASSERT
(
m_ro
 =
z
);

267 
	gm_ro
 = 
y
;

269 } i(
	gy
->
c
(=
Bck
)

270 
moveFixup
(
x
, 
xPt
);

272  
	gz
;

275 
NodeTy
* 
move
(cڡ 
KeyTy
& 
key
)

277 
NodeTy
* 
	gsu
 = 
fdExa
(
key
);

278 i(!
	gsu
)

280  
move
(
su
);

283 
NodeTy
* 
fdExa
(cڡ 
KeyTy
& 
key
) const

285 
NodeTy
* 
	gcut
 = 
m_ro
; current;) {

286 i(
	gcut
->
key
() == key)

287  
cut
;

288 i(
	gkey
 < 
	gcut
->
key
())

289 
	gcut
 = 
cut
->

();

291 
	gcut
 = 
cut
->
right
();

296 
NodeTy
* 
fdLGThOrEqu
(cڡ 
KeyTy
& 
key
) const

298 
NodeTy
* 
	gbe
 = 0;

299 
NodeTy
* 
	gcut
 = 
m_ro
; current;) {

300 i(
	gcut
->
key
() == key)

301  
cut
;

302 i(
	gcut
->
key
(< 
	gkey
)

303 
	gcut
 = 
cut
->
right
();

305 
	gbe
 = 
cut
;

306 
	gcut
 = 
cut
->

();

309  
	gbe
;

312 
NodeTy
* 
fdGeLessThOrEqu
(cڡ 
KeyTy
& 
key
) const

314 
NodeTy
* 
	gbe
 = 0;

315 
NodeTy
* 
	gcut
 = 
m_ro
; current;) {

316 i(
	gcut
->
key
() == key)

317  
cut
;

318 i(
	gcut
->
key
(> 
	gkey
)

319 
	gcut
 = 
cut
->

();

321 
	gbe
 = 
cut
;

322 
	gcut
 = 
cut
->
right
();

325  
	gbe
;

328 
NodeTy
* 
f
() const

330 i(!
	gm_ro
)

332  
Mimum
(
m_ro
);

335 
NodeTy
* 
ϡ
() const

337 i(!
	gm_ro
)

339  
Maximum
(
m_ro
);

343 
size_t
 
size
()

345 
size_t
 
	gsu
 = 0;

346 
NodeTy
* 
	gcut
 = 
f
(); cut; cu
cut
->
sucss
())

347 
su
++;

348  
	gsu
;

352 
bo
 
isEmy
()

354  !
	gm_ro
;

357 
	give
:

360 
NodeTy
* 
Mimum
(NodeTy* 
x
)

362 
x
->

())

363 
x
 = x->

();

364  
	gx
;

367 
NodeTy
* 
Maximum
(NodeTy* 
x
)

369 
	gx
->
right
())

370 
	gx
 = 
x
->
right
();

371  
	gx
;

374 cڡ 
NodeTy
* 
Mimum
(cڡ NodeTy* 
x
)

376 
	gx
->

())

377 
	gx
 = 
x
->

();

378  
	gx
;

381 cڡ 
NodeTy
* 
Maximum
(cڡ NodeTy* 
x
)

383 
	gx
->
right
())

384 
	gx
 = 
x
->
right
();

385  
	gx
;

388 
In
(
NodeTy
* 
z
)

390 
ASSERT
(!
z
->

());

391 
ASSERT
(!
z
->
right
());

392 
ASSERT
(!
z
->

());

393 
ASSERT
(
z
->
c
(=
Red
);

395 
NodeTy
* 
	gy
 = 0;

396 
NodeTy
* 
	gx
 = 
m_ro
;

397 
	gx
) {

398 
	gy
 = 
x
;

399 i(
	gz
->
key
(< 
	gx
->key())

400 
	gx
 = 
x
->

();

402 
	gx
 = 
x
->
right
();

404 
	gz
->
tPt
(
y
);

405 i(!
	gy
)

406 
	gm_ro
 = 
z
;

408 i(
	gz
->
key
(< 
	gy
->key())

409 
	gy
->
tLe
(
z
);

411 
	gy
->
tRight
(
z
);

421 
NodeTy
* 
R٩e
(NodeTy* 
x
)

424 
NodeTy
* 
	gy
 = 
x
->
right
();

427 
	gx
->
tRight
(
y
->

());

428 i(
	gy
->

())

429 
	gy
->

()->
tPt
(
x
);

432 
	gy
->
tPt
(
x
->

());

433 i(!
	gx
->

())

434 
	gm_ro
 = 
y
;

436 i(
	gx
 =
x
->

()->

())

437 
x
->

()->
tLe
(
y
);

439 
	gx
->

()->
tRight
(
y
);

443 
	gy
->
tLe
(
x
);

444 
	gx
->
tPt
(
y
);

446  
	gy
;

451 
NodeTy
* 
rightR٩e
(NodeTy* 
y
)

454 
NodeTy
* 
	gx
 = 
y
->

();

457 
	gy
->
tLe
(
x
->
right
());

458 i(
	gx
->
right
())

459 
	gx
->
right
()->
tPt
(
y
);

462 
	gx
->
tPt
(
y
->

());

463 i(!
	gy
->

())

464 
	gm_ro
 = 
x
;

466 i(
	gy
 =
y
->

()->

())

467 
y
->

()->
tLe
(
x
);

469 
	gy
->

()->
tRight
(
x
);

473 
	gx
->
tRight
(
y
);

474 
	gy
->
tPt
(
x
);

476  
	gx
;

482 
moveFixup
(
NodeTy
* 
x
, NodeTy* 
xPt
)

484 
	gx
 !
m_ro
 && (!
x
 || x->
c
(=
Bck
)) {

485 i(
x
 =
xPt
->

()) {

490 
NodeTy
* 
w
 = 
xPt
->
right
();

491 
ASSERT
(
w
);

492 i(
	gw
->
c
(=
Red
) {

494 
w
->
tC
(
Bck
);

495 
	gxPt
->
tC
(
Red
);

496 
R٩e
(
xPt
);

497 
	gw
 = 
xPt
->
right
();

499 i((!
	gw
->

(|| w->()->
c
(=
Bck
)

500 && (!
w
->
right
(|| w->right()->
c
(=
Bck
)) {

502 
w
->
tC
(
Red
);

503 
	gx
 = 
xPt
;

504 
	gxPt
 = 
x
->

();

506 i(!
	gw
->
right
(|| w->right()->
c
(=
Bck
) {

508 
w
->

()->
tC
(
Bck
);

509 
	gw
->
tC
(
Red
);

510 
rightR٩e
(
w
);

511 
	gw
 = 
xPt
->
right
();

514 
	gw
->
tC
(
xPt
->
c
());

515 
	gxPt
->
tC
(
Bck
);

516 i(
	gw
->
right
())

517 
	gw
->
right
()->
tC
(
Bck
);

518 
R٩e
(
xPt
);

519 
	gx
 = 
m_ro
;

520 
	gxPt
 = 
x
->

();

530 
NodeTy
* 
	gw
 = 
xPt
->

();

531 
ASSERT
(
w
);

532 i(
	gw
->
c
(=
Red
) {

534 
w
->
tC
(
Bck
);

535 
	gxPt
->
tC
(
Red
);

536 
rightR٩e
(
xPt
);

537 
	gw
 = 
xPt
->

();

539 i((!
	gw
->
right
(|| w->right()->
c
(=
Bck
)

540 && (!
w
->

(|| w->()->
c
(=
Bck
)) {

542 
w
->
tC
(
Red
);

543 
	gx
 = 
xPt
;

544 
	gxPt
 = 
x
->

();

546 i(!
	gw
->

(|| w->()->
c
(=
Bck
) {

548 
w
->
right
()->
tC
(
Bck
);

549 
	gw
->
tC
(
Red
);

550 
R٩e
(
w
);

551 
	gw
 = 
xPt
->

();

554 
	gw
->
tC
(
xPt
->
c
());

555 
	gxPt
->
tC
(
Bck
);

556 i(
	gw
->

())

557 
	gw
->

()->
tC
(
Bck
);

558 
rightR٩e
(
xPt
);

559 
	gx
 = 
m_ro
;

560 
	gxPt
 = 
x
->

();

564 i(
	gx
)

565 
	gx
->
tC
(
Bck
);

568 
NodeTy
* 
	gm_ro
;

	@Ref.h

26 #ide
WTF_Ref_h


27 
	#WTF_Ref_h


	)

29 
	~<wtf/GP.h
>

30 
	~<wtf/Ncyab.h
>

32 
mea
 
	gWTF
 {

34 
	gme
<
tyme
 
	gT
> 
ass
 
	gPassRef
;

36 
	gme
<
tyme
 
	gT
> cs
	cRef
 {

37 
WTF_MAKE_NONCOPYABLE
(
Ref
)

38 
	gpublic
:

39 
Ref
(
T
& 
obje
: 
m_r
(&obje{ m_r->
f
(); }

40 
	gme
<
tyme
 
	gU
> 
Ref
(
PassRef
<
U
> 
n
: 
m_r
(&n.
akRef
()) { }

42 ~
Ref
({ 
m_r
->
def
(); }

44 
	gRef
& 
	gݔ
=(
T
& 
obje
)

46 
obje
.
f
();

47 
	gm_r
->
def
();

48 
	gm_r
 = &
obje
;

49  *
	gthis
;

51 
	gme
<
tyme
 
	gU
> 
	gRef
& 
	gݔ
=(
PassRef
<
U
> 
n
)

53 
m_r
->
def
();

54 
	gm_r
 = &
n
.
akRef
();

55  *
	gthis
;

58 cڡ 
T
* 
	gݔ
->(cڡ {  
	gm_r
; }

59 
T
* 
	gݔ
->({  
	gm_r
; }

61 cڡ 
	gT
& 
g
(cڡ {  *
	gm_r
; }

62 
	gT
& 
g
({  *
	gm_r
; }

64 
	gme
<
tyme
 
	gU
> 
	gPassRef
<
	gT
> 
a
(
PassRef
<
U
>
	gWARN_UNUSED_RETURN
;

66 
	give
:

67 
T
* 
m_r
;

70 
	gme
<
tyme
 
	gT
>eme<tym
	gU
> 
le
 
	gPassRef
<T> 
	gRef
<T>::
a
(
PassRef
<
U
> 
n
)

72 aut
dRen
 = 
adtRef
(*
m_r
);

73 
	gm_r
 = &
n
.
akRef
();

74  
	gdRen
;

77 
	gme
 <
tyme
 
	gT
>

78 
	gGPHr
<
	gRef
<
	gT
>> {

79 
T
* 
	tPTy
;

80 
T
* 
gP
(cڡ 
Ref
<T>& 
p
{  
	gcڡ_
<
	gT
*>(&
	gp
.
g
()); }

85 
usg
 
	gWTF
::
Ref
;

	@RefCounted.h

21 #ide
RefCoued_h


22 
	#RefCoued_h


	)

24 
	~<wtf/Asis.h
>

25 
	~<wtf/FaMloc.h
>

26 
	~<wtf/Ncyab.h
>

28 
mea
 
	gWTF
 {

30 #ifde
NDEBUG


31 
	#CHECK_REF_COUNTED_LIFECYCLE
 0

	)

33 
	#CHECK_REF_COUNTED_LIFECYCLE
 1

	)

39 as
	cRefCouedBa
 {

40 
	gpublic
:

41 
f
()

43 #i
CHECK_REF_COUNTED_LIFECYCLE


44 
ASSERT
(!
m_diHasBegun
);

45 
ASSERT
(!
m_adtiIsRequed
);

47 ++
	gm_fCou
;

50 
bo
 
hasORef
() const

52 #i
CHECK_REF_COUNTED_LIFECYCLE


53 
ASSERT
(!
m_diHasBegun
);

55  
	gm_fCou
 == 1;

58 
fCou
() const

60  
	gm_fCou
;

63 
xAdtiRequemt
()

65 #i
CHECK_REF_COUNTED_LIFECYCLE


66 
ASSERT
(!
m_diHasBegun
);

67 
ASSERT
(
m_adtiIsRequed
);

68 
	gm_adtiIsRequed
 = 
l
;

72 
	geed
:

73 
RefCouedBa
()

74 : 
m_fCou
(1)

75 #i
CHECK_REF_COUNTED_LIFECYCLE


76 , 
m_diHasBegun
(
l
)

77 , 
m_adtiIsRequed
(
ue
)

82 ~
RefCouedBa
()

84 #i
CHECK_REF_COUNTED_LIFECYCLE


85 
ASSERT
(
m_diHasBegun
);

86 
ASSERT
(!
m_adtiIsRequed
);

91 
bo
 
defBa
()

93 #i
CHECK_REF_COUNTED_LIFECYCLE


94 
ASSERT
(!
m_diHasBegun
);

95 
ASSERT
(!
m_adtiIsRequed
);

98 
ASSERT
(
m_fCou
);

99 
	gmpRefCou
 = 
m_fCou
 - 1;

100 i(!
	gmpRefCou
) {

101 #i
CHECK_REF_COUNTED_LIFECYCLE


102 
	gm_diHasBegun
 = 
ue
;

104  
	gue
;

106 
	gm_fCou
 = 
mpRefCou
;

107  
	gl
;

110 #i
CHECK_REF_COUNTED_LIFECYCLE


111 
bo
 
diHasBegun
() const

113  
	gm_diHasBegun
;

117 
	give
:

119 #i
CHECK_REF_COUNTED_LIFECYCLE


120 
nd
 
ad݋d
(
RefCouedBa
*);

123 
	gm_fCou
;

124 #i
CHECK_REF_COUNTED_LIFECYCLE


125 
bo
 
	gm_diHasBegun
;

126 
bo
 
	gm_adtiIsRequed
;

130 #i
CHECK_REF_COUNTED_LIFECYCLE


131 
le
 
	$ad݋d
(
RefCouedBa
* 
obje
)

133 i(!
obje
)

135 
	`ASSERT
(!
obje
->
m_diHasBegun
);

136 
obje
->
m_adtiIsRequed
 = 
l
;

137 
	}
}

140 
	gme
<
tyme
 
	gT
> cs
	cRefCoued
 : 
public
 
RefCouedBa
 {

141 
WTF_MAKE_NONCOPYABLE
(
RefCoued
); 
	gWTF_MAKE_FAST_ALLOCATED
;

142 
	gpublic
:

143 
def
()

145 i(
defBa
())

146 
de
 
ic_
<
T
*>(
this
);

149 
	geed
:

150 
RefCoued
() { }

151 ~
RefCoued
()

158 
usg
 
	gWTF
::
RefCoued
;

	@RefCountedArray.h

26 #ide
RefCouedAay_h


27 
	#RefCouedAay_h


	)

29 
	~<wtf/FaMloc.h
>

30 
	~<wtf/StdLibExas.h
>

31 
	~<wtf/Ve.h
>

44 
mea
 
	gWTF
 {

46 
	gme
<
tyme
 
	gT
>

47 as
	cRefCouedAay
 {

48 
	gpublic
:

49 
RefCouedAay
()

50 : 
m_da
(0)

54 
RefCouedAay
(cڡ RefCouedAay& 
h
)

55 : 
m_da
(
h
.m_data)

57 i(
m_da
)

58 
Hd
::
omPayld
(
m_da
)->
fCou
++;

61 
exic
 
RefCouedAay
(
size_t
 
size
)

63 i(!
	gsize
) {

64 
	gm_da
 = 0;

68 
	gm_da
 = (
ic_
<
Hd
*>(
Mloc
(Hd::
size
(+ (
T
* size)))->
yld
();

69 
	gHd
::
omPayld
(
m_da
)->
fCou
 = 1;

70 
	gHd
::
omPayld
(
m_da
)->
ngth
 = 
size
;

71 
ASSERT
(
Hd
::
omPayld
(
m_da
)->
ngth
 =
size
);

72 
	gVeTyOtis
<
	gT
>::
lize
(
beg
(), 
d
());

75 
exic
 
RefCouedAay
(cڡ 
Ve
<
T
>& 
h
)

77 i(
	gh
.
isEmy
()) {

78 
	gm_da
 = 0;

82 
	gm_da
 = (
ic_
<
Hd
*>(
Mloc
(Hd::
size
(+ (
T
* 
h
.size())))->
yld
();

83 
	gHd
::
omPayld
(
m_da
)->
fCou
 = 1;

84 
	gHd
::
omPayld
(
m_da
)->
ngth
 = 
h
.
size
();

85 
ASSERT
(
Hd
::
omPayld
(
m_da
)->
ngth
 =
h
.
size
());

86 
	gVeTyOtis
<
	gT
>::
unlizedCy
(
h
.
beg
(), oth.
d
(), 
m_da
);

89 
	gRefCouedAay
& 
	gݔ
=(cڡ 
RefCouedAay
& 
h
)

91 
T
* 
dDa
 = 
m_da
;

92 
	gm_da
 = 
h
.
m_da
;

93 i(
	gm_da
)

94 
	gHd
::
omPayld
(
m_da
)->
fCou
++;

96 i(!
	gdDa
)

97  *
	gthis
;

98 i(--
	gHd
::
omPayld
(
dDa
)->
fCou
)

99  *
this
;

100 
	gVeTyOtis
<
	gT
>::
deru
(
dDa
, oldD+ 
Hd
::
omPayld
(dDa)->
ngth
);

101 
Fe
(
Hd
::
omPayld
(
dDa
));

102  *
	gthis
;

105 ~
RefCouedAay
()

107 i(!
	gm_da
)

109 i(--
	gHd
::
omPayld
(
m_da
)->
fCou
)

111 
	gVeTyOtis
<
	gT
>::
deru
(
beg
(), 
d
());

112 
Fe
(
Hd
::
omPayld
(
m_da
));

115 
fCou
() const

117 i(!
	gm_da
)

119  
	gHd
::
omPayld
(
m_da
)->
fCou
;

122 
size_t
 
size
() const

124 i(!
	gm_da
)

126  
	gHd
::
omPayld
(
m_da
)->
ngth
;

129 
size_t
 
bySize
(cڡ {  
size
(* (
	gT
); }

131 
T
* 
da
({  
	gm_da
; }

132 
T
* 
beg
({  
	gm_da
; }

133 
T
* 
d
()

135 i(!
	gm_da
)

137  
	gm_da
 + 
	gHd
::
omPayld
(
m_da
)->
ngth
;

140 cڡ 
T
* 
da
(cڡ {  
	gm_da
; }

141 cڡ 
T
* 
beg
(cڡ {  
	gm_da
; }

142 cڡ 
T
* 
d
(cڡ {  
	gcڡ_
<
	gRefCouedAay
*>(
	gthis
)->end(); }

144 
	gT
& 

(
size_t
 
i
)

146 
ASSERT_WITH_SECURITY_IMPLICATION
(
i
 < 
size
());

147  
beg
()[
i
];

150 cڡ 
	gT
& 

(
size_t
 
i
) const

152 
ASSERT_WITH_SECURITY_IMPLICATION
(
i
 < 
size
());

153  
beg
()[
i
];

156 
	gT
& 
	gݔ
[](
size_t
 
	gi
{  

(
i
); }

157 cڡ 
	gT
& 
	gݔ
[](
size_t
 
	gi
cڡ {  

(
i
); }

159 
bo
 
	gݔ
==(cڡ 
RefCouedAay
& 
h
) const

161 i(
m_da
 =
h
.m_data)

162  
ue
;

163 i(!
	gm_da
 || !
	gh
.m_data)

164  
	gl
;

165 
	gngth
 = 
Hd
::
omPayld
(
m_da
)->
ngth
;

166 i(
	gngth
 !
Hd
::
omPayld
(
h
.
m_da
)->
ngth
)

167  
l
;

168 
	gi
 = 0; i < 
	gngth
; ++i) {

169 i(
	gm_da
[
i
] !
h
.
m_da
[i])

170  
l
;

172  
	gue
;

175 
	give
:

176 
	sHd
 {

177 
fCou
;

178 
	gngth
;

180 
size_t
 
size
()

182  ((
	gHd
) + 7) & ~7;

185 
T
* 
yld
()

187 * 
	gsu
 = 
t_
<*>(
this
+ 
size
();

188 
ASSERT
(!(
bwi_
<
u_t
>(
su
) & 7));

189  
	gt__r
<
	gT
*>(
	gsu
);

192 
Hd
* 
omPayld
(
T
* 
yld
)

194  
	gt__r
<
	gHd
*>(
	gt_
<*>(
	gyld
- 
size
());

198 
T
* 
	gm_da
;

203 
usg
 
	gWTF
::
RefCouedAay
;

	@RefCountedLeakCounter.cpp

21 
	~"cfig.h
"

22 
	~"RefCouedLkCou.h
"

24 
	~<wtf/HashCouedS.h
>

26 
mea
 
	gWTF
 {

28 #ifde
NDEBUG


30 
	gRefCouedLkCou
::
sussMesges
(const *) { }

31 
RefCouedLkCou
::
nlMesgeSussi
(const *) { }

33 
RefCouedLkCou
::RefCountedLeakCounter(const *) { }

34 
RefCouedLkCou
::~RefCountedLeakCounter() { }

36 
RefCouedLkCou
::
emt
() { }

37 
RefCouedLkCou
::
deemt
() { }

41 
	#LOG_CHANNEL_PREFIX
 
Log


	)

42 
WTFLogChl
 
LogRefCouedLks
 = { 
WTFLogChlOn
, "RefCountedLeaks" };

44 
	gHashCouedS
<cڡ *, 
	tPHash
<cڡ *>> 
	tRsS
;

45 
RsS
* 
	gakMesgeSussiRss
;

47 
	gRefCouedLkCou
::
sussMesges
(cڡ * 
as
)

49 i(!
akMesgeSussiRss
)

50 
akMesgeSussiRss
 = 
w
 
RsS
;

51 
	gakMesgeSussiRss
->
add
(
as
);

54 
	gRefCouedLkCou
::
nlMesgeSussi
(cڡ * 
as
)

56 
ASSERT
(
akMesgeSussiRss
);

57 
ASSERT
(
akMesgeSussiRss
->
cڏs
(
as
));

58 
	gakMesgeSussiRss
->
move
(
as
);

61 
	gRefCouedLkCou
::
RefCouedLkCou
(cڡ * 
desti
)

62 : 
m_desti
(
desti
)

66 
RefCouedLkCou
::~RefCountedLeakCounter()

68 
bo
 
loggedSussiRs
;

69 i(
	gm_cou
) {

70 i(!
	gakMesgeSussiRss
 ||kMesgeSussiRss->
isEmy
())

71 
LOG
(
RefCouedLks
, "LEAK: %u %s", 
m_cou
.
ld
(), 
m_desti
);

72 i(!
	gloggedSussiRs
) {

74 
LOG
(
RefCouedLks
, "Nak checkg de: %s", 
akMesgeSussiRss
->
beg
()->
key
);

75 
	gloggedSussiRs
 = 
ue
;

80 
	gRefCouedLkCou
::
emt
()

82 ++
m_cou
;

85 
	gRefCouedLkCou
::
deemt
()

87 --
m_cou
;

	@RefCountedLeakCounter.h

21 #ide
RefCouedLkCou_h


22 
	#RefCouedLkCou_h


	)

24 
	~<omic
>

25 
	~<wtf/Asis.h
>

27 
mea
 
	gWTF
 {

29 
	sRefCouedLkCou
 {

30 
WTF_EXPORT_PRIVATE
 
sussMesges
(const *);

31 
WTF_EXPORT_PRIVATE
 
nlMesgeSussi
(const *);

33 
WTF_EXPORT_PRIVATE
 
exic
 
RefCouedLkCou
(cڡ * 
desti
);

34 
	gWTF_EXPORT_PRIVATE
 ~
RefCouedLkCou
();

36 
WTF_EXPORT_PRIVATE
 
emt
();

37 
WTF_EXPORT_PRIVATE
 
deemt
();

39 #ide
NDEBUG


40 
	give
:

41 
d
::
omic
<> 
m_cou
;

42 cڡ * 
	gm_desti
;

	@RefPtr.h

23 #ide
WTF_RefP_h


24 
	#WTF_RefP_h


	)

26 
	~<gܙhm
>

27 
	~<uty
>

28 
	~<wtf/FaMloc.h
>

29 
	~<wtf/GP.h
>

30 
	~<wtf/PassRefP.h
>

32 
mea
 
	gWTF
 {

34 
	eHashTabDedVueTy
 { 
	gHashTabDedVue
 };

36 
	gme
<
tyme
 
	gT
> cs
	cRefP
 {

37 
	gWTF_MAKE_FAST_ALLOCATED
;

38 
	gpublic
:

39 
T
 
	tVueTy
;

40 
VueTy
* 
	tPTy
;

42 
ALWAYS_INLINE
 
RefP
(: 
m_r
(
nuαr
) { }

43 
ALWAYS_INLINE
 
RefP
(
T
* 
r
: 
m_r
Ռ{ 
fIfNNu
(ptr); }

44 
ALWAYS_INLINE
 
RefP
(cڡ RefP& 
o
: 
m_r
(o.m_r{ 
fIfNNu
(m_ptr); }

45 
	gme
<
tyme
 
	gU
> 
RefP
(cڡ RefP<
U
>& 
o
: 
m_r
(o.
g
(){ 
fIfNNu
(m_ptr); }

47 
ALWAYS_INLINE
 
RefP
(RefP&& 
o
: 
m_r
(o.
a
().
akRef
()) { }

48 
me
<
tyme
 
U
> 
RefP
(RefP<U>&& 
o
: 
m_r
(o.
a
().
akRef
()) { }

51 
me
<
tyme
 
U
> 
RefP
(cڡ 
PassRefP
<U>&);

53 
	gme
<
tyme
 
	gU
> 
RefP
(
PassRef
<
U
>&&);

56 
RefP
(
HashTabDedVueTy
: 
m_r
(
hashTabDedVue
()) { }

57 
bo
 
isHashTabDedVue
(cڡ {  
m_r
 =
hashTabDedVue
(); }

59 
	gALWAYS_INLINE
 ~
RefP
({ 
defIfNNu
(
m_r
); }

61 
T
* 
g
(cڡ {  
	gm_r
; }

63 
r
();

64 
	gPassRefP
<
	gT
> 
a
({ PassRefP<T> 
	gtmp
 = 
adtRef
(
m_r
); 
	gm_r
 = 
nuαr
; mp; }

65 
	gPassRef
<
	gT
> 
aNNu
({ 
ASSERT
(
m_r
); PassRef<T> 
	gtmp
 = 
adtRef
(*m_r); 
	gm_r
 = 
nuαr
; mp; }

67 
	gT
& 
	gݔ
*(cڡ {  *
	gm_r
; }

68 
ALWAYS_INLINE
 
T
* 
	gݔ
->(cڡ {  
	gm_r
; }

70 
bo
 
	gݔ
!(cڡ {  !
	gm_r
; }

73 
	gT
* (
	tRefP
::*
	tUnecifdBoTy
);

74 
ݔ
 
UnecifdBoTy
(cڡ {  
	gm_r
 ? &
	gRefP
::
m_r
 : 
nuαr
; }

76 
	gRefP
& 
	gݔ
=(cڡ 
RefP
&);

77 
	gRefP
& 
	gݔ
=(
T
*);

78 
	gRefP
& 
	gݔ
=(cڡ 
PassRefP
<
T
>&);

79 
	gme
<
tyme
 
	gU
> 
	gRefP
& 
	gݔ
=(cڡ 
RefP
<
U
>&);

80 
	gme
<
tyme
 
	gU
> 
	gRefP
& 
	gݔ
=(cڡ 
PassRefP
<
U
>&);

81 
	gRefP
& 
	gݔ
=(
RefP
&&);

82 
	gme
<
tyme
 
	gU
> 
	gRefP
& 
	gݔ
=(
RefP
<
U
>&&);

83 
	gme
<
tyme
 
	gU
> 
	gRefP
& 
	gݔ
=(
PassRef
<
U
>);

85 
sw
(
RefP
&);

87 
T
* 
hashTabDedVue
({  
	gt_
<
	gT
*>(-1); }

89 
	give
:

90 
T
* 
m_r
;

93 
	gme
<
tyme
 
	gT
>eme<tym
	gU
> 
le
 
	gRefP
<T>::
RefP
(cڡ 
PassRefP
<
U
>& 
o
)

94 : 
m_r
(
o
.
	$akRef
())

96 
	}
}

98 
me
<
tyme
 
T
>eme<tym
U
> 
le
 
RefP
<T>::RefP(
PassRef
<U>&& 
n
)

99 : 
m_r
(&
n
.
	$akRef
())

101 
	}
}

103 
me
<
tyme
 
T
> 
le
 
RefP
<T>::
	$r
()

105 
T
* 
r
 = 
m_r
;

106 
m_r
 = 
nuαr
;

107 
	`defIfNNu
(
r
);

108 
	}
}

110 
	gme
<
tyme
 
	gT
> 
le
 
	gRefP
<T>& RefP<T>::
ݔ
=(cڡ 
RefP
& 
o
)

112 
RefP
 
r
 = 
o
;

113 
sw
(
r
);

114  *
	gthis
;

117 
	gme
<
tyme
 
	gT
>eme<tym
	gU
> 
le
 
	gRefP
<T>& RefP<T>::
ݔ
=(cڡ 
RefP
<
U
>& 
o
)

119 
RefP
 
r
 = 
o
;

120 
sw
(
r
);

121  *
	gthis
;

124 
	gme
<
tyme
 
	gT
> 
le
 
	gRefP
<T>& RefP<T>::
ݔ
=(
T
* 
݌
)

126 
RefP
 
r
 = 
݌
;

127 
sw
(
r
);

128  *
	gthis
;

131 
	gme
<
tyme
 
	gT
> 
le
 
	gRefP
<T>& RefP<T>::
ݔ
=(cڡ 
PassRefP
<
T
>& 
o
)

133 
RefP
 
r
 = 
o
;

134 
sw
(
r
);

135  *
	gthis
;

138 
	gme
<
tyme
 
	gT
>eme<tym
	gU
> 
le
 
	gRefP
<T>& RefP<T>::
ݔ
=(cڡ 
PassRefP
<
U
>& 
o
)

140 
RefP
 
r
 = 
o
;

141 
sw
(
r
);

142  *
	gthis
;

145 
	gme
<
tyme
 
	gT
> 
le
 
	gRefP
<T>& RefP<T>::
ݔ
=(
RefP
&& 
o
)

147 
RefP
 
r
 = 
WTF
::
move
(
o
);

148 
sw
(
r
);

149  *
	gthis
;

152 
	gme
<
tyme
 
	gT
>eme<tym
	gU
> 
le
 
	gRefP
<T>& RefP<T>::
ݔ
=(
RefP
<
U
>&& 
o
)

154 
RefP
 
r
 = 
WTF
::
move
(
o
);

155 
sw
(
r
);

156  *
	gthis
;

159 
	gme
<
tyme
 
	gT
>eme<tym
	gU
> 
le
 
	gRefP
<T>& RefP<T>::
ݔ
=(
PassRef
<
U
> 
n
)

161 
RefP
 
r
 = 
WTF
::
move
(
n
);

162 
sw
(
r
);

163  *
	gthis
;

166 
	gme
<
ass
 
	gT
> 
le
 
	gRefP
<T>::
	$sw
(
RefP
& 
o
)

168 
d
::
	`sw
(
m_r
, 
o
.m_ptr);

169 
	}
}

171 
	gme
<
ass
 
	gT
> 
le
 
sw
(
RefP
<
T
>& 
a
, RefP<T>& 
b
)

173 
	ga
.
sw
(
b
);

176 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
==(cڡ 
RefP
<
T
>& 
a
, cڡ 
	gRefP
<U>& 
	gb
)

178  
	ga
.
g
(=
b
.get();

181 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
==(cڡ 
RefP
<
T
>& 
a
, 
U
* 
	gb
)

183  
	ga
.
g
(=
b
;

186 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
==(
T
* 
a
, cڡ 
	gRefP
<U>& 
	gb
)

188  
	ga
 =
b
.
g
();

191 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
!=(cڡ 
RefP
<
T
>& 
a
, cڡ 
	gRefP
<U>& 
	gb
)

193  
	ga
.
g
(!
b
.get();

196 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
!=(cڡ 
RefP
<
T
>& 
a
, 
U
* 
	gb
)

198  
	ga
.
g
(!
b
;

201 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
!=(
T
* 
a
, cڡ 
	gRefP
<U>& 
	gb
)

203  
	ga
 !
b
.
g
();

206 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
	gRefP
<T> 
ic_por_
(cڡ 
RefP
<
U
>& 
p
)

208  
	gRefP
<
	gT
>(
	gic_
<T*>(
	gp
.
g
()));

211 
	gme
 <
tyme
 
	gT
> 
	gIsSmtP
<
	gRefP
<T>> {

212 cڡ 
bo
 
	gvue
 = 
ue
;

217 
usg
 
	gWTF
::
RefP
;

218 
usg
 
	gWTF
::
ic_por_
;

	@RefPtrHashMap.h

21 #ide
RefPHashM_h


22 
	#RefPHashM_h


	)

24 
mea
 
	gWTF
 {

31 
	gme
<
tyme
 
	gT
,ym
	gMdArg
,ym
	gHashArg
,ym
	gKeyTsArg
,ym
	gMdTsArg
>

32 
ass
 
	gHashM
<
	gRefP
<
	gT
>, 
	gMdArg
, 
	gHashArg
, 
	gKeyTsArg
, 
	gMdTsArg
> {

33 
	gWTF_MAKE_FAST_ALLOCATED
;

34 
	give
:

35 
KeyTsArg
 
	tKeyTs
;

36 
MdTsArg
 
	tMdTs
;

37 
	gKeyVuePaHashTs
<
	tKeyTs
, 
	tMdTs
> 
	tVueTs
;

39 
	gpublic
:

40 
tyme
 
	tKeyTs
::
	tTTy
 
	tKeyTy
;

41 
T
* 
	tRawKeyTy
;

42 
tyme
 
	tMdTs
::
	tTTy
 
	tMdTy
;

43 
tyme
 
	tVueTs
::
	tTTy
 
	tVueTy
;

45 
	give
:

46 
tyme
 
	tMdTs
::
	tPkTy
 
	tMdPkTy
;

48 
HashArg
 
	tHashFunis
;

50 
	gHashTab
<
	tKeyTy
, 
	tVueTy
, 
	tKeyVuePaKeyExa
<ValueType>,

51 
	tHashFunis
, 
	tVueTs
, 
	tKeyTs
> 
	tHashTabTy
;

53 
	gHashMTn
<
	tVueTs
, 
	tHashFunis
>

54 
	tTn
;

56 
	gpublic
:

57 
HashTabItAdr
<
	tHashTabTy
, 
	tVueTy
> 
	t
;

58 
	gHashTabCڡItAdr
<
	tHashTabTy
, 
	tVueTy
> 
	tcڡ_
;

59 
tyme
 
	tHashTabTy
::
	tAddResu
 AddResult;

61 
sw
(
HashM
&);

63 
size
() const;

64 
cy
() const;

65 
bo
 
isEmy
() const;

68 

 
beg
();

69 

 
d
();

70 
cڡ_
 
beg
() const;

71 
cڡ_
 
d
() const;

73 
	gItRge
<
tyme
 
	g
::
Keys
> 
keys
({  
makeItRge
(
beg
().keys(), 
d
().keys()); }

74 cڡ 
	gItRge
<
tyme
 
	gcڡ_
::
Keys
> 
keys
(cڡ {  
makeItRge
(
beg
().keys(), 
d
().keys()); }

76 
	gItRge
<
tyme
 
	g
::
Vues
> 
vues
({  
makeItRge
(
beg
().vues(), 
d
().values()); }

77 cڡ 
	gItRge
<
tyme
 
	gcڡ_
::
Vues
> 
vues
(cڡ {  
makeItRge
(
beg
().vues(), 
d
().values()); }

79 

 
fd
(cڡ 
KeyTy
&);

80 

 
fd
(
RawKeyTy
);

81 
cڡ_
 
fd
(cڡ 
KeyTy
&) const;

82 
cڡ_
 
fd
(
RawKeyTy
) const;

83 
bo
 
cڏs
(cڡ 
KeyTy
&) const;

84 
bo
 
cڏs
(
RawKeyTy
) const;

85 
MdPkTy
 
g
(cڡ 
KeyTy
&) const;

86 
MdPkTy
 
g
(
RawKeyTy
) const;

87 
MdPkTy
 
leG
(
RawKeyTy
) const;

92 
	gme
<
tyme
 
	gV
> 
AddResu
 
t
(cڡ 
KeyTy
&, 
V
&&);

93 
	gme
<
tyme
 
	gV
> 
AddResu
 
t
(
RawKeyTy
, 
V
&&);

98 
	gme
<
tyme
 
	gV
> 
AddResu
 
add
(cڡ 
KeyTy
&, 
V
&&);

99 
	gme
<
tyme
 
	gV
> 
AddResu
 
add
(
RawKeyTy
, 
V
&&);

101 
bo
 
move
(cڡ 
KeyTy
&);

102 
bo
 
move
(
RawKeyTy
);

103 
bo
 
move
(

);

104 
r
();

106 
MdTy
 
ke
(cڡ 
KeyTy
&);

107 
MdTy
 
ke
(
RawKeyTy
);

109 
	give
:

110 
me
<
tyme
 
V
>

111 
AddResu
 
leAdd
(cڡ 
KeyTy
&, 
V
&&);

113 
	gme
<
tyme
 
	gV
>

114 
AddResu
 
leAdd
(
RawKeyTy
, 
V
&&);

116 
HashTabTy
 
	gm_im
;

119 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

120 
le
 
	gHashM
<
	gRefP
<
	gT
>, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
sw
(
HashM
& 
h
)

122 
m_im
.
sw
(
h
.m_impl);

125 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

126 
le
 
	gHashM
<
	gRefP
<
	gT
>, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
size
() const

128  
m_im
.
size
();

131 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

132 
le
 
	gHashM
<
	gRefP
<
	gT
>, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
cy
() const

134  
m_im
.
cy
();

137 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

138 
le
 
bo
 
	gHashM
<
	gRefP
<
	gT
>, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
isEmy
() const

140  
m_im
.
isEmy
();

143 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

144 
le
 
tyme
 
	gHashM
<
	gRefP
<
	gT
>, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::

 
HashM
<
RefP
<
T
>, U, V, W, X>::
beg
()

146  
m_im
.
beg
();

149 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

150 
le
 
tyme
 
	gHashM
<
	gRefP
<
	gT
>, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::

 
HashM
<
RefP
<
T
>, U, V, W, X>::
d
()

152  
m_im
.
d
();

155 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

156 
le
 
tyme
 
	gHashM
<
	gRefP
<
	gT
>, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
cڡ_
 
HashM
<
RefP
<
T
>, U, V, W, X>::
beg
() const

158  
m_im
.
beg
();

161 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

162 
le
 
tyme
 
	gHashM
<
	gRefP
<
	gT
>, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
cڡ_
 
HashM
<
RefP
<
T
>, U, V, W, X>::
d
() const

164  
m_im
.
d
();

167 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

168 
le
 
tyme
 
	gHashM
<
	gRefP
<
	gT
>, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::

 
HashM
<
RefP
<
T
>, U, V, W, X>::
fd
(cڡ 
KeyTy
& 
key
)

170  
m_im
.
fd
(
key
);

173 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

174 
le
 
tyme
 
	gHashM
<
	gRefP
<
	gT
>, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::

 
HashM
<
RefP
<
T
>, U, V, W, X>::
fd
(
RawKeyTy
 
key
)

176  
m_im
.
me
 
fd
<
Tn
>(
key
);

179 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

180 
le
 
tyme
 
	gHashM
<
	gRefP
<
	gT
>, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
cڡ_
 
HashM
<
RefP
<
T
>, U, V, W, X>::
fd
(cڡ 
KeyTy
& 
key
) const

182  
m_im
.
fd
(
key
);

185 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

186 
le
 
tyme
 
	gHashM
<
	gRefP
<
	gT
>, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
cڡ_
 
HashM
<
RefP
<
T
>, U, V, W, X>::
fd
(
RawKeyTy
 
key
) const

188  
m_im
.
me
 
fd
<
Tn
>(
key
);

191 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

192 
le
 
bo
 
	gHashM
<
	gRefP
<
	gT
>, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
cڏs
(cڡ 
KeyTy
& 
key
) const

194  
m_im
.
cڏs
(
key
);

197 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

198 
le
 
bo
 
	gHashM
<
	gRefP
<
	gT
>, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
cڏs
(
RawKeyTy
 
key
) const

200  
m_im
.
me
 
cڏs
<
Tn
>(
key
);

203 
	gme
<
tyme
 
	gKeyArg
,ym
	gMdArg
,ym
	gHashArg
,ym
	gKeyTsArg
,ym
	gMdTsArg
>

204 
	gme
<
tyme
 
	gV
>

205 aut
	gHashM
<
	gRefP
<
	gKeyArg
>, 
	gMdArg
, 
	gHashArg
, 
	gKeyTsArg
, 
	gMdTsArg
>::
leAdd
(cڡ 
KeyTy
& 
key
, 
V
&& 
md
-> 
	gAddResu


207  
	gm_im
.
me
 
	gadd
<
	gTn
>(
	gkey
, 
	gd
::
fwd
<
V
>(
md
));

210 
	gme
<
tyme
 
	gKeyArg
,ym
	gMdArg
,ym
	gHashArg
,ym
	gKeyTsArg
,ym
	gMdTsArg
>

211 
	gme
<
tyme
 
	gV
>

212 aut
	gHashM
<
	gRefP
<
	gKeyArg
>, 
	gMdArg
, 
	gHashArg
, 
	gKeyTsArg
, 
	gMdTsArg
>::
leAdd
(
RawKeyTy
 
key
, 
V
&& 
md
-> 
	gAddResu


214  
	gm_im
.
me
 
	gadd
<
	gTn
>(
	gkey
, 
	gd
::
fwd
<
V
>(
md
));

217 
	gme
<
tyme
 
	gKeyArg
,ym
	gMdArg
,ym
	gHashArg
,ym
	gKeyTsArg
,ym
	gMdTsArg
>

218 
	gme
<
tyme
 
	gV
>

219 aut
	gHashM
<
	gRefP
<
	gKeyArg
>, 
	gMdArg
, 
	gHashArg
, 
	gKeyTsArg
, 
	gMdTsArg
>::
t
(cڡ 
KeyTy
& 
key
, 
V
&& 
vue
-> 
	gAddResu


221 
AddResu
 
	gsu
 = 
leAdd
(
key
, 
d
::
fwd
<
V
>(
vue
));

222 i(!
	gsu
.
	gisNewEry
) {

224 
	gsu
.
	g
->
	gvue
 = 
d
::
fwd
<
V
>(
vue
);

226  
	gsu
;

229 
	gme
<
tyme
 
	gKeyArg
,ym
	gMdArg
,ym
	gHashArg
,ym
	gKeyTsArg
,ym
	gMdTsArg
>

230 
	gme
<
tyme
 
	gV
>

231 aut
	gHashM
<
	gRefP
<
	gKeyArg
>, 
	gMdArg
, 
	gHashArg
, 
	gKeyTsArg
, 
	gMdTsArg
>::
t
(
RawKeyTy
 
key
, 
V
&& 
vue
-> 
	gAddResu


233 
AddResu
 
	gsu
 = 
leAdd
(
key
, 
d
::
fwd
<
V
>(
vue
));

234 i(!
	gsu
.
	gisNewEry
) {

236 
	gsu
.
	g
->
	gvue
 = 
d
::
fwd
<
V
>(
vue
);

238  
	gsu
;

241 
	gme
<
tyme
 
	gKeyArg
,ym
	gMdArg
,ym
	gHashArg
,ym
	gKeyTsArg
,ym
	gMdTsArg
>

242 
	gme
<
tyme
 
	gV
>

243 aut
	gHashM
<
	gRefP
<
	gKeyArg
>, 
	gMdArg
, 
	gHashArg
, 
	gKeyTsArg
, 
	gMdTsArg
>::
add
(cڡ 
KeyTy
& 
key
, 
V
&& 
vue
-> 
	gAddResu


245  
leAdd
(
key
, 
d
::
fwd
<
V
>(
vue
));

248 
	gme
<
tyme
 
	gKeyArg
,ym
	gMdArg
,ym
	gHashArg
,ym
	gKeyTsArg
,ym
	gMdTsArg
>

249 
	gme
<
tyme
 
	gV
>

250 aut
	gHashM
<
	gRefP
<
	gKeyArg
>, 
	gMdArg
, 
	gHashArg
, 
	gKeyTsArg
, 
	gMdTsArg
>::
add
(
RawKeyTy
 
key
, 
V
&& 
vue
-> 
	gAddResu


252  
leAdd
(
key
, 
d
::
fwd
<
V
>(
vue
));

255 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gMdTs
>

256 
tyme
 
	gHashM
<
	gRefP
<
	gT
>, 
	gU
, 
	gV
, 
	gW
, 
	gMdTs
>::
MdPkTy


257 
HashM
<
RefP
<
T
>, 
	gU
, 
	gV
, 
	gW
, 
	gMdTs
>::
g
(cڡ 
KeyTy
& 
key
) const

259 
VueTy
* 
y
 = 
cڡ_
<
HashTabTy
&>(
m_im
).
lookup
(
key
);

260 i(!
	gy
)

261  
	gMdTs
::
ek
(
MdTs
::
emyVue
());

262  
	gMdTs
::
ek
(
y
->
vue
);

265 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gMdTs
>

266 
tyme
 
	gHashM
<
	gRefP
<
	gT
>, 
	gU
, 
	gV
, 
	gW
, 
	gMdTs
>::
MdPkTy


267 
le
 
HashM
<
RefP
<
T
>, 
	gU
, 
	gV
, 
	gW
, 
	gMdTs
>::
leG
(
RawKeyTy
 
key
) const

269 
VueTy
* 
y
 = 
cڡ_
<
HashTabTy
&>(
m_im
).
me
 
lookup
<
Tn
>(
key
);

270 i(!
	gy
)

271  
	gMdTs
::
ek
(
MdTs
::
emyVue
());

272  
	gMdTs
::
ek
(
y
->
vue
);

275 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gMdTs
>

276 
tyme
 
	gHashM
<
	gRefP
<
	gT
>, 
	gU
, 
	gV
, 
	gW
, 
	gMdTs
>::
MdPkTy


277 
HashM
<
RefP
<
T
>, 
	gU
, 
	gV
, 
	gW
, 
	gMdTs
>::
g
(
RawKeyTy
 
key
) const

279  
leG
(
key
);

282 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

283 
le
 
bo
 
	gHashM
<
	gRefP
<
	gT
>, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
move
(

 

)

285 i(

.
m_im
 =m_im.
d
())

286  
l
;

287 
	gm_im
.
CheckTabCsicy
();

288 
	gm_im
.
moveWhoutEryCsicyCheck
(

.
m_im
);

289  
	gue
;

292 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

293 
le
 
bo
 
	gHashM
<
	gRefP
<
	gT
>, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
move
(cڡ 
KeyTy
& 
key
)

295  
move
(
fd
(
key
));

298 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

299 
le
 
bo
 
	gHashM
<
	gRefP
<
	gT
>, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
move
(
RawKeyTy
 
key
)

301  
move
(
fd
(
key
));

304 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gX
>

305 
le
 
	gHashM
<
	gRefP
<
	gT
>, 
	gU
, 
	gV
, 
	gW
, 
	gX
>::
r
()

307 
m_im
.
r
();

310 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gMdTs
>

311 aut
	gHashM
<
	gRefP
<
	gT
>, 
	gU
, 
	gV
, 
	gW
, 
	gMdTs
>::
ke
(cڡ 
KeyTy
& 
key
-> 
MdTy


313 

 

 = 
fd
(
key
);

314 i(
	g
 =
d
())

315  
MdTs
::
emyVue
();

316 
MdTy
 
	gvue
 = 
WTF
::
move
(

->
vue
);

317 
move
(

);

318  
	gvue
;

321 
	gme
<
tyme
 
	gT
,ym
	gU
,ym
	gV
,ym
	gW
,ym
	gMdTs
>

322 aut
	gHashM
<
	gRefP
<
	gT
>, 
	gU
, 
	gV
, 
	gW
, 
	gMdTs
>::
ke
(
RawKeyTy
 
key
-> 
MdTy


324 

 

 = 
fd
(
key
);

325 i(
	g
 =
d
())

326  
MdTs
::
emyVue
();

327 
MdTy
 
	gvue
 = 
WTF
::
move
(

->
vue
);

328 
move
(

);

329  
	gvue
;

	@RetainPtr.h

21 #ide
RaP_h


22 
	#RaP_h


	)

24 #i
USE
(
CF
|| 
defed
(
__OBJC__
)

26 
	~<wtf/HashTs.h
>

27 
	~<gܙhm
>

28 
	~<cddef
>

30 #i
USE
(
CF
)

31 
	~<CeFoundi/CeFoundi.h
>

34 #ifde
__OBJC__


35 #imp܈<
Foundi
/Foundi.
h
>

38 #ide
CF_RELEASES_ARGUMENT


39 
	#CF_RELEASES_ARGUMENT


	)

42 #ide
NS_RELEASES_ARGUMENT


43 
	#NS_RELEASES_ARGUMENT


	)

46 
mea
 
	gWTF
 {

51 
	gme
<
tyme
 
	gT
> 
ass
 
	gRaP
;

53 
	gme
<
tyme
 
	gT
> 
	gRaP
<T> 
adtOS
(
T
 
CF_RELEASES_ARGUMENT

	gWARN_UNUSED_RETURN
;

54 
	gme
<
tyme
 
	gT
> 
	gRaP
<T> 
adtCF
(
T
 
CF_RELEASES_ARGUMENT

	gWARN_UNUSED_RETURN
;

55 
	gme
<
tyme
 
	gT
> 
	gRaP
<T> 
adtNS
(
T
 
NS_RELEASES_ARGUMENT

	gWARN_UNUSED_RETURN
;

57 
	gme
<
tyme
 
	gT
> cs
	cRaP
 {

58 
	gpublic
:

59 
tyme
 
	td
::
	tmove_por
<
	tT
>::
	tty
 
	tVueTy
;

60 
VueTy
* 
	tPTy
;

61 
CFTyRef
 
	tStageTy
;

63 
RaP
(: 
m_r
(
nuαr
) { }

64 
RaP
(
PTy
 
r
: 
m_r
(
toStageTy
Ռ){ i(m_r
CFRa
(m_ptr); }

66 
RaP
(cڡ RaP& 
o
: 
m_r
(o.m_r{ i(
StageTy
 
r
 = m_r
CFRa
(ptr); }

68 
RaP
(RaP&& 
o
: 
m_r
(
toStageTy
(o.
akRef
())) { }

69 
me
<
tyme
 
U
> 
RaP
(RaP<U>&& 
o
: 
m_r
(
toStageTy
(o.
akRef
())) { }

72 
RaP
(
HashTabDedVueTy
: 
m_r
(
hashTabDedVue
()) { }

73 
bo
 
isHashTabDedVue
(cڡ {  
m_r
 =
hashTabDedVue
(); }

75 ~
RaP
({ i(
StageTy
 
	gr
 = 
m_r

CFR
(
r
); }

77 
	gme
<
tyme
 
	gU
> 
RaP
(cڡ RaP<
U
>&);

79 
r
();

80 
PTy
 
akRef
(
	gWARN_UNUSED_RETURN
;

81 
PTy
 
autܖ
();

83 
PTy
 
g
(cڡ {  
omStageTy
(
m_r
); }

84 
PTy
 
	gݔ
->(cڡ {  
omStageTy
(
m_r
); }

85 
exic
 
ݔ
 
PTy
(cڡ {  
omStageTy
(
m_r
); }

86 
exic
 
ݔ
 
bo
(cڡ {  
	gm_r
; }

88 
bo
 
	gݔ
!(cڡ {  !
	gm_r
; }

91 
StageTy
 
	tRaP
::*
	tUnecifdBoTy
;

92 
ݔ
 
UnecifdBoTy
(cڡ {  
	gm_r
 ? &
	gRaP
::
m_r
 : 
nuαr
; }

94 
	gRaP
& 
	gݔ
=(cڡ 
RaP
&);

95 
	gme
<
tyme
 
	gU
> 
	gRaP
& 
	gݔ
=(cڡ 
RaP
<
U
>&);

96 
	gRaP
& 
	gݔ
=(
PTy
);

97 
	gme
<
tyme
 
	gU
> 
	gRaP
& 
	gݔ
=(
U
*);

99 
	gRaP
& 
	gݔ
=(
RaP
&&);

100 
	gme
<
tyme
 
	gU
> 
	gRaP
& 
	gݔ
=(
RaP
<
U
>&&);

102 
sw
(
RaP
&);

104 
	gme
<
tyme
 
	gU
> 
nd
 
	gRaP
<U> 
adtOS
(
U
 
CF_RELEASES_ARGUMENT

	gWARN_UNUSED_RETURN
;

105 
	gme
<
tyme
 
	gU
> 
nd
 
	gRaP
<U> 
adtCF
(
U
 
CF_RELEASES_ARGUMENT

	gWARN_UNUSED_RETURN
;

106 
	gme
<
tyme
 
	gU
> 
nd
 
	gRaP
<U> 
adtNS
(
U
 
NS_RELEASES_ARGUMENT

	gWARN_UNUSED_RETURN
;

108 
	give
:

109 
	eAdtTag
 { 
Adt
 };

110 
RaP
(
PTy
 
r
, 
AdtTag
: 
m_r
(
toStageTy
(ptr)) { }

112 
PTy
 
hashTabDedVue
({  
t_
<PtrType>(-1); }

114 #i
defed
 (
__OBJC__
&& 
__has_u
(
objc_c
)

115 
	gme
<
tyme
 
	gU
>

116 
tyme
 
	gd
::
ab_if
<
d
::
is_cvtib
<
U
, 
	gid
>::
vue
, 
	gPTy
>::
ty


117 
omStageTyHr
(
StageTy
 
r
) const

119  (
__bridge
 
PTy
)
r
;

122 
	gme
<
tyme
 
	gU
>

123 
tyme
 
	gd
::
ab_if
<!
d
::
is_cvtib
<
U
, 
	gid
>::
vue
, 
	gPTy
>::
ty


124 
omStageTyHr
(
StageTy
 
r
) const

126  (
PTy
)
r
;

129 
PTy
 
omStageTy
(
StageTy
 
r
cڡ {  
	gomStageTyHr
<
	gPTy
>(
	gr
); }

130 
StageTy
 
toStageTy
(
id
 
r
cڡ {  (
__bridge
 
	gStageTy
)
	gr
; }

131 
StageTy
 
toStageTy
(
CFTyRef
 
r
cڡ {  (
	gStageTy
)
	gr
; }

133 
PTy
 
omStageTy
(
StageTy
 
r
cڡ {  (
	gPTy
)
	gr
; }

134 
StageTy
 
toStageTy
(
PTy
 
r
cڡ {  (
	gStageTy
)
	gr
; }

137 
StageTy
 
	gm_r
;

141 
	gme
<
tyme
 
	gT
> 
le
 
	gRaP
<T> 
	$P
(
T

WARN_UNUSED_RETURN
;

143 
me
<
tyme
 
T
>eme<tym
U
> 
le
 
RaP
<T>::
	`RaP
(cڡ RaP<U>& 
o
)

144 : 
	`m_r
(
	`toStageTy
(
o
.
	$g
()))

146 i(
StageTy
 
r
 = 
m_r
)

147 
	`CFRa
(
r
);

148 
	}
}

150 
	gme
<
tyme
 
	gT
> 
le
 
	gRaP
<T>::
	$r
()

152 i(
StageTy
 
r
 = 
m_r
) {

153 
m_r
 = 
nuαr
;

154 
	`CFR
(
r
);

156 
	}
}

158 
	gme
<
tyme
 
	gT
> 
le
ym
	gRaP
<T>::
PTy
 
RaP
<
T
>::
	$akRef
()

160 
PTy
 
r
 = 
	`omStageTy
(
m_r
);

161 
m_r
 = 
nuαr
;

162  
r
;

163 
	}
}

165 #ifde
__OBJC__


166 
	gme
<
tyme
 
	gT
> 
le
ut
	gRaP
<T>::
autܖ
(-> 
PTy


168  (
__bridge
 
PTy
)
CFBridggR
(
akRef
());

172 
	gme
<
tyme
 
	gT
> 
le
 
	gRaP
<T>& RaP<T>::
ݔ
=(cڡ 
RaP
& 
o
)

174 
RaP
 
r
 = 
o
;

175 
sw
(
r
);

176  *
	gthis
;

179 
	gme
<
tyme
 
	gT
>eme<tym
	gU
> 
le
 
	gRaP
<T>& RaP<T>::
ݔ
=(cڡ 
RaP
<
U
>& 
o
)

181 
RaP
 
r
 = 
o
;

182 
sw
(
r
);

183  *
	gthis
;

186 
	gme
<
tyme
 
	gT
> 
le
 
	gRaP
<T>& RaP<T>::
ݔ
=(
PTy
 
݌
)

188 
RaP
 
r
 = 
݌
;

189 
sw
(
r
);

190  *
	gthis
;

193 
	gme
<
tyme
 
	gT
>eme<tym
	gU
> 
le
 
	gRaP
<T>& RaP<T>::
ݔ
=(
U
* 
݌
)

195 
RaP
 
r
 = 
݌
;

196 
sw
(
r
);

197  *
	gthis
;

200 
	gme
<
tyme
 
	gT
> 
le
 
	gRaP
<T>& RaP<T>::
ݔ
=(
RaP
&& 
o
)

202 
RaP
 
r
 = 
WTF
::
move
(
o
);

203 
sw
(
r
);

204  *
	gthis
;

207 
	gme
<
tyme
 
	gT
>eme<tym
	gU
> 
le
 
	gRaP
<T>& RaP<T>::
ݔ
=(
RaP
<
U
>&& 
o
)

209 
RaP
 
r
 = 
WTF
::
move
(
o
);

210 
sw
(
r
);

211  *
	gthis
;

214 
	gme
<
tyme
 
	gT
> 
le
 
	gRaP
<T>::
	$sw
(
RaP
& 
o
)

216 
d
::
	`sw
(
m_r
, 
o
.m_ptr);

217 
	}
}

219 
	gme
<
tyme
 
	gT
> 
le
 
sw
(
RaP
<
T
>& 
a
, RaP<T>& 
b
)

221 
	ga
.
sw
(
b
);

224 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
==(cڡ 
RaP
<
T
>& 
a
, cڡ 
	gRaP
<U>& 
	gb
)

226  
	ga
.
g
(=
b
.get();

229 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
==(cڡ 
RaP
<
T
>& 
a
, 
U
* 
	gb
)

231  
	ga
.
g
(=
b
;

234 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
==(
T
* 
a
, cڡ 
	gRaP
<U>& 
	gb
)

236  
	ga
 =
b
.
g
();

239 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
!=(cڡ 
RaP
<
T
>& 
a
, cڡ 
	gRaP
<U>& 
	gb
)

241  
	ga
.
g
(!
b
.get();

244 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
!=(cڡ 
RaP
<
T
>& 
a
, 
U
* 
	gb
)

246  
	ga
.
g
(!
b
;

249 
	gme
<
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
!=(
T
* 
a
, cڡ 
	gRaP
<U>& 
	gb
)

251  
	ga
 !
b
.
g
();

254 
	gme
<
tyme
 
	gT
> 
le
 
	gRaP
<T> 
	$adtOS
(
T
 
CF_RELEASES_ARGUMENT
 
r
)

256  
RaP
<
T
>(
r
, RaP<T>::
Adt
);

257 
	}
}

259 
	gme
<
tyme
 
	gT
> 
le
 
	gRaP
<T> 
	$adtCF
(
T
 
CF_RELEASES_ARGUMENT
 
r
)

261 #ifde
__OBJC__


262 
	`ic_as
((!
d
::
is_cvtib
<
T
, 
id
>::
vue
), "Don't usedoptCF with Objective-Cointerypes, usedoptNS.");

264  
RaP
<
T
>(
r
, RaP<T>::
Adt
);

265 
	}
}

267 #ifde
__OBJC__


268 
	gme
<
tyme
 
	gT
> 
le
 
	gRaP
<T> 
	$adtNS
(
T
 
NS_RELEASES_ARGUMENT
 
r
)

270 #i
	`__has_u
(
objc_c
)

271  
r
;

272 #i
	`defed
(
OBJC_NO_GC
)

273  
RaP
<
T
>(
r
, RaP<T>::
Adt
);

275 
RaP
<
T
> 
su
 = 
r
;

276 [
r
 
a
];

277  
su
;

279 
	}
}

282 
	gme
<
tyme
 
	gT
> 
le
 
	gRaP
<T> 
	$P
(
T
 
r
)

284  
r
;

285 
	}
}

287 
	gme
 <
tyme
 
	gT
> 
	gIsSmtP
<
	gRaP
<T>> {

288 cڡ 
bo
 
	gvue
 = 
ue
;

291 
	gme
<
tyme
 
	gP
> 
	gHashTs
<
	gRaP
<P>> : 
SimeCssHashTs
<
RaP
<
P
>> {

294 
	gme
<
tyme
 
	gP
> 
	gDeuHash
<
	gRaP
<P>> {

295 
	gPHash
<
	tRaP
<
	tP
>> 
	tHash
;

298 
	gme
 <
tyme
 
	gP
>

299 
	gRaPObjeHashTs
 : 
SimeCssHashTs
<
RaP
<
P
>> {

300 cڡ 
RaP
<
P
>& 
emyVue
()

302 
RaP
<
P
>& 
nu
 = *(
w
 RetainPtr<P>);

303  
	gnu
;

307 
	gme
 <
tyme
 
	gP
>

308 
	sRaPObjeHash
 {

309 
hash
(cڡ 
RaP
<
P
>& 
o
)

311 
ASSERT_WITH_MESSAGE
(
o
.
g
(), "attempto useull RetainPtr in HashTable");

312  
	gic_
<>(
CFHash
(
o
.
g
()));

314 
bo
 
equ
(cڡ 
RaP
<
P
>& 
a
, cڡ RaP<P>& 
b
)

316  
CFEqu
(
a
.
g
(), 
b
.get());

318 cڡ 
bo
 
	gToComToEmyOrDed
 = 
l
;

323 
usg
 
	gWTF
::
RaP
;

324 
usg
 
	gWTF
::
adtOS
;

325 
usg
 
	gWTF
::
adtCF
;

326 
usg
 
	gWTF
::
adtNS
;

327 
usg
 
	gWTF
::
P
;

	@RunLoop.cpp

26 
	~"cfig.h
"

27 
	~"RunLo.h
"

29 
	~<wtf/StdLibExas.h
>

30 
	~<wtf/ThadScific.h
>

32 
mea
 
	gWTF
 {

34 
RunLo
* 
	gs_maRunLo
;

37 as
	cRunLo
::
Hd
 {

38 
public
:

39 
Hd
()

40 : 
m_runLo
(
adtRef
(*
w
 
RunLo
))

44 
RunLo
& 
runLo
({  
m_runLo
.
g
(); }

46 
	give
:

47 
Ref
<
RunLo
> 
m_runLo
;

50 
	gRunLo
::
	$lizeMaRunLo
()

52 i(
s_maRunLo
)

54 
s_maRunLo
 = &
RunLo
::
	`cut
();

55 
	}
}

57 
	gRunLo
& RunLo::
	$cut
()

59 
	`DEPRECATED_DEFINE_STATIC_LOCAL
(
WTF
::
ThadScific
<
RunLo
::
Hd
>, 
runLoHd
, ());

60  
runLoHd
->
	`runLo
();

61 
	}
}

63 
	gRunLo
& RunLo::
	$ma
()

65 
	`ASSERT
(
s_maRunLo
);

66  *
s_maRunLo
;

67 
	}
}

69 
bo
 
	gRunLo
::
	$isMa
()

71 
	`ASSERT
(
s_maRunLo
);

72  
s_maRunLo
 =&
RunLo
::
	`cut
();

73 
	}
}

75 
	gRunLo
::
	$rfmWk
()

91 
d
::
funi
<()> function;

92 
size_t
 
funisToHd
 = 0;

95 
MuxLock
 
	`lock
(
m_funiQueueLock
);

96 
funisToHd
 = 
m_funiQueue
.
	`size
();

98 i(
m_funiQueue
.
	`isEmy
())

101 
funi
 = 
m_funiQueue
.
	`keF
();

104 
	`funi
();

106 
size_t
 
funisHdd
 = 1; funisHdd < 
funisToHd
; ++functionsHandled) {

108 
MuxLock
 
	`lock
(
m_funiQueueLock
);

113 i(
m_funiQueue
.
	`isEmy
())

116 
funi
 = 
m_funiQueue
.
	`keF
();

119 
	`funi
();

121 
	}
}

123 
	gRunLo
::
dich
(
d
::
funi
<()> function)

125 
MuxLock
 
lock
(
m_funiQueueLock
);

126 
	gm_funiQueue
.
nd
(
WTF
::
move
(
funi
));

128 
wakeUp
();

	@RunLoop.h

28 #ide
RunLo_h


29 
	#RunLo_h


	)

31 
	~<wtf/Deque.h
>

32 
	~<wtf/Fwd.h
>

33 
	~<wtf/FuniDich.h
>

34 
	~<wtf/Funiڮ.h
>

35 
	~<wtf/HashM.h
>

36 
	~<wtf/RaP.h
>

37 
	~<wtf/Thadg.h
>

39 #i
USE
(
GLIB
)

40 
	~<wtf/gobje/GMaLoSour.h
>

43 #i
PLATFORM
(
EFL
)

44 
	~<Ece.h
>

45 
	~<wtf/e/UniquePE.h
>

48 
mea
 
	gWTF
 {

50 as
	cRunLo
 : 
public
 
FuniDich
 {

51 
WTF_MAKE_NONCOPYABLE
(
RunLo
);

52 
	gpublic
:

55 
WTF_EXPORT_PRIVATE
 
lizeMaRunLo
();

57 
WTF_EXPORT_PRIVATE
 
	gRunLo
& 
cut
();

58 
WTF_EXPORT_PRIVATE
 
	gRunLo
& 
ma
();

59 
WTF_EXPORT_PRIVATE
 
bo
 
isMa
();

60 ~
RunLo
();

62 
vtu
 
dich
(
d
::
funi
<()>
ovride
;

64 
WTF_EXPORT_PRIVATE
 
run
();

65 
WTF_EXPORT_PRIVATE
 

();

66 
WTF_EXPORT_PRIVATE
 
wakeUp
();

68 #i
PLATFORM
(
COCOA
)

69 
WTF_EXPORT_PRIVATE
 
runFDuti
(
duti
);

72 as
	cTimBa
 {

73 
nd
 
ass
 
	gRunLo
;

74 
	gpublic
:

75 
WTF_EXPORT_PRIVATE
 
exic
 
TimBa
(
RunLo
&);

76 
WTF_EXPORT_PRIVATE
 
	gvtu
 ~
TimBa
();

78 
tRtg
(
Iv
{ 
t
ԕtIv, 
ue
); }

79 
tRtg
(
d
::
chro
::
mlicds
 
Iv
{ sRtgԕtIv.
cou
() * 0.001); }

80 
tOSh
(
rv
{ 
t
(rv, 
l
); }

82 
WTF_EXPORT_PRIVATE
 

();

83 
WTF_EXPORT_PRIVATE
 
bo
 
isAive
() const;

85 
vtu
 
fed
() = 0;

87 
	give
:

88 
WTF_EXPORT_PRIVATE
 
t
(
xtFeIv
, 
bo
 

);

90 
	gRunLo
& 
	gm_runLo
;

92 #i
PLATFORM
(
WIN
)

93 
timFed
(
RunLo
*, 
ut64_t
 
ID
);

94 
ut64_t
 
	gm_ID
;

95 
bo
 
	gm_isRtg
;

96 #i
PLATFORM
(
COCOA
)

97 
timFed
(
CFRunLoTimRef
, *);

98 
	gRaP
<
	gCFRunLoTimRef
> 
	gm_tim
;

99 #i
PLATFORM
(
EFL
)

100 
bo
 
timFed
(* 
da
);

101 
Ece_Tim
* 
	gm_tim
;

102 
bo
 
	gm_isRtg
;

103 #i
USE
(
GLIB
)

104 
GMaLoSour
 
	gm_timSour
;

108 
	gme
 <
tyme
 
	gTimFedCss
>

109 as
	cTim
 : 
public
 
TimBa
 {

110 
public
:

111 (
TimFedCss
::*
	tTimFedFuni
)();

113 
Tim
(
RunLo
& 
runLo
, 
TimFedCss
* 
o
, 
TimFedFuni
 
f
)

114 : 
TimBa
(
runLo
)

115 , 
m_obje
(
o
)

116 , 
m_funi
(
f
)

120 
	give
:

121 
vtu
 
fed
({ (
m_obje
->*
m_funi
)(); }

123 
TimFedCss
* 
	gm_obje
;

124 
TimFedFuni
 
	gm_funi
;

127 
ass
 
	gHd
;

129 
	give
:

130 
RunLo
();

132 
rfmWk
();

134 
Mux
 
	gm_funiQueueLock
;

135 
	gDeque
<
	gd
::
funi
<()>> 
m_funiQueue
;

137 #i
PLATFORM
(
WIN
)

138 
bo
 
giRunLoMesgeWdowCss
();

139 
LRESULT
 
CALLBACK
 
RunLoWndProc
(
HWND
, 
UINT
, 
WPARAM
, 
LPARAM
);

140 
LRESULT
 
wndProc
(
HWND
 
hWnd
, 
UINT
 
mesge
, 
WPARAM
 
wPam
, 
LPARAM
 
lPam
);

141 
HWND
 
	gm_runLoMesgeWdow
;

143 
	gHashM
<
	tut64_t
, 
	tTimBa
*> 
	tTimM
;

144 
TimM
 
	gm_aiveTims
;

145 #i
PLATFORM
(
COCOA
)

146 
rfmWk
(*);

147 
	gRaP
<
	gCFRunLoRef
> 
	gm_runLo
;

148 
	gRaP
<
	gCFRunLoSourRef
> 
	gm_runLoSour
;

149 
	gm_ágLev
;

150 #i
PLATFORM
(
EFL
)

151 
Mux
 
	gm_peLock
;

152 
	gEUniqueP
<
	gEce_Pe
> 
	gm_pe
;

154 
Mux
 
	gm_wakeUpEvtRequeedLock
;

155 
bo
 
	gm_wakeUpEvtRequeed
;

157 
wakeUpEvt
(* 
da
, *, );

158 #i
USE
(
GLIB
)

159 
	gpublic
:

160 
gboޗn
 
queueWk
(
RunLo
*);

161 
GMaLo
* 
rmoLo
();

162 
pushNeedMaLo
(
GMaLo
*);

163 
pNeedMaLo
();

164 
	give
:

165 
GRefP
<
GMaCڋxt
> 
m_runLoCڋxt
;

166 
	gVe
<
	gGRefP
<
	gGMaLo
>> 
	gm_runLoMaLos
;

172 
usg
 
	gWTF
::
RunLo
;

	@RunLoopTimer.h

29 #ide
RunLoTim_h


30 
	#RunLoTim_h


	)

32 
	~<wtf/ScheduPa.h
>

33 
	~<wtf/RaP.h
>

35 
mea
 
	gWTF
 {

39 as
	cWTF_EXPORT_PRIVATE
 
	gRunLoTimBa
 {

40 
WTF_MAKE_NONCOPYABLE
(
RunLoTimBa
);

41 
	gpublic
:

42 
RunLoTimBa
() { }

43 
WTF_EXPORT_PRIVATE
 
vtu
 ~
RunLoTimBa
();

45 
WTF_EXPORT_PRIVATE
 
schedu
(cڡ 
ScheduPa
*);

46 
WTF_EXPORT_PRIVATE
 
schedu
(cڡ 
ScheduPaHashS
&);

48 
WTF_EXPORT_PRIVATE
 
t
(
xtFeIv
, 
Iv
);

50 
tRtg
(
Iv
{ 
t
(repeatInterval,epeatInterval); }

51 
tOSh
(
rv
{ 
t
(interval, 0); }

53 
WTF_EXPORT_PRIVATE
 

();

54 
bo
 
isAive
() const;

56 
vtu
 
fed
() = 0;

58 
	give
:

59 #i
USE
(
CF
)

60 
RaP
<
CFRunLoTimRef
> 
m_tim
;

64 
	gme
 <
tyme
 
	gTimFedCss
> cs
	cRunLoTim
 : 
public
 
RunLoTimBa
 {

65 
public
:

66 (
TimFedCss
::*
	tTimFedFuni
)(
	tRunLoTim
*);

68 
RunLoTim
(
TimFedCss
* 
o
, 
TimFedFuni
 
f
)

69 : 
m_obje
(
o
), 
m_funi
(
f
) { }

71 
vtu
 
fed
({ (
	gm_obje
->*
	gm_funi
)(
	gthis
); }

73 
	give
:

74 
TimFedCss
* 
m_obje
;

75 
TimFedFuni
 
	gm_funi
;

80 
usg
 
	gWTF
::
RunLoTim
;

	@RunLoopTimerCF.cpp

29 
	~"cfig.h
"

31 #i
PLATFORM
(
COCOA
&& 
HAVE
(
RUNLOOP_TIMER
)

33 
	~"RunLoTim.h
"

35 
	~"AutodedPo.h
"

37 
mea
 
	gWTF
 {

39 
	gRunLoTimBa
::~
RunLoTimBa
()

41 

();

44 
timFed
(
CFRunLoTimRef
, * 
cڋxt
)

50 
AutodedPo
 
	gpo
;

51 
RunLoTimBa
* 
	gtim
 = 
ic_
<RunLoTimBa*>(
cڋxt
);

52 
	gtim
->
fed
();

55 
	gRunLoTimBa
::
t
(
xtFeIv
, 
Iv
)

57 i(
	gm_tim
)

58 
CFRunLoTimInvide
(
m_tim
.
g
());

59 
CFRunLoTimCڋxt
 
	gcڋxt
 = { 0, 
this
, 0, 0, 0 };

60 
	gm_tim
 = 
adtCF
(
CFRunLoTimCe
(0, 
CFAbsuTimeGCut
(+ 
xtFeIv
, 
Iv
, 0, 0, 
timFed
, &
cڋxt
));

63 
	gRunLoTimBa
::
schedu
(cڡ 
ScheduPa
* 
scheduPa
)

65 
ASSERT_ARG
(
scheduPa
, schedulePair);

66 
ASSERT_WITH_MESSAGE
(
m_tim
, "Timer must have one ofhe start functions called before calling schedule().");

67 
CFRunLoAddTim
(
scheduPa
->
runLo
(), 
m_tim
.
g
(), scheduPa->
mode
());

70 
	gRunLoTimBa
::
schedu
(cڡ 
ScheduPaHashS
& 
scheduPas
)

72 
ScheduPaHashS
::
cڡ_
 
d
 = 
scheduPas
.end();

73 
	gScheduPaHashS
::
cڡ_
 

 = 
scheduPas
.
beg
(); 
	g
 !
d
; ++it)

74 
schedu
((*

).
g
());

77 
	gRunLoTimBa
::

()

79 i(!
m_tim
)

81 
CFRunLoTimInvide
(
m_tim
.
g
());

82 
	gm_tim
 = 0;

85 
bo
 
	gRunLoTimBa
::
isAive
() const

87  
m_tim
 && 
CFRunLoTimIsVid
(m_tim.
g
());

	@SHA1.cpp

35 
	~"cfig.h
"

36 
	~"SHA1.h
"

38 
	~"Asis.h
"

40 
	~"SgExas.h
"

41 
	~"xt/CSg.h
"

43 
mea
 
	gWTF
 {

45 
le
 
ut32_t
 
f
(
t
, ut32_
b
, ut32_
c
, ut32_
d
)

47 
ASSERT
(
t
 >= 0 && < 80);

48 i(
	gt
 < 20)

49  (
	gb
 & 
	gc
| ((~b& 
	gd
);

50 i(
	gt
 < 40)

51  
	gb
 ^ 
	gc
 ^ 
	gd
;

52 i(
	gt
 < 60)

53  (
	gb
 & 
	gc
| (b & 
	gd
) | (c & d);

54  
	gb
 ^ 
	gc
 ^ 
	gd
;

57 
le
 
ut32_t
 
k
(
t
)

59 
ASSERT
(
t
 >= 0 && < 80);

60 i(
	gt
 < 20)

62 i(
	gt
 < 40)

64 i(
	gt
 < 60)

69 
le
 
ut32_t
 
r٩eLe
(
n
, ut32_
x
)

71 
ASSERT
(
n
 >= 0 && < 32);

72  (
	gx
 << 
	gn
) | (x >> (32 -));

75 
	gSHA1
::
SHA1
()

77 
t
();

80 
	gSHA1
::
addBys
(cڡ 
ut8_t
* 
put
, 
size_t
 
ngth
)

82 
	gngth
--) {

83 
ASSERT
(
m_curs
 < 64);

84 
	gm_bufr
[
m_curs
++] = *
put
++;

85 ++
	gm_tٮBys
;

86 i(
	gm_curs
 == 64)

87 
ossBlock
();

91 
	gSHA1
::
compuHash
(
Dige
& 
dige
)

93 
fize
();

95 
size_t
 
	gi
 = 0; i < 5; ++i) {

97 
ut32_t
 
	ghashVue
 = 
m_hash
[
i
];

98 
	gj
 = 0; j < 4; ++j) {

99 
	gdige
[4 * 
i
 + (3 - 
j
)] = 
hashVue
 & 0xFF;

100 
	ghashVue
 >>= 8;

104 
t
();

107 
CSg
 
	gSHA1
::
hexDige
(cڡ 
Dige
& 
dige
)

109 * 
t
 = 0;

110 
CSg
 
	gsu
 = CSg::
wUnlized
(40, 
t
);

111 * 
	gbufr
 = 
t
;

112 
size_t
 
	gi
 = 0; i < 
	ghashSize
; ++i) {

113 
tf
(
bufr
, 3, "%02X", 
dige
.

(
i
));

114 
	gbufr
 += 2;

116  
	gsu
;

119 
CSg
 
	gSHA1
::
compuHexDige
()

121 
Dige
 
dige
;

122 
compuHash
(
dige
);

123  
hexDige
(
dige
);

126 
	gSHA1
::
fize
()

128 
ASSERT
(
m_curs
 < 64);

129 
	gm_bufr
[
m_curs
++] = 0x80;

130 i(
	gm_curs
 > 56) {

132 
	gm_curs
 < 64)

133 
	gm_bufr
[
m_curs
++] = 0x00;

134 
ossBlock
();

137 
size_t
 
	gi
 = 
m_curs
; i < 56; ++i)

138 
	gm_bufr
[
i
] = 0x00;

141 
ut64_t
 
	gbs
 = 
m_tٮBys
 * 8;

142 
	gi
 = 0; i < 8; ++i) {

143 
	gm_bufr
[56 + (7 - 
i
)] = 
bs
 & 0xFF;

144 
	gbs
 >>= 8;

146 
	gm_curs
 = 64;

147 
ossBlock
();

150 
	gSHA1
::
ossBlock
()

152 
ASSERT
(
m_curs
 == 64);

154 
ut32_t
 
	gw
[80] = { 0 };

155 
	gt
 = 0; < 16; ++t)

156 
	gw
[
t
] = (
m_bufr
[t * 4] << 24) | (m_buffer[t * 4 + 1] << 16) | (m_buffer[t * 4 + 2] << 8) | m_buffer[t * 4 + 3];

157 
	gt
 = 16; < 80; ++t)

158 
	gw
[
t
] = 
r٩eLe
(1, 
w
[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16]);

160 
ut32_t
 
	ga
 = 
m_hash
[0];

161 
ut32_t
 
	gb
 = 
m_hash
[1];

162 
ut32_t
 
	gc
 = 
m_hash
[2];

163 
ut32_t
 
	gd
 = 
m_hash
[3];

164 
ut32_t
 
	ge
 = 
m_hash
[4];

166 
	gt
 = 0; < 80; ++t) {

167 
ut32_t
 
	gmp
 = 
r٩eLe
(5, 
a
+ 
f
(
t
, 
b
, 
c
, 
d
+ 
	ge
 + 
	gw
[t] + 
k
(t);

168 
	ge
 = 
d
;

169 
	gd
 = 
c
;

170 
	gc
 = 
r٩eLe
(30, 
b
);

171 
	gb
 = 
a
;

172 
	ga
 = 
mp
;

175 
	gm_hash
[0] +
a
;

176 
	gm_hash
[1] +
b
;

177 
	gm_hash
[2] +
c
;

178 
	gm_hash
[3] +
d
;

179 
	gm_hash
[4] +
e
;

181 
	gm_curs
 = 0;

184 
	gSHA1
::
t
()

186 
m_curs
 = 0;

187 
	gm_tٮBys
 = 0;

188 
	gm_hash
[0] = 0x67452301;

189 
	gm_hash
[1] = 0xefcdab89;

190 
	gm_hash
[2] = 0x98badcfe;

191 
	gm_hash
[3] = 0x10325476;

192 
	gm_hash
[4] = 0xc3d2e1f0;

195 
memt
(
m_bufr
, 0, (m_buffer));

	@SHA1.h

31 #ide
WTF_SHA1_h


32 
	#WTF_SHA1_h


	)

34 
	~<y
>

35 
	~<wtf/Ve.h
>

36 
	~<wtf/xt/CSg.h
>

38 
mea
 
	gWTF
 {

40 as
	cSHA1
 {

41 
	gpublic
:

42 
WTF_EXPORT_PRIVATE
 
SHA1
();

44 
addBys
(cڡ 
Ve
<
ut8_t
>& 
put
)

46 
addBys
(
put
.
da
(), iut.
size
());

48 
addBys
(cڡ 
CSg
& 
put
)

50 cڡ * 
	grg
 = 
put
.
da
();

55 
ASSERT
(
put
.
ngth
(=

(
rg
));

56 
addBys
(
t_
<cڡ 
ut8_t
*>(
rg
), 
put
.
ngth
());

58 
WTF_EXPORT_PRIVATE
 
addBys
(cڡ 
ut8_t
* 
put
, 
size_t
 
ngth
);

61 
WTF_EXPORT_PRIVATE
 cڡ 
size_t
 
	ghashSize
 = 20;

64 
	gd
::
	ty
<
	tut8_t
, 
	thashSize
> 
	tDige
;

67 
WTF_EXPORT_PRIVATE
 
compuHash
(
Dige
&);

70 
WTF_EXPORT_PRIVATE
 
CSg
 
hexDige
(cڡ 
Dige
&);

73 
WTF_EXPORT_PRIVATE
 
CSg
 
compuHexDige
();

75 
	give
:

76 
fize
();

77 
ossBlock
();

78 
t
();

80 
ut8_t
 
	gm_bufr
[64];

81 
size_t
 
	gm_curs
;

82 
ut64_t
 
	gm_tٮBys
;

83 
ut32_t
 
	gm_hash
[5];

88 
usg
 
	gWTF
::
SHA1
;

	@SaturatedArithmetic.h

31 #ide
SudArhmic_h


32 
	#SudArhmic_h


	)

34 
	~<lims
>

35 
	~<dt.h
>

36 
	~<dlib.h
>

38 
le
 
t32_t
 
	$tudAddi
(
t32_t
 
a
, i32_
b
)

40 
ut32_t
 
ua
 = 
a
;

41 
ut32_t
 
ub
 = 
b
;

42 
ut32_t
 
su
 = 
ua
 + 
ub
;

46 i(!((
ua
 ^ 
ub
>> 31& (
su
 ^ ua) >> 31)

47 
su
 = 
d
::
numic_lims
<>::
	`max
(+ (
ua
 >> 31);

49  
su
;

50 
	}
}

52 
le
 
t32_t
 
	$tudSubai
(
t32_t
 
a
, i32_
b
)

54 
ut32_t
 
ua
 = 
a
;

55 
ut32_t
 
ub
 = 
b
;

56 
ut32_t
 
su
 = 
ua
 - 
ub
;

60 i((
ua
 ^ 
ub
>> 31 & (
su
 ^ ua) >> 31)

61 
su
 = 
d
::
numic_lims
<>::
	`max
(+ (
ua
 >> 31);

63  
su
;

64 
	}
}

	@SchedulePair.h

29 #ide
ScheduPa_h


30 
	#ScheduPa_h


	)

32 
	~<wtf/HashS.h
>

33 
	~<wtf/RefCoued.h
>

34 
	~<wtf/RaP.h
>

35 
	~<wtf/xt/SgHash.h
>

36 
	~<wtf/xt/WTFSg.h
>

38 #i
USE
(
FOUNDATION
)

39 
OBJC_CLASS
 
	gNSRunLo
;

42 
mea
 
	gWTF
 {

44 
ass
 
	gScheduPa
 : 
public
 
RefCoued
<
ScheduPa
> {

45 
public
:

46 
PassRefP
<
ScheduPa
> 

(
CFRunLoRef
 
runLo
, 
CFSgRef
 
mode
{  
adtRef
(
w
 SchedulePair(runLoop, mode)); }

48 #i
USE
(
FOUNDATION
&& !USE(
CFNETWORK
)

49 
	gPassRefP
<
	gScheduPa
> 

(
NSRunLo
* 
runLo
, 
CFSgRef
 
mode
{  
adtRef
(
w
 
ScheduPa
(runLoop, mode)); }

50 
NSRunLo
* 
nsRunLo
(cڡ {  
	gm_nsRunLo
.
g
(); }

53 
CFRunLoRef
 
runLo
(cڡ {  
	gm_runLo
.
g
(); }

54 
CFSgRef
 
mode
(cڡ {  
	gm_mode
.
g
(); }

56 
WTF_EXPORT_PRIVATE
 
bo
 
	gݔ
==(cڡ 
ScheduPa
& 
h
) const;

58 
	give
:

59 
ScheduPa
(
CFRunLoRef
 
runLo
, 
CFSgRef
 
mode
)

60 : 
m_runLo
(
runLo
)

62 i(
mode
)

63 
m_mode
 = 
adtCF
(
CFSgCeCy
(0, 
mode
));

66 #i
USE
(
FOUNDATION
&& !USE(
CFNETWORK
)

67 
WTF_EXPORT_PRIVATE
 
ScheduPa
(
NSRunLo
*, 
CFSgRef
);

68 
	gRaP
<
	gNSRunLo
*> 
	gm_nsRunLo
;

71 
	gRaP
<
	gCFRunLoRef
> 
	gm_runLo
;

72 
	gRaP
<
	gCFSgRef
> 
	gm_mode
;

75 
	sScheduPaHash
 {

76 
hash
(cڡ 
RefP
<
ScheduPa
>& 

)

78 
u_t
 
	ghashCodes
[2] = { 
t_
<u_t>(

->
runLo
()),a->
mode
(? 
CFHash
(pair->mode()) : 0 };

79  
	gSgHash
::
hashMemy
<(
hashCodes
)>(hashCodes);

82 
bo
 
equ
(cڡ 
RefP
<
ScheduPa
>& 
a
, cڡ RefP<ScheduPa>& 
b
{  
	ga
 == b; }

84 cڡ 
bo
 
	gToComToEmyOrDed
 = 
ue
;

87 
	gHashS
<
	tRefP
<
	tScheduPa
>, 
	tScheduPaHash
> 
	tScheduPaHashS
;

91 
usg
 
	gWTF
::
ScheduPa
;

92 
usg
 
	gWTF
::
ScheduPaHashS
;

	@SchedulePairCF.cpp

29 
	~"cfig.h
"

30 
	~"ScheduPa.h
"

32 
mea
 
	gWTF
 {

34 
bo
 
	gScheduPa
::
ݔ
==(cڡ 
ScheduPa
& 
h
) const

36 i(
runLo
(!
h
.runLoop())

37  
l
;

38 
CFSgRef
 
	gthisMode
 = 
mode
();

39 
CFSgRef
 
	ghMode
 = 
h
.
mode
();

40 i(!
	gthisMode
 || !
	ghMode
)

41  
	gthisMode
 =
hMode
;

42  
CFEqu
(
thisMode
, 
hMode
);

	@SegmentedVector.h

29 #ide
SegmdVe_h


30 
	#SegmdVe_h


	)

32 
	~<wtf/Ncyab.h
>

33 
	~<wtf/Ve.h
>

35 
mea
 
	gWTF
 {

38 
	gme
 <
tyme
 
	gT
, 
size_t
 
	gSegmtSize
 = 8, size_
	gIƚeCacy
 = 32> 
ass
 
SegmdVe
;

39 
	gme
 <
tyme
 
	gT
, 
size_t
 
	gSegmtSize
 = 8, size_
	gIƚeCacy
 = 32> cs
	cSegmdVeIt
 {

40 
ive
:

41 
nd
 
ass
 
SegmdVe
<
T
, 
SegmtSize
, 
IƚeCacy
>;

42 
	gpublic
:

43 
SegmdVeIt
<
	tT
, 
	tSegmtSize
, 
	tIƚeCacy
> 
	tIt
;

45 ~
SegmdVeIt
() { }

47 
	gT
& 
	gݔ
*(cڡ {  
	gm_ve
.
	gm_gmts
.

(
m_gmt
)->(
m_dex
); }

48 
T
* 
	gݔ
->(cڡ {  &
	gm_ve
.
	gm_gmts
.

(
m_gmt
)->(
m_dex
); }

51 
	gIt
& 
	gݔ
++()

53 
ASSERT
(
m_dex
 !
SegmtSize
);

54 ++
	gm_dex
;

55 i(
	gm_dex
 >
m_ve
.
m_gmts
.

(
m_gmt
)->
size
()) {

56 i(
m_gmt
 + 1 < 
m_ve
.
m_gmts
.
size
()) {

57 
ASSERT
(
m_ve
.
m_gmts
.

(
m_gmt
)->
size
() > 0);

58 ++
	gm_gmt
;

59 
	gm_dex
 = 0;

62 
	gm_gmt
 = 0;

63 
	gm_dex
 = 
SegmtSize
;

66  *
	gthis
;

69 
bo
 
	gݔ
==(cڡ 
It
& 
h
) const

71  
m_dex
 =
h
.m_dex && 
m_gmt
 =h.m_gm&& &
m_ve
 == &other.m_vector;

74 
bo
 
	gݔ
!=(cڡ 
It
& 
h
) const

76  
m_dex
 !
h
.m_dex || 
m_gmt
 !h.m_gm|| &
m_ve
 != &other.m_vector;

79 
	gSegmdVeIt
& 
	gݔ
=(cڡ 
SegmdVeIt
<
T
, 
	gSegmtSize
, 
	gIƚeCacy
>& 
	gh
)

81 
	gm_ve
 = 
h
.
m_ve
;

82 
	gm_gmt
 = 
h
.
m_gmt
;

83 
	gm_dex
 = 
h
.
m_dex
;

84  *
	gthis
;

87 
	give
:

88 
SegmdVeIt
(
SegmdVe
<
T
, 
SegmtSize
, 
IƚeCacy
>& 
ve
, 
size_t
 
gmt
, size_
dex
)

89 : 
m_ve
(
ve
)

90 , 
m_gmt
(
gmt
)

91 , 
m_dex
(
dex
)

95 
	gSegmdVe
<
	gT
, 
	gSegmtSize
, 
	gIƚeCacy
>& 
	gm_ve
;

96 
size_t
 
	gm_gmt
;

97 
size_t
 
	gm_dex
;

105 
	gme
 <
tyme
 
	gT
, 
size_t
 
	gSegmtSize
, size_
	gIƚeCacy
>

106 as
	cSegmdVe
 {

107 
nd
 
ass
 
	gSegmdVeIt
<
	gT
, 
	gSegmtSize
, 
	gIƚeCacy
>;

108 
WTF_MAKE_NONCOPYABLE
(
SegmdVe
);

110 
	gpublic
:

111 
SegmdVeIt
<
	tT
, 
	tSegmtSize
, 
	tIƚeCacy
> 
	tIt
;

113 
SegmdVe
()

114 : 
m_size
(0)

118 ~
SegmdVe
()

120 
deASegmts
();

123 
size_t
 
size
(cڡ {  
	gm_size
; }

124 
bo
 
isEmy
(cڡ {  !
size
(); }

126 
	gT
& 

(
size_t
 
dex
)

128  
gmtF
(
dex
)->

(
substF
(index));

131 cڡ 
	gT
& 

(
size_t
 
dex
) const

133  
	gcڡ_
<
	gSegmdVe
<
	gT
, 
	gSegmtSize
, 
	gIƚeCacy
>*>(
	gthis
)->

(
dex
);

136 
	gT
& 
	gݔ
[](
size_t
 
	gdex
)

138  

(
dex
);

141 cڡ 
	gT
& 
	gݔ
[](
size_t
 
	gdex
) const

143  

(
dex
);

146 
	gT
& 
ϡ
()

148  

(
size
() - 1);

151 
	gme
 <
tyme
 
	gU
> 
nd
(
U
&& 
vue
)

153 ++
	gm_size
;

155 i(!
gmtExisF
(
m_size
 - 1))

156 
	gm_gmts
.
nd
(
w
 
Segmt
);

157 
gmtF
(
m_size
 - 1)->
uncheckedAd
(
d
::
fwd
<
U
>(
vue
));

160 
	gme
<
	gtyme
... 
	gArgs
>

161 
	gT
& 
loc
(
Args
... 
gs
)

163 
	gnd
<
	gT
>(
T
(
gs
...));

164  
ϡ
();

167 
moveLa
()

169 
gmtF
(
m_size
 - 1)->
moveLa
();

170 --
	gm_size
;

173 
grow
(
size_t
 
size
)

175 
ASSERT
(
size
 > 
m_size
);

176 
suSegmtsF
(
size
);

177 
	gm_size
 = 
size
;

180 
r
()

182 
deASegmts
();

183 
	gm_gmts
.
r
();

184 
	gm_size
 = 0;

187 
It
 
beg
()

189  
It
(*
this
, 0, 
m_size
 ? 0 : 
SegmtSize
);

192 
It
 
d
()

194  
It
(*
this
, 0, 
SegmtSize
);

197 
shrkToF
()

199 
	gm_gmts
.
shrkToF
();

202 
	give
:

203 
Ve
<
	tT
, 
	tSegmtSize
> 
	tSegmt
;

205 
deASegmts
()

207 
size_t
 
	gi
 = 0; i < 
	gm_gmts
.
size
(); i++)

208 
de
 
	gm_gmts
[
i
];

211 
bo
 
gmtExisF
(
size_t
 
dex
)

213  
	gdex
 / 
	gSegmtSize
 < 
	gm_gmts
.
size
();

216 
Segmt
* 
gmtF
(
size_t
 
dex
)

218  
	gm_gmts
[
dex
 / 
SegmtSize
];

221 
size_t
 
substF
(size_
dex
)

223  
	gdex
 % 
	gSegmtSize
;

226 
suSegmtsF
(
size_t
 
size
)

228 
size_t
 
	ggmtCou
 = (
m_size
 + 
SegmtSize
 - 1) / SegmentSize;

229 
size_t
 
	gededSegmtCou
 = (
size
 + 
SegmtSize
 - 1) / SegmentSize;

232 
size_t
 
	gd
 = 
ededSegmtCou
 - 1;

233 
size_t
 
	gi
 = 
gmtCou
 ? segmtCou - 1 : 0; i < 
	gd
; ++i)

234 
suSegmt
(
i
, 
SegmtSize
);

237 
suSegmt
(
d
, 
substF
(
size
 - 1) + 1);

240 
suSegmt
(
size_t
 
gmtIndex
, size_
size
)

242 
ASSERT_WITH_SECURITY_IMPLICATION
(
gmtIndex
 <
m_gmts
.
size
());

243 i(
	ggmtIndex
 =
m_gmts
.
size
())

244 
m_gmts
.
nd
(
w
 
Segmt
);

245 
	gm_gmts
[
gmtIndex
]->
grow
(
size
);

248 
size_t
 
	gm_size
;

249 
	gVe
<
	gSegmt
*> 
	gm_gmts
;

254 
usg
 
	gWTF
::
SegmdVe
;

	@SentinelLinkedList.h

37 #ide
StLkedLi_h


38 
	#StLkedLi_h


	)

40 
mea
 
	gWTF
 {

42 
	eStTag
 { 
	gSt
 };

44 
	gme
<
tyme
 
	gT
>

45 as
	cBasicRawStNode
 {

46 
	gpublic
:

47 
BasicRawStNode
(
StTag
)

48 : 
m_xt
(0)

49 , 
m_ev
(0)

53 
BasicRawStNode
()

54 : 
m_xt
(0)

55 , 
m_ev
(0)

59 
tPv
(
BasicRawStNode
* 
ev
{ 
	gm_ev
 =rev; }

60 
tNext
(
BasicRawStNode
* 
xt
{ 
	gm_xt
 =ext; }

62 
T
* 
ev
({  
	gic_
<
	gT
*>(
	gm_ev
); }

63 
T
* 
xt
({  
	gic_
<
	gT
*>(
	gm_xt
); }

65 
bo
 
isOnLi
() const

67 
ASSERT
(!!
m_ev
 =!!
m_xt
);

68  !!
	gm_ev
;

71 
move
();

73 
	give
:

74 
BasicRawStNode
* 
m_xt
;

75 
BasicRawStNode
* 
	gm_ev
;

78 
	gme
 <
tyme
 
	gT
,ym
	gRawNode
 = 
T
> cs
	cStLkedLi
 {

79 
public
:

80 
T
* 
	t
;

82 
StLkedLi
();

84 
push
(
T
*);

85 
move
(
T
*);

87 
bo
 
isOnLi
(
T
*);

89 

 
beg
();

90 

 
d
();

92 
bo
 
isEmy
({  
beg
(=
d
(); }

94 
	give
:

95 
RawNode
 
m_hdSt
;

96 
RawNode
 
	gm_St
;

99 
	gme
 <
tyme
 
	gT
> 
	gBasicRawStNode
<T>::
	$move
()

101 
StLkedLi
<
T
, 
BasicRawStNode
<T>>::
	`move
(
ic_
<T*>(
this
));

102 
	}
}

104 
	gme
 <
tyme
 
	gT
,ym
	gRawNode
> 
le
 
	gStLkedLi
<T, RawNode>::
	$StLkedLi
()

105 : 
	`m_hdSt
(
St
)

106 , 
	$m_St
(
St
)

108 
m_hdSt
.
	`tNext
(&
m_St
);

109 
m_hdSt
.
	`tPv
(0);

111 
m_St
.
	`tPv
(&
m_hdSt
);

112 
m_St
.
	`tNext
(0);

113 
	}
}

115 
	gme
 <
tyme
 
	gT
,ym
	gRawNode
> 
le
ym
	gStLkedLi
<T, RawNode>::

 
StLkedLi
<
T
, RawNode>::
	$beg
()

117  
ic_
<
T
*>(
m_hdSt
.
	`xt
());

118 
	}
}

120 
	gme
 <
tyme
 
	gT
,ym
	gRawNode
> 
le
ym
	gStLkedLi
<T, RawNode>::

 
StLkedLi
<
T
, RawNode>::
	$d
()

122  
ic_
<
T
*>(&
m_St
);

123 
	}
}

125 
	gme
 <
tyme
 
	gT
,ym
	gRawNode
> 
le
 
	gStLkedLi
<T, RawNode>::
	$push
(
T
* 
node
)

127 
	`ASSERT
(
node
);

128 
	`ASSERT
(!
node
->
	`ev
());

129 
	`ASSERT
(!
node
->
	`xt
());

131 
RawNode
* 
ev
 = &
m_hdSt
;

132 
RawNode
* 
xt
 = 
m_hdSt
.
	`xt
();

134 
node
->
	`tPv
(
ev
);

135 
node
->
	`tNext
(
xt
);

137 
ev
->
	`tNext
(
node
);

138 
xt
->
	`tPv
(
node
);

139 
	}
}

141 
	gme
 <
tyme
 
	gT
,ym
	gRawNode
> 
le
 
	gStLkedLi
<T, RawNode>::
	$move
(
T
* 
node
)

143 
	`ASSERT
(
node
);

144 
	`ASSERT
(!!
node
->
	`ev
());

145 
	`ASSERT
(!!
node
->
	`xt
());

147 
RawNode
* 
ev
 = 
node
->
	`ev
();

148 
RawNode
* 
xt
 = 
node
->
	`xt
();

150 
ev
->
	`tNext
(
xt
);

151 
xt
->
	`tPv
(
ev
);

153 
node
->
	`tPv
(0);

154 
node
->
	`tNext
(0);

155 
	}
}

157 
	gme
 <
tyme
 
	gT
,ym
	gRawNode
> 
le
 
bo
 
	gStLkedLi
<T, RawNode>::
	$isOnLi
(
T
* 
node
)

159 i(!
node
->
	`isOnLi
())

160  
l
;

162 
T
* 

 = 
	`beg
(); i!
	`d
(); i->
	`xt
()) {

163 i(

 =
node
)

164  
ue
;

167  
l
;

168 
	}
}

172 
usg
 
	gWTF
::
BasicRawStNode
;

173 
usg
 
	gWTF
::
StLkedLi
;

	@SimpleStats.h

26 #ide
SimeSts_h


27 
	#SimeSts_h


	)

29 
	~<wtf/MhExas.h
>

30 
	~<wtf/StdLibExas.h
>

32 
mea
 
	gWTF
 {

36 as
	cSimeSts
 {

37 
	gpublic
:

38 
SimeSts
()

39 : 
m_cou
(0)

40 , 
m_sum
(0)

41 , 
m_sumOfSques
(0)

45 
add
(
vue
)

47 
	gm_cou
++;

48 
	gm_sum
 +
vue
;

49 
	gm_sumOfSques
 +
vue
 * value;

52 
bo
 
	gݔ
!() const

54  !
	gm_cou
;

57 
cou
() const

59  
	gm_cou
;

62 
sum
() const

64  
	gm_sum
;

67 
sumOfSques
() const

69  
	gm_sumOfSques
;

72 
mn
() const

74  
	gm_sum
 / 
	gm_cou
;

80 
vn
() const

82 i(
	gm_cou
 < 2)

86 
	gcdMomt
 = 
m_sumOfSques
 / 
m_cou
;

87 
	gfMomt
 = 
m_sum
 / 
m_cou
;

89 
	gsu
 = 
cdMomt
 - 
fMomt
 * firstMoment;

93 i(
	gsu
 <= 0)

96  
	gsu
;

100 
ddDevti
() const

102  
sq
(
vn
());

105 
	give
:

106 
m_cou
;

107 
	gm_sum
;

108 
	gm_sumOfSques
;

	@SinglyLinkedList.h

26 #ide
SglyLkedLi_h


27 
	#SglyLkedLi_h


	)

29 
mea
 
	gWTF
 {

31 
	gme
 <
tyme
 
	gNode
> cs
	cSglyLkedLi
 {

32 
	gpublic
:

33 
SglyLkedLi
();

35 
bo
 
isEmy
();

37 
push
(
Node
*);

38 
Node
* 
p
();

40 
	give
:

41 
Node
* 
m_hd
;

44 
	gme
 <
tyme
 
	gNode
> 
le
 
	gSglyLkedLi
<Node>::
	$SglyLkedLi
()

45 : 
	$m_hd
(0)

47 
	}
}

49 
me
 <
tyme
 
Node
> 
le
 
bo
 
SglyLkedLi
<Node>::
	$isEmy
()

51  !
m_hd
;

52 
	}
}

54 
	gme
 <
tyme
 
	gNode
> 
le
 
	gSglyLkedLi
<Node>::
	$push
(
Node
* 
node
)

56 
	`ASSERT
(
node
);

57 
node
->
	`tNext
(
m_hd
);

58 
m_hd
 = 
node
;

59 
	}
}

61 
	gme
 <
tyme
 
	gNode
> 
le
 
Node
* 
	gSglyLkedLi
<Node>::
	$p
()

63 
Node
* 
tmp
 = 
m_hd
;

64 
m_hd
 = m_hd->
	`xt
();

65  
tmp
;

66 
	}
}

70 
usg
 
	gWTF
::
SglyLkedLi
;

	@SixCharacterHash.cpp

26 
	~"cfig.h
"

27 
	~"SixChaHash.h
"

29 
	~<wtf/StdLibExas.h
>

31 
	~<rg.h
>

33 
mea
 
	gWTF
 {

35 
	#TABLE
 ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnqruvwxyz0123456789")

	)

37 
sixChaHashSgToIeg
(cڡ * 
rg
)

39 
	ghash
 = 0;

41 
RELEASE_ASSERT
(

(
rg
) == 6);

43 
	gi
 = 0; i < 6; ++i) {

44 
	ghash
 *= 62;

45 
	gc
 = 
rg
[
i
];

46 i(
	gc
 >'A' && 
c
 <= 'Z') {

47 
hash
 +
c
 - 'A';

50 i(
	gc
 >'a' && 
c
 <= 'z') {

51 
hash
 +
c
 - 'a' + 26;

54 
ASSERT
(
c
 >= '0' && c <= '9');

55 
	ghash
 +
c
 - '0' + 26 * 2;

58  
	ghash
;

61 
	gd
::
y
<, 7> 
gToSixChaHashSg
(
hash
)

63 
ic_as
(
WTF_ARRAY_LENGTH
(
TABLE
) - 1 == 62, "Six character hashable isot 62 charactersong.");

65 
	gd
::
y
<, 7> 
	gbufr
;

66 
	gaccumut
 = 
hash
;

67 
	gi
 = 6; i--;) {

68 
	gbufr
[
i
] = 
TABLE
[
accumut
 % 62];

69 
	gaccumut
 /= 62;

71 
	gbufr
[6] = 0;

72  
	gbufr
;

	@SixCharacterHash.h

26 #ide
SixChaHash_h


27 
	#SixChaHash_h


	)

29 
	~<y
>

31 
mea
 
	gWTF
 {

36 
WTF_EXPORT_PRIVATE
 
sixChaHashSgToIeg
(const *);

40 
WTF_EXPORT_PRIVATE
 
	gd
::
y
<, 7> 
gToSixChaHashSg
();

44 
usg
 
	gWTF
::
sixChaHashSgToIeg
;

45 
usg
 
	gWTF
::
gToSixChaHashSg
;

	@SizeLimits.cpp

31 
	~"cfig.h
"

33 
	~<ty_as
>

34 
	~<uty
>

35 
	~<wtf/Asis.h
>

36 
	~<wtf/OwnP.h
>

37 
	~<wtf/PassRefP.h
>

38 
	~<wtf/RefCoued.h
>

39 
	~<wtf/RefP.h
>

40 
	~<wtf/Ve.h
>

42 
mea
 
	gWTF
 {

44 #ide
NDEBUG


45 
	sSameSizeAsRefCoued
 {

46 
	ga
;

47 
bo
 
	gb
;

48 
bo
 
	gc
;

52 
	sSameSizeAsRefCoued
 {

53 
	ga
;

57 
	gme
<
tyme
 
	gT
, 
	gleCacy
 = 0>

58 
SameSizeAsVeWhIƚeCacy
;

60 
	gme
<
tyme
 
	gT
>

61 
	gSameSizeAsVeWhIƚeCacy
<
	gT
, 0> {

62 * 
	gbufrPor
;

63 
	gcy
;

64 
	gsize
;

67 
	gme
<
tyme
 
	gT
, 
	gleCacy
>

68 
	sSameSizeAsVeWhIƚeCacy
 {

69 
	gSameSizeAsVeWhIƚeCacy
<
	gT
, 0> 
	gbaCacy
;

70 
tyme
 
	gd
::
igd_age
<(
T
), std::
ignmt_of
<T>::
vue
>::
ty
 
leBufr
[
leCacy
];

73 
ic_as
((
OwnP
<>) == (*), "OwnPtr should stay small!");

74 
ic_as
((
PassRefP
<
RefCoued
<>>) == (*), "PassRefPtr should stay small!");

75 
ic_as
((
RefCoued
<>=(
SameSizeAsRefCoued
), "RefCounted should stay small!");

76 
ic_as
((
RefP
<
RefCoued
<>>) == (*), "RefPtr should stay small!");

77 
ic_as
((
Ve
<>=(
SameSizeAsVeWhIƚeCacy
<>), "Vector should stay small!");

78 
ic_as
((
Ve
<, 1>=(
SameSizeAsVeWhIƚeCacy
<, 1>), "Vector should stay small!");

79 
ic_as
((
Ve
<, 2>=(
SameSizeAsVeWhIƚeCacy
<, 2>), "Vector should stay small!");

80 
ic_as
((
Ve
<, 3>=(
SameSizeAsVeWhIƚeCacy
<, 3>), "Vector should stay small!");

	@Spectrum.h

26 #ide
Srum_h


27 
	#Srum_h


	)

29 
	~<wtf/HashM.h
>

30 
	~<wtf/Ve.h
>

31 
	~<gܙhm
>

33 
mea
 
	gWTF
 {

35 
	gme
<
tyme
 
	gT
,ym
	gCouTy
 = >

36 as
	cSrum
 {

37 
public
:

38 
tyme
 
	tHashM
<
	tT
, 
	tCouTy
>::
	t
 iterator;

39 
tyme
 
	tHashM
<
	tT
, 
	tCouTy
>::
	tcڡ_
 const_iterator;

41 
Srum
() { }

43 
add
(cڡ 
T
& 
key
, 
CouTy
 
cou
 = 1)

45 i(!
cou
)

47 
tyme
 
	gHashM
<
	gT
, 
	gCouTy
>::
AddResu
 
su
 = 
m_m
.
add
(
key
, 
cou
);

48 i(!
	gsu
.
	gisNewEry
)

49 
	gsu
.
	g
->
	gvue
 +
cou
;

52 
	gme
<
tyme
 
	gU
>

53 
addA
(cڡ 
Srum
<
T
, 
U
>& 
hSrum
)

55 auto& 
	gy
 : 
hSrum
)

56 
add
(
y
.
key
,ry.
cou
);

59 
CouTy
 
g
(cڡ 
T
& 
key
) const

61 
cڡ_
 
	g
 = 
m_m
.
fd
(
key
);

62 i(
	g
 =
m_m
.
d
())

64  
	g
->
	gvue
;

67 
size_t
 
size
(cڡ {  
	gm_m
.size(); }

69 

 
beg
({  
	gm_m
.begin(); }

70 

 
d
({  
	gm_m
.end(); }

71 
cڡ_
 
beg
(cڡ {  
	gm_m
.begin(); }

72 
cڡ_
 
d
(cڡ {  
	gm_m
.end(); }

74 
	sKeyAndCou
 {

75 
KeyAndCou
() { }

77 
KeyAndCou
(cڡ 
T
& 
key
, 
CouTy
 
cou
)

78 : 
key
(key)

79 , 
cou
(count)

83 
bo
 
	gݔ
<(cڡ 
	gKeyAndCou
& 
	gh
) const

85 i(
	gcou
 !
h
.
cou
)

86  
cou
 < 
h
.count;

90  
	gkey
 > 
	gh
.key;

93 
T
 
	gkey
;

94 
CouTy
 
	gcou
;

98 
	gVe
<
	gKeyAndCou
> 
budLi
() const

100 
	gVe
<
	gKeyAndCou
> 
	gli
;

101 
cڡ_
 
	g
 = 
beg
(); i!
d
(); ++iter)

102 
	gli
.
nd
(
KeyAndCou
(

->
key
, ir->
vue
));

104 
	gd
::
st
(
li
.
beg
(),i.
d
());

105  
	gli
;

108 
r
({ 
	gm_m
.clear(); }

110 
	gme
<
tyme
 
	gFun
>

111 
moveIf
(cڡ 
Fun
& 
fun
)

113 
	gm_m
.
moveIf
([&
fun
] (
tyme
 
HashM
<
T
, 
CouTy
>::
KeyVuePaTy
& 

) {

114  
fun
(
KeyAndCou
(

.
key
,a.
vue
));

118 
	give
:

119 
HashM
<
T
, 
	gCouTy
> 
	gm_m
;

124 
usg
 
	gWTF
::
Srum
;

	@StackBounds.cpp

21 
	~"cfig.h
"

22 
	~"SckBounds.h
"

24 #i
OS
(
DARWIN
)

26 
	~<mach/sk.h
>

27 
	~<mach/thad_a.h
>

28 
	~<had.h
>

30 #i
OS
(
WINDOWS
)

32 
	~<wdows.h
>

34 #i
OS
(
SOLARIS
)

36 
	~<thad.h
>

38 #i
OS
(
UNIX
)

40 
	~<had.h
>

41 #i
HAVE
(
PTHREAD_NP_H
)

42 
	~<had_.h
>

47 
mea
 
	gWTF
 {

49 #i
OS
(
DARWIN
)

51 
	gSckBounds
::
lize
()

53 
had_t
 
thad
 = 
had_lf
();

54 
	gm_ig
 = 
had_g_ackaddr_
(
thad
);

55 
im_t
 
	gsize
 = 0;

56 i(
had_ma_
()) {

59 
im
 
	glim
;

60 
gim
(
RLIMIT_STACK
, &
lim
);

61 
	gsize
 = 
lim
.
im_cur
;

63 
	gsize
 = 
had_g_acksize_
(
thad
);

65 
	gm_bound
 = 
ic_
<*>(
m_ig
- 
size
;

68 #i
OS
(
SOLARIS
)

70 
	gSckBounds
::
lize
()

72 
ack_t
 
s
;

73 
thr_kgmt
(&
s
);

74 
	gm_ig
 = 
s
.
ss_
;

75 
	gm_bound
 = 
ic_
<*>(
m_ig
- 
s
.
ss_size
;

78 #i
OS
(
OPENBSD
)

80 
	gSckBounds
::
lize
()

82 
had_t
 
thad
 = 
had_lf
();

83 
ack_t
 
	gack
;

84 
had_ackg_
(
thad
, &
ack
);

85 
	gm_ig
 = 
ack
.
ss_
;

86 #i
CPU
(
HPPA
)

87 
	gm_bound
 = 
ic_
<*>(
m_ig
+ 
ack
.
ss_size
;

89 
	gm_bound
 = 
ic_
<*>(
m_ig
- 
ack
.
ss_size
;

93 #i
OS
(
UNIX
)

95 
	gSckBounds
::
lize
()

97 * 
ackBa
 = 0;

98 
size_t
 
	gackSize
 = 0;

100 
had_t
 
	gthad
 = 
had_lf
();

101 
had__t
 
	gr
;

102 
had__
(&
r
);

103 #i
HAVE
(
PTHREAD_NP_H
|| 
OS
(
NETBSD
)

105 
had__g_
(
thad
, &
r
);

108 
had_g_
(
thad
, &
r
);

110 
	grc
 = 
had__gack
(&
r
, &
ackBa
, &
ackSize
);

111 ()
	grc
;

112 
ASSERT
(
ackBa
);

113 
had__deroy
(&
r
);

114 
	gm_bound
 = 
ackBa
;

115 
	gm_ig
 = 
ic_
<*>(
ackBa
+ 
ackSize
;

118 #i
OS
(
WINDOWS
)

120 
	gSckBounds
::
lize
()

122 
MEMORY_BASIC_INFORMATION
 
ackOrig
 = { 0 };

123 
VtuQuy
(&
ackOrig
, &stackOrigin, (stackOrigin));

126 
	gm_ig
 = 
ic_
<*>(
ackOrig
.
BaAddss
+ sckOrig.
RegiSize
;

142 
MEMORY_BASIC_INFORMATION
 
	guncommdMemy
;

143 
VtuQuy
(
ackOrig
.
AotiBa
, &
uncommdMemy
, (uncommittedMemory));

144 
ASSERT
(
uncommdMemy
.
S
 =
MEM_RESERVE
);

146 
MEMORY_BASIC_INFORMATION
 
	ggudPage
;

147 
VtuQuy
(
ic_
<*>(
uncommdMemy
.
BaAddss
+ uncommdMemy.
RegiSize
, &
gudPage
, (guardPage));

148 
ASSERT
(
gudPage
.
Pre
 & 
PAGE_GUARD
);

150 * 
	gdOfSck
 = 
ackOrig
.
AotiBa
;

152 #ide
NDEBUG


153 
MEMORY_BASIC_INFORMATION
 
	gcommdMemy
;

154 
VtuQuy
(
ic_
<*>(
gudPage
.
BaAddss
+ gudPage.
RegiSize
, &
commdMemy
, (committedMemory));

155 
ASSERT
(
commdMemy
.
S
 =
MEM_COMMIT
);

157 * 
	gcompudEnd
 = 
ic_
<*>(
m_ig
- (
uncommdMemy
.
RegiSize
 + 
gudPage
.RegiSiz+ 
commdMemy
.RegionSize);

159 
ASSERT
(
ackOrig
.
AotiBa
 =
uncommdMemy
.AllocationBase);

160 
ASSERT
(
ackOrig
.
AotiBa
 =
gudPage
.AllocationBase);

161 
ASSERT
(
ackOrig
.
AotiBa
 =
commdMemy
.AllocationBase);

162 
ASSERT
(
ackOrig
.
AotiBa
 =
uncommdMemy
.
BaAddss
);

163 
ASSERT
(
dOfSck
 =
compudEnd
);

165 
	gm_bound
 = 
ic_
<*>(
dOfSck
+ 
gudPage
.
RegiSize
;

169 #r 
Nd
 
a
 
way
 
to
 
g
 
the
 
ack
 
bounds
 

 
this
 
fm


	@StackBounds.h

27 #ide
SckBounds_h


28 
	#SckBounds_h


	)

30 
	~<gܙhm
>

32 
mea
 
	gWTF
 {

34 as
	cSckBounds
 {

40 cڡ 
size_t
 
	gs_deuAvaabyD
 = 64 * 1024;

42 
	gpublic
:

43 
SckBounds
 
cutThadSckBounds
()

45 
SckBounds
 
bounds
;

46 
	gbounds
.
lize
();

47 
	gbounds
.
checkCsicy
();

48  
	gbounds
;

51 * 
ig
() const

53 
ASSERT
(
m_ig
);

54  
	gm_ig
;

57 
size_t
 
size
() const

59 i(
isGrowgDownwd
())

60  
	gic_
<*>(
	gm_ig
- stic_<*>(
	gm_bound
);

61  
	gic_
<*>(
	gm_bound
- stic_<*>(
	gm_ig
);

64 * 
cursiLim
(
size_t
 
mAvaabD
 = 
s_deuAvaabyD
) const

66 
checkCsicy
();

67 i(
isGrowgDownwd
())

68  
	gic_
<*>(
	gm_bound
+ 
	gmAvaabD
;

69  
	gic_
<*>(
	gm_bound
- 
	gmAvaabD
;

72 * 
cursiLim
(* 
tOfUrSck
, 
size_t
 
maxUrSck
, size_
rvedZeSize
) const

74 
checkCsicy
();

75 i(
	gmaxUrSck
 < 
	grvedZeSize
)

76 
	grvedZeSize
 = 
maxUrSck
;

77 
size_t
 
	gmaxUrSckWhRervedZe
 = 
maxUrSck
 - 
rvedZeSize
;

79 i(
isGrowgDownwd
()) {

80 * 
	gdOfSckWhRervedZe
 = 
t_
<*>(
m_bound
+ 
rvedZeSize
;

81 i(
	gtOfUrSck
 < 
	gdOfSckWhRervedZe
)

82  
	gdOfSckWhRervedZe
;

83 
size_t
 
	gavaabUrSck
 = 
tOfUrSck
 - 
dOfSckWhRervedZe
;

84 i(
	gmaxUrSckWhRervedZe
 > 
	gavaabUrSck
)

85 
	gmaxUrSckWhRervedZe
 = 
avaabUrSck
;

86  
	gtOfUrSck
 - 
	gmaxUrSckWhRervedZe
;

89 * 
	gdOfSckWhRervedZe
 = 
t_
<*>(
m_bound
- 
rvedZeSize
;

90 i(
	gtOfUrSck
 > 
	gdOfSckWhRervedZe
)

91  
	gdOfSckWhRervedZe
;

92 
size_t
 
	gavaabUrSck
 = 
dOfSckWhRervedZe
 - 
tOfUrSck
;

93 i(
	gmaxUrSckWhRervedZe
 > 
	gavaabUrSck
)

94 
	gmaxUrSckWhRervedZe
 = 
avaabUrSck
;

95  
	gtOfUrSck
 + 
	gmaxUrSckWhRervedZe
;

98 
bo
 
isGrowgDownwd
() const

100 
ASSERT
(
m_ig
 && 
m_bound
);

101  
	gue
;

104 
	give
:

105 
SckBounds
()

106 : 
m_ig
(0)

107 , 
m_bound
(0)

111 
WTF_EXPORT_PRIVATE
 
lize
();

113 
checkCsicy
() const

115 #i!
ASSERT_DISABLED


116 * 
	gcutPosi
 = &
cutPosi
;

117 
ASSERT
(
m_ig
 !
m_bound
);

118 
ASSERT
(
isGrowgDownwd
()

119 ? (
cutPosi
 < 
m_ig
 && cutPosi > 
m_bound
)

120 : (
cutPosi
 > 
m_ig
 && cutPosi < 
m_bound
));

124 * 
	gm_ig
;

125 * 
	gm_bound
;

127 
nd
 
ass
 
	gSckSts
;

132 
usg
 
	gWTF
::
SckBounds
;

	@StackStats.cpp

26 
	~"cfig.h
"

27 
	~"SckSts.h
"

29 #i
ENABLE
(
STACK_STATS
)

31 
	~"Asis.h
"

32 
	~"DaLog.h
"

33 
	~"WTFThadDa.h
"

39 
	#ENABLE_VERBOSE_STACK_STATS
 1

	)

42 
mea
 
	gWTF
 {

45 
	gd
::
mux
* 
SckSts
::
s_shedMux
 = 0;

46 
	gSckSts
::
CheckPot
* 
SckSts
::
s_tCheckPot
 = 0;

47 
	gSckSts
::
LayoutCheckPot
* 
SckSts
::
s_fLayoutCheckPot
 = 0;

48 
	gSckSts
::
LayoutCheckPot
* 
SckSts
::
s_tLayoutCheckPot
 = 0;

51 
	gSckSts
::
s_maxCheckPotDiff
 = 0;

52 
	gSckSts
::
s_maxSckHeight
 = 0;

53 
	gSckSts
::
s_maxRryDth
 = 0;

55 
	gSckSts
::
s_maxLayoutCheckPotDiff
 = 0;

56 
	gSckSts
::
s_maxTٮLayoutCheckPotDiff
 = 0;

57 
	gSckSts
::
s_maxLayoutRryDth
 = 0;

61 
	gSckSts
::
lize
()

63 
s_shedMux
 = 
d
::
make_unique
<d::
mux
>().
a
();

64 
daLogF
(" === LOGew stack stats ========\n");

67 
	gSckSts
::
PThadSts
::PerThreadStats()

69 cڡ 
SckBounds
& 
ack
 = 
wtfThadDa
().stack();

70 
	gm_yDth
 = 0;

71 
	gm_ackS
 = (*)
ack
.
ig
();

72 
	gm_cutCheckPot
 = 0;

74 
daLogF
(" ==THREADew sckS %========\n", 
m_ackS
);

77 
	gSckSts
::
CheckPot
::CheckPoint()

79 
d
::
lock_gud
<d::
mux
> 
lock
(*
SckSts
::
s_shedMux
);

80 
WTFThadDa
* 
	gthadDa
 = 
cڡ_
<WTFThadDa*>(&
wtfThadDa
());

81 
	gSckSts
::
PThadSts
& 
t
 = 
thadDa
->
ackSts
();

82 cڡ 
	gSckBounds
& 
	gack
 = 
thadDa
->
ack
();

84 
bo
 
	gisGrowgDownwd
 = 
ack
.
isGrowgDownwd
();

85 
bo
 
	gedToLog
 = 
l
;

86 * 
	gcut
 = 
t_
<*>(
this
);

87 * 
	gϡ
 = 
t_
<*>(
t
.
m_cutCheckPot
);

90 i(!
	gϡ
)

91 
	gϡ
 = 
t
.
m_ackS
;

94 
	gt
.
	gm_yDth
++;

95 i(
	gt
.
	gm_yDth
 > 
	gSckSts
::
s_maxRryDth
) {

96 
SckSts
::
s_maxRryDth
 = 
t
.
m_yDth
;

97 
	gedToLog
 = 
ue
;

101 
	gheight
 = 
t
.
m_ackS
 - 
cut
;

102 i(!
	gisGrowgDownwd
)

103 
	gheight
 = -
height
;

104 i(
	gheight
 > 
	gSckSts
::
s_maxSckHeight
) {

105 
SckSts
::
s_maxSckHeight
 = 
height
;

106 
	gedToLog
 = 
ue
;

110 
	gdiff
 = 
ϡ
 - 
cut
;

111 i(!
	gisGrowgDownwd
)

112 
	gdiff
 = -
diff
;

113 i(
	gdiff
 > 
	gSckSts
::
s_maxCheckPotDiff
) {

114 
SckSts
::
s_maxCheckPotDiff
 = 
diff
;

115 
	gedToLog
 = 
ue
;

119 
	gm_ev
 = 
t
.
m_cutCheckPot
;

120 
	gt
.
	gm_cutCheckPot
 = 
this
;

122 #i
ENABLE
(
VERBOSE_STACK_STATS
)

123 
	gedToLog
 = 
ue
;

127 i(
	gedToLog
)

128 
daLogF
(" CHECKPOINT %p diff %d/%.1fk/max %.1fk |eentry %d/max %d | height %.1fk/max %.1fk | stack %p size %.1fk\n",

129 
this
, 
diff
, dif/ 1024.0, 
SckSts
::
s_maxCheckPotDiff
 / 1024.0,

130 
t
.
m_yDth
, 
SckSts
::
s_maxRryDth
,

131 
height
 / 1024.0, 
SckSts
::
s_maxSckHeight
 / 1024.0,

132 
ack
.
ig
(), sck.
size
() / 1024.0);

135 
	gSckSts
::
CheckPot
::~CheckPoint()

137 
d
::
lock_gud
<d::
mux
> 
lock
(*
SckSts
::
s_shedMux
);

138 
WTFThadDa
* 
	gthadDa
 = 
cڡ_
<WTFThadDa*>(&
wtfThadDa
());

139 
	gSckSts
::
PThadSts
& 
t
 = 
thadDa
->
ackSts
();

142 
	gt
.
	gm_cutCheckPot
 = 
m_ev
;

143 --
	gt
.
	gm_yDth
;

146 #i
ENABLE
(
VERBOSE_STACK_STATS
)

147 i(!
	gm_ev
) {

148 cڡ 
	gSckBounds
& 
	gack
 = 
thadDa
->
ack
();

149 
bo
 
	gisGrowgDownwd
 = 
ack
.
isGrowgDownwd
();

151 * 
	gcut
 = 
t_
<*>(
this
);

152 
	gheight
 = 
t
.
m_ackS
 - 
cut
;

154 i(!
	gisGrowgDownwd
)

155 
	gheight
 = -
height
;

157 
daLogF
(" POPo %p diff max %.1fk |eentry %d/%d max | height %.1fk/max %.1fk | stack %p size %.1fk)\n",

158 
this
, 
SckSts
::
s_maxCheckPotDiff
 / 1024.0,

159 
t
.
m_yDth
, 
SckSts
::
s_maxRryDth
,

160 
height
 / 1024.0, 
SckSts
::
s_maxSckHeight
 / 1024.0,

161 
ack
.
ig
(), sck.
size
() / 1024.0);

166 
	gSckSts
::
obe
()

168 
d
::
lock_gud
<d::
mux
> 
lock
(*
SckSts
::
s_shedMux
);

169 
WTFThadDa
* 
	gthadDa
 = 
cڡ_
<WTFThadDa*>(&
wtfThadDa
());

170 
	gSckSts
::
PThadSts
& 
t
 = 
thadDa
->
ackSts
();

171 cڡ 
	gSckBounds
& 
	gack
 = 
thadDa
->
ack
();

173 
bo
 
	gisGrowgDownwd
 = 
ack
.
isGrowgDownwd
();

175 
bo
 
	gedToLog
 = 
l
;

177 
	gdummy
;

178 * 
	gcut
 = 
t_
<*>(&
dummy
);

179 * 
	gϡ
 = 
t_
<*>(
t
.
m_cutCheckPot
);

182 i(!
	gϡ
)

183 
	gϡ
 = 
t
.
m_ackS
;

189 
	gheight
 = 
t
.
m_ackS
 - 
cut
;

190 i(!
	gisGrowgDownwd
)

191 
	gheight
 = -
height
;

192 i(
	gheight
 > 
	gSckSts
::
s_maxSckHeight
) {

193 
SckSts
::
s_maxSckHeight
 = 
height
;

194 
	gedToLog
 = 
ue
;

198 
	gdiff
 = 
ϡ
 - 
cut
;

199 i(!
	gisGrowgDownwd
)

200 
	gdiff
 = -
diff
;

201 i(
	gdiff
 > 
	gSckSts
::
s_maxCheckPotDiff
) {

202 
SckSts
::
s_maxCheckPotDiff
 = 
diff
;

203 
	gedToLog
 = 
ue
;

206 #i
ENABLE
(
VERBOSE_STACK_STATS
)

207 
	gedToLog
 = 
ue
;

210 i(
	gedToLog
)

211 
daLogF
(" PROBE %p diff %d/%.1fk/max %.1fk |eentry %d/max %d | height %.1fk/max %.1fk | stack %p size %.1fk\n",

212 
cut
, 
diff
, dif/ 1024.0, 
SckSts
::
s_maxCheckPotDiff
 / 1024.0,

213 
t
.
m_yDth
, 
SckSts
::
s_maxRryDth
,

214 
height
 / 1024.0, 
SckSts
::
s_maxSckHeight
 / 1024.0,

215 
ack
.
ig
(), sck.
size
() / 1024.0);

218 
	gSckSts
::
LayoutCheckPot
::LayoutCheckPoint()

227 
SckSts
::
obe
();

229 
	gd
::
lock_gud
<
d
::
mux
> 
lock
(*
SckSts
::
s_shedMux
);

230 
WTFThadDa
* 
	gthadDa
 = 
cڡ_
<WTFThadDa*>(&
wtfThadDa
());

231 
	gSckSts
::
PThadSts
& 
t
 = 
thadDa
->
ackSts
();

232 cڡ 
	gSckBounds
& 
	gack
 = 
thadDa
->
ack
();

234 
bo
 
	gisGrowgDownwd
 = 
ack
.
isGrowgDownwd
();

237 
	gm_ev
 = 
SckSts
::
s_tLayoutCheckPot
;

238 i(
	gm_ev
)

239 
	gm_dth
 = 
m_ev
->
m_dth
 + 1;

241 
	gSckSts
::
s_fLayoutCheckPot
 = 
this
;

242 
	gm_dth
 = 0;

244 
	gSckSts
::
s_tLayoutCheckPot
 = 
this
;

247 * 
	gcut
 = 
t_
<*>(
this
);

248 * 
	gϡ
 = 
t_
<*>(
m_ev
);

249 * 
	gro
 = 
t_
<*>(
SckSts
::
s_fLayoutCheckPot
);

250 
bo
 
	gedToLog
 = 
l
;

252 
	gdiff
 = 
ϡ
 - 
cut
;

253 i(!
	gϡ
)

254 
	gdiff
 = 0;

255 
	gtٮDiff
 = 
ro
 - 
cut
;

256 i(!
	gro
)

257 
	gtٮDiff
 = 0;

260 
	gheight
 = 
t
.
m_ackS
 - 
cut
;

261 i(!
	gisGrowgDownwd
)

262 
	gheight
 = -
height
;

263 i(
	gheight
 > 
	gSckSts
::
s_maxSckHeight
) {

264 
SckSts
::
s_maxSckHeight
 = 
height
;

265 
	gedToLog
 = 
ue
;

269 i(!
	gisGrowgDownwd
)

270 
	gdiff
 = -
diff
;

271 i(
	gdiff
 > 
	gSckSts
::
s_maxLayoutCheckPotDiff
) {

272 
SckSts
::
s_maxLayoutCheckPotDiff
 = 
diff
;

273 
	gedToLog
 = 
ue
;

277 i(!
	gisGrowgDownwd
)

278 
	gtٮDiff
 = -
tٮDiff
;

279 i(
	gtٮDiff
 > 
	gSckSts
::
s_maxTٮLayoutCheckPotDiff
) {

280 
SckSts
::
s_maxTٮLayoutCheckPotDiff
 = 
tٮDiff
;

281 
	gedToLog
 = 
ue
;

284 #i
ENABLE
(
VERBOSE_STACK_STATS
)

285 
	gedToLog
 = 
ue
;

288 i(
	gedToLog
)

289 
daLogF
(" LAYOUT %p diff %d/%.1fk/max %.1fk |eentry %d/max %d | height %.1fk/max %.1fk | stack %p size %.1fk\n",

290 
cut
, 
diff
, dif/ 1024.0, 
SckSts
::
s_maxLayoutCheckPotDiff
 / 1024.0,

291 
m_dth
, 
SckSts
::
s_maxLayoutRryDth
,

292 
tٮDiff
 / 1024.0, 
SckSts
::
s_maxTٮLayoutCheckPotDiff
 / 1024.0,

293 
ack
.
ig
(), sck.
size
() / 1024.0);

296 
	gSckSts
::
LayoutCheckPot
::~LayoutCheckPoint()

298 
d
::
lock_gud
<d::
mux
> 
lock
(*
SckSts
::
s_shedMux
);

301 
	gSckSts
::
s_tLayoutCheckPot
 = 
m_ev
;

302 i(!
	gm_dth
)

303 
	gSckSts
::
s_fLayoutCheckPot
 = 0;

	@StackStats.h

26 #ide
SckSts_h


27 
	#SckSts_h


	)

29 
	~"ExptMaos.h
"

30 
	~<mux
>

43 
	#ENABLE_STACK_STATS
 0

	)

46 
mea
 
	gWTF
 {

48 #i!
ENABLE
(
STACK_STATS
)

50 as
	cSckSts
 {

51 
	gpublic
:

55 as
	cCheckPot
 {

56 
public
:

57 
CheckPot
() { }

60 as
	cPThadSts
 {

61 
	gpublic
:

62 
PThadSts
() { }

65 as
	cLayoutCheckPot
 {

66 
	gpublic
:

67 
LayoutCheckPot
() { }

70 
lize
() { }

71 
obe
() { }

76 as
	cSckSts
 {

77 
	gpublic
:

81 as
	cCheckPot
 {

82 
public
:

83 
CheckPot
();

84 ~
CheckPot
();

85 
	give
:

86 
CheckPot
* 
m_ev
;

89 as
	cPThadSts
 {

90 
	gpublic
:

91 
PThadSts
();

93 
	give
:

94 
m_yDth
;

95 * 
	gm_ackS
;

96 
CheckPot
* 
	gm_cutCheckPot
;

98 
nd
 
ass
 
	gCheckPot
;

99 
nd
 
ass
 
	gSckSts
;

102 as
	cLayoutCheckPot
 {

103 
	gpublic
:

104 
WTF_EXPORT_PRIVATE
 
LayoutCheckPot
();

105 
	gWTF_EXPORT_PRIVATE
 ~
LayoutCheckPot
();

107 
	give
:

108 
LayoutCheckPot
* 
m_ev
;

109 
	gm_dth
;

113 
lize
();

123 
obe
();

125 
	give
:

127 
d
::
mux
* 
s_shedMux
;

128 
CheckPot
* 
	gs_tCheckPot
;

129 
LayoutCheckPot
* 
	gs_fLayoutCheckPot
;

130 
LayoutCheckPot
* 
	gs_tLayoutCheckPot
;

133 
	gs_maxCheckPotDiff
;

134 
	gs_maxSckHeight
;

135 
	gs_maxRryDth
;

137 
	gs_maxLayoutCheckPotDiff
;

138 
	gs_maxTٮLayoutCheckPotDiff
;

139 
	gs_maxLayoutRryDth
;

141 
nd
 
ass
 
	gCheckPot
;

142 
nd
 
ass
 
	gLayoutCheckPot
;

149 
usg
 
	gWTF
::
SckSts
;

	@StaticConstructors.h

21 #ide
SticCڡrus_h


22 
	#SticCڡrus_h


	)

39 #ifde
SKIP_STATIC_CONSTRUCTORS_ON_MSVC


48 #agm
wng
(
dib
:4075)

49 #agm
_g
(".unwantedstaticinits")

52 #ide
SKIP_STATIC_CONSTRUCTORS_ON_GCC


54 
	#DEFINE_GLOBAL
(
ty
, 
me
, ...) \

55 cڡ 
ty
 
me
;

	)

60 
	#DEFINE_GLOBAL
(
ty
, 
me
, ...) \

61 * 
me
[((
ty
+ (*- 1/ (*)];

	)

	@StdLibExtras.h

27 #ide
WTF_StdLibExas_h


28 
	#WTF_StdLibExas_h


	)

30 
	~<chro
>

31 
	~<memy
>

32 
	~<wtf/Asis.h
>

33 
	~<wtf/CheckedArhmic.h
>

40 #ide
DEPRECATED_DEFINE_STATIC_LOCAL


41 #i
COMPILER
(
GCC
&& 
defed
(
__APPLE_CC__
&& 
__GNUC__
 =4 && 
__GNUC_MINOR__
 =0 && 
__GNUC_PATCHLEVEL__
 == 1

42 
	#DEPRECATED_DEFINE_STATIC_LOCAL
(
ty
, 
me
, 
gumts
) \

43 
ty
* 
me
##
P
 = 
w
y 
gumts
; \

44 
ty
& 
me
 = *me##
P


	)

46 
	#DEPRECATED_DEFINE_STATIC_LOCAL
(
ty
, 
me
, 
gumts
) \

47 
ty
& 
me
 = *
w
y 
gumts


	)

54 
	#DEFINE_GLOBAL_FOR_LOGGING
(
ty
, 
me
, 
gumts
) \

55 
	`_Pgma
("clang diagnosticush") \

56 
	`_Pgma
("clang diagnostic ignored \"-Wglobal-constructors\"") \

57 
	`_Pgma
("clang diagnostic ignored \"-Wexit-time-destructors\"") \

58 
ty
 
me
 
gumts
; \

59 
	`_Pgma
("g dgnoip")

	)

61 #ide
NDEBUG


62 #i
COMPILER
(
CLANG
)

63 
	#DEFINE_DEBUG_ONLY_GLOBAL
(
ty
, 
me
, 
gumts

	`DEFINE_GLOBAL_FOR_LOGGING
y,ame,rgumts)

	)

65 
	#DEFINE_DEBUG_ONLY_GLOBAL
(
ty
, 
me
, 
gumts
) \

66 
ty
 
me
 
gumts
;

	)

69 
	#DEFINE_DEBUG_ONLY_GLOBAL
(
ty
, 
me
, 
gumts
)

	)

75 
	#OBJECT_OFFSETOF
(
ass
, 
fld
(
t_
<
rdiff_t
>(&et_<ass*>(0x4000)->fld)- 0x4000)

	)

78 
	#STRINGIZE
(
exp
#exp

	)

79 
	#STRINGIZE_VALUE_OF
(
exp

	`STRINGIZE
xp)

	)

91 #i(
CPU
(
ARM
|| CPU(
MIPS
)&& 
COMPILER
(
GCC
)

92 
	gme
<
tyme
 
	gTy
>

93 
le
 
bo
 
	$isPorTyAlignmtOkay
(
Ty
* 
r
)

95  !(
t_
<
_t
>(
r
% 
	`__ignof__
(
Ty
));

96 
	}
}

98 
	gme
<
tyme
 
	gTyP
>

99 
le
 
TyP
 
	$t__r
(* 
r
)

101 
	`ASSERT
(
	`isPorTyAlignmtOkay
(
t_
<
TyP
>(
r
)));

102  
t_
<
TyP
>(
r
);

103 
	}
}

105 
	gme
<
tyme
 
	gTyP
>

106 
le
 
TyP
 
	$t__r
(cڡ * 
r
)

108 
	`ASSERT
(
	`isPorTyAlignmtOkay
(
t_
<
TyP
>(
r
)));

109  
t_
<
TyP
>(
r
);

110 
	}
}

112 
	gme
<
tyme
 
	gTy
>

113 
le
 
bo
 
	$isPorTyAlignmtOkay
(
Ty
*)

115  
ue
;

116 
	}
}

117 
	#t__r
 
t_


	)

120 
mea
 
	gWTF
 {

122 
	gme
<
tyme
 
	gT
>

123 
ALWAYS_INLINE
 
tyme
 
	gd
::
move_n
<
T
>::
ty
&& 
move
(T&& 
vue
)

125 
ic_as
(
d
::
is_lvue_n
<
T
>::
vue
, "T isotnvalueeference; move() is unnecessary.");

127 
usg
 
	gNRefQuifdTy
 = 
tyme
 
d
::
move_n
<
T
>::
ty
;

128 
ic_as
(!
d
::
is_cڡ
<
NRefQuifdTy
>::
vue
, "T is const qualified.");

129  
	gd
::
move
(
vue
);

132 cڡ 
size_t
 
	gKB
 = 1024;

133 cڡ 
size_t
 
	gMB
 = 1024 * 1024;

135 
le
 
bo
 
isPorAligd
(* 
p
)

137  !((
	g_t
)(
	gp
) & ((*) - 1));

140 
le
 
bo
 
is8ByAligd
(* 
p
)

142  !((
	gu_t
)(
	gp
) & (() - 1));

148 
	gme
<
tyme
 
	gToTy
,ym
	gFromTy
>

149 
le
 
ToTy
 
bwi_
(
FromTy
 
om
)

151 
ic_as
((
FromTy
=(
ToTy
), "bitwise_cast size of FromTypend ToType must bequal!");

153 
FromTy
 
	gom
;

154 
ToTy
 
	gto
;

155 } 
	gu
;

156 
	gu
.
	gom
 = 
om
;

157  
	gu
.
	gto
;

160 
	gme
<
tyme
 
	gToTy
,ym
	gFromTy
>

161 
le
 
ToTy
 
Ca
(
FromTy
 
vue
)

163 
ASSERT
(
isInBounds
<
ToTy
>(
vue
));

164  
	gic_
<
	gToTy
>(
	gvue
);

168 
le
 
size_t
 
bCou
(
bs
)

170 
	gbs
 = 
bs
 - ((bits >> 1) & 0x55555555);

171 
	gbs
 = (
bs
 & 0x33333333) + ((bits >> 2) & 0x33333333);

172  (((
	gbs
 + (bits >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24;

175 
le
 
size_t
 
bCou
(
ut64_t
 
bs
)

177  
bCou
(
ic_
<>(
bs
)) + bitCount(static_cast<>(bits >> 32));

181 
	gme
<
tyme
 
	gT
, 
size_t
 
	gSize
> (&
AayLgthHrFuni
(
T
 (&)[
Size
]))[Size];

183 #i
COMPILER
(
GCC
)

184 
	gme
<
tyme
 
	gT
> (&
AayLgthHrFuni
(
T
 (&)[0]))[0];

186 
	#WTF_ARRAY_LENGTH
(
y
(::
WTF
::
	`AayLgthHrFuni
׼ay))

	)

189 
le
 
size_t
 
roundUpToMuɝOf
(size_
divis
, size_
x
)

191 
ASSERT
(
divis
 && !(divisor & (divisor - 1)));

192 
size_t
 
	gmadMask
 = 
divis
 - 1;

193  (
	gx
 + 
	gmadMask
) & ~remainderMask;

196 
	gme
<
size_t
 
	gdivis
> 
le
 size_
roundUpToMuɝOf
(size_
x
)

198 
ic_as
(
divis
 && !(divisor & (divisor - 1)), "divisor must beower ofwo!");

199  
roundUpToMuɝOf
(
divis
, 
x
);

202 
	eBySrchMode
 {

203 
	gKeyMuBePInAay
,

204 
	gKeyMightNBePInAay
,

205 
	gRuAdjaEmtIfKeyIsNP


208 
	gme
<
tyme
 
	gAayEmtTy
,ym
	gKeyTy
,ym
	gAayTy
,ym
	gExaKey
, 
BySrchMode
 
	gmode
>

209 
le
 
AayEmtTy
* 
bySrchIm
(
AayTy
& 
y
, 
size_t
 
size
, 
KeyTy
 
key
, cڡ 
ExaKey
& 
exaKey
 = ExtractKey())

211 
size_t
 
offt
 = 0;

212 
	gsize
 > 1) {

213 
size_t
 
	gpos
 = (
size
 - 1) >> 1;

214 
KeyTy
 
	gv
 = 
exaKey
(&
y
[
offt
 + 
pos
]);

216 i(
	gv
 =
key
)

217  &
y
[
offt
 + 
pos
];

220 i(
	gkey
 < 
	gv
)

221 
	gsize
 = 
pos
;

224 
	gsize
 -(
pos
 + 1);

225 
	gofft
 +(
pos
 + 1);

228 
ASSERT
(
mode
 !
KeyMuBePInAay
 || 
size
);

231 i(
	gmode
 =
KeyMightNBePInAay
 && !
size
)

234 
AayEmtTy
* 
	gsu
 = &
y
[
offt
];

236 i(
	gmode
 =
KeyMightNBePInAay
 && 
key
 !
exaKey
(
su
))

239 i(
	gmode
 =
KeyMuBePInAay
) {

240 
ASSERT
(
size
 == 1);

241 
ASSERT
(
key
 =
exaKey
(
su
));

244  
	gsu
;

248 
	gme
<
tyme
 
	gAayEmtTy
,ym
	gKeyTy
,ym
	gAayTy
,ym
	gExaKey
>

249 
le
 
AayEmtTy
* 
bySrch
(
AayTy
& 
y
, 
size_t
 
size
, 
KeyTy
 
key
, 
ExaKey
 
exaKey
 = ExtractKey())

251  
bySrchIm
<
AayEmtTy
, 
KeyTy
, 
AayTy
, 
ExaKey
, 
KeyMuBePInAay
>(
y
, 
size
, 
key
, 
exaKey
);

255 
	gme
<
tyme
 
	gAayEmtTy
,ym
	gKeyTy
,ym
	gAayTy
,ym
	gExaKey
>

256 
le
 
AayEmtTy
* 
yBySrch
(
AayTy
& 
y
, 
size_t
 
size
, 
KeyTy
 
key
, 
ExaKey
 
exaKey
 = ExtractKey())

258  
bySrchIm
<
AayEmtTy
, 
KeyTy
, 
AayTy
, 
ExaKey
, 
KeyMightNBePInAay
>(
y
, 
size
, 
key
, 
exaKey
);

262 
	gme
<
tyme
 
	gAayEmtTy
,ym
	gKeyTy
,ym
	gAayTy
,ym
	gExaKey
>

263 
le
 
AayEmtTy
* 
oximeBySrch
(
AayTy
& 
y
, 
size_t
 
size
, 
KeyTy
 
key
, 
ExaKey
 
exaKey
 = ExtractKey())

265  
bySrchIm
<
AayEmtTy
, 
KeyTy
, 
AayTy
, 
ExaKey
, 
RuAdjaEmtIfKeyIsNP
>(
y
, 
size
, 
key
, 
exaKey
);

269 
	gme
<
tyme
 
	gAayEmtTy
,ym
	gKeyTy
,ym
	gAayTy
,ym
	gExaKey
>

270 
le
 
AayEmtTy
* 
bySrch
(cڡ 
AayTy
& 
y
, 
size_t
 
size
, 
KeyTy
 
key
, 
ExaKey
 
exaKey
 = ExtractKey())

272  
bySrchIm
<
AayEmtTy
, 
KeyTy
, 
AayTy
, 
ExaKey
, 
KeyMuBePInAay
>(
cڡ_
<AayTy&>(
y
), 
size
, 
key
, 
exaKey
);

274 
	gme
<
tyme
 
	gAayEmtTy
,ym
	gKeyTy
,ym
	gAayTy
,ym
	gExaKey
>

275 
le
 
AayEmtTy
* 
yBySrch
(cڡ 
AayTy
& 
y
, 
size_t
 
size
, 
KeyTy
 
key
, 
ExaKey
 
exaKey
 = ExtractKey())

277  
bySrchIm
<
AayEmtTy
, 
KeyTy
, 
AayTy
, 
ExaKey
, 
KeyMightNBePInAay
>(
cڡ_
<AayTy&>(
y
), 
size
, 
key
, 
exaKey
);

279 
	gme
<
tyme
 
	gAayEmtTy
,ym
	gKeyTy
,ym
	gAayTy
,ym
	gExaKey
>

280 
le
 
AayEmtTy
* 
oximeBySrch
(cڡ 
AayTy
& 
y
, 
size_t
 
size
, 
KeyTy
 
key
, 
ExaKey
 
exaKey
 = ExtractKey())

282  
bySrchIm
<
AayEmtTy
, 
KeyTy
, 
AayTy
, 
ExaKey
, 
RuAdjaEmtIfKeyIsNP
>(
cڡ_
<AayTy&>(
y
), 
size
, 
key
, 
exaKey
);

285 
	gme
<
tyme
 
	gVeTy
,ym
	gEmtTy
>

286 
le
 
IoBoundedVe
(
VeTy
& 
ve
, 
size_t
 
size
, cڡ 
EmtTy
& 
emt
, size_
dex
)

288 
size_t
 
	gi
 = 
size
; i-- > 
	gdex
 + 1;)

289 
	gve
[
i
] = 
ve
[i - 1];

290 
	gve
[
dex
] = 
emt
;

296 
WTF_EXPORT_PRIVATE
 
bo
 
isCompiThad
();

301 
	eNNuTag
 { 
	mNNu
 };

302 
le
 * 
ݔ
 
	$w
(
size_t
, 
NNuTag
, * 
loti
)

304 
	`ASSERT
(
loti
);

305  
loti
;

306 
	}
}

308 #i(
COMPILER
(
GCC
&& !COMPILER(
CLANG
&& !
GCC_VERSION_AT_LEAST
(4, 8, 1))

311 
mea
 
	gd
 {

312 
	gme
<
ass
 
	gT
> 
	sis_ivy_deruib
 {

313 cڡ 
bo
 
	gvue
 = 
d
::
has_ivl_deru
<
T
>::
vue
;

319 
mea
 
	gd
 {

321 #i!
defed
(
_MSC_VER
) || _MSC_VER < 1800

322 
	gme
<
ass
 
	gT
> 
	s_Unique_if
 {

323 
	gunique_r
<
	tT
> 
	t_Sg_obje
;

326 
	gme
<
ass
 
	gT
> 
	g_Unique_if
<T[]> {

327 
	gunique_r
<
	tT
[]> 
	t_Unknown_bound
;

330 
	gme
<
ass
 
	gT
, 
size_t
 
	gN
> 
	g_Unique_if
<T[
N
]> {

331 
	t_Known_bound
;

334 
	gme
<
ass
 
	gT
, 
	gass
... 
	gArgs
> 
le
 
tyme
 
	g_Unique_if
<T>::
_Sg_obje


335 
make_unique
(
Args
&&... 
gs
)

337  
unique_r
<
T
>(
w
 T(
d
::
fwd
<
Args
>(
gs
)...));

340 
	gme
<
ass
 
	gT
> 
le
 
tyme
 
	g_Unique_if
<T>::
_Unknown_bound


341 
make_unique
(
size_t
 
n
)

343 
tyme
 
	tmove_ex
<
	tT
>::
	tty
 
	tU
;

344  
	gunique_r
<
	gT
>(
w
 
	gU
[
n
]());

347 
	gme
<
ass
 
	gT
, 
	gass
... 
	gArgs
> 
tyme
 
	g_Unique_if
<T>::
_Known_bound


348 
make_unique
(
Args
&&...
de
;

354 
	gme
<
	gsize_t
... 
	gdexes
> 
	sdex_qu
 {

355 
size_t
 
size
({  ...(
	gdexes
); }

358 
	gme
<
size_t
 
	gcutIndex
, 
	gsize_t
...
	gdexes
> 
	gmake_dex_qu_hr
;

360 
	gme
<
	gsize_t
...
	gdexes
> 
	gmake_dex_qu_hr
<0, indexes...> {

361 
	gd
::
	tdex_qu
<
	tdexes
...> 
	tty
;

364 
	gme
<
size_t
 
	gcutIndex
, 
	gsize_t
...
	gdexes
> 
	smake_dex_qu_hr
 {

365 
tyme
 
	tmake_dex_qu_hr
<
	tcutIndex
 - 1, cutIndex - 1, 
	tdexes
...>::
	tty
ype;

368 
	gme
<
size_t
 
	gngth
> 
	gmake_dex_qu
 : 
public
 
make_dex_qu_hr
<
ngth
>::
ty
 { };

370 #i
COMPILER_SUPPORTS
(
CXX_USER_LITERALS
)

373 
mea
 
	gls
 {

374 
mea
 
	gchro_ls
 {

375 
CONSTEXPR
 
le
 
	gchro
::
cds
 
ݔ
"" 
_s
(
s
)

377  
chro
::
cds
(
ic_
<chro::cds::
p
>(
s
));

380 
CONSTEXPR
 
	gchro
::
mlicds
 
ݔ
"" 
_ms
(
ms
)

382  
chro
::
mlicds
(
ic_
<chro::mlicds::
p
>(
ms
));

389 
usg
 
	gWTF
::
KB
;

390 
usg
 
	gWTF
::
MB
;

391 
usg
 
	gWTF
::
isCompiThad
;

392 
usg
 
	gWTF
::
IoBoundedVe
;

393 
usg
 
	gWTF
::
isPorAligd
;

394 
usg
 
	gWTF
::
is8ByAligd
;

395 
usg
 
	gWTF
::
bySrch
;

396 
usg
 
	gWTF
::
yBySrch
;

397 
usg
 
	gWTF
::
oximeBySrch
;

398 
usg
 
	gWTF
::
bwi_
;

399 
usg
 
	gWTF
::
Ca
;

401 #i
COMPILER_SUPPORTS
(
CXX_USER_LITERALS
)

403 
usg
 
mea
 
	gd
::
ls
::
chro_ls
;

	@StreamBuffer.h

31 #ide
WTF_SmBufr_h


32 
	#WTF_SmBufr_h


	)

34 
	~<wtf/Deque.h
>

36 
mea
 
	gWTF
 {

38 
	gme
 <
tyme
 
	gT
, 
size_t
 
	gBlockSize
> cs
	cSmBufr
 {

39 
	give
:

40 
Ve
<
	tT
> 
	tBlock
;

41 
	gpublic
:

42 
SmBufr
()

43 : 
m_size
(0)

44 , 
m_adOfft
(0)

48 ~
SmBufr
()

52 
bo
 
isEmy
(cڡ {  !
size
(); }

54 
nd
(cڡ 
T
* 
da
, 
size_t
 
size
)

56 i(!
	gsize
)

59 
	gm_size
 +
size
;

60 
	gsize
) {

61 i(!
	gm_bufr
.
size
(|| m_bufr.
ϡ
()->size(=
BlockSize
)

62 
m_bufr
.
nd
(
d
::
make_unique
<
Block
>());

63 
size_t
 
	gndSize
 = 
d
::
m
(
BlockSize
 - 
m_bufr
.
ϡ
()->
size
(), size);

64 
	gm_bufr
.
ϡ
()->
nd
(
da
, 
ndSize
);

65 
	gda
 +
ndSize
;

66 
	gsize
 -
ndSize
;

72 
csume
(
size_t
 
size
)

74 
ASSERT
(
m_size
 >
size
);

75 i(!
	gm_size
)

78 
ASSERT
(
m_bufr
.
size
() > 0);

79 
ASSERT
(
m_adOfft
 + 
size
 <
m_bufr
.
f
()->size());

80 
	gm_adOfft
 +
size
;

81 
	gm_size
 -
size
;

82 i(
	gm_adOfft
 >
m_bufr
.
f
()->
size
()) {

83 
m_adOfft
 = 0;

84 
	gm_bufr
.
moveF
();

88 
size_t
 
size
(cڡ {  
	gm_size
; }

90 cڡ 
T
* 
fBlockDa
() const

92 i(!
	gm_size
)

94 
ASSERT
(
m_bufr
.
size
() > 0);

95  &
	gm_bufr
.
f
()->
da
()[
m_adOfft
];

98 
size_t
 
fBlockSize
() const

100 i(!
	gm_size
)

102 
ASSERT
(
m_bufr
.
size
() > 0);

103  
	gm_bufr
.
f
()->
size
(- 
	gm_adOfft
;

106 
	give
:

107 
size_t
 
m_size
;

108 
size_t
 
	gm_adOfft
;

109 
	gDeque
<
	gd
::
unique_r
<
Block
>> 
m_bufr
;

114 
usg
 
	gWTF
::
SmBufr
;

	@StringExtras.h

26 #ide
WTF_SgExas_h


27 
	#WTF_SgExas_h


	)

29 
	~<dg.h
>

30 
	~<dio.h
>

31 
	~<rg.h
>

33 #i
HAVE
(
STRINGS_H
)

34 
	~<rgs.h
>

37 #i
COMPILER
(
MSVC
)

40 
le
 
	$tf
(* 
bufr
, 
size_t
 
cou
, cڡ * 
fm
, ...)

42 
su
;

43 
va_li
 
gs
;

44 
	`va_t
(
gs
, 
fm
);

45 
su
 = 
	`_vtf
(
bufr
, 
cou
, 
fm
, 
gs
);

46 
	`va_d
(
gs
);

50 i(
cou
 > 0)

51 
bufr
[
cou
 - 1] = '\0';

53  
su
;

54 
	}
}

56 
le
 
	$wtf_vtf
(* 
bufr
, 
size_t
 
cou
, cڡ * 
fm
, 
va_li
 
gs
)

58 
su
 = 
	`_vtf
(
bufr
, 
cou
, 
fm
, 
gs
);

62 i(
cou
 > 0)

63 
bufr
[
cou
 - 1] = '\0';

65  
su
;

66 
	}
}

70 
	#vtf
(
bufr
, 
cou
, 
fm
, 
gs

	`wtf_vtf
(bufr, cou, fm,rgs)

	)

72 
le
 
	$cmp
(cڡ * 
s1
, cڡ * 
s2
, 
size_t
 
n
)

74  
	`_icmp
(
s1
, 
s2
, 
n
);

75 
	}
}

77 
le
 
	$rcmp
(cڡ * 
s1
, cڡ * 
s2
)

79  
	`_ricmp
(
s1
, 
s2
);

80 
	}
}

84 #i!
HAVE
(
STRNSTR
)

86 
le
 * 
	$r
(cڡ * 
bufr
, cڡ * 
rg
, 
size_t
 
bufrLgth
)

88 
size_t
 
rgLgth
 = 
	`
(
rg
);

89 i(
rgLgth
 == 0)

90  
cڡ_
<*>(
bufr
);

91 cڡ * 
t
 = 
bufr
; *&& s + 
rgLgth
 <buf+ 
bufrLgth
; start++) {

92 i(*
t
 =*
rg
 && 
	`cmp
(+ 1,g + 1, 
rgLgth
 - 1) == 0)

93  
cڡ_
<*>(
t
);

96 
	}
}

	@StringHashDumpContext.h

26 #ide
SgHashDumpCڋxt_h


27 
	#SgHashDumpCڋxt_h


	)

29 
	~<wtf/HashM.h
>

30 
	~<wtf/SixChaHash.h
>

31 
	~<wtf/StdLibExas.h
>

32 
	~<wtf/SgPrtSm.h
>

33 
	~<wtf/xt/CSg.h
>

35 
mea
 
	gWTF
 {

37 
	gme
<
tyme
 
	gT
>

38 as
	cSgHashDumpCڋxt
 {

39 
	gpublic
:

40 
SgHashDumpCڋxt
() { }

42 
CSg
 
gID
(cڡ 
T
* 
vue
)

44 
tyme
 
HashM
<cڡ 
T
*, 
	gCSg
>::

 

 = 
m_fwdM
.
fd
(
vue
);

45 i(
	g
 !
m_fwdM
.
d
())

46  

->
vue
;

48 
	ghashVue
 = 
toCSg
(*
vue
).
hash
(); ; hashValue++) {

49 
CSg
 
	gfuHash
 = 
gToSixChaHashSg
(
hashVue
).
da
();

51 
	gngth
 = 2;ength < 6; ++length) {

52 
CSg
 
	gshtHash
 = CSg(
fuHash
.
da
(), 
ngth
);

53 i(!
	gm_backwdM
.
cڏs
(
shtHash
)) {

54 
	gm_fwdM
.
add
(
vue
, 
shtHash
);

55 
	gm_backwdM
.
add
(
shtHash
, 
vue
);

56  
	gshtHash
;

62 
dumpBrf
(cڡ 
T
* 
vue
, 
PrtSm
& 
out
)

64 
	gvue
->
dumpBrf
(
out
, 
gID
(
vue
));

67 
CSg
 
brf
(cڡ 
T
* 
vue
)

69 
SgPrtSm
 
	gout
;

70 
dumpBrf
(
vue
, 
out
);

71  
	gout
.
toCSg
();

74 
bo
 
isEmy
(cڡ {  
	gm_fwdM
.isEmpty(); }

76 
dump
(
PrtSm
& 
out
, cڡ * 
efix
 = "") const

78 
out
.
t
(
efix
);

79 
	gT
::
dumpCڋxtHd
(
out
);

80 
	gout
.
t
("\n");

82 
	gVe
<
	gCSg
> 
	gkeys
;

83 
	gmaxKeySize
 = 0;

85 
tyme
 
	gHashM
<
	gCSg
, cڡ 
	gT
*>::
cڡ_
 

 = 
m_backwdM
.
beg
();

86 
	g
 !
m_backwdM
.
d
();

87 ++
	g
) {

88 
	gkeys
.
nd
(

->
key
);

89 
	gmaxKeySize
 = 
d
::
max
(
maxKeySize
, 
ic_
<>(
brf
(

->
vue
, ir->
key
).
ngth
()));

92 
	gd
::
st
(
keys
.
beg
(), keys.
d
());

94 
	gi
 = 0; i < 
	gkeys
.
size
(); ++i) {

95 cڡ 
T
* 
	gvue
 = 
m_backwdM
.
g
(
keys
[
i
]);

96 
	gout
.
t
(
efix
, " ");

97 
CSg
 
	gbrfSg
 = 
brf
(
vue
, 
keys
[
i
]);

98 
	gout
.
t
(
brfSg
);

99 
	gn
 = 
brfSg
.
ngth
(); < 
	gmaxKeySize
; ++n)

100 
	gout
.
t
(" ");

101 
	gout
.
t
(" = ", *
vue
, "\n");

105 
	gpublic
:

106 
CSg
 
brf
(cڡ 
T
* 
vue
, cڡ CSg& 
rg
)

108 
SgPrtSm
 
	gout
;

109 
	gvue
->
dumpBrf
(
out
, 
rg
);

110  
	gout
.
toCSg
();

113 
	gHashM
<cڡ 
	gT
*, 
	gCSg
> 
	gm_fwdM
;

114 
	gHashM
<
	gCSg
, cڡ 
	gT
*> 
	gm_backwdM
;

119 
usg
 
	gWTF
::
SgHashDumpCڋxt
;

	@StringHasher.h

22 #ide
WTF_SgHash_h


23 
	#WTF_SgHash_h


	)

25 
	~<unicode/utys.h
>

26 
	~<wtf/xt/LCh.h
>

28 
mea
 
	gWTF
 {

39 cڡ 
	grgHashgSVue
 = 0x9E3779B9U;

41 as
	cSgHash
 {

42 
	gpublic
:

43 cڡ 
agCou
 = 8;

45 
SgHash
()

46 : 
m_hash
(
rgHashgSVue
)

47 , 
m_hasPdgCha
(
l
)

48 , 
m_ndgCha
(0)

55 
addChasAssumgAligd
(
UCh
 
a
, UCh 
b
)

57 
ASSERT
(!
m_hasPdgCha
);

58 
	gm_hash
 +
a
;

59 
	gm_hash
 = (
m_hash
 << 16^ ((
b
 << 11) ^ m_hash);

60 
	gm_hash
 +
m_hash
 >> 11;

63 
addCha
(
UCh
 
cha
)

65 i(
	gm_hasPdgCha
) {

66 
	gm_hasPdgCha
 = 
l
;

67 
addChasAssumgAligd
(
m_ndgCha
, 
cha
);

71 
	gm_ndgCha
 = 
cha
;

72 
	gm_hasPdgCha
 = 
ue
;

75 
addChas
(
UCh
 
a
, UCh 
b
)

77 i(
	gm_hasPdgCha
) {

78 #i!
ASSERT_DISABLED


79 
	gm_hasPdgCha
 = 
l
;

81 
addChasAssumgAligd
(
m_ndgCha
, 
a
);

82 
	gm_ndgCha
 = 
b
;

83 #i!
ASSERT_DISABLED


84 
	gm_hasPdgCha
 = 
ue
;

89 
addChasAssumgAligd
(
a
, 
b
);

92 
	gme
<
tyme
 
	gT
, 
UCh
 
Cvr
(
T
)> 
addChasAssumgAligd
(cڡ T* 
da
, 
ngth
)

94 
ASSERT
(!
m_hasPdgCha
);

96 
bo
 
	gmad
 = 
ngth
 & 1;

97 
	gngth
 >>= 1;

99 
	gngth
--) {

100 
addChasAssumgAligd
(
Cvr
(
da
[0]), Converter(data[1]));

101 
	gda
 += 2;

104 i(
	gmad
)

105 
addCha
(
Cvr
(*
da
));

108 
	gme
<
tyme
 
	gT
> 
addChasAssumgAligd
(cڡ 
T
* 
da
, 
ngth
)

110 
	gaddChasAssumgAligd
<
	gT
, 
	gdeuCvr
>(
	gda
, 
	gngth
);

113 
	gme
<
tyme
 
	gT
, 
UCh
 
Cvr
(
T
)> 
addChasAssumgAligd
(cڡ T* 
da
)

115 
ASSERT
(!
m_hasPdgCha
);

117 
T
 
	ga
 = *
da
++) {

118 
T
 
b
 = *
da
++;

119 i(!
	gb
) {

120 
addCha
(
Cvr
(
a
));

123 
addChasAssumgAligd
(
Cvr
(
a
), Cvr(
b
));

127 
	gme
<
tyme
 
	gT
> 
addChasAssumgAligd
(cڡ 
T
* 
da
)

129 
	gaddChasAssumgAligd
<
	gT
, 
	gdeuCvr
>(
	gda
);

132 
	gme
<
tyme
 
	gT
, 
UCh
 
Cvr
(
T
)> 
addChas
(cڡ T* 
da
, 
ngth
)

134 i(
	gm_hasPdgCha
 && 
	gngth
) {

135 
	gm_hasPdgCha
 = 
l
;

136 
addChasAssumgAligd
(
m_ndgCha
, 
Cvr
(*
da
++));

137 --
	gngth
;

139 
	gaddChasAssumgAligd
<
	gT
, 
	gCvr
>(
	gda
, 
	gngth
);

142 
	gme
<
tyme
 
	gT
> 
addChas
(cڡ 
T
* 
da
, 
ngth
)

144 
	gaddChas
<
	gT
, 
	gdeuCvr
>(
	gda
, 
	gngth
);

147 
	gme
<
tyme
 
	gT
, 
UCh
 
Cvr
(
T
)> 
addChas
(cڡ T* 
da
)

149 i(
	gm_hasPdgCha
 && *
	gda
) {

150 
	gm_hasPdgCha
 = 
l
;

151 
addChasAssumgAligd
(
m_ndgCha
, 
Cvr
(*
da
++));

153 
	gaddChasAssumgAligd
<
	gT
, 
	gCvr
>(
	gda
);

156 
	gme
<
tyme
 
	gT
> 
addChas
(cڡ 
T
* 
da
)

158 
	gaddChas
<
	gT
, 
	gdeuCvr
>(
	gda
);

161 
hashWhT8BsMasked
() const

163 
	gsu
 = 
avcheBs
();

167 
	gsu
 &(1U << ((
su
* 8 - 
agCou
)) - 1;

173 i(!
	gsu
)

174 
	gsu
 = 0x80000000 >> 
agCou
;

176  
	gsu
;

179 
hash
() const

181 
	gsu
 = 
avcheBs
();

187 i(!
	gsu
)

188 
	gsu
 = 0x80000000;

190  
	gsu
;

193 
	gme
<
tyme
 
	gT
, 
UCh
 
Cvr
(
T
)> 
compuHashAndMaskT8Bs
(cڡ T* 
da
, 
ngth
)

195 
SgHash
 
	ghash
;

196 
	ghash
.
	gaddChasAssumgAligd
<
	gT
, 
	gCvr
>(
	gda
, 
	gngth
);

197  
	ghash
.
hashWhT8BsMasked
();

200 
	gme
<
tyme
 
	gT
, 
UCh
 
Cvr
(
T
)> 
compuHashAndMaskT8Bs
(cڡ T* 
da
)

202 
SgHash
 
	ghash
;

203 
	ghash
.
	gaddChasAssumgAligd
<
	gT
, 
	gCvr
>(
	gda
);

204  
	ghash
.
hashWhT8BsMasked
();

207 
	gme
<
tyme
 
	gT
> 
compuHashAndMaskT8Bs
(cڡ 
T
* 
da
, 
ngth
)

209  
	gcompuHashAndMaskT8Bs
<
	gT
, 
	gdeuCvr
>(
	gda
, 
	gngth
);

212 
	gme
<
tyme
 
	gT
> 
compuHashAndMaskT8Bs
(cڡ 
T
* 
da
)

214  
	gcompuHashAndMaskT8Bs
<
	gT
, 
	gdeuCvr
>(
	gda
);

217 
	gme
<
tyme
 
	gT
, 
UCh
 
Cvr
(
T
)> 
compuHash
(cڡ T* 
da
, 
ngth
)

219 
SgHash
 
	ghash
;

220 
	ghash
.
	gaddChasAssumgAligd
<
	gT
, 
	gCvr
>(
	gda
, 
	gngth
);

221  
	ghash
.
hash
();

224 
	gme
<
tyme
 
	gT
, 
UCh
 
Cvr
(
T
)> 
compuHash
(cڡ T* 
da
)

226 
SgHash
 
	ghash
;

227 
	ghash
.
	gaddChasAssumgAligd
<
	gT
, 
	gCvr
>(
	gda
);

228  
	ghash
.
hash
();

231 
	gme
<
tyme
 
	gT
> 
compuHash
(cڡ 
T
* 
da
, 
ngth
)

233  
	gcompuHash
<
	gT
, 
	gdeuCvr
>(
	gda
, 
	gngth
);

236 
	gme
<
tyme
 
	gT
> 
compuHash
(cڡ 
T
* 
da
)

238  
	gcompuHash
<
	gT
, 
	gdeuCvr
>(
	gda
);

241 
hashMemy
(cڡ * 
da
, 
ngth
)

246 
ASSERT
(!(
ngth
 % 2));

247  
	gcompuHashAndMaskT8Bs
<
	gUCh
>(
	gic_
<cڡ UCh*>(
	gda
), 
	gngth
 / (UChar));

250 
	gme
<
size_t
 
	gngth
> 
hashMemy
(cڡ * 
da
)

252 
ic_as
(!(
ngth
 % 2), "length must be multiple ofwo!");

253  
hashMemy
(
da
, 
ngth
);

256 
	give
:

257 
UCh
 
deuCvr
(UCh 
cha
)

259  
cha
;

262 
UCh
 
deuCvr
(
LCh
 
cha
)

264  
	gcha
;

267 
avcheBs
() const

269 
	gsu
 = 
m_hash
;

272 i(
	gm_hasPdgCha
) {

273 
	gsu
 +
m_ndgCha
;

274 
	gsu
 ^
su
 << 11;

275 
	gsu
 +
su
 >> 17;

279 
	gsu
 ^
su
 << 3;

280 
	gsu
 +
su
 >> 5;

281 
	gsu
 ^
su
 << 2;

282 
	gsu
 +
su
 >> 15;

283 
	gsu
 ^
su
 << 10;

285  
	gsu
;

288 
	gm_hash
;

289 
bo
 
	gm_hasPdgCha
;

290 
UCh
 
	gm_ndgCha
;

295 
usg
 
	gWTF
::
SgHash
;

	@StringPrintStream.cpp

26 
	~"cfig.h
"

27 
	~"SgPrtSm.h
"

29 
	~<dg.h
>

30 
	~<dio.h
>

31 
	~<wtf/FaMloc.h
>

32 
	~<wtf/SgExas.h
>

34 
mea
 
	gWTF
 {

36 
	gSgPrtSm
::
SgPrtSm
()

37 : 
m_bufr
(
m_leBufr
)

38 , 
m_xt
(0)

39 , 
m_size
((
m_leBufr
))

41 
	gm_bufr
[0] = 0;

44 
	gSgPrtSm
::~
SgPrtSm
()

46 i(
m_bufr
 =
m_leBufr
)

48 
Fe
(
m_bufr
);

51 
	gSgPrtSm
::
vtf
(cڡ * 
fm
, 
va_li
 
gLi
)

53 
ASSERT_WITH_SECURITY_IMPLICATION
(
m_xt
 < 
m_size
);

54 
ASSERT
(!
m_bufr
[
m_xt
]);

56 
va_li
 
	gfPassArgLi
;

57 
va_cy
(
fPassArgLi
, 
gLi
);

59 
	gnumbOfBysNInudgTmThWouldHaveBnWrn
 =

60 
vtf
(
m_bufr
 + 
m_xt
, 
m_size
 - m_xt, 
fm
, 
fPassArgLi
);

62 
	gnumbOfBysThWouldHaveBnWrn
 =

63 
numbOfBysNInudgTmThWouldHaveBnWrn
 + 1;

65 i(
	gm_xt
 + 
	gnumbOfBysThWouldHaveBnWrn
 <
m_size
) {

66 
m_xt
 +
numbOfBysNInudgTmThWouldHaveBnWrn
;

70 
Size
(
m_xt
 + 
numbOfBysThWouldHaveBnWrn
);

72 
	gnumbOfBysNInudgTmThWeWrn
 =

73 
vtf
(
m_bufr
 + 
m_xt
, 
m_size
 - m_xt, 
fm
, 
gLi
);

75 
	gnumbOfBysThWeWrn
 = 
numbOfBysNInudgTmThWeWrn
 + 1;

77 
ASSERT_UNUSED
(
numbOfBysThWeWrn
, 
m_xt
 +umbOfBysThWeWr<
m_size
);

79 
	gm_xt
 +
numbOfBysNInudgTmThWeWrn
;

81 
ASSERT_WITH_SECURITY_IMPLICATION
(
m_xt
 < 
m_size
);

82 
ASSERT
(!
m_bufr
[
m_xt
]);

85 
CSg
 
	gSgPrtSm
::
toCSg
()

87 
ASSERT
(
m_xt
 =

(
m_bufr
));

88  
CSg
(
m_bufr
, 
m_xt
);

91 
	gSgPrtSm
::
t
()

93 
m_xt
 = 0;

94 
	gm_bufr
[0] = 0;

97 
Sg
 
	gSgPrtSm
::
toSg
()

99 
ASSERT
(
m_xt
 =

(
m_bufr
));

100  
	gSg
::
omUTF8
(
m_bufr
, 
m_xt
);

103 
	gSgPrtSm
::
Size
(
size_t
 
wSize
)

105 
ASSERT_WITH_SECURITY_IMPLICATION
(
wSize
 > 
m_size
);

106 
ASSERT
(
wSize
 > (
m_leBufr
));

109 
	gm_size
 = 
wSize
 << 1;

114 * 
	gwBufr
 = 
ic_
<*>(
Mloc
(
m_size
));

115 
memy
(
wBufr
, 
m_bufr
, 
m_xt
 + 1);

116 i(
	gm_bufr
 !
m_leBufr
)

117 
Fe
(
m_bufr
);

118 
	gm_bufr
 = 
wBufr
;

	@StringPrintStream.h

26 #ide
SgPrtSm_h


27 
	#SgPrtSm_h


	)

29 
	~<wtf/PrtSm.h
>

30 
	~<wtf/xt/CSg.h
>

31 
	~<wtf/xt/WTFSg.h
>

33 
mea
 
	gWTF
 {

35 as
	cSgPrtSm
 : 
public
 
PrtSm
 {

36 
public
:

37 
WTF_EXPORT_PRIVATE
 
SgPrtSm
();

38 
WTF_EXPORT_PRIVATE
 
	gvtu
 ~
SgPrtSm
();

40 
vtu
 
vtf
(cڡ * 
fm
, 
va_li

ovride
 
WTF_ATTRIBUTE_PRINTF
(2, 0);

42 
WTF_EXPORT_PRIVATE
 
CSg
 
toCSg
();

43 
WTF_EXPORT_PRIVATE
 
Sg
 
toSg
();

44 
WTF_EXPORT_PRIVATE
 
t
();

46 
	give
:

47 
Size
(
size_t
);

49 * 
	gm_bufr
;

50 
size_t
 
	gm_xt
;

51 
size_t
 
	gm_size
;

52 
	gm_leBufr
[128];

57 
	gme
<
	gtyme
... 
	gTys
>

58 
CSg
 
	$toCSg
(cڡ 
Tys
&... 
vues
)

60 
SgPrtSm
 
am
;

61 
am
.
	`t
(
vues
...);

62  
am
.
	`toCSg
();

63 
	}
}

65 
	gme
<
	gtyme
... 
	gTys
>

66 
Sg
 
	$toSg
(cڡ 
Tys
&... 
vues
)

68 
SgPrtSm
 
am
;

69 
am
.
	`t
(
vues
...);

70  
am
.
	`toSg
();

71 
	}
}

75 
usg
 
	gWTF
::
SgPrtSm
;

76 
usg
 
	gWTF
::
toCSg
;

77 
usg
 
	gWTF
::
toSg
;

	@TCPackedCache.h

111 #ide
TCMALLOC_PACKED_CACHE_INL_H__


112 
	#TCMALLOC_PACKED_CACHE_INL_H__


	)

114 #ide
WTF_CHANGES


115 
	~"ba/basiys.h
"

116 
	~"ba/loggg.h
"

119 #ide
DCHECK_EQ


120 
	#DCHECK_EQ
(
v1
, 
v2

	`ASSERT
((v1=(v2))

	)

125 
	#N_ONES_
(
ITy
, 
N
) \

126 (
N
=0 ? 0 : ((
ic_
<
ITy
>(1) << ((N)-1))-1 + \

127 (
ic_
<
ITy
>(1<< ((
N
)-1)))

	)

134 
	gme
 <
	gkKeybs
, 
tyme
 
	gT
>

135 as
	cPackedCache
 {

136 
	mpublic
:

137 
u_t
 
	tK
;

138 
size_t
 
	tV
;

139 cڡ 
size_t
 
	mkHashbs
 = 12;

140 cڡ 
size_t
 
	mkVuebs
 = 8;

142 
exic
 
	$PackedCache
(
V
 
l_vue
) {

143 
	`COMPILE_ASSERT
(
kKeybs
 <(
K
* 8, 
key_size
);

144 
	`COMPILE_ASSERT
(
kVuebs
 <(
V
* 8, 
vue_size
);

145 
	`COMPILE_ASSERT
(
kHashbs
 <
kKeybs
, 
hash_funi
);

146 
	`COMPILE_ASSERT
(
kKeybs
 - 
kHashbs
 + 
kVuebs
 <
kTbs
,

147 
y_size_mu_be_big_ough
);

148 
	`Cˬ
(
l_vue
);

151 
	$Put
(
K
 
key
, 
V
 
vue
) {

152 
	`DCHECK_EQ
(
key
, key & 
kKeyMask
);

153 
	`DCHECK_EQ
(
vue
, vu& 
kVueMask
);

154 
y_
[
	`Hash
(
key
)] = 
ic_
<
T
>(
	`KeyToU
(key| 
vue
);

155 
	}
}

157 
bo
 
	$Has
(
K
 
key
) const {

158 
	`DCHECK_EQ
(
key
, key & 
kKeyMask
);

159  
	`KeyMch
(
y_
[
	`Hash
(
key
)], key);

160 
	}
}

162 
V
 
	$GOrDeu
(
K
 
key
, 
V
 
deu_vue
) const {

167 
	`DCHECK_EQ
(
key
, key & 
kKeyMask
);

168 
T
 
y
 = 
y_
[
	`Hash
(
key
)];

169  
	`KeyMch
(
y
, 
key
? 
	`EryToVue
ry: 
deu_vue
;

170 
	}
}

172 
	$Cˬ
(
V
 
vue
) {

173 
	`DCHECK_EQ
(
vue
, vu& 
kVueMask
);

174 
i
 = 0; i < 1 << 
kHashbs
; i++) {

175 
y_
[
i
] = 
ic_
<
T
>(
vue
);

177 
	}
}

179 
	give
:

183 
T
 
	tUPPER
;

185 
V
 
	$EryToVue
(
T
 
t
{  & 
kVueMask
; 
	}
}

187 
UPPER
 
	$EryToU
(
T
 
t
{  & 
kUMask
; 
	}
}

193 
UPPER
 
	$KeyToU
(
K
 
k
) {

194 cڡ 
shi
 = 
kHashbs
 - 
kVuebs
;

196  
ic_
<
T
>(
k
 >> 
shi
& 
kUMask
;

197 
	}
}

201 
K
 
	$UToPtlKey
(
UPPER
 
u
) {

202 
	`DCHECK_EQ
(
u
, u & 
kUMask
);

203 cڡ 
shi
 = 
kHashbs
 - 
kVuebs
;

205  
ic_
<
K
>(
u
<< 
shi
;

206 
	}
}

208 
size_t
 
	$Hash
(
K
 
key
) {

209  
ic_
<
size_t
>(
key
& 
	`N_ONES_
(size_t, 
kHashbs
);

210 
	}
}

213 
bo
 
	$KeyMch
(
T
 
y
, 
K
 
key
) {

214  ((
	`KeyToU
(
key
^ 
y
& 
kUMask
) == 0;

215 
	}
}

217 cڡ 
size_t
 
	gkTbs
 = 8 * (
T
);

218 cڡ 
	gkUbs
 = 
kKeybs
 - 
kHashbs
;

221 cڡ 
K
 
	gkKeyMask
 = 
N_ONES_
(K, 
kKeybs
);

224 cڡ 
T
 
	gkUMask
 = 
N_ONES_
(T, 
kUbs
<< 
	gkVuebs
;

227 cڡ 
V
 
	gkVueMask
 = 
N_ONES_
(V, 
kVuebs
);

229 
T
 
	gy_
[1 << 
kHashbs
];

232 #unde
N_ONES_


	@TCPageMap.h

45 #ide
TCMALLOC_PAGEMAP_H__


46 
	#TCMALLOC_PAGEMAP_H__


	)

48 
	~<dt.h
>

49 
	~<rg.h
>

50 
	~<wtf/Asis.h
>

53 
	gme
 <
	gBITS
>

54 as
	cTCMloc_PageM1
 {

55 
	mive
:

56 ** 
y_
;

58 
	mpublic
:

59 
u_t
 
	tNumb
;

61 

(* (*
lot
)(
size_t
)) {

62 
	my_
 = 
t_
<**>((*
lot
)((*<< 
BITS
));

63 
memt
(
y_
, 0, (*<< 
BITS
);

68 
bo
 
	$Ensu
(
Numb
, 
size_t
) {

70  
ue
;

71 
	}
}

73 
	$PloMeMemy
({
	}
}

80 * 
	$g
(
Numb
 
k
) const {

81  
y_
[
k
];

82 
	}
}

88 
	$t
(
Numb
 
k
, * 
v
) {

89 
y_
[
k
] = 
v
;

90 
	}
}

94 
	gme
 <
	gBITS
>

95 as
	cTCMloc_PageM2
 {

96 
	mive
:

98 cڡ 
ROOT_BITS
 = 5;

99 cڡ 
	mROOT_LENGTH
 = 1 << 
ROOT_BITS
;

101 cڡ 
	mLEAF_BITS
 = 
BITS
 - 
ROOT_BITS
;

102 cڡ 
	mLEAF_LENGTH
 = 1 << 
LEAF_BITS
;

105 
	sLf
 {

106 * 
	mvues
[
LEAF_LENGTH
];

109 
Lf
* 
	gro_
[
ROOT_LENGTH
];

110 * (*
	glot_
)(
	gsize_t
);

112 
	gpublic
:

113 
u_t
 
	tNumb
;

115 

(* (*
lot
)(
size_t
)) {

116 
	glot_
 = 
lot
;

117 
memt
(
ro_
, 0, (root_));

120 * 
	$g
(
Numb
 
k
) const {

121 
	`ASSERT
(
k
 >> 
BITS
 == 0);

122 cڡ 
Numb
 
i1
 = 
k
 >> 
LEAF_BITS
;

123 cڡ 
Numb
 
i2
 = 
k
 & (
LEAF_LENGTH
-1);

124  
ro_
[
i1
]->
vues
[
i2
];

125 
	}
}

127 
	$t
(
Numb
 
k
, * 
v
) {

128 
	`ASSERT
(
k
 >> 
BITS
 == 0);

129 cڡ 
Numb
 
i1
 = 
k
 >> 
LEAF_BITS
;

130 cڡ 
Numb
 
i2
 = 
k
 & (
LEAF_LENGTH
-1);

131 
ro_
[
i1
]->
vues
[
i2
] = 
v
;

132 
	}
}

134 
bo
 
	$Ensu
(
Numb
 
t
, 
size_t
 
n
) {

135 
Numb
 
key
 = 
t
; key <𡬈+ 
n
 - 1; ) {

136 cڡ 
Numb
 
i1
 = 
key
 >> 
LEAF_BITS
;

139 i(
ro_
[
i1
] =
NULL
) {

140 
Lf
* 
af
 = 
t_
<Lf*>((*
lot_
)((Leaf)));

141 i(
af
 =
NULL
 
l
;

142 
	`memt
(
af
, 0, (*leaf));

143 
ro_
[
i1
] = 
af
;

147 
key
 = ((key >> 
LEAF_BITS
) + 1) << LEAF_BITS;

149  
ue
;

150 
	}
}

152 
	$PloMeMemy
() {

154 
	`Ensu
(0, 1 << 
BITS
);

155 
	}
}

157 #ifde
WTF_CHANGES


158 
	gme
<
ass
 
	gVis
, cs
	gMemyRd
>

159 
	$visVues
(
Vis
& 
vis
, cڡ 
MemyRd
& 
ad
)

161 cڡ 
Numb
 
afIndexMask
 = 
LEAF_LENGTH
 - 1;

163 cڡ 
Numb
 
maxKey
 = (1<< 
BITS
) - 1;

164 cڡ 
Numb
 
vidIndex
 = 
maxKey
;

165 
Numb
 
eviousRoIndex
 = 
vidIndex
;

167 
Lf
* 
af
 = 0;

169 
Numb
 
key
 = 0; key < 
maxKey
; ) {

170 cڡ 
Numb
 
roIndex
 = 
key
 >> 
LEAF_BITS
;

171 cڡ 
Numb
 
afIndex
 = 
key
 & 
afIndexMask
;

173 i(
roIndex
 !
eviousRoIndex
) {

174 i(!
ro_
[
roIndex
]) {

177 
key
 +1 << 
LEAF_BITS
;

178 
key
 &~
afIndexMask
;

182 
af
 = 
	`ad
(
ro_
[
roIndex
]);

183 
eviousRoIndex
 = 
roIndex
;

186 
key
 +
vis
.
	`vis
(
af
->
vues
[
afIndex
]);

188 
	}
}

190 
	gme
<
ass
 
	gVis
, cs
	gMemyRd
>

191 
	$visAotis
(
Vis
& 
vis
, cڡ 
MemyRd
&) {

192 
i
 = 0; i < 
ROOT_LENGTH
; i++) {

193 i(
ro_
[
i
])

194 
vis
.
	`vis
(
ro_
[
i
], (
Lf
));

196 
	}
}

201 
	gme
 <
	gBITS
>

202 as
	cTCMloc_PageM3
 {

203 
	mive
:

205 cڡ 
INTERIOR_BITS
 = (
BITS
 + 2) / 3;

206 cڡ 
	mINTERIOR_LENGTH
 = 1 << 
INTERIOR_BITS
;

209 cڡ 
	mLEAF_BITS
 = 
BITS
 - 2*
INTERIOR_BITS
;

210 cڡ 
	mLEAF_LENGTH
 = 1 << 
LEAF_BITS
;

213 
	sNode
 {

214 
Node
* 
	mrs
[
INTERIOR_LENGTH
];

218 
	sLf
 {

219 * 
	gvues
[
LEAF_LENGTH
];

222 
Node
* 
	gro_
;

223 * (*
	glot_
)(
	gsize_t
);

225 
Node
* 
	$NewNode
() {

226 
Node
* 
su
 = 
t_
<Node*>((*
lot_
)((Node)));

227 i(
su
 !
NULL
) {

228 
	`memt
(
su
, 0, (*result));

230  
su
;

231 
	}
}

233 
	gpublic
:

234 
u_t
 
	tNumb
;

236 

(* (*
lot
)(
size_t
)) {

237 
	glot_
 = 
lot
;

238 
	gro_
 = 
NewNode
();

241 * 
	$g
(
Numb
 
k
) const {

242 
	`ASSERT
(
k
 >> 
BITS
 == 0);

243 cڡ 
Numb
 
i1
 = 
k
 >> (
LEAF_BITS
 + 
INTERIOR_BITS
);

244 cڡ 
Numb
 
i2
 = (
k
 >> 
LEAF_BITS
& (
INTERIOR_LENGTH
-1);

245 cڡ 
Numb
 
i3
 = 
k
 & (
LEAF_LENGTH
-1);

246  
t_
<
Lf
*>(
ro_
->
rs
[
i1
]->rs[
i2
])->
vues
[
i3
];

247 
	}
}

249 
	$t
(
Numb
 
k
, * 
v
) {

250 
	`ASSERT
(
k
 >> 
BITS
 == 0);

251 cڡ 
Numb
 
i1
 = 
k
 >> (
LEAF_BITS
 + 
INTERIOR_BITS
);

252 cڡ 
Numb
 
i2
 = (
k
 >> 
LEAF_BITS
& (
INTERIOR_LENGTH
-1);

253 cڡ 
Numb
 
i3
 = 
k
 & (
LEAF_LENGTH
-1);

254 
t_
<
Lf
*>(
ro_
->
rs
[
i1
]->rs[
i2
])->
vues
[
i3
] = 
v
;

255 
	}
}

257 
bo
 
	$Ensu
(
Numb
 
t
, 
size_t
 
n
) {

258 
Numb
 
key
 = 
t
; key <𡬈+ 
n
 - 1; ) {

259 cڡ 
Numb
 
i1
 = 
key
 >> (
LEAF_BITS
 + 
INTERIOR_BITS
);

260 cڡ 
Numb
 
i2
 = (
key
 >> 
LEAF_BITS
& (
INTERIOR_LENGTH
-1);

263 i(
ro_
->
rs
[
i1
] =
NULL
) {

264 
Node
* 
n
 = 
	`NewNode
();

265 i(
n
 =
NULL
 
l
;

266 
ro_
->
rs
[
i1
] = 
n
;

270 i(
ro_
->
rs
[
i1
]->rs[
i2
] =
NULL
) {

271 
Lf
* 
af
 = 
t_
<Lf*>((*
lot_
)((Leaf)));

272 i(
af
 =
NULL
 
l
;

273 
	`memt
(
af
, 0, (*leaf));

274 
ro_
->
rs
[
i1
]->rs[
i2
] = 
t_
<
Node
*>(
af
);

278 
key
 = ((key >> 
LEAF_BITS
) + 1) << LEAF_BITS;

280  
ue
;

281 
	}
}

283 
	$PloMeMemy
() {

284 
	}
}

286 #ifde
WTF_CHANGES


287 
	gme
<
ass
 
	gVis
, cs
	gMemyRd
>

288 
	$visVues
(
Vis
& 
vis
, cڡ 
MemyRd
& 
ad
) {

289 cڡ 
Numb
 
rmedIndexMask
 = (
INTERIOR_LENGTH
 - 1<< 
LEAF_BITS
;

290 cڡ 
Numb
 
afIndexMask
 = 
LEAF_LENGTH
 - 1;

292 cڡ 
Numb
 
maxKey
 = (1<< 
BITS
) - 1;

293 cڡ 
Numb
 
vidIndex
 = 
maxKey
;

294 
Numb
 
eviousRoIndex
 = 
vidIndex
;

295 
Numb
 
eviousImedIndex
 = 
vidIndex
;

297 
Node
* 
rmedNode
 = 0;

298 
Lf
* 
af
 = 0;

300 
Node
* 
ro
 = 
	`ad
(
ro_
);

301 
Numb
 
key
 = 0; key < 
maxKey
; ) {

302 cڡ 
Numb
 
roIndex
 = 
key
 >> (
LEAF_BITS
 + 
INTERIOR_BITS
);

303 cڡ 
Numb
 
rmedIndex
 = (
key
 & 
rmedIndexMask
>> 
LEAF_BITS
;

304 cڡ 
Numb
 
afIndex
 = 
key
 & 
afIndexMask
;

306 i(
roIndex
 !
eviousRoIndex
) {

307 i(!
ro
->
rs
[
roIndex
]) {

310 
key
 +1 << (
LEAF_BITS
 + 
INTERIOR_BITS
);

311 
key
 &~(
afIndexMask
 | 
rmedIndexMask
);

315 
rmedNode
 = 
	`ad
(
ro
->
rs
[
roIndex
]);

316 
eviousRoIndex
 = 
roIndex
;

319 
eviousImedIndex
 = 
vidIndex
;

322 i(
rmedIndex
 !
eviousImedIndex
) {

323 i(!
rmedNode
->
rs
[
rmedIndex
]) {

326 
key
 +1 << 
LEAF_BITS
;

327 
key
 &~
afIndexMask
;

331 
af
 = 
	`ad
(
t_
<
Lf
*>(
rmedNode
->
rs
[
rmedIndex
]));

332 
eviousImedIndex
 = 
rmedIndex
;

335 
key
 +
vis
.
	`vis
(
af
->
vues
[
afIndex
]);

337 
	}
}

339 
	gme
<
ass
 
	gVis
, cs
	gMemyRd
>

340 
	$visAotis
(
Vis
& 
vis
, cڡ 
MemyRd
& 
ad
) {

341 
vis
.
	`vis
(
ro_
, (
Node
));

343 
Node
* 
ro
 = 
	`ad
(
ro_
);

344 
i
 = 0; i < 
INTERIOR_LENGTH
; i++) {

345 i(!
ro
->
rs
[
i
])

348 
vis
.
	`vis
(
ro
->
rs
[
i
], (
Node
));

349 
Node
* 
n
 = 
	`ad
(
ro
->
rs
[
i
]);

350 
j
 = 0; j < 
INTERIOR_LENGTH
; j++) {

351 i(!
n
->
rs
[
j
])

354 
vis
.
	`vis
(
n
->
rs
[
j
], (
Lf
));

357 
	}
}

	@TCSpinLock.h

34 #ide
TCMALLOC_INTERNAL_SPINLOCK_H__


35 
	#TCMALLOC_INTERNAL_SPINLOCK_H__


	)

37 
	~<wtf/Atomics.h
>

38 #i
OS
(
UNIX
)

39 
	~<sched.h
>

42 #i
ENABLE
(
COMPARE_AND_SWAP
)

44 
TCMloc_SlowLock
(* 
lockwd
);

47 
	sTCMloc_SpLock
 {

48 
Lock
() {

49 i(!
	mWTF
::
wkComAndSw
(&
lockwd_
, 0, 1))

50 
TCMloc_SlowLock
(&
lockwd_
);

51 
	mWTF
::
memyBrrALock
();

54 
Uock
() {

55 
	mWTF
::
memyBrrBefeUock
();

56 
	mlockwd_
 = 0;

63 
bo
 
IsHd
() const {

64  
	mlockwd_
 != 0;

67 
In
({ 
	mlockwd_
 = 0; }

68 
Fize
() { }

70 
	mlockwd_
;

73 
	#SPINLOCK_INITIALIZER
 { 0 }

	)

75 
	$TCMloc_SlowLock
(* 
lockwd
) {

77 #i
	`OS
(
WINDOWS
)

78 
	`S˕
(0);

80 #i!
	`ENABLE
(
VMOLAB
)

81 
	`sched_yld
();

84 } !
WTF
::
	`wkComAndSw
(
lockwd
, 0, 1));

85 
	}
}

89 
	~<had.h
>

92 
	sTCMloc_SpLock
 {

93 
had_mux_t
 
	mive_lock_
;

95 
le
 
In
() {

96 i(
had_mux_
(&
ive_lock_
, 
NULL
!0
CRASH
();

98 
le
 
Fize
() {

99 i(
had_mux_deroy
(&
ive_lock_
!0
CRASH
();

101 
le
 
Lock
() {

102 i(
had_mux_lock
(&
ive_lock_
!0
CRASH
();

104 
le
 
Uock
() {

105 i(
had_mux_uock
(&
ive_lock_
!0
CRASH
();

107 
bo
 
IsHd
() {

108 i(
had_mux_ylock
(&
ive_lock_
))

109  
	mue
;

111 
Uock
();

112  
	ml
;

116 
	#SPINLOCK_INITIALIZER
 { 
PTHREAD_MUTEX_INITIALIZER
 }

	)

122 as
	cTCMloc_SpLockHd
 {

123 
	mive
:

124 
TCMloc_SpLock
* 
lock_
;

125 
	mpublic
:

126 
le
 
exic
 
	$TCMloc_SpLockHd
(
TCMloc_SpLock
* 
l
)

127 : 
	$lock_
(
l
{->
	`Lock
(); }

128 
le
 ~
	$TCMloc_SpLockHd
({ 
lock_
->
	`Uock
(); 
	}
}

132 
TCMloc_SpLock
 
	tSpLock
;

133 
TCMloc_SpLockHd
 
	tSpLockHd
;

	@TCSystemAlloc.cpp

33 
	~"cfig.h
"

34 #i!(
defed
(
USE_SYSTEM_MALLOC
) && USE_SYSTEM_MALLOC)

35 
	~"TCSyemAoc.h
"

37 
	~"Asis.h
"

38 
	~"CheckedArhmic.h
"

39 
	~"TCSpLock.h
"

40 
	~"VMTags.h
"

41 
	~<gܙhm
>

42 
	~<dt.h
>

44 #i
OS
(
WINDOWS
)

45 
	~"wdows.h
"

47 
	~<o.h
>

48 
	~<unid.h
>

49 
	~<sys/mm.h
>

52 #ide
MAP_ANONYMOUS


53 
	#MAP_ANONYMOUS
 
MAP_ANON


	)

56 
usg
 
mea
 
	gd
;

59 
	uMemyAligr
 {

60 * 
	mp
;

61 
	md
;

62 
size_t
 
	ms
;

65 
SpLock
 
	glock
 = 
SPINLOCK_INITIALIZER
;

68 
size_t
 
	ggesize
 = 0;

76 #ide
WTF_CHANGES


77 
bo
 
	gu_devmem
 = 
l
;

78 
bo
 
	gu_sbrk
 = 
l
;

81 #i
HAVE
(
MMAP
)

82 
bo
 
	gu_mm
 = 
ue
;

85 #i
HAVE
(
VIRTUALALLOC
)

86 
bo
 
	gu_VtuAoc
 = 
ue
;

90 
bo
 
	gdevmem_u
 = 
l
;

91 
bo
 
	gsbrk_u
 = 
l
;

92 
bo
 
	gmm_u
 = 
l
;

93 
bo
 
	gVtuAoc_u
 = 
l
;

95 #ide
WTF_CHANGES


96 
DEFINE_t32
(
mloc_devmem_t
, 0,

99 
DEFINE_t32
(
mloc_devmem_lim
, 0,

104 #ide
WTF_CHANGES


106 * 
	$TrySbrk
(
size_t
 
size
, size_*
au_size
, size_
ignmt
) {

107 
size
 = ((siz+ 
ignmt
 - 1) /lignment) *lignment;

111 i(
au_size
)

112 *
au_size
 = 
size
;

114 * 
su
 = 
	`sbrk
(
size
);

115 i(
su
 =
t_
<*>(-1)) {

116 
sbrk_u
 = 
ue
;

117  
NULL
;

121 
u_t
 
r
 = 
t_
<u_t>(
su
);

122 i((
r
 & (
ignmt
-1)=0 
su
;

125 
size_t
 
exa
 = 
ignmt
 - (
r
 & (alignment-1));

126 * 
r2
 = 
	`sbrk
(
exa
);

127 i(
t_
<
u_t
>(
r2
=(
r
 + 
size
)) {

129  
t_
<*>(
r
 + 
exa
);

134 
su
 = 
	`sbrk
(
size
 + 
ignmt
 - 1);

135 i(
su
 =
t_
<*>(-1)) {

136 
sbrk_u
 = 
ue
;

137  
NULL
;

139 
r
 = 
t_
<
u_t
>(
su
);

140 i((
r
 & (
ignmt
-1)) != 0) {

141 
r
 +
ignmt
 - (ptr & (alignment-1));

143  
t_
<*>(
r
);

144 
	}
}

148 #i
HAVE
(
MMAP
)

150 * 
	$TryMm
(
size_t
 
size
, size_*
au_size
, size_
ignmt
) {

152 i(
gesize
 =0gesiz
	`ggesize
();

153 i(
ignmt
 < 
gesize
)lignment =agesize;

154 
size
 = ((siz+ 
ignmt
 - 1) /lignment) *lignment;

158 i(
au_size
)

159 *
au_size
 = 
size
;

162 
size_t
 
exa
 = 0;

163 i(
ignmt
 > 
gesize
) {

164 
exa
 = 
ignmt
 - 
gesize
;

166 
Checked
<
size_t
> 
mSize
 = Checked<size_t>(
size
+ 
exa
 + 2 * 
gesize
;

167 * 
su
 = 
	`mm
(
NULL
, 
mSize
.
	`unG
(),

168 
PROT_READ
 | 
PROT_WRITE
,

169 
MAP_PRIVATE
|
MAP_ANONYMOUS
,

170 
VM_TAG_FOR_TCMALLOC_MEMORY
, 0);

171 i(
su
 =
t_
<*>(
MAP_FAILED
)) {

172 
mm_u
 = 
ue
;

173  
NULL
;

175 
	`mm
(
su
, 
gesize
, 
PROT_NONE
, 
MAP_FIXED
 | 
MAP_PRIVATE
 | 
MAP_ANON
, 
VM_TAG_FOR_TCMALLOC_MEMORY
, 0);

176 
	`mm
(
ic_
<*>(
su
+ (
mSize
 - 
gesize
).
	`unG
(),agesize, 
PROT_NONE
, 
MAP_FIXED
 | 
MAP_PRIVATE
 | 
MAP_ANON
, 
VM_TAG_FOR_TCMALLOC_MEMORY
, 0);

177 
su
 = 
ic_
<*>esu+ 
gesize
;

179 
u_t
 
r
 = 
t_
<u_t>(
su
);

180 
size_t
 
adju
 = 0;

181 i((
r
 & (
ignmt
 - 1)) != 0) {

182 
adju
 = 
ignmt
 - (
r
 & (alignment - 1));

186 i(
adju
 > 0) {

187 
	`munm
(
t_
<*>(
r
), 
adju
);

189 i(
adju
 < 
exa
) {

190 
	`munm
(
t_
<*>(
r
 + 
adju
 + 
size
), 
exa
 -djust);

193 
r
 +
adju
;

194  
t_
<*>(
r
);

195 
	}
}

199 #i
HAVE
(
VIRTUALALLOC
)

201 * 
	$TryVtuAoc
(
size_t
 
size
, size_*
au_size
, size_
ignmt
) {

203 i(
gesize
 == 0) {

204 
SYSTEM_INFO
 
syem_fo
;

205 
	`GSyemInfo
(&
syem_fo
);

206 
gesize
 = 
syem_fo
.
dwPageSize
;

209 i(
ignmt
 < 
gesize
)lignment =agesize;

210 
size
 = ((siz+ 
ignmt
 - 1) /lignment) *lignment;

214 i(
au_size
)

215 *
au_size
 = 
size
;

218 
size_t
 
exa
 = 0;

219 i(
ignmt
 > 
gesize
) {

220 
exa
 = 
ignmt
 - 
gesize
;

222 * 
su
 = 
	`VtuAoc
(
NULL
, 
size
 + 
exa
,

223 
MEM_RESERVE
 | 
MEM_COMMIT
 | 
MEM_TOP_DOWN
,

224 
PAGE_READWRITE
);

226 i(
su
 =
NULL
) {

227 
VtuAoc_u
 = 
ue
;

228  
NULL
;

232 
u_t
 
r
 = 
t_
<u_t>(
su
);

233 
size_t
 
adju
 = 0;

234 i((
r
 & (
ignmt
 - 1)) != 0) {

235 
adju
 = 
ignmt
 - (
r
 & (alignment - 1));

240 i(
adju
 > 0) {

241 
	`VtuFe
(
t_
<*>(
r
), 
adju
, 
MEM_DECOMMIT
);

243 i(
adju
 < 
exa
) {

244 
	`VtuFe
(
t_
<*>(
r
 + 
adju
 + 
size
), 
exa
-adju, 
MEM_DECOMMIT
);

247 
r
 +
adju
;

248  
t_
<*>(
r
);

249 
	}
}

253 #ide
WTF_CHANGES


254 * 
	$TryDevMem
(
size_t
 
size
, size_*
au_size
, size_
ignmt
) {

255 
bo
 
lized
 = 
l
;

256 
off_t
 
physmem_ba
;

257 
off_t
 
physmem_lim
;

258 
physmem_fd
;

264 i(
FLAGS_mloc_devmem_t
 == 0) {

267  
NULL
;

270 i(!
lized
) {

271 
physmem_fd
 = 
	`ݒ
("/dev/mem", 
O_RDWR
);

272 i(
physmem_fd
 < 0) {

273 
devmem_u
 = 
ue
;

274  
NULL
;

276 
physmem_ba
 = 
FLAGS_mloc_devmem_t
*1024LL*1024LL;

277 
physmem_lim
 = 
FLAGS_mloc_devmem_lim
*1024LL*1024LL;

278 
lized
 = 
ue
;

282 i(
gesize
 =0gesiz
	`ggesize
();

283 i(
ignmt
 < 
gesize
)lignment =agesize;

284 
size
 = ((siz+ 
ignmt
 - 1) /lignment) *lignment;

288 i(
au_size
)

289 *
au_size
 = 
size
;

292 
size_t
 
exa
 = 0;

293 i(
ignmt
 > 
gesize
) {

294 
exa
 = 
ignmt
 - 
gesize
;

298 i(
physmem_lim
 !0 && 
physmem_ba
 + 
size
 + 
exa
 >hysmem_limit) {

299 
devmem_u
 = 
ue
;

300  
NULL
;

302 *
su
 = 
	`mm
(0, 
size
 + 
exa
, 
PROT_READ
 | 
PROT_WRITE
,

303 
MAP_SHARED
, 
physmem_fd
, 
physmem_ba
);

304 i(
su
 =
t_
<*>(
MAP_FAILED
)) {

305 
devmem_u
 = 
ue
;

306  
NULL
;

308 
u_t
 
r
 = 
t_
<u_t>(
su
);

311 
size_t
 
adju
 = 0;

312 i((
r
 & (
ignmt
 - 1)) != 0) {

313 
adju
 = 
ignmt
 - (
r
 & (alignment - 1));

317 i(
adju
 > 0) {

318 
	`munm
(
t_
<*>(
r
), 
adju
);

320 i(
adju
 < 
exa
) {

321 
	`munm
(
t_
<*>(
r
 + 
adju
 + 
size
), 
exa
 -djust);

324 
r
 +
adju
;

325 
physmem_ba
 +
adju
 + 
size
;

327  
t_
<*>(
r
);

328 
	}
}

331 * 
	$TCMloc_SyemAoc
(
size_t
 
size
, size_*
au_size
, size_
ignmt
) {

333 i(
size
 + 
ignmt
 < size 
NULL
;

335 
SpLockHd
 
	`lock_hd
(&
lock
);

338 i(
ignmt
 < (
MemyAligr
))lignment = (MemoryAligner);

342 
i
 = 0; i < 2; i++) {

344 #ide
WTF_CHANGES


345 i(
u_devmem
 && !
devmem_u
) {

346 * 
su
 = 
	`TryDevMem
(
size
, 
au_size
, 
ignmt
);

347 i(
su
 !
NULL
) esult;

350 i(
u_sbrk
 && !
sbrk_u
) {

351 * 
su
 = 
	`TrySbrk
(
size
, 
au_size
, 
ignmt
);

352 i(
su
 !
NULL
) esult;

356 #i
	`HAVE
(
MMAP
)

357 i(
u_mm
 && !
mm_u
) {

358 * 
su
 = 
	`TryMm
(
size
, 
au_size
, 
ignmt
);

359 i(
su
 !
NULL
) esult;

363 #i
	`HAVE
(
VIRTUALALLOC
)

364 i(
u_VtuAoc
 && !
VtuAoc_u
) {

365 * 
su
 = 
	`TryVtuAoc
(
size
, 
au_size
, 
ignmt
);

366 i(
su
 !
NULL
) esult;

371 
devmem_u
 = 
l
;

372 
sbrk_u
 = 
l
;

373 
mm_u
 = 
l
;

374 
VtuAoc_u
 = 
l
;

376  
NULL
;

377 
	}
}

379 #i
HAVE
(
MADV_FREE_REUSE
)

381 
	$TCMloc_SyemR
(* 
t
, 
size_t
 
ngth
)

383 
madviResu
;

385 (
madviResu
 = 
	`madvi
(
t
, 
ngth
, 
MADV_FREE_REUSABLE
)=-1 && 
o
 =
EAGAIN
) { }

388 
	`ASSERT_UNUSED
(
madviResu
, madviseResult != -1);

389 
	}
}

391 #i
HAVE
(
MADV_FREE
|| HAVE(
MADV_DONTNEED
)

393 
	$TCMloc_SyemR
(* 
t
, 
size_t
 
ngth
)

397 #i
	`HAVE
(
MADV_FREE
)

398 cڡ 
advi
 = 
MADV_FREE
;

400 cڡ 
advi
 = 
MADV_DONTNEED
;

402 i(
gesize
 =0gesiz
	`ggesize
();

403 cڡ 
size_t
 
gemask
 = 
gesize
 - 1;

405 
size_t
 
w_t
 = 
t_
<size_t>(
t
);

406 
size_t
 
d
 = 
w_t
 + 
ngth
;

407 
size_t
 
w_d
 = 
d
;

411 
w_t
 = (w_+ 
gesize
 - 1& ~
gemask
;

412 
w_d
 =ew_d & ~
gemask
;

414 
	`ASSERT
((
w_t
 & 
gemask
) == 0);

415 
	`ASSERT
((
w_d
 & 
gemask
) == 0);

416 
	`ASSERT
(
w_t
 >
t_
<
size_t
>(
t
));

417 
	`ASSERT
(
w_d
 <
d
);

419 i(
w_d
 > 
w_t
) {

422 
	`madvi
(
t_
<*>(
w_t
), 
w_d
 -ew_start,

423 
advi
) == -1 &&

424 
o
 =
EAGAIN
) {

428 
	}
}

430 #i
HAVE
(
MMAP
)

432 
	$TCMloc_SyemR
(* 
t
, 
size_t
 
ngth
)

434 * 
wAddss
 = 
	`mm
(
t
, 
ngth
, 
PROT_READ
 | 
PROT_WRITE
, 
MAP_PRIVATE
 | 
MAP_ANONYMOUS
 | 
MAP_FIXED
, -1, 0);

436 
	`ASSERT_UNUSED
(
wAddss
,ewAdds=
t
 ||ewAdds=
t_
<*>(
MAP_FAILED
));

437 
	}
}

439 #i
HAVE
(
VIRTUALALLOC
)

441 
	$TCMloc_SyemR
(* 
t
, 
size_t
 
ngth
)

443 i(
	`VtuFe
(
t
, 
ngth
, 
MEM_DECOMMIT
))

451 * 
r
 = 
ic_
<*>(
t
);

452 * 
d
 = 
r
 + 
ngth
;

453 
MEMORY_BASIC_INFORMATION
 
fo
;

454 
r
 < 
d
) {

455 
size_t
 
suSize
 = 
	`VtuQuy
(
r
, &
fo
, (info));

456 
	`ASSERT_UNUSED
(
suSize
,esuSiz=(
fo
));

458 
size_t
 
decommSize
 = 
m
<size_t>(
fo
.
RegiSize
, 
d
 - 
r
);

459 
BOOL
 
sucss
 = 
	`VtuFe
(
r
, 
decommSize
, 
MEM_DECOMMIT
);

460 
	`ASSERT_UNUSED
(
sucss
, success);

461 
r
 +
decommSize
;

463 
	}
}

472 #i
HAVE
(
MADV_FREE_REUSE
)

474 
	$TCMloc_SyemComm
(* 
t
, 
size_t
 
ngth
)

476 
	`madvi
(
t
, 
ngth
, 
MADV_FREE_REUSE
=-1 && 
o
 =
EAGAIN
) { }

477 
	}
}

479 #i
HAVE
(
VIRTUALALLOC
)

481 
	$TCMloc_SyemComm
(* 
t
, 
size_t
 
ngth
)

483 i(
	`VtuAoc
(
t
, 
ngth
, 
MEM_COMMIT
, 
PAGE_READWRITE
) == start)

491 * 
r
 = 
ic_
<*>(
t
);

492 * 
d
 = 
r
 + 
ngth
;

493 
MEMORY_BASIC_INFORMATION
 
fo
;

494 
r
 < 
d
) {

495 
size_t
 
suSize
 = 
	`VtuQuy
(
r
, &
fo
, (info));

496 
	`ASSERT_UNUSED
(
suSize
,esuSiz=(
fo
));

498 
size_t
 
commSize
 = 
m
<size_t>(
fo
.
RegiSize
, 
d
 - 
r
);

499 * 
wAddss
 = 
	`VtuAoc
(
r
, 
commSize
, 
MEM_COMMIT
, 
PAGE_READWRITE
);

500 
	`ASSERT_UNUSED
(
wAddss
,ewAdds=
r
);

501 
r
 +
commSize
;

503 
	}
}

	@TCSystemAlloc.h

36 #ide
TCMALLOC_SYSTEM_ALLOC_H__


37 
	#TCMALLOC_SYSTEM_ALLOC_H__


	)

51 * 
TCMloc_SyemAoc
(
size_t
 
bys
, size_*
au_bys
,

52 
size_t
 
ignmt
 = 0);

63 
TCMloc_SyemR
(* 
t
, 
size_t
 
ngth
);

65 
TCMloc_SyemComm
(* 
t
, 
size_t
 
ngth
);

67 #i!
HAVE
(
MADV_FREE_REUSE
&& !HAVE(
MADV_DONTNEED
&& !HAVE(
MMAP
&& !HAVE(
VIRTUALALLOC
)

68 
le
 
	$TCMloc_SyemR
(*, 
size_t
{ 
	}
}

71 #i!
HAVE
(
VIRTUALALLOC
&& !HAVE(
MADV_FREE_REUSE
)

72 
le
 
	$TCMloc_SyemComm
(*, 
size_t
{ 
	}
}

	@TemporaryChange.h

26 #ide
TempܬyChge_h


27 
	#TempܬyChge_h


	)

29 
	~<wtf/Ncyab.h
>

31 
mea
 
	gWTF
 {

42 
	gme
<
tyme
 
	gT
>

43 as
	cTempܬyChge
 {

44 
WTF_MAKE_NONCOPYABLE
(
TempܬyChge
);

45 
	gpublic
:

46 
TempܬyChge
(
T
& 
scedVb
, T 
wVue
)

47 : 
m_scedVb
(
scedVb
)

48 , 
m_igVue
(
scedVb
)

50 
	gm_scedVb
 = 
wVue
;

53 ~
TempܬyChge
()

55 
	gm_scedVb
 = 
m_igVue
;

59 
	give
:

60 
T
& 
m_scedVb
;

61 
T
 
	gm_igVue
;

66 
usg
 
	gWTF
::
TempܬyChge
;

	@ThreadFunctionInvocation.h

29 #ide
ThadFuniInvoti_h


30 
	#ThadFuniInvoti_h


	)

32 
mea
 
	gWTF
 {

34 (*
	gThadFuni
)(* 
	tgumt
);

36 
	sThadFuniInvoti
 {

37 
	gWTF_MAKE_FAST_ALLOCATED
;

38 
	gpublic
:

39 
ThadFuniInvoti
(
ThadFuni
 
funi
, * 
da
)

40 : 
funi
(function)

41 , 
da
(data)

45 
ThadFuni
 
	gfuni
;

46 * 
	gda
;

	@ThreadIdentifierDataPthreads.cpp

31 
	~"cfig.h
"

33 #i
USE
(
PTHREADS
)

35 
	~"ThadIdtifrDaPthads.h
"

37 
	~"Thadg.h
"

39 #i
OS
(
HURD
)

41 
	#PTHREAD_KEYS_MAX
 1024

	)

43 
	~<lims.h
>

46 
mea
 
	gWTF
 {

48 
had_key_t
 
	gThadIdtifrDa
::
m_key
 = 
PTHREAD_KEYS_MAX
;

50 
thadDidEx
(
ThadIdtifr
);

52 
	gThadIdtifrDa
::~
ThadIdtifrDa
()

54 
thadDidEx
(
m_idtifr
);

57 
	gThadIdtifrDa
::
lizeOn
()

59 i(
had_key_
(&
m_key
, 
deru
))

60 
CRASH
();

63 
ThadIdtifr
 
	gThadIdtifrDa
::
idtifr
()

65 
ASSERT
(
m_key
 !
PTHREAD_KEYS_MAX
);

66 
ThadIdtifrDa
* 
	gthadIdtifrDa
 = 
ic_
<ThadIdtifrDa*>(
had_gecific
(
m_key
));

68  
	gthadIdtifrDa
 ?hadIdtifrDa->
	gm_idtifr
 : 0;

71 
	gThadIdtifrDa
::
lize
(
ThadIdtifr
 
id
)

73 
ASSERT
(!
idtifr
());

74 
had_tecific
(
m_key
, 
w
 
ThadIdtifrDa
(
id
));

77 
	gThadIdtifrDa
::
deru
(* 
da
)

79 
ThadIdtifrDa
* 
thadIdtifrDa
 = 
ic_
<ThadIdtifrDa*>(
da
);

80 
ASSERT
(
thadIdtifrDa
);

82 i(
	gthadIdtifrDa
->
	gm_isDeroyedOn
) {

83 
de
 
	gthadIdtifrDa
;

87 
	gthadIdtifrDa
->
	gm_isDeroyedOn
 = 
ue
;

89 
had_tecific
(
m_key
, 
thadIdtifrDa
);

	@ThreadIdentifierDataPthreads.h

31 #ide
ThadIdtifrDaPthads_h


32 
	#ThadIdtifrDaPthads_h


	)

34 
	~<wtf/Thadg.h
>

36 
mea
 
	gWTF
 {

40 as
	cThadIdtifrDa
 {

41 
WTF_MAKE_NONCOPYABLE
(
ThadIdtifrDa
);

42 
	gpublic
:

43 ~
ThadIdtifrDa
();

47 
lizeOn
();

50 
lize
(
ThadIdtifr
 
idtifr
);

53 
ThadIdtifr
 
idtifr
();

55 
	give
:

56 
ThadIdtifrDa
(
ThadIdtifr
 
idtifr
)

57 : 
m_idtifr
(
idtifr
)

58 , 
m_isDeroyedOn
(
l
)

67 
deru
(* 
da
);

69 
ThadIdtifr
 
	gm_idtifr
;

70 
bo
 
	gm_isDeroyedOn
;

71 
had_key_t
 
	gm_key
;

	@ThreadSafeRefCounted.h

59 #ide
ThadSaRefCoued_h


60 
	#ThadSaRefCoued_h


	)

62 
	~<omic
>

63 
	~<wtf/FaMloc.h
>

64 
	~<wtf/Ncyab.h
>

66 
mea
 
	gWTF
 {

68 as
	cThadSaRefCouedBa
 {

69 
WTF_MAKE_NONCOPYABLE
(
ThadSaRefCouedBa
);

70 
	gWTF_MAKE_FAST_ALLOCATED
;

71 
	gpublic
:

72 
ThadSaRefCouedBa
(
lRefCou
 = 1)

73 : 
m_fCou
(
lRefCou
)

77 
f
()

79 ++
m_fCou
;

82 
bo
 
hasORef
()

84  
fCou
() == 1;

87 
fCou
() const

89  
	gm_fCou
;

92 
	geed
:

94 
bo
 
defBa
()

96 i(--
m_fCou
 <= 0) {

97  
ue
;

100  
	gl
;

103 
	give
:

104 
d
::
omic
<> 
m_fCou
;

107 
	gme
<
ass
 
	gT
> cs
	cThadSaRefCoued
 : 
public
 
ThadSaRefCouedBa
 {

108 
public
:

109 
def
()

111 i(
defBa
())

112 
de
 
ic_
<
T
*>(
this
);

115 
	geed
:

116 
ThadSaRefCoued
()

123 
usg
 
	gWTF
::
ThadSaRefCoued
;

	@ThreadSpecific.h

42 #ide
WTF_ThadScific_h


43 
	#WTF_ThadScific_h


	)

45 
	~<wtf/Ncyab.h
>

46 
	~<wtf/StdLibExas.h
>

48 #i
USE
(
PTHREADS
)

49 
	~<had.h
>

50 #i
OS
(
WINDOWS
)

51 
	~<wdows.h
>

54 
mea
 
	gWTF
 {

56 #i
OS
(
WINDOWS
)

59 
ThadScificThadEx
();

62 
	gme
<
tyme
 
	gT
> cs
	cThadScific
 {

63 
WTF_MAKE_NONCOPYABLE
(
ThadScific
);

64 
	gpublic
:

65 
ThadScific
();

66 
bo
 
isS
();

67 
T
* 
	gݔ
->();

68 
ݔ
 
	gT
*();

69 
	gT
& 
	gݔ
*();

71 #i
USE
(
WEB_THREAD
)

72 
a
(
T
*);

75 
	give
:

76 #i
OS
(
WINDOWS
)

77 
nd
 
ThadScificThadEx
();

84 ~
ThadScific
();

86 
T
* 
g
();

87 
t
(
T
*);

88 
deroy
(* 
r
);

90 
	sDa
 {

91 
WTF_MAKE_NONCOPYABLE
(
Da
);

92 
	gpublic
:

93 
Da
(
T
* 
vue
, 
ThadScific
<T>* 
owr
) : value(value), owner(owner) {}

95 
T
* 
	gvue
;

96 
	gThadScific
<
	gT
>* 
	gowr
;

97 #i
OS
(
WINDOWS
)

98 (*
	gderu
)(*);

102 #i
USE
(
PTHREADS
)

103 
had_key_t
 
	gm_key
;

104 #i
OS
(
WINDOWS
)

105 
	gm_dex
;

109 #i
	$USE
(
PTHREADS
)

111 
had_key_t
 
	tThadScificKey
;

113 
le
 
	`thadScificKeyCe
(
ThadScificKey
* 
key
, (*
deru
)(*))

115 
r
 = 
	`had_key_
(
key
, 
deru
);

116 i(
r
)

117 
	`CRASH
();

118 
	}
}

120 
le
 
	$thadScificKeyDe
(
ThadScificKey
 
key
)

122 
r
 = 
	`had_key_de
(
key
);

123 i(
r
)

124 
	`CRASH
();

125 
	}
}

127 
le
 
	$thadScificS
(
ThadScificKey
 
key
, * 
vue
)

129 
	`had_tecific
(
key
, 
vue
);

130 
	}
}

132 
le
 * 
	$thadScificG
(
ThadScificKey
 
key
)

134  
	`had_gecific
(
key
);

135 
	}
}

137 
	gme
<
tyme
 
	gT
>

138 
le
 
	gThadScific
<
	gT
>::
	$ThadScific
()

140 
r
 = 
	`had_key_
(&
m_key
, 
deroy
);

141 i(
r
)

142 
	`CRASH
();

143 
	}
}

145 
	gme
<
tyme
 
	gT
>

146 
le
 
T
* 
	gThadScific
<
	gT
>::
	$g
()

148 
Da
* 
da
 = 
ic_
<Da*>(
	`had_gecific
(
m_key
));

149  
da
 ? da->
vue
 : 0;

150 
	}
}

152 
	gme
<
tyme
 
	gT
>

153 
le
 
	gThadScific
<
	gT
>::
	$t
(
T
* 
r
)

155 
	`ASSERT
(!
	`g
());

156 
	`had_tecific
(
m_key
, 
w
 
	`Da
(
r
, 
this
));

157 
	}
}

159 #i
	$OS
(
WINDOWS
)

164 cڡ 
kMaxTlsKeySize
 = 256;

166 
WTF_EXPORT_PRIVATE
 & 
	`sKeyCou
();

167 
WTF_EXPORT_PRIVATE
 
DWORD
* 
	`sKeys
();

169 
ass
 
PtfmThadScificKey
;

170 
PtfmThadScificKey
* 
	tThadScificKey
;

172 
WTF_EXPORT_PRIVATE
 
	`thadScificKeyCe
(
ThadScificKey
*, (*)(*));

173 
WTF_EXPORT_PRIVATE
 
	`thadScificKeyDe
(
ThadScificKey
);

174 
WTF_EXPORT_PRIVATE
 
	`thadScificS
(
ThadScificKey
, *);

175 
WTF_EXPORT_PRIVATE
 * 
	`thadScificG
(
ThadScificKey
);

177 
me
<
tyme
 
T
>

178 
le
 
ThadScific
<
T
>::
	$ThadScific
()

179 : 
	`m_dex
(-1)

181 
DWORD
 
sKey
 = 
	`TlsAoc
();

182 i(
sKey
 =
TLS_OUT_OF_INDEXES
)

183 
	`CRASH
();

185 
m_dex
 = 
	`IlockedInemt
(&
	`sKeyCou
()) - 1;

186 i(
m_dex
 >
kMaxTlsKeySize
)

187 
	`CRASH
();

188 
	`sKeys
()[
m_dex
] = 
sKey
;

189 
	}
}

191 
	gme
<
tyme
 
	gT
>

192 
le
 
	gThadScific
<
	gT
>::~
	$ThadScific
()

195 
	`TlsFe
(
	`sKeys
()[
m_dex
]);

196 
	}
}

198 
	gme
<
tyme
 
	gT
>

199 
le
 
T
* 
	gThadScific
<
	gT
>::
	$g
()

201 
Da
* 
da
 = 
ic_
<Da*>(
	`TlsGVue
(
	`sKeys
()[
m_dex
]));

202  
da
 ? da->
vue
 : 0;

203 
	}
}

205 
	gme
<
tyme
 
	gT
>

206 
le
 
	gThadScific
<
	gT
>::
	$t
(
T
* 
r
)

208 
	`ASSERT
(!
	`g
());

209 
Da
* 
da
 = 
w
 
	`Da
(
r
, 
this
);

210 
da
->
deru
 = &
ThadScific
<
T
>::
deroy
;

211 
	`TlsSVue
(
	`sKeys
()[
m_dex
], 
da
);

212 
	}
}

215 #r 
ThadScific
 
is
 
n
 
imemd
 
this
 
fm
.

218 
	gme
<
tyme
 
	gT
>

219 
le
 
	gThadScific
<
	gT
>::
	$deroy
(* 
r
)

221 
Da
* 
da
 = 
ic_
<Da*>(
r
);

223 #i
	`USE
(
PTHREADS
)

226 
	`had_tecific
(
da
->
owr
->
m_key
, 
r
);

229 
da
->
vue
->~
	`T
();

230 
	`Fe
(
da
->
vue
);

232 #i
	`USE
(
PTHREADS
)

233 
	`had_tecific
(
da
->
owr
->
m_key
, 0);

234 #i
	`OS
(
WINDOWS
)

235 
	`TlsSVue
(
	`sKeys
()[
da
->
owr
->
m_dex
], 0);

237 #r 
ThadScific
 
is
 
n
 
imemd
 
this
 
fm
.

240 
de
 
da
;

241 
	}
}

243 
	gme
<
tyme
 
	gT
>

244 
le
 
bo
 
	gThadScific
<
	gT
>::
	$isS
()

246  !!
	`g
();

247 
	}
}

249 
	gme
<
tyme
 
	gT
>

250 
le
 
	gThadScific
<
	gT
>::
ݔ
 
T
*()

252 
T
* 
r
 = 
ic_
<T*>(
g
());

253 i(!
	gr
) {

256 
	gr
 = 
ic_
<
T
*>(
ZdMloc
((T)));

257 
t
(
r
);

258 
w
 (
NNu
, 
r

	gT
;

260  
	gr
;

263 
	gme
<
tyme
 
	gT
>

264 
le
 
T
* 
	gThadScific
<
	gT
>::
ݔ
->()

266  
ݔ
 
T
*();

269 
	gme
<
tyme
 
	gT
>

270 
le
 
	gT
& 
	gThadScific
<T>::
ݔ
*()

272  *
ݔ
 
T
*();

275 #i
	$USE
(
WEB_THREAD
)

276 
me
<
tyme
 
T
>

277 
le
 
ThadScific
<
T
>::
	$a
(
T
* 
wP
)

279 
	`ASSERT
(
wP
);

280 
Da
* 
da
 = 
ic_
<Da*>(
	`had_gecific
(
m_key
));

281 
	`ASSERT
(
da
);

282 
da
->
vue
->~
	`T
();

283 
	`Fe
(
da
->
vue
);

284 
da
->
vue
 = 
wP
;

285 
	}
}

	@ThreadSpecificWin.cpp

22 
	~"cfig.h
"

23 
	~"ThadScific.h
"

25 #i
OS
(
WINDOWS
)

27 
	~"StdLibExas.h
"

28 
	~"ThadgPrimives.h
"

29 
	~<wtf/DoublyLkedLi.h
>

31 #i!
USE
(
PTHREADS
)

33 
mea
 
	gWTF
 {

35 
	gDoublyLkedLi
<
	gPtfmThadScificKey
>& 
derusLi
()

37 
	gDoublyLkedLi
<
	gPtfmThadScificKey
> 
	gicLi
;

38  
	gicLi
;

41 
	gMux
& 
derusMux
()

43 
Mux
 
	gicMux
;

44  
	gicMux
;

47 
ass
 
	gPtfmThadScificKey
 : 
public
 
DoublyLkedLiNode
<
PtfmThadScificKey
> {

48 
public
:

49 
nd
 
ass
 
DoublyLkedLiNode
<
PtfmThadScificKey
>;

51 
PtfmThadScificKey
((*
deru
)(*))

52 : 
m_deru
(
deru
)

54 
m_sKey
 = 
TlsAoc
();

55 i(
	gm_sKey
 =
TLS_OUT_OF_INDEXES
)

56 
CRASH
();

59 ~
PtfmThadScificKey
()

61 
TlsFe
(
m_sKey
);

64 
tVue
(* 
da
{ 
TlsSVue
(
m_sKey
, data); }

65 * 
vue
({  
TlsGVue
(
m_sKey
); }

67 
Deru
()

69 i(* 
	gda
 = 
vue
())

70 
m_deru
(
da
);

73 
	give
:

74 (*
m_deru
)(*);

75 
DWORD
 
	gm_sKey
;

76 
PtfmThadScificKey
* 
	gm_ev
;

77 
PtfmThadScificKey
* 
	gm_xt
;

80 & 
sKeyCou
()

82 
	gcou
;

83  
	gcou
;

86 
DWORD
* 
sKeys
()

88 
DWORD
 
	gkeys
[
kMaxTlsKeySize
];

89  
	gkeys
;

92 
thadScificKeyCe
(
ThadScificKey
* 
key
, (*
deru
)(*))

95 *
	gkey
 = 
ic_
<
PtfmThadScificKey
*>(::
mloc
((PlatformThreadSpecificKey)));

96 
w
 (*
key

PtfmThadScificKey
(
deru
);

98 
MuxLock
 
lock
(
derusMux
());

99 
derusLi
().
push
(*
key
);

102 
thadScificKeyDe
(
ThadScificKey
 
key
)

104 
MuxLock
 
lock
(
derusMux
());

105 
derusLi
().
move
(
key
);

106 
	gkey
->~
PtfmThadScificKey
();

107 ::

(
key
);

110 
thadScificS
(
ThadScificKey
 
key
, * 
da
)

112 
	gkey
->
tVue
(
da
);

115 * 
thadScificG
(
ThadScificKey
 
key
)

117  
	gkey
->
vue
();

120 
ThadScificThadEx
()

122 
	gi
 = 0; i < 
sKeyCou
(); i++) {

124 
	gThadScific
<>::
Da
* 
da
 = 
ic_
<
ThadScific
<>::Da*>(
TlsGVue
(
sKeys
()[
i
]));

125 i(
	gda
)

126 
	gda
->
deru
(
da
);

129 
MuxLock
 
lock
(
derusMux
());

130 
PtfmThadScificKey
* 
	gkey
 = 
derusLi
().
hd
();

131 
	gkey
) {

132 
PtfmThadScificKey
* 
	gxtKey
 = 
key
->
xt
();

133 
	gkey
->
Deru
();

134 
	gkey
 = 
xtKey
;

	@Threading.cpp

26 
	~"cfig.h
"

27 
	~"Thadg.h
"

29 
	~<rg.h
>

31 
mea
 
	gWTF
 {

33 
	sNewThadCڋxt
 {

34 
	gWTF_MAKE_FAST_ALLOCATED
;

35 
	gpublic
:

36 
NewThadCڋxt
(
ThadFuni
 
yPot
, * 
da
, cڡ * 
me
)

37 : 
yPot
(entryPoint)

38 , 
da
(data)

39 , 
me
(name)

43 
ThadFuni
 
	gyPot
;

44 * 
	gda
;

45 cڡ * 
	gme
;

47 
Mux
 
	gtiMux
;

50 
thadEryPot
(* 
cڋxtDa
)

52 
NewThadCڋxt
* 
	gcڋxt
 = 
t_
<NewThadCڋxt*>(
cڋxtDa
);

57 
MuxLock
 
lock
(
cڋxt
->
tiMux
);

60 
lizeCutThadIl
(
cڋxt
->
me
);

63 
ThadFuni
 
	gyPot
 = 
cڋxt
->
yPot
;

64 * 
	gda
 = 
cڋxt
->
da
;

65 
de
 
	gcڋxt
;

67 
yPot
(
da
);

70 
ThadIdtifr
 
Thad
(
ThadFuni
 
yPot
, * 
da
, cڡ * 
me
)

74 #i!
LOG_DISABLED
 && 
PLATFORM
(
WIN
)

75 i(
	gme
 && 

(
me
) > 31)

76 
LOG_ERROR
("Thadam\"%s\" ilgh 31 chad wbund by Visu Studio", 
me
);

79 
NewThadCڋxt
* 
	gcڋxt
 = 
w
 NewThadCڋxt(
yPot
, 
da
, 
me
);

82 
MuxLock
 
lock
(
cڋxt
->
tiMux
);

84  
ThadIl
(
thadEryPot
, 
cڋxt
, 
me
);

87 
tCutThadIsUrIaive
()

89 #i
HAVE
(
QOS_CLASSES
)

90 
had_t_qos_ass_lf_
(
QOS_CLASS_USER_INTERACTIVE
, 0);

94 
tCutThadIsUrInd
()

96 #i
HAVE
(
QOS_CLASSES
)

97 
had_t_qos_ass_lf_
(
QOS_CLASS_USER_INITIATED
, 0);

101 #i
PLATFORM
(
MAC
|| PLATFORM(
WIN
)

107 * (*
	tThadFuniWhRuVue
)(* 
	tgumt
);

109 
WTF_EXPORT_PRIVATE
 
ThadIdtifr
 
Thad
(
ThadFuniWhRuVue
 
yPot
, * 
da
, cڡ * 
me
);

111 
	sThadFuniWhRuVueInvoti
 {

112 
ThadFuniWhRuVueInvoti
(
ThadFuniWhRuVue
 
funi
, * 
da
)

113 : 
funi
(function)

114 , 
da
(data)

118 
ThadFuniWhRuVue
 
	gfuni
;

119 * 
	gda
;

122 
comtEryPot
(* 
m
)

125 aut
	gvoti
 = 
d
::
unique_r
<
ThadFuniWhRuVueInvoti
>(
ic_
<ThadFuniWhRuVueInvoti*>(
m
));

126 
	gvoti
->
funi
(
voti
->
da
);

129 
ThadIdtifr
 
Thad
(
ThadFuniWhRuVue
 
yPot
, * 
da
, cڡ * 
me
)

131 aut
	gvoti
 = 
d
::
make_unique
<
ThadFuniWhRuVueInvoti
>(
yPot
, 
	gda
);

134  
Thad
(
comtEryPot
, 
voti
.
a
(), 
me
);

137 
WTF_EXPORT_PRIVATE
 
waFThadComi
(
ThadIdtifr
, **);

139 
waFThadComi
(
ThadIdtifr
 
thadID
, **)

141  
waFThadComi
(
thadID
);

147 
WTF_EXPORT_PRIVATE
 
ThadIdtifr
 
Thad
(
ThadFuniWhRuVue
 
yPot
, * 
da
);

149 
ThadIdtifr
 
Thad
(
ThadFuniWhRuVue
 
yPot
, * 
da
)

151 aut
	gvoti
 = 
d
::
make_unique
<
ThadFuniWhRuVueInvoti
>(
yPot
, 
	gda
);

154  
Thad
(
comtEryPot
, 
voti
.
a
(), 0);

	@Threading.h

59 #ide
Thadg_h


60 
	#Thadg_h


	)

62 
	~<dt.h
>

63 
	~<wtf/Asis.h
>

64 
	~<wtf/Atomics.h
>

65 
	~<wtf/Lock.h
>

66 
	~<wtf/Ncyab.h
>

67 
	~<wtf/ThadSaRefCoued.h
>

68 
	~<wtf/ThadgPrimives.h
>

70 
mea
 
	gWTF
 {

72 
ut32_t
 
	tThadIdtifr
;

73 (*
	gThadFuni
)(* 
	tgumt
);

78 
WTF_EXPORT_PRIVATE
 
lizeThadg
();

82 
WTF_EXPORT_PRIVATE
 
ThadIdtifr
 
Thad
(
ThadFuni
, *, cڡ * 
thadName
);

85 
WTF_EXPORT_PRIVATE
 
tCutThadIsUrIaive
();

87 
WTF_EXPORT_PRIVATE
 
tCutThadIsUrInd
();

90 
ThadIdtifr
 
ThadIl
(
ThadFuni
, *, cڡ * 
thadName
);

94 
lizeCutThadIl
(cڡ * 
thadName
);

96 
WTF_EXPORT_PRIVATE
 
ThadIdtifr
 
cutThad
();

97 
WTF_EXPORT_PRIVATE
 
chgeThadPriܙy
(
ThadIdtifr
, );

98 
WTF_EXPORT_PRIVATE
 
waFThadComi
(
ThadIdtifr
);

99 
WTF_EXPORT_PRIVATE
 
dachThad
(
ThadIdtifr
);

103 
usg
 
	gWTF
::
ThadIdtifr
;

104 
usg
 
	gWTF
::
Thad
;

105 
usg
 
	gWTF
::
cutThad
;

106 
usg
 
	gWTF
::
chgeThadPriܙy
;

107 
usg
 
	gWTF
::
dachThad
;

108 
usg
 
	gWTF
::
waFThadComi
;

	@ThreadingPrimitives.h

31 #ide
ThadgPrimives_h


32 
	#ThadgPrimives_h


	)

34 
	~<wtf/Asis.h
>

35 
	~<wtf/FaMloc.h
>

36 
	~<wtf/Lock.h
>

37 
	~<wtf/Ncyab.h
>

39 #i
OS
(
WINDOWS
)

40 
	~<wdows.h
>

43 #i
USE
(
PTHREADS
)

44 
	~<had.h
>

47 
mea
 
	gWTF
 {

49 #i
USE
(
PTHREADS
)

50 
had_mux_t
 
	tPtfmMux
;

51 
had_cd_t
 
	tPtfmCdi
;

52 #i
OS
(
WINDOWS
)

53 
	sPtfmMux
 {

54 
CRITICAL_SECTION
 
	gm_Mux
;

55 
size_t
 
	gm_cursiCou
;

57 
	sPtfmCdi
 {

58 
size_t
 
	gm_wasGe
;

59 
size_t
 
	gm_wasBlocked
;

60 
size_t
 
	gm_wasToUnblock
;

61 
HANDLE
 
	gm_blockLock
;

62 
HANDLE
 
	gm_blockQueue
;

63 
HANDLE
 
	gm_unblockLock
;

65 
bo
 
timedWa
(
PtfmMux
&, 
DWORD
 
dutiMlicds
);

66 
sigl
(
bo
 
unblockA
);

69 * 
	tPtfmMux
;

70 * 
	tPtfmCdi
;

73 as
	cMux
 {

74 
WTF_MAKE_NONCOPYABLE
(
Mux
); 
	gWTF_MAKE_FAST_ALLOCATED
;

75 
	gpublic
:

76 
WTF_EXPORT_PRIVATE
 
Mux
();

77 
	gWTF_EXPORT_PRIVATE
 ~
Mux
();

79 
WTF_EXPORT_PRIVATE
 
lock
();

80 
WTF_EXPORT_PRIVATE
 
bo
 
yLock
();

81 
WTF_EXPORT_PRIVATE
 
uock
();

83 
	gpublic
:

84 
PtfmMux
& 
im
({  
m_mux
; }

85 
	give
:

86 
PtfmMux
 
m_mux
;

89 
	gLock
<
	tMux
> 
	tMuxLock
;

91 as
	cThadCdi
 {

92 
WTF_MAKE_NONCOPYABLE
(
ThadCdi
);

93 
	gpublic
:

94 
WTF_EXPORT_PRIVATE
 
ThadCdi
();

95 
	gWTF_EXPORT_PRIVATE
 ~
ThadCdi
();

97 
WTF_EXPORT_PRIVATE
 
wa
(
Mux
& 
mux
);

100 
WTF_EXPORT_PRIVATE
 
bo
 
timedWa
(
Mux
&, 
absuTime
);

101 
WTF_EXPORT_PRIVATE
 
sigl
();

102 
WTF_EXPORT_PRIVATE
 
brd
();

104 
	give
:

105 
PtfmCdi
 
m_cdi
;

108 #i
	$OS
(
WINDOWS
)

111 
WTF_EXPORT_PRIVATE
 
DWORD
 
	`absuTimeToWaTimeoutIv
(
absuTime
);

114 
	}
}

116 
usg
 
	gWTF
::
Mux
;

117 
usg
 
	gWTF
::
MuxLock
;

118 
usg
 
	gWTF
::
ThadCdi
;

120 #i
OS
(
WINDOWS
)

121 
usg
 
	gWTF
::
absuTimeToWaTimeoutIv
;

	@ThreadingPthreads.cpp

31 
	~"cfig.h
"

32 
	~"Thadg.h
"

34 #i
USE
(
PTHREADS
)

36 
	~"CutTime.h
"

37 
	~"DeMh.h
"

38 
	~"dt.h
"

39 
	~"dt/ched-pows.h
"

40 
	~"HashM.h
"

41 
	~"RdomNumbSd.h
"

42 
	~"SckSts.h
"

43 
	~"StdLibExas.h
"

44 
	~"ThadFuniInvoti.h
"

45 
	~"ThadIdtifrDaPthads.h
"

46 
	~"ThadScific.h
"

47 
	~<wtf/DaLog.h
>

48 
	~<wtf/RawPor.h
>

49 
	~<wtf/WTFThadDa.h
>

50 
	~<o.h
>

52 #i!
COMPILER
(
MSVC
)

53 
	~<lims.h
>

54 
	~<sched.h
>

55 
	~<sys/time.h
>

58 #i
OS
(
MAC_OS_X
)

59 
	~<objc/objc-auto.h
>

62 
mea
 
	gWTF
 {

64 as
	cPthadS
 {

65 
	gWTF_MAKE_FAST_ALLOCATED
;

66 
	gpublic
:

67 
	eJoabS
 {

68 
Joab
,

70 
	gJoed
,

75 
	gDached


79 
PthadS
(
had_t
 
hd
)

80 : 
m_joabS
(
Joab
)

81 , 
m_didEx
(
l
)

82 , 
m_hadHd
(
hd
)

86 
JoabS
 
joabS
({  
	gm_joabS
; }

87 
had_t
 
hadHd
({  
	gm_hadHd
; }

88 
didBecomeDached
({ 
	gm_joabS
 = 
Dached
; }

89 
didEx
({ 
	gm_didEx
 = 
ue
; }

90 
didJo
({ 
	gm_joabS
 = 
Joed
; }

91 
bo
 
hasExed
({  
	gm_didEx
; }

93 
	give
:

94 
JoabS
 
m_joabS
;

95 
bo
 
	gm_didEx
;

96 
had_t
 
	gm_hadHd
;

99 
	gHashM
<
	tThadIdtifr
, 
	td
::
	tunique_r
<
	tPthadS
>> 
	tThadM
;

101 
unThadWasDached
(
ThadIdtifr
);

102 
thadDidEx
(
ThadIdtifr
);

103 
thadWasJoed
(
ThadIdtifr
);

105 
	gMux
& 
	$thadMMux
()

107 
	`DEPRECATED_DEFINE_STATIC_LOCAL
(
Mux
, 
mux
, ());

108  
mux
;

109 
	}
}

111 
	$lizeThadg
()

113 
bo
 
isInlized
;

115 i(
isInlized
)

118 
isInlized
 = 
ue
;

120 
WTF
::
doub_cvsi
::
	`lize
();

123 
SgIm
::
	`emy
();

124 
	`thadMMux
();

125 
	`lizeRdomNumbG
();

126 
ThadIdtifrDa
::
	`lizeOn
();

127 
SckSts
::
	`lize
();

128 
	`wtfThadDa
();

129 
s_dtP5Mux
 = 
w
 
Mux
;

130 
	`lizeDes
();

131 
	}
}

133 
	gThadM
& 
	$thadM
()

135 
	`DEPRECATED_DEFINE_STATIC_LOCAL
(
ThadM
, 
m
, ());

136  
m
;

137 
	}
}

139 
ThadIdtifr
 
	$idtifrByPthadHd
(cڡ 
had_t
& 
hadHd
)

141 
MuxLock
 
	`lock
(
	`thadMMux
());

143 
ThadM
::

 
i
 = 
	`thadM
().
	`beg
();

144 ; 
i
 !
	`thadM
().
	`d
(); ++i) {

145 i(
	`had_equ
(
i
->
vue
->
	`hadHd
(), 
hadHd
&& !i->vue->
	`hasExed
())

146  
i
->
key
;

150 
	}
}

152 
ThadIdtifr
 
	$eablishIdtifrFPthadHd
(cڡ 
had_t
& 
hadHd
)

154 
	`ASSERT
(!
	`idtifrByPthadHd
(
hadHd
));

155 
MuxLock
 
	`lock
(
	`thadMMux
());

156 
ThadIdtifr
 
idtifrCou
 = 1;

157 
	`thadM
().
	`add
(
idtifrCou
, 
d
::
make_unique
<
PthadS
>(
hadHd
));

158  
idtifrCou
++;

159 
	}
}

161 
had_t
 
	$hadHdFIdtifrWhLockA̗dyHd
(
ThadIdtifr
 
id
)

163  
	`thadM
().
	`g
(
id
)->
	`hadHd
();

164 
	}
}

166 * 
	$wtfThadEryPot
(* 
m
)

169 aut
voti
 = 
d
::
unique_r
<
ThadFuniInvoti
>(
ic_
<ThadFuniInvoti*>(
m
));

170 
voti
->
	`funi
(voti->
da
);

171  
nuαr
;

172 
	}
}

174 
ThadIdtifr
 
	$ThadIl
(
ThadFuni
 
yPot
, * 
da
, const *)

176 aut
voti
 = 
d
::
make_unique
<
ThadFuniInvoti
>(
yPot
, 
da
);

177 
had_t
 
thadHd
;

178 
had__t
 

;

179 
	`had__
(&

);

180 #i
	`HAVE
(
QOS_CLASSES
)

181 
	`had__t_qos_ass_
(&

, 
QOS_CLASS_USER_INITIATED
, 0);

183 
r
 = 
	`had_
(&
thadHd
, &

, 
wtfThadEryPot
, 
voti
.
	`g
());

184 
	`had__deroy
(&

);

185 i(
r
) {

186 
	`LOG_ERROR
("Faedthadyo%wh d%p", 
wtfThadEryPot
, 
voti
.
	`g
());

191 
ThadFuniInvoti
* 
akedInvoti
 = 
voti
.
	`a
();

192 
	`UNUSED_PARAM
(
akedInvoti
);

194  
	`eablishIdtifrFPthadHd
(
thadHd
);

195 
	}
}

197 
	$lizeCutThadIl
(cڡ * 
thadName
)

199 #i
	`HAVE
(
PTHREAD_SETNAME_NP
)

200 
	`had_ame_
(
thadName
);

202 
	`UNUSED_PARAM
(
thadName
);

205 #i
	`OS
(
MAC_OS_X
)

208 
	`objc_giThadWhC
();

211 
ThadIdtifr
 
id
 = 
	`idtifrByPthadHd
(
	`had_lf
());

212 
	`ASSERT
(
id
);

213 
ThadIdtifrDa
::
	`lize
(
id
);

214 
	}
}

216 
	$chgeThadPriܙy
(
ThadIdtifr
 
thadID
, 
d
)

218 
had_t
 
hadHd
;

219 
	`ASSERT
(
thadID
);

222 
MuxLock
 
	`lock
(
	`thadMMux
());

223 
hadHd
 = 
	`hadHdFIdtifrWhLockA̗dyHd
(
thadID
);

224 
	`ASSERT
(
hadHd
);

227 
picy
;

228 
sched_m
 
m
;

230 i(
	`had_gschedm
(
hadHd
, &
picy
, &
m
))

233 
m
.
sched_iܙy
 +
d
;

235 
	`had_tschedm
(
hadHd
, 
picy
, &
m
);

236 
	}
}

238 
	$waFThadComi
(
ThadIdtifr
 
thadID
)

240 
had_t
 
hadHd
;

241 
	`ASSERT
(
thadID
);

245 
MuxLock
 
	`lock
(
	`thadMMux
());

246 
hadHd
 = 
	`hadHdFIdtifrWhLockA̗dyHd
(
thadID
);

247 
	`ASSERT
(
hadHd
);

250 
joResu
 = 
	`had_jo
(
hadHd
, 0);

252 i(
joResu
 =
EDEADLK
)

253 
	`LOG_ERROR
("ThadIdtif%u wafoundbddlockedrygqu", 
thadID
);

254 i(
joResu
)

255 
	`LOG_ERROR
("ThadIdtif%u waubˁbjoed.\n", 
thadID
);

257 
MuxLock
 
	`lock
(
	`thadMMux
());

258 
PthadS
* 
e
 = 
	`thadM
().
	`g
(
thadID
);

259 
	`ASSERT
(
e
);

260 
	`ASSERT
(
e
->
	`joabS
(=
PthadS
::
Joab
);

263 i(
e
->
	`hasExed
())

264 
	`thadM
().
	`move
(
thadID
);

267 
e
->
	`didJo
();

269  
joResu
;

270 
	}
}

272 
	$dachThad
(
ThadIdtifr
 
thadID
)

274 
	`ASSERT
(
thadID
);

276 
MuxLock
 
	`lock
(
	`thadMMux
());

277 
had_t
 
hadHd
 = 
	`hadHdFIdtifrWhLockA̗dyHd
(
thadID
);

278 
	`ASSERT
(
hadHd
);

280 
dachResu
 = 
	`had_dach
(
hadHd
);

281 i(
dachResu
)

282 
	`LOG_ERROR
("ThadIdtif%u waubˁbdached\n", 
thadID
);

284 
PthadS
* 
e
 = 
	`thadM
().
	`g
(
thadID
);

285 
	`ASSERT
(
e
);

286 i(
e
->
	`hasExed
())

287 
	`thadM
().
	`move
(
thadID
);

289 
	`thadM
().
	`g
(
thadID
)->
	`didBecomeDached
();

290 
	}
}

292 
	$thadDidEx
(
ThadIdtifr
 
thadID
)

294 
MuxLock
 
	`lock
(
	`thadMMux
());

295 
PthadS
* 
e
 = 
	`thadM
().
	`g
(
thadID
);

296 
	`ASSERT
(
e
);

298 
e
->
	`didEx
();

300 i(
e
->
	`joabS
(!
PthadS
::
Joab
)

301 
	`thadM
().
	`move
(
thadID
);

302 
	}
}

304 
ThadIdtifr
 
	$cutThad
()

306 
ThadIdtifr
 
id
 = 
ThadIdtifrDa
::
	`idtifr
();

307 i(
id
)

308  
id
;

311 
id
 = 
	`eablishIdtifrFPthadHd
(
	`had_lf
());

312 
ThadIdtifrDa
::
	`lize
(
id
);

313  
id
;

314 
	}
}

316 
	gMux
::
	$Mux
()

318 
had_mux_t
 

;

319 
	`had_mux_
(&

);

320 
	`had_mux_y
(&

, 
PTHREAD_MUTEX_NORMAL
);

322 
su
 = 
	`had_mux_
(&
m_mux
, &

);

323 
	`ASSERT_UNUSED
(
su
, !result);

325 
	`had_mux_deroy
(&

);

326 
	}
}

328 
	gMux
::~
	$Mux
()

330 
su
 = 
	`had_mux_deroy
(&
m_mux
);

331 
	`ASSERT_UNUSED
(
su
, !result);

332 
	}
}

334 
	gMux
::
	$lock
()

336 
su
 = 
	`had_mux_lock
(&
m_mux
);

337 
	`ASSERT_UNUSED
(
su
, !result);

338 
	}
}

340 
bo
 
	gMux
::
	$yLock
()

342 
su
 = 
	`had_mux_ylock
(&
m_mux
);

344 i(
su
 == 0)

345  
ue
;

346 i(
su
 =
EBUSY
)

347  
l
;

349 
	`ASSERT_NOT_REACHED
();

350  
l
;

351 
	}
}

353 
	gMux
::
	$uock
()

355 
su
 = 
	`had_mux_uock
(&
m_mux
);

356 
	`ASSERT_UNUSED
(
su
, !result);

357 
	}
}

359 
	gThadCdi
::
	$ThadCdi
()

361 
	`had_cd_
(&
m_cdi
, 
NULL
);

362 
	}
}

364 
	gThadCdi
::~
	$ThadCdi
()

366 
	`had_cd_deroy
(&
m_cdi
);

367 
	}
}

369 
	gThadCdi
::
	$wa
(
Mux
& 
mux
)

371 
su
 = 
	`had_cd_wa
(&
m_cdi
, &
mux
.
	`im
());

372 
	`ASSERT_UNUSED
(
su
, !result);

373 
	}
}

375 
bo
 
	gThadCdi
::
	$timedWa
(
Mux
& 
mux
, 
absuTime
)

377 i(
absuTime
 < 
	`cutTime
())

378  
l
;

380 i(
absuTime
 > 
INT_MAX
) {

381 
	`wa
(
mux
);

382  
ue
;

385 
timeSecds
 = 
ic_
<>(
absuTime
);

386 
timeNocds
 = 
ic_
<>((
absuTime
 - 
timeSecds
) * 1E9);

388 
timeec
 
rgTime
;

389 
rgTime
.
tv_c
 = 
timeSecds
;

390 
rgTime
.
tv_nc
 = 
timeNocds
;

392  
	`had_cd_timedwa
(&
m_cdi
, &
mux
.
	`im
(), &
rgTime
) == 0;

393 
	}
}

395 
	gThadCdi
::
	$sigl
()

397 
su
 = 
	`had_cd_sigl
(&
m_cdi
);

398 
	`ASSERT_UNUSED
(
su
, !result);

399 
	}
}

401 
	gThadCdi
::
	$brd
()

403 
su
 = 
	`had_cd_brd
(&
m_cdi
);

404 
	`ASSERT_UNUSED
(
su
, !result);

405 
	}
}

	@ThreadingWin.cpp

86 
	~"cfig.h
"

87 
	~"Thadg.h
"

89 #i
OS
(
WINDOWS
)

91 
	~"DeMh.h
"

92 
	~"dt.h
"

93 
	~"dt/ched-pows.h
"

95 
	~"MaThad.h
"

96 
	~"ThadFuniInvoti.h
"

97 
	~<oss.h
>

98 
	~<wdows.h
>

99 
	~<wtf/CutTime.h
>

100 
	~<wtf/HashM.h
>

101 
	~<wtf/MhExas.h
>

102 
	~<wtf/OwnP.h
>

103 
	~<wtf/PassOwnP.h
>

104 
	~<wtf/RdomNumbSd.h
>

105 
	~<wtf/WTFThadDa.h
>

107 #i!
USE
(
PTHREADS
&& 
OS
(
WINDOWS
)

108 
	~"ThadScific.h
"

111 #i
HAVE
(
ERRNO_H
)

112 
	~<o.h
>

115 
mea
 
	gWTF
 {

118 cڡ 
DWORD
 
	gMS_VC_EXCEPTION
 = 0x406D1388;

120 #agm
ck
(
push
, 8)

121 
	sgTHREADNAME_INFO
 {

122 
DWORD
 
	gdwTy
;

123 
LPCSTR
 
	gszName
;

124 
DWORD
 
	gdwThadID
;

125 
DWORD
 
	gdwFgs
;

126 } 
	tTHREADNAME_INFO
;

127 #agm
ck
(
p
)

129 
lizeCutThadIl
(cڡ * 
szThadName
)

131 #i
COMPILER
(
MINGW
)

133 
UNUSED_PARAM
(
szThadName
);

135 
THREADNAME_INFO
 
	gfo
;

136 
	gfo
.
	gdwTy
 = 0x1000;

137 
	gfo
.
	gszName
 = 
szThadName
;

138 
	gfo
.
	gdwThadID
 = 
GCutThadId
();

139 
	gfo
.
	gdwFgs
 = 0;

141 
	g__y
 {

142 
RaiExi
(
MS_VC_EXCEPTION
, 0, (
fo
)/(
ULONG_PTR
), 
t_
<ULONG_PTR*>(&info));

143 } 
__ex
 (
EXCEPTION_CONTINUE_EXECUTION
) {

148 
	gMux
& 
thadMMux
()

150 
Mux
 
	gmux
;

151  
	gmux
;

154 
lizeThadg
()

156 
bo
 
	gisInlized
;

158 i(
	gisInlized
)

161 
	gisInlized
 = 
ue
;

163 
	gWTF
::
doub_cvsi
::
lize
();

166 
	gSgIm
::
emy
();

167 
thadMMux
();

168 
lizeRdomNumbG
();

169 
wtfThadDa
();

170 
	gs_dtP5Mux
 = 
w
 
Mux
;

171 
lizeDes
();

174 
	gHashM
<
	gDWORD
, 
	gHANDLE
>& 
thadM
()

176 
	gHashM
<
	gDWORD
, 
	gHANDLE
> 
	gm
;

177  
	gm
;

180 
eThadHdByIdtifr
(
DWORD
 
thadID
, 
HANDLE
 
thadHd
)

182 
MuxLock
 
lock
(
thadMMux
());

183 
ASSERT
(!
thadM
().
cڏs
(
thadID
));

184 
thadM
().
add
(
thadID
, 
thadHd
);

187 
HANDLE
 
thadHdFIdtifr
(
ThadIdtifr
 
id
)

189 
MuxLock
 
lock
(
thadMMux
());

190  
thadM
().
g
(
id
);

193 
rThadHdFIdtifr
(
ThadIdtifr
 
id
)

195 
MuxLock
 
lock
(
thadMMux
());

196 
ASSERT
(
thadM
().
cڏs
(
id
));

197 
thadM
().
move
(
id
);

200 
__d
 
wtfThadEryPot
(* 
m
)

202 
	gOwnP
<
	gThadFuniInvoti
> 
	gvoti
 = 
adtP
(
ic_
<
ThadFuniInvoti
*>(
m
));

203 
	gvoti
->
funi
(
voti
->
da
);

205 #i!
USE
(
PTHREADS
&& 
OS
(
WINDOWS
)

207 
ThadScificThadEx
();

213 
ThadIdtifr
 
ThadIl
(
ThadFuni
 
yPot
, * 
da
, cڡ * 
thadName
)

215 
	gthadIdtifr
 = 0;

216 
ThadIdtifr
 
	gthadID
 = 0;

217 
	gOwnP
<
	gThadFuniInvoti
> 
	gvoti
 = 
adtP
(
w
 
ThadFuniInvoti
(
yPot
, 
da
));

218 
HANDLE
 
	gthadHd
 = 
t_
<HANDLE>(
_begthadex
(0, 0, 
wtfThadEryPot
, 
voti
.
g
(), 0, &
thadIdtifr
));

219 i(!
	gthadHd
) {

220 #i!
HAVE
(
ERRNO_H
)

221 
LOG_ERROR
("Faedhadyo%wh d%p.", 
yPot
, 
da
);

223 
LOG_ERROR
("Faedhadyo%wh d%p: %ld", 
yPot
, 
da
, 
o
);

229 
ThadFuniInvoti
* 
	gakedInvoti
 = 
voti
.
akP
();

230 
UNUSED_PARAM
(
akedInvoti
);

232 
	gthadID
 = 
ic_
<
ThadIdtifr
>(
thadIdtifr
);

233 
eThadHdByIdtifr
(
thadIdtifr
, 
thadHd
);

235  
	gthadID
;

238 
chgeThadPriܙy
(
ThadIdtifr
 
thadID
, 
d
)

240 
ASSERT
(
thadID
);

242 
HANDLE
 
	gthadHd
 = 
thadHdFIdtifr
(
thadID
);

243 i(!
	gthadHd
)

244 
LOG_ERROR
("ThadIdtif%u d۠n cܻdتivthad", 
thadID
);

246 
SThadPriܙy
(
thadHd
, 
THREAD_PRIORITY_NORMAL
 + 
d
);

249 
waFThadComi
(
ThadIdtifr
 
thadID
)

251 
ASSERT
(
thadID
);

253 
HANDLE
 
	gthadHd
 = 
thadHdFIdtifr
(
thadID
);

254 i(!
	gthadHd
)

255 
LOG_ERROR
("ThadIdtif%u did cܻdتivthad whrygqu", 
thadID
);

257 
DWORD
 
	gjoResu
 = 
WaFSgObje
(
thadHd
, 
INFINITE
);

258 i(
	gjoResu
 =
WAIT_FAILED
)

259 
LOG_ERROR
("ThadIdtif%u wafoundbddlockedrygqu", 
thadID
);

261 
CloHd
(
thadHd
);

262 
rThadHdFIdtifr
(
thadID
);

264  
	gjoResu
;

267 
dachThad
(
ThadIdtifr
 
thadID
)

269 
ASSERT
(
thadID
);

271 
HANDLE
 
	gthadHd
 = 
thadHdFIdtifr
(
thadID
);

272 i(
	gthadHd
)

273 
CloHd
(
thadHd
);

274 
rThadHdFIdtifr
(
thadID
);

277 
ThadIdtifr
 
cutThad
()

279  
	gic_
<
	gThadIdtifr
>(
GCutThadId
());

282 
	gMux
::
Mux
()

284 
m_mux
.
m_cursiCou
 = 0;

285 
InlizeCrilSei
(&
m_mux
.
m_Mux
);

288 
	gMux
::~
Mux
()

290 
DeCrilSei
(&
m_mux
.
m_Mux
);

293 
	gMux
::
lock
()

295 
ECrilSei
(&
m_mux
.
m_Mux
);

296 ++
	gm_mux
.
	gm_cursiCou
;

299 
bo
 
	gMux
::
yLock
()

307 
DWORD
 
su
 = 
TryECrilSei
(&
m_mux
.
m_Mux
);

309 i(
	gsu
 != 0) {

313 i(
m_mux
.
m_cursiCou
 > 0) {

314 
LveCrilSei
(&
m_mux
.
m_Mux
);

315  
	gl
;

318 ++
	gm_mux
.
	gm_cursiCou
;

319  
	gue
;

322  
	gl
;

325 
	gMux
::
uock
()

327 
ASSERT
(
m_mux
.
m_cursiCou
);

328 --
	gm_mux
.
	gm_cursiCou
;

329 
LveCrilSei
(&
m_mux
.
m_Mux
);

332 
bo
 
	gPtfmCdi
::
timedWa
(
PtfmMux
& 
mux
, 
DWORD
 
dutiMlicds
)

335 
DWORD
 
	gs
 = 
WaFSgObje
(
m_blockLock
, 
INFINITE
);

336 
ASSERT_UNUSED
(
s
,e=
WAIT_OBJECT_0
);

337 ++
	gm_wasBlocked
;

338 
	gs
 = 
RSemhe
(
m_blockLock
, 1, 0);

339 
ASSERT_UNUSED
(
s
,es);

341 --
	gmux
.
	gm_cursiCou
;

342 
LveCrilSei
(&
mux
.
m_Mux
);

345 
bo
 
	gtimedOut
 = (
WaFSgObje
(
m_blockQueue
, 
dutiMlicds
=
WAIT_TIMEOUT
);

347 
	gs
 = 
WaFSgObje
(
m_unblockLock
, 
INFINITE
);

348 
ASSERT_UNUSED
(
s
,e=
WAIT_OBJECT_0
);

350 
	gsiglsLe
 = 
m_wasToUnblock
;

352 i(
	gm_wasToUnblock
)

353 --
	gm_wasToUnblock
;

354 i(++
	gm_wasGe
 =(
INT_MAX
 / 2)) {

358 
s
 = 
WaFSgObje
(
m_blockLock
, 
INFINITE
);

359 
ASSERT_UNUSED
(
s
,e=
WAIT_OBJECT_0
);

360 
	gm_wasBlocked
 -
m_wasGe
;

361 
	gs
 = 
RSemhe
(
m_blockLock
, 1, 0);

362 
ASSERT_UNUSED
(
s
,es);

363 
	gm_wasGe
 = 0;

366 
	gs
 = 
RMux
(
m_unblockLock
);

367 
ASSERT_UNUSED
(
s
,es);

369 i(
	gsiglsLe
 == 1) {

370 
s
 = 
RSemhe
(
m_blockLock
, 1, 0);

371 
ASSERT_UNUSED
(
s
,es);

374 
ECrilSei
 (&
mux
.
m_Mux
);

375 ++
	gmux
.
	gm_cursiCou
;

377  !
	gtimedOut
;

380 
	gPtfmCdi
::
sigl
(
bo
 
unblockA
)

382 
siglsToIssue
 = 0;

384 
DWORD
 
	gs
 = 
WaFSgObje
(
m_unblockLock
, 
INFINITE
);

385 
ASSERT_UNUSED
(
s
,e=
WAIT_OBJECT_0
);

387 i(
	gm_wasToUnblock
) {

388 i(!
	gm_wasBlocked
) {

389 
	gs
 = 
RMux
(
m_unblockLock
);

390 
ASSERT_UNUSED
(
s
,es);

394 i(
	gunblockA
) {

395 
	gsiglsToIssue
 = 
m_wasBlocked
;

396 
	gm_wasToUnblock
 +
m_wasBlocked
;

397 
	gm_wasBlocked
 = 0;

399 
	gsiglsToIssue
 = 1;

400 ++
	gm_wasToUnblock
;

401 --
	gm_wasBlocked
;

403 } i(
	gm_wasBlocked
 > 
	gm_wasGe
) {

404 
	gs
 = 
WaFSgObje
(
m_blockLock
, 
INFINITE
);

405 
ASSERT_UNUSED
(
s
,e=
WAIT_OBJECT_0
);

406 i(
	gm_wasGe
 != 0) {

407 
m_wasBlocked
 -
m_wasGe
;

408 
	gm_wasGe
 = 0;

410 i(
	gunblockA
) {

411 
	gsiglsToIssue
 = 
m_wasBlocked
;

412 
	gm_wasToUnblock
 = 
m_wasBlocked
;

413 
	gm_wasBlocked
 = 0;

415 
	gsiglsToIssue
 = 1;

416 
	gm_wasToUnblock
 = 1;

417 --
	gm_wasBlocked
;

420 
	gs
 = 
RMux
(
m_unblockLock
);

421 
ASSERT_UNUSED
(
s
,es);

425 
	gs
 = 
RMux
(
m_unblockLock
);

426 
ASSERT_UNUSED
(
s
,es);

428 i(
	gsiglsToIssue
) {

429 
	gs
 = 
RSemhe
(
m_blockQueue
, 
siglsToIssue
, 0);

430 
ASSERT_UNUSED
(
s
,es);

434 cڡ 
	gMaxSemheCou
 = 
ic_
<>(~0UL >> 1);

436 
	gThadCdi
::
ThadCdi
()

438 
m_cdi
.
m_wasGe
 = 0;

439 
	gm_cdi
.
	gm_wasBlocked
 = 0;

440 
	gm_cdi
.
	gm_wasToUnblock
 = 0;

441 
	gm_cdi
.
	gm_blockLock
 = 
CeSemhe
(0, 1, 1, 0);

442 
	gm_cdi
.
	gm_blockQueue
 = 
CeSemhe
(0, 0, 
MaxSemheCou
, 0);

443 
	gm_cdi
.
	gm_unblockLock
 = 
CeMux
(0, 0, 0);

445 i(!
	gm_cdi
.
	gm_blockLock
 || !m_cdi.
	gm_blockQueue
 || !m_cdi.
	gm_unblockLock
) {

446 i(
	gm_cdi
.
	gm_blockLock
)

447 
CloHd
(
m_cdi
.
m_blockLock
);

448 i(
	gm_cdi
.
	gm_blockQueue
)

449 
CloHd
(
m_cdi
.
m_blockQueue
);

450 i(
	gm_cdi
.
	gm_unblockLock
)

451 
CloHd
(
m_cdi
.
m_unblockLock
);

455 
	gThadCdi
::~
ThadCdi
()

457 
CloHd
(
m_cdi
.
m_blockLock
);

458 
CloHd
(
m_cdi
.
m_blockQueue
);

459 
CloHd
(
m_cdi
.
m_unblockLock
);

462 
	gThadCdi
::
wa
(
Mux
& 
mux
)

464 
m_cdi
.
timedWa
(
mux
.
im
(), 
INFINITE
);

467 
bo
 
	gThadCdi
::
timedWa
(
Mux
& 
mux
, 
absuTime
)

469 
DWORD
 
	grv
 = 
absuTimeToWaTimeoutIv
(
absuTime
);

471 i(!
	grv
) {

474  
	gl
;

477  
	gm_cdi
.
timedWa
(
mux
.
im
(), 
rv
);

480 
	gThadCdi
::
sigl
()

482 
m_cdi
.
sigl
(
l
);

485 
	gThadCdi
::
brd
()

487 
m_cdi
.
sigl
(
ue
);

490 
DWORD
 
absuTimeToWaTimeoutIv
(
absuTime
)

492 
	gcutTime
 = 
WTF
::
cutTime
();

495 i(
	gabsuTime
 < 
	gcutTime
)

499 i(
	gabsuTime
 - 
	gcutTime
 > 
	gic_
<>(
	gINT_MAX
) / 1000.0)

500  
	gINFINITE
;

502  
	gic_
<
	gDWORD
>((
	gabsuTime
 - 
	gcutTime
) * 1000.0);

	@TriState.h

26 #ide
TriS_h


27 
	#TriS_h


	)

29 
mea
 
	gWTF
 {

31 
	eTriS
 {

32 
	gFTriS
,

33 
	gTrueTriS
,

34 
	gMixedTriS


37 
le
 
TriS
 
iS
(
bo
 
boޗn
)

39  
	gic_
<
	gTriS
>(
	gboޗn
);

44 
usg
 
	gWTF
::
TriS
;

45 
usg
 
	gWTF
::
FTriS
;

46 
usg
 
	gWTF
::
TrueTriS
;

47 
usg
 
	gWTF
::
MixedTriS
;

48 
usg
 
	gWTF
::
iS
;

	@UniStdExtras.h

26 #ide
UniStdExas_h


27 
	#UniStdExas_h


	)

29 
	~<o.h
>

30 
	~<unid.h
>

32 
mea
 
	gWTF
 {

34 
le
 
oWhRry
(
feDest
)

36 
	gt
;

37 #i
OS
(
LINUX
)

42 i((
	gt
 = 
o
(
feDest
)=-1 && 
o
 =
EINTR
)

45 (
	gt
 = 
o
(
feDest
)=-1 && 
o
 =
EINTR
) { }

47  
t
;

52 
usg
 
	gWTF
::
oWhRry
;

	@UnionFind.h

26 #ide
UniFd_h


27 
	#UniFd_h


	)

29 
	~<wtf/Asis.h
>

31 
mea
 
	gWTF
 {

62 
	gme
<
tyme
 
	gT
>

63 as
	cUniFd
 {

64 
	gpublic
:

65 
UniFd
()

66 : 
m_
(0)

70 
bo
 
isRo
() const

72 
bo
 
su
 = !
m_
;

73 
ASSERT
(
su
 =(
cڡ_
<
UniFd
<
T
>*>(
this
)->
fd
() ==his));

74  
	gsu
;

77 
T
* 
fd
()

79 
T
* 
	gsu
 = 
ic_
<T*>(
this
);

80 
T
* 
	gxt
 = 
su
->
m_
;

81 
	gxt
) {

82 
	gsu
 = 
xt
;

83 
	gxt
 = 
su
->
m_
;

85 
ASSERT
(
su
);

86 i(
	gsu
 !
this
)

87 
m_
 = 
su
;

88  
	gsu
;

91 
unify
(
T
* 
h
)

93 
T
* 
	ga
 = 
ic_
<T*>(
this
)->
fd
();

94 
T
* 
	gb
 = 
h
->
fd
();

96 
ASSERT
(!
a
->
m_
);

97 
ASSERT
(!
b
->
m_
);

99 i(
	ga
 =
b
)

102 
	ga
->
	gm_
 = 
b
;

104 
	give
:

105 
T
* 
m_
;

110 
usg
 
	gWTF
::
UniFd
;

	@VMTags.h

26 #ide
VMTags_h


27 
	#VMTags_h


	)

31 #i
OS
(
DARWIN
)

33 
	~<mach/vm_iics.h
>

35 #i
defed
(
VM_MEMORY_TCMALLOC
)

36 
	#VM_TAG_FOR_TCMALLOC_MEMORY
 
	`VM_MAKE_TAG
(
VM_MEMORY_TCMALLOC
)

	)

38 
	#VM_TAG_FOR_TCMALLOC_MEMORY
 
	`VM_MAKE_TAG
(53)

	)

41 #i
defed
(
VM_MEMORY_JAVASCRIPT_JIT_EXECUTABLE_ALLOCATOR
)

42 
	#VM_TAG_FOR_EXECUTABLEALLOCATOR_MEMORY
 
	`VM_MAKE_TAG
(
VM_MEMORY_JAVASCRIPT_JIT_EXECUTABLE_ALLOCATOR
)

	)

44 
	#VM_TAG_FOR_EXECUTABLEALLOCATOR_MEMORY
 
	`VM_MAKE_TAG
(64)

	)

47 #i
defed
(
VM_MEMORY_JAVASCRIPT_JIT_REGISTER_FILE
)

48 
	#VM_TAG_FOR_REGISTERFILE_MEMORY
 
	`VM_MAKE_TAG
(
VM_MEMORY_JAVASCRIPT_JIT_REGISTER_FILE
)

	)

50 
	#VM_TAG_FOR_REGISTERFILE_MEMORY
 
	`VM_MAKE_TAG
(65)

	)

53 #i
defed
(
VM_MEMORY_JAVASCRIPT_CORE
)

54 
	#VM_TAG_FOR_COLLECTOR_MEMORY
 
	`VM_MAKE_TAG
(
VM_MEMORY_JAVASCRIPT_CORE
)

	)

56 
	#VM_TAG_FOR_COLLECTOR_MEMORY
 
	`VM_MAKE_TAG
(63)

	)

61 
	#VM_TAG_FOR_TCMALLOC_MEMORY
 -1

	)

62 
	#VM_TAG_FOR_COLLECTOR_MEMORY
 -1

	)

63 
	#VM_TAG_FOR_EXECUTABLEALLOCATOR_MEMORY
 -1

	)

64 
	#VM_TAG_FOR_REGISTERFILE_MEMORY
 -1

	)

	@ValueCheck.h

26 #ide
VueCheck_h


27 
	#VueCheck_h


	)

29 
	~<wtf/FaMloc.h
>

31 
mea
 
	gWTF
 {

33 
	gme
<
tyme
 
	gT
> 
	sVueCheck
 {

34 
T
 
	tTTy
;

35 
checkCsicy
(cڡ 
T
&) { }

38 #i!
ASSERT_DISABLED


39 
	gme
<
tyme
 
	gP
> 
	gVueCheck
<P*> {

40 
P
* 
	tTTy
;

41 
checkCsicy
(cڡ 
P
* 
p
)

43 i(!
	gp
)

45 
ASSERT
(
MlocSize
(
p
));

46 
	gVueCheck
<
	gP
>::
checkCsicy
(*
p
);

	@Vector.h

21 #ide
WTF_Ve_h


22 
	#WTF_Ve_h


	)

24 
	~<liz_li
>

25 
	~<lims
>

26 
	~<rg.h
>

27 
	~<ty_as
>

28 
	~<uty
>

29 
	~<wtf/CheckedArhmic.h
>

30 
	~<wtf/FaMloc.h
>

31 
	~<wtf/MlocP.h
>

32 
	~<wtf/Ncyab.h
>

33 
	~<wtf/StdLibExas.h
>

34 
	~<wtf/VueCheck.h
>

35 
	~<wtf/VeTs.h
>

37 
mea
 
	gWTF
 {

39 cڡ 
size_t
 
	gnFound
 = 
ic_
<size_t>(-1);

41 
	gme
 <
bo
 
	gedsDerui
, 
tyme
 
	gT
>

42 
	gVeDeru
;

44 
	gme
<
tyme
 
	gT
>

45 
	gVeDeru
<
	gl
, 
	gT
>

47 
deru
(
T
*, T*) {}

50 
	gme
<
tyme
 
	gT
>

51 
	gVeDeru
<
	gue
, 
	gT
>

53 
deru
(
T
* 
beg
, T* 
d
)

55 
T
* 
	gcur
 = 
beg
; cu!
d
; ++cur)

56 
	gcur
->~
T
();

60 
	gme
 <
bo
 
	gedsInlizi
, bo 
	gnInlizeWhMemt
, 
tyme
 
	gT
>

61 
	gVeInliz
;

63 
	gme
<
bo
 
	gigne
, 
tyme
 
	gT
>

64 
	gVeInliz
<
	gl
, 
	gigne
, 
	gT
>

66 
lize
(
T
*, T*) {}

69 
	gme
<
tyme
 
	gT
>

70 
	gVeInliz
<
	gue
, 
	gl
, 
	gT
>

72 
lize
(
T
* 
beg
, T* 
d
)

74 
T
* 
	gcur
 = 
beg
; cu!
d
; ++cur)

75 
w
 (
NNu
, 
cur

	gT
;

79 
	gme
<
tyme
 
	gT
>

80 
	gVeInliz
<
	gue
,rue, 
	gT
>

82 
lize
(
T
* 
beg
, T* 
d
)

84 
memt
(
beg
, 0, 
t_
<*>(
d
) -einterpret_cast<*>(begin));

88 
	gme
 <
bo
 
	gnMoveWhMemy
, 
tyme
 
	gT
>

89 
	gVeMov
;

91 
	gme
<
tyme
 
	gT
>

92 
	gVeMov
<
	gl
, 
	gT
>

94 
move
(
T
* 
c
, T* 
cEnd
, T* 
d
)

96 
	gc
 !
cEnd
) {

97 
w
 (
NNu
, 
d

T
(
WTF
::
move
(*
c
));

98 
	gc
->~
T
();

99 ++
	gd
;

100 ++
	gc
;

103 
moveOvϵg
(
T
* 
c
, T* 
cEnd
, T* 
d
)

105 i(
	gc
 > 
	gd
)

106 
move
(
c
, 
cEnd
, 
d
);

108 
T
* 
	gdEnd
 = 
d
 + (
cEnd
 - 
c
);

109 
	gc
 !
cEnd
) {

110 --
cEnd
;

111 --
	gdEnd
;

112 
w
 (
NNu
, 
dEnd

T
(
WTF
::
move
(*
cEnd
));

113 
	gcEnd
->~
T
();

119 
	gme
<
tyme
 
	gT
>

120 
	gVeMov
<
	gue
, 
	gT
>

122 
move
(cڡ 
T
* 
c
, cڡ T* 
cEnd
, T* 
d
)

124 
memy
(
d
, 
c
, 
t_
<cڡ *>(
cEnd
) -einterpret_cast<const *>(src));

126 
moveOvϵg
(cڡ 
T
* 
c
, cڡ T* 
cEnd
, T* 
d
)

128 
memmove
(
d
, 
c
, 
t_
<cڡ *>(
cEnd
) -einterpret_cast<const *>(src));

132 
	gme
 <
bo
 
	gnCyWhMemy
, 
tyme
 
	gT
>

133 
	gVeCݛr
;

135 
	gme
<
tyme
 
	gT
>

136 
	gVeCݛr
<
	gl
, 
	gT
>

138 
	gme
<
tyme
 
	gU
>

139 
unlizedCy
(cڡ 
T
* 
c
, cڡ T* 
cEnd
, 
U
* 
d
)

141 
	gc
 !
cEnd
) {

142 
w
 (
NNu
, 
d

U
(*
c
);

143 ++
	gd
;

144 ++
	gc
;

149 
	gme
<
tyme
 
	gT
>

150 
	gVeCݛr
<
	gue
, 
	gT
>

152 
unlizedCy
(cڡ 
T
* 
c
, cڡ T* 
cEnd
, T* 
d
)

154 
memy
(
d
, 
c
, 
t_
<cڡ *>(
cEnd
) -einterpret_cast<const *>(src));

156 
	gme
<
tyme
 
	gU
>

157 
unlizedCy
(cڡ 
T
* 
c
, cڡ T* 
cEnd
, 
U
* 
d
)

159 
	gVeCݛr
<
	gl
, 
	gT
>::
unlizedCy
(
c
, 
cEnd
, 
d
);

163 
	gme
 <
bo
 
	gnFlWhMemt
, 
tyme
 
	gT
>

164 
	gVeFr
;

166 
	gme
<
tyme
 
	gT
>

167 
	gVeFr
<
	gl
, 
	gT
>

169 
unlizedFl
(
T
* 
d
, T* 
dEnd
, cڡ T& 
v
)

171 
	gd
 !
dEnd
) {

172 
w
 (
NNu
, 
d

T
(
v
);

173 ++
	gd
;

178 
	gme
<
tyme
 
	gT
>

179 
	gVeFr
<
	gue
, 
	gT
>

181 
unlizedFl
(
T
* 
d
, T* 
dEnd
, cڡ T& 
v
)

183 
ic_as
((
T
) == 1, "Size ofype T should bequalo one!");

184 #i
COMPILER
(
GCC
&& 
defed
(
_FORTIFY_SOURCE
)

185 i(!
__but_cڡt_p
(
dEnd
 - 
d
|| (!(
	gdEnd
 - 
	gd
)))

187 
memt
(
d
, 
v
, 
dEnd
 - dst);

191 
	gme
<
bo
 
	gnComWhMemcmp
, 
tyme
 
	gT
>

192 
	gVeComr
;

194 
	gme
<
tyme
 
	gT
>

195 
	gVeComr
<
	gl
, 
	gT
>

197 
bo
 
com
(cڡ 
T
* 
a
, cڡ T* 
b
, 
size_t
 
size
)

199 
size_t
 
	gi
 = 0; i < 
	gsize
; ++i)

200 i(!(
	ga
[
i
] =
b
[i]))

201  
l
;

202  
	gue
;

206 
	gme
<
tyme
 
	gT
>

207 
	gVeComr
<
	gue
, 
	gT
>

209 
bo
 
com
(cڡ 
T
* 
a
, cڡ T* 
b
, 
size_t
 
size
)

211  
memcmp
(
a
, 
b
, (
T
* 
size
) == 0;

215 
	gme
<
tyme
 
	gT
>

216 
	sVeTyOtis


218 
deru
(
T
* 
beg
, T* 
d
)

220 
	gVeDeru
<!
	gd
::
is_ivy_deruib
<
T
>::
vue
, 
	gT
>::
deru
(
beg
, 
d
);

223 
lize
(
T
* 
beg
, T* 
d
)

225 
	gVeInliz
<
	gVeTs
<
	gT
>::
edsInlizi
, VeTs<T>::
nInlizeWhMemt
, T>::
lize
(
beg
, 
d
);

228 
move
(
T
* 
c
, T* 
cEnd
, T* 
d
)

230 
	gVeMov
<
	gVeTs
<
	gT
>::
nMoveWhMemy
, T>::
move
(
c
, 
cEnd
, 
d
);

233 
moveOvϵg
(
T
* 
c
, T* 
cEnd
, T* 
d
)

235 
	gVeMov
<
	gVeTs
<
	gT
>::
nMoveWhMemy
, T>::
moveOvϵg
(
c
, 
cEnd
, 
d
);

238 
unlizedCy
(cڡ 
T
* 
c
, cڡ T* 
cEnd
, T* 
d
)

240 
	gVeCݛr
<
	gVeTs
<
	gT
>::
nCyWhMemy
, T>::
unlizedCy
(
c
, 
cEnd
, 
d
);

243 
unlizedFl
(
T
* 
d
, T* 
dEnd
, cڡ T& 
v
)

245 
	gVeFr
<
	gVeTs
<
	gT
>::
nFlWhMemt
, T>::
unlizedFl
(
d
, 
dEnd
, 
v
);

248 
bo
 
com
(cڡ 
T
* 
a
, cڡ T* 
b
, 
size_t
 
size
)

250  
	gVeComr
<
	gVeTs
<
	gT
>::
nComWhMemcmp
, T>::
com
(
a
, 
b
, 
size
);

254 
	gme
<
tyme
 
	gT
>

255 as
	cVeBufrBa
 {

256 
WTF_MAKE_NONCOPYABLE
(
VeBufrBa
);

257 
	gpublic
:

258 
loBufr
(
size_t
 
wCacy
)

260 
ASSERT
(
wCacy
);

261 i(
	gwCacy
 > 
	gd
::
numic_lims
<>::
max
(/ (
T
))

262 
CRASH
();

263 
size_t
 
	gsizeToAo
 = 
MlocGoodSize
(
wCacy
 * (
T
));

264 
	gm_cy
 = 
sizeToAo
 / (
T
);

265 
	gm_bufr
 = 
ic_
<
T
*>(
Mloc
(
sizeToAo
));

268 
bo
 
yAoBufr
(
size_t
 
wCacy
)

270 
ASSERT
(
wCacy
);

271 i(
	gwCacy
 > 
	gd
::
numic_lims
<>::
max
(/ (
T
))

272  
l
;

274 
size_t
 
	gsizeToAo
 = 
MlocGoodSize
(
wCacy
 * (
T
));

275 
T
* 
	gwBufr
;

276 i(
yFaMloc
(
sizeToAo
).
gVue
(
wBufr
)) {

277 
	gm_cy
 = 
sizeToAo
 / (
T
);

278 
	gm_bufr
 = 
wBufr
;

279  
	gue
;

281  
	gl
;

284 
bo
 
shouldRoBufr
(
size_t
 
wCacy
) const

286  
	gVeTs
<
	gT
>::
nMoveWhMemy
 && 
m_cy
 && 
wCacy
;

289 
loBufr
(
size_t
 
wCacy
)

291 
ASSERT
(
shouldRoBufr
(
wCacy
));

292 i(
	gwCacy
 > 
	gd
::
numic_lims
<
size_t
>::
max
(/ (
T
))

293 
CRASH
();

294 
size_t
 
	gsizeToAo
 = 
MlocGoodSize
(
wCacy
 * (
T
));

295 
	gm_cy
 = 
sizeToAo
 / (
T
);

296 
	gm_bufr
 = 
ic_
<
T
*>(
Roc
(
m_bufr
, 
sizeToAo
));

299 
doBufr
(
T
* 
bufrToDo
)

301 i(!
	gbufrToDo
)

304 i(
	gm_bufr
 =
bufrToDo
) {

305 
m_bufr
 = 0;

306 
	gm_cy
 = 0;

309 
Fe
(
bufrToDo
);

312 
T
* 
bufr
({  
	gm_bufr
; }

313 cڡ 
T
* 
bufr
(cڡ {  
	gm_bufr
; }

314 
rdiff_t
 
bufrMemyOfft
({  
OBJECT_OFFSETOF
(
VeBufrBa
, 
m_bufr
); }

315 
size_t
 
cy
(cڡ {  
	gm_cy
; }

317 
	gMlocP
<
	gT
> 
aBufr
()

319 
T
* 
	gbufr
 = 
m_bufr
;

320 
	gm_bufr
 = 0;

321 
	gm_cy
 = 0;

322  
adtMlocP
(
bufr
);

325 
	geed
:

326 
VeBufrBa
()

327 : 
m_bufr
(0)

328 , 
m_cy
(0)

329 , 
m_size
(0)

333 
VeBufrBa
(
T
* 
bufr
, 
size_t
 
cy
, size_
size
)

334 : 
m_bufr
(
bufr
)

335 , 
m_cy
(
cy
)

336 , 
m_size
(
size
)

340 ~
VeBufrBa
()

345 
T
* 
	gm_bufr
;

346 
	gm_cy
;

347 
	gm_size
;

350 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

351 
ass
 
	gVeBufr
;

353 
	gme
<
tyme
 
	gT
>

354 
ass
 
	gVeBufr
<
	gT
, 0> : 
ive
 
VeBufrBa
<
T
> {

355 
ive
:

356 
VeBufrBa
<
	tT
> 
	tBa
;

357 
	gpublic
:

358 
VeBufr
()

362 
VeBufr
(
size_t
 
cy
, size_
size
 = 0)

364 
m_size
 = 
size
;

367 i(
	gcy
)

368 
loBufr
(
cy
);

371 ~
VeBufr
()

373 
doBufr
(
bufr
());

376 
sw
(
VeBufr
<
T
, 0>& 
h
, 
size_t
, size_t)

378 
	gd
::
sw
(
m_bufr
, 
h
.m_buffer);

379 
	gd
::
sw
(
m_cy
, 
h
.m_capacity);

382 
eIƚeBufrIfNded
() { }

384 
usg
 
	gBa
::
loBufr
;

385 
usg
 
	gBa
::
yAoBufr
;

386 
usg
 
	gBa
::
shouldRoBufr
;

387 
usg
 
	gBa
::
loBufr
;

388 
usg
 
	gBa
::
doBufr
;

390 
usg
 
	gBa
::
bufr
;

391 
usg
 
	gBa
::
cy
;

392 
usg
 
	gBa
::
bufrMemyOfft
;

394 
usg
 
	gBa
::
aBufr
;

396 
	geed
:

397 
usg
 
Ba
::
m_size
;

399 
	give
:

400 
usg
 
Ba
::
m_bufr
;

401 
usg
 
	gBa
::
m_cy
;

404 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
>

405 
ass
 
	gVeBufr
 : 
ive
 
VeBufrBa
<
T
> {

406 
WTF_MAKE_NONCOPYABLE
(
VeBufr
);

407 
	give
:

408 
VeBufrBa
<
	tT
> 
	tBa
;

409 
	gpublic
:

410 
VeBufr
()

411 : 
Ba
(
leBufr
(), 
leCacy
, 0)

415 
VeBufr
(
size_t
 
cy
, size_
size
 = 0)

416 : 
Ba
(
leBufr
(), 
leCacy
, 
size
)

418 i(
	gcy
 > 
	gleCacy
)

419 
	gBa
::
loBufr
(
cy
);

422 ~
VeBufr
()

424 
doBufr
(
bufr
());

427 
loBufr
(
size_t
 
wCacy
)

430 i(
	gwCacy
 > 
	gleCacy
)

431 
	gBa
::
loBufr
(
wCacy
);

433 
	gm_bufr
 = 
leBufr
();

434 
	gm_cy
 = 
leCacy
;

438 
bo
 
yAoBufr
(
size_t
 
wCacy
)

440 i(
	gwCacy
 > 
	gleCacy
)

441  
	gBa
::
yAoBufr
(
wCacy
);

442 
	gm_bufr
 = 
leBufr
();

443 
	gm_cy
 = 
leCacy
;

444  
	gue
;

447 
doBufr
(
T
* 
bufrToDo
)

449 i(
	gbufrToDo
 =
leBufr
())

451 
	gBa
::
doBufr
(
bufrToDo
);

454 
bo
 
shouldRoBufr
(
size_t
 
wCacy
) const

457  
	gBa
::
shouldRoBufr
(
wCacy
&& 
d
::
m
(
ic_
<
size_t
>(
m_cy
),ewCacy> 
	gleCacy
;

460 
loBufr
(
size_t
 
wCacy
)

462 
ASSERT
(
shouldRoBufr
(
wCacy
));

463 
	gBa
::
loBufr
(
wCacy
);

466 
sw
(
VeBufr
& 
h
, 
size_t
 
mySize
, size_
hSize
)

468 i(
bufr
(=
leBufr
(&& 
h
.buffer() == other.inlineBuffer()) {

469 
swIƚeBufr
(
h
, 
mySize
, 
hSize
);

470 
	gd
::
sw
(
m_cy
, 
h
.m_capacity);

471 } i(
bufr
(=
leBufr
()) {

472 
m_bufr
 = 
h
.m_buffer;

473 
	gh
.
	gm_bufr
 = 
h
.
leBufr
();

474 
swIƚeBufr
(
h
, 
mySize
, 0);

475 
	gd
::
sw
(
m_cy
, 
h
.m_capacity);

476 } i(
	gh
.
bufr
(=
h
.
leBufr
()) {

477 
h
.
m_bufr
 = m_buffer;

478 
	gm_bufr
 = 
leBufr
();

479 
swIƚeBufr
(
h
, 0, 
hSize
);

480 
	gd
::
sw
(
m_cy
, 
h
.m_capacity);

482 
	gd
::
sw
(
m_bufr
, 
h
.m_buffer);

483 
	gd
::
sw
(
m_cy
, 
h
.m_capacity);

487 
eIƚeBufrIfNded
()

489 i(
	gm_bufr
)

491 
	gm_bufr
 = 
leBufr
();

492 
	gm_cy
 = 
leCacy
;

495 
usg
 
	gBa
::
bufr
;

496 
usg
 
	gBa
::
cy
;

497 
usg
 
	gBa
::
bufrMemyOfft
;

499 
	gMlocP
<
	gT
> 
aBufr
()

501 i(
bufr
(=
leBufr
())

502  
nuαr
;

503  
	gBa
::
aBufr
();

506 
	geed
:

507 
usg
 
Ba
::
m_size
;

509 
	give
:

510 
usg
 
Ba
::
m_bufr
;

511 
usg
 
	gBa
::
m_cy
;

513 
swIƚeBufr
(
VeBufr
& 
h
, 
size_t
 
mySize
, size_
hSize
)

518 i(
	gd
::
is_pod
<
T
>::
vue
)

519 
d
::
sw
(
m_leBufr
, 
h
.m_inlineBuffer);

521 
swIƚeBufrs
(
leBufr
(), 
h
.leBufr(), 
mySize
, 
hSize
);

524 
swIƚeBufrs
(
T
* 

, T* 
right
, 
size_t
 
Size
, size_
rightSize
)

526 i(
	g
 =
right
)

529 
ASSERT
(
Size
 <
leCacy
);

530 
ASSERT
(
rightSize
 <
leCacy
);

532 
size_t
 
	gswBound
 = 
d
::
m
(
Size
, 
rightSize
);

533 
	gi
 = 0; i < 
	gswBound
; ++i)

534 
	gd
::
sw
(

[
i
], 
right
[i]);

535 
	gVeTyOtis
<
	gT
>::
move
(

 + 
swBound
,e + 
Size
, 
right
 + swapBound);

536 
	gVeTyOtis
<
	gT
>::
move
(
right
 + 
swBound
,igh+ 
rightSize
, 

 + swapBound);

539 
T
* 
leBufr
({  
	gt__r
<
	gT
*>(
	gm_leBufr
); }

540 cڡ 
T
* 
leBufr
(cڡ {  
	gt__r
<cڡ 
	gT
*>(
	gm_leBufr
); }

542 
tyme
 
	gd
::
igd_age
<(
T
), std::
ignmt_of
<T>::
vue
>::
ty
 
m_leBufr
[
leCacy
];

545 
	sUnVeOvow
 {

546 
NO_RETURN_DUE_TO_ASSERT
 
ovowed
()

548 
ASSERT_NOT_REACHED
();

552 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
 = 0,ym
	gOvowHdr
 = 
CshOnOvow
>

553 
ass
 
Ve
 : 
ive
 
VeBufr
<
T
, 
	gleCacy
> {

554 
	gWTF_MAKE_FAST_ALLOCATED
;

555 
	give
:

556 
VeBufr
<
	tT
, 
	tleCacy
> 
	tBa
;

557 
	gVeTyOtis
<
	tT
> 
	tTyOtis
;

559 
	gpublic
:

560 
T
 
	tVueTy
;

562 
T
* 
	t
;

563 cڡ 
	tT
* 
	tcڡ_
;

564 
	gd
::
	tv_
<
	t
>everse_iterator;

565 
	gd
::
	tv_
<
	tcڡ_
> 
	tcڡ_v_
;

567 
Ve
()

572 
exic
 
Ve
(
size_t
 
size
)

573 : 
Ba
(
size
, size)

575 i(
beg
())

576 
	gTyOtis
::
lize
(
beg
(), 
d
());

579 
Ve
(
size_t
 
size
, cڡ 
T
& 
v
)

580 : 
Ba
(
size
, size)

582 i(
beg
())

583 
	gTyOtis
::
unlizedFl
(
beg
(), 
d
(), 
v
);

586 
Ve
(
d
::
liz_li
<
T
> 
lizLi
)

588 
rveInlCacy
(
lizLi
.
size
());

589 cڡuto& 
	gemt
 : 
lizLi
)

590 
uncheckedAd
(
emt
);

593 ~
Ve
()

595 i(
	gm_size
)

596 
shrk
(0);

599 
Ve
(const Vector&);

600 
	gme
<
size_t
 
	ghCacy
, 
tyme
 
	ghOvowBehaviour
>

601 
Ve
(cڡ Ve<
T
, 
hCacy
, 
hOvowBehaviour
>&);

603 
	gVe
& 
	gݔ
=(cڡ 
Ve
&);

604 
	gme
<
size_t
 
	ghCacy
, 
tyme
 
	ghOvowBehaviour
>

605 
	gVe
& 
	gݔ
=(cڡ 
Ve
<
T
, 
	ghCacy
, 
	ghOvowBehaviour
>&);

607 
Ve
(Vector&&);

608 
	gVe
& 
	gݔ
=(
Ve
&&);

610 
size_t
 
size
(cڡ {  
	gm_size
; }

611 
rdiff_t
 
sizeMemyOfft
({  
OBJECT_OFFSETOF
(
Ve
, 
m_size
); }

612 
size_t
 
cy
(cڡ {  
	gBa
::capacity(); }

613 
bo
 
isEmy
(cڡ {  !
size
(); }

615 
	gT
& 

(
size_t
 
i
)

617 i(
UNLIKELY
(
i
 >
size
()))

618 
OvowHdr
::
ovowed
();

619  
	gBa
::
bufr
()[
i
];

621 cڡ 
	gT
& 

(
size_t
 
i
) const

623 i(
UNLIKELY
(
i
 >
size
()))

624 
OvowHdr
::
ovowed
();

625  
	gBa
::
bufr
()[
i
];

627 
	gT
& 

(
Checked
<
size_t
> 
i
)

629 
RELEASE_ASSERT
(
i
 < 
size
());

630  
	gBa
::
bufr
()[
i
];

632 cڡ 
	gT
& 

(
Checked
<
size_t
> 
i
) const

634 
RELEASE_ASSERT
(
i
 < 
size
());

635  
	gBa
::
bufr
()[
i
];

638 
	gT
& 
	gݔ
[](
size_t
 
	gi
{  

(
i
); }

639 cڡ 
	gT
& 
	gݔ
[](
size_t
 
	gi
cڡ {  

(
i
); }

640 
	gT
& 
	gݔ
[](
	gChecked
<
	gsize_t
> 
	gi
{  

(
i
); }

641 cڡ 
	gT
& 
	gݔ
[](
	gChecked
<
	gsize_t
> 
	gi
cڡ {  

(
i
); }

643 
T
* 
da
({  
	gBa
::
bufr
(); }

644 cڡ 
T
* 
da
(cڡ {  
	gBa
::
bufr
(); }

645 
rdiff_t
 
daMemyOfft
({  
	gBa
::
bufrMemyOfft
(); }

647 

 
beg
({  
da
(); }

648 

 
d
({  
beg
(+ 
	gm_size
; }

649 
cڡ_
 
beg
(cڡ {  
da
(); }

650 
cڡ_
 
d
(cڡ {  
beg
(+ 
	gm_size
; }

652 
v_
 
rbeg
({ ev_(
d
()); }

653 
v_
 
nd
({ ev_(
beg
()); }

654 
cڡ_v_
 
rbeg
(cڡ {  cڡ_v_(
d
()); }

655 
cڡ_v_
 
nd
(cڡ {  cڡ_v_(
beg
()); }

657 
	gT
& 
f
({  

(0); }

658 cڡ 
	gT
& 
f
(cڡ {  

(0); }

659 
	gT
& 
ϡ
({  

(
size
() - 1); }

660 cڡ 
	gT
& 
ϡ
(cڡ {  

(
size
() - 1); }

662 
T
 
keLa
()

664 
T
 
	gsu
 = 
WTF
::
move
(
ϡ
());

665 
moveLa
();

666  
	gsu
;

669 
	gme
<
tyme
 
	gU
> 
bo
 
cڏs
(cڡ 
U
&) const;

670 
	gme
<
tyme
 
	gU
> 
size_t
 
fd
(cڡ 
U
&) const;

671 
	gme
<
tyme
 
	gU
> 
size_t
 
vFd
(cڡ 
U
&) const;

673 
shrk
(
size_t
 
size
);

674 
grow
(
size_t
 
size
);

675 
size
(
size_t
 
size
);

676 
sizeToF
(
size_t
 
size
);

677 
rveCacy
(
size_t
 
wCacy
);

678 
bo
 
yRerveCacy
(
size_t
 
wCacy
);

679 
rveInlCacy
(
size_t
 
lCacy
);

680 
shrkCacy
(
size_t
 
wCacy
);

681 
shrkToF
({ 
shrkCacy
(
size
()); }

683 
r
({ 
shrkCacy
(0); }

685 
	gme
<
tyme
 
	gU
> 
nd
(cڡ 
U
*, 
size_t
);

686 
	gme
<
tyme
 
	gU
> 
nd
(
U
&&);

687 
	gme
<
tyme
 
	gU
> 
uncheckedAd
(
U
&& 
v
);

688 
	gme
<
tyme
 
	gU
, 
size_t
 
	ghCacy
> 
ndVe
(cڡ 
Ve
<
U
, 
hCacy
>&);

689 
	gme
<
tyme
 
	gU
> 
bo
 
yAd
(cڡ 
U
*, 
size_t
);

691 
	gme
<
tyme
 
	gU
> 

(
size_t
 
posi
, cڡ 
U
*, size_t);

692 
	gme
<
tyme
 
	gU
> 

(
size_t
 
posi
, 
U
&&);

693 
	gme
<
tyme
 
	gU
, 
size_t
 
	gc
> 
Ve
(size_
posi
, cڡ 
Ve
<
U
, 
c
>&);

695 
move
(
size_t
 
posi
);

696 
move
(
size_t
 
posi
, size_
ngth
);

698 
moveLa
()

700 i(
UNLIKELY
(
isEmy
()))

701 
	gOvowHdr
::
ovowed
();

702 
shrk
(
size
() - 1);

705 
fl
(cڡ 
T
&, 
size_t
);

706 
fl
(cڡ 
T
& 
v
{ fl(v, 
size
()); }

708 
	gme
<
tyme
 
	gIt
> 
ndRge
(
It
 
t
, It 
d
);

710 
	gMlocP
<
	gT
> 
aBufr
();

712 
sw
(
Ve
<
T
, 
leCacy
, 
OvowHdr
>& 
h
)

714 
	gBa
::
sw
(
h
, 
m_size
, other.m_size);

715 
	gd
::
sw
(
m_size
, 
h
.m_size);

718 
v
();

720 
checkCsicy
();

722 
	give
:

723 
exndCacy
(
size_t
 
wMCacy
);

724 
T
* 
exndCacy
(
size_t
 
wMCacy
, T*);

725 
bo
 
yExndCacy
(
size_t
 
wMCacy
);

726 cڡ 
T
* 
yExndCacy
(
size_t
 
wMCacy
, const T*);

727 
	gme
<
tyme
 
	gU
> 
U
* 
exndCacy
(
size_t
 
wMCacy
, U*);

728 
	gme
<
tyme
 
	gU
> 
ndSlowCa
(
U
&&);

730 
usg
 
	gBa
::
m_size
;

731 
usg
 
	gBa
::
bufr
;

732 
usg
 
	gBa
::
cy
;

733 
usg
 
	gBa
::
sw
;

734 
usg
 
	gBa
::
loBufr
;

735 
usg
 
	gBa
::
doBufr
;

736 
usg
 
	gBa
::
yAoBufr
;

737 
usg
 
	gBa
::
shouldRoBufr
;

738 
usg
 
	gBa
::
loBufr
;

739 
usg
 
	gBa
::
eIƚeBufrIfNded
;

740 
usg
 
	gBa
::
aBufr
;

743 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

744 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$Ve
(cڡ 
Ve
& 
h
)

745 : 
	`Ba
(
h
.
	`cy
(), oth.
	$size
())

747 i(
	`beg
())

748 
TyOtis
::
	`unlizedCy
(
h
.
	`beg
(), oth.
	`d
(), begin());

749 
	}
}

751 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

752 
	gme
<
size_t
 
	ghCacy
, 
tyme
 
	ghOvowBehaviour
>

753 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
Ve
(cڡ Ve<
T
, 
hCacy
, 
hOvowBehaviour
>& 
h
)

754 : 
Ba
(
h
.
cy
(), oth.
	$size
())

756 i(
	`beg
())

757 
TyOtis
::
	`unlizedCy
(
h
.
	`beg
(), oth.
	`d
(), begin());

758 
	}
}

760 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

761 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>& Ve<T, iƚeCacy, OvowHdr>::
ݔ
=(cڡ 
Ve
<
T
, iƚeCacy, OvowHdr>& 
	gh
)

763 i(&
	gh
 =
this
)

764  *
this
;

766 i(
size
(> 
	gh
.size())

767 
shrk
(
h
.
size
());

768 i(
	gh
.
size
(> 
cy
()) {

769 
r
();

770 
rveCacy
(
h
.
size
());

771 
ASSERT
(
beg
());

774 
	gd
::
cy
(
h
.
beg
(), oth.beg(+ 
size
(), begin());

775 
	gTyOtis
::
unlizedCy
(
h
.
beg
(+ 
size
(), oth.
d
(),nd());

776 
	gm_size
 = 
h
.
size
();

778  *
	gthis
;

781 
le
 
bo
 
	$tyssPorsAEqu
(cڡ * 
a
, cڡ * 
b
{  =b; 
	}
}

783 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

784 
	gme
<
size_t
 
	ghCacy
, 
tyme
 
	ghOvowBehaviour
>

785 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>& Ve<T, iƚeCacy, OvowHdr>::
ݔ
=(cڡ 
Ve
<
T
, 
	ghCacy
, 
	ghOvowBehaviour
>& 
	gh
)

790 
ASSERT
(!
tyssPorsAEqu
(&
h
, 
this
));

792 i(
size
(> 
	gh
.size())

793 
shrk
(
h
.
size
());

794 i(
	gh
.
size
(> 
cy
()) {

795 
r
();

796 
rveCacy
(
h
.
size
());

797 
ASSERT
(
beg
());

800 
	gd
::
cy
(
h
.
beg
(), oth.beg(+ 
size
(), begin());

801 
	gTyOtis
::
unlizedCy
(
h
.
beg
(+ 
size
(), oth.
d
(),nd());

802 
	gm_size
 = 
h
.
size
();

804  *
	gthis
;

807 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

808 
le
 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
Ve
(Ve<
T
, 
leCacy
, 
OvowHdr
>&& 
h
)

810 
sw
(
h
);

813 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

814 
le
 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>& Ve<T, iƚeCacy, OvowHdr>::
ݔ
=(
Ve
<
T
, iƚeCacy, OvowHdr>&& 
	gh
)

816 
sw
(
h
);

817  *
	gthis
;

820 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

821 
	gme
<
tyme
 
	gU
>

822 
bo
 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$cڏs
(cڡ 
U
& 
vue
) const

824  
	`fd
(
vue
!
nFound
;

825 
	}
}

827 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

828 
	gme
<
tyme
 
	gU
>

829 
size_t
 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$fd
(cڡ 
U
& 
vue
) const

831 
size_t
 
i
 = 0; i < 
	`size
(); ++i) {

832 i(
	`
(
i
=
vue
)

833  
i
;

835  
nFound
;

836 
	}
}

838 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

839 
	gme
<
tyme
 
	gU
>

840 
size_t
 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$vFd
(cڡ 
U
& 
vue
) const

842 
size_t
 
i
 = 1; i <
	`size
(); ++i) {

843 cڡ 
size_t
 
dex
 = 
	`size
(- 
i
;

844 i(
	`
(
dex
=
vue
)

845  
dex
;

847  
nFound
;

848 
	}
}

850 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

851 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$fl
(cڡ 
T
& 
v
, 
size_t
 
wSize
)

853 i(
	`size
(> 
wSize
)

854 
	`shrk
(
wSize
);

855 i(
wSize
 > 
	`cy
()) {

856 
	`r
();

857 
	`rveCacy
(
wSize
);

858 
	`ASSERT
(
	`beg
());

861 
d
::
	`fl
(
	`beg
(), 
	`d
(), 
v
);

862 
TyOtis
::
	`unlizedFl
(
	`d
(), 
	`beg
(+ 
wSize
, 
v
);

863 
m_size
 = 
wSize
;

864 
	}
}

866 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

867 
	gme
<
tyme
 
	gIt
>

868 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$ndRge
(
It
 
t
, It 
d
)

870 
It
 

 = 
t
; i!
d
; ++it)

871 
	`nd
(*

);

872 
	}
}

874 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

875 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$exndCacy
(
size_t
 
wMCacy
)

877 
	`rveCacy
(
d
::
	`max
(
wMCacy
, std::max(
ic_
<
size_t
>(16), 
	`cy
() + capacity() / 4 + 1)));

878 
	}
}

880 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

881 
T
* 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$exndCacy
(
size_t
 
wMCacy
, 
T
* 
r
)

883 i(
r
 < 
	`beg
(|| >
	`d
()) {

884 
	`exndCacy
(
wMCacy
);

885  
r
;

887 
size_t
 
dex
 = 
r
 - 
	`beg
();

888 
	`exndCacy
(
wMCacy
);

889  
	`beg
(+ 
dex
;

890 
	}
}

892 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

893 
bo
 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$yExndCacy
(
size_t
 
wMCacy
)

895  
	`yRerveCacy
(
d
::
	`max
(
wMCacy
, std::max(
ic_
<
size_t
>(16), 
	`cy
() + capacity() / 4 + 1)));

896 
	}
}

898 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

899 cڡ 
T
* 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$yExndCacy
(
size_t
 
wMCacy
, cڡ 
T
* 
r
)

901 i(
r
 < 
	`beg
(|| >
	`d
()) {

902 i(!
	`yExndCacy
(
wMCacy
))

904  
r
;

906 
size_t
 
dex
 = 
r
 - 
	`beg
();

907 i(!
	`yExndCacy
(
wMCacy
))

909  
	`beg
(+ 
dex
;

910 
	}
}

912 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>eme<tym
	gU
>

913 
le
 
U
* 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$exndCacy
(
size_t
 
wMCacy
, 
U
* 
r
)

915 
	`exndCacy
(
wMCacy
);

916  
r
;

917 
	}
}

919 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

920 
le
 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$size
(
size_t
 
size
)

922 i(
size
 <
m_size
)

923 
TyOtis
::
	`deru
(
	`beg
(+ 
size
, 
	`d
());

925 i(
size
 > 
	`cy
())

926 
	`exndCacy
(
size
);

927 i(
	`beg
())

928 
TyOtis
::
	`lize
(
	`d
(), 
	`beg
(+ 
size
);

931 
m_size
 = 
size
;

932 
	}
}

934 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

935 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$sizeToF
(
size_t
 
size
)

937 
	`rveCacy
(
size
);

938 
	`size
(
size
);

939 
	}
}

941 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

942 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$shrk
(
size_t
 
size
)

944 
	`ASSERT
(
size
 <
m_size
);

945 
TyOtis
::
	`deru
(
	`beg
(+ 
size
, 
	`d
());

946 
m_size
 = 
size
;

947 
	}
}

949 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

950 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$grow
(
size_t
 
size
)

952 
	`ASSERT
(
size
 >
m_size
);

953 i(
size
 > 
	`cy
())

954 
	`exndCacy
(
size
);

955 i(
	`beg
())

956 
TyOtis
::
	`lize
(
	`d
(), 
	`beg
(+ 
size
);

957 
m_size
 = 
size
;

958 
	}
}

960 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

961 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$rveCacy
(
size_t
 
wCacy
)

963 i(
wCacy
 <
	`cy
())

965 
T
* 
dBufr
 = 
	`beg
();

966 
T
* 
dEnd
 = 
	`d
();

967 
Ba
::
	`loBufr
(
wCacy
);

968 
	`ASSERT
(
	`beg
());

969 
TyOtis
::
	`move
(
dBufr
, 
dEnd
, 
	`beg
());

970 
Ba
::
	`doBufr
(
dBufr
);

971 
	}
}

973 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

974 
bo
 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$yRerveCacy
(
size_t
 
wCacy
)

976 i(
wCacy
 <
	`cy
())

977  
ue
;

978 
T
* 
dBufr
 = 
	`beg
();

979 
T
* 
dEnd
 = 
	`d
();

980 i(!
Ba
::
	`yAoBufr
(
wCacy
))

981  
l
;

982 
	`ASSERT
(
	`beg
());

983 
TyOtis
::
	`move
(
dBufr
, 
dEnd
, 
	`beg
());

984 
Ba
::
	`doBufr
(
dBufr
);

985  
ue
;

986 
	}
}

988 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

989 
le
 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$rveInlCacy
(
size_t
 
lCacy
)

991 
	`ASSERT
(!
m_size
);

992 
	`ASSERT
(
	`cy
(=
leCacy
);

993 i(
lCacy
 > 
leCacy
)

994 
Ba
::
	`loBufr
(
lCacy
);

995 
	}
}

997 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

998 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$shrkCacy
(
size_t
 
wCacy
)

1000 i(
wCacy
 >
	`cy
())

1003 i(
wCacy
 < 
	`size
())

1004 
	`shrk
(
wCacy
);

1006 
T
* 
dBufr
 = 
	`beg
();

1007 i(
wCacy
 > 0) {

1008 i(
Ba
::
	`shouldRoBufr
(
wCacy
)) {

1009 
Ba
::
	`loBufr
(
wCacy
);

1013 
T
* 
dEnd
 = 
	`d
();

1014 
Ba
::
	`loBufr
(
wCacy
);

1015 i(
	`beg
(!
dBufr
)

1016 
TyOtis
::
	`move
(
dBufr
, 
dEnd
, 
	`beg
());

1019 
Ba
::
	`doBufr
(
dBufr
);

1020 
Ba
::
	`eIƚeBufrIfNded
();

1021 
	}
}

1026 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>eme<tym
	gU
>

1027 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$nd
(cڡ 
U
* 
da
, 
size_t
 
daSize
)

1029 
size_t
 
wSize
 = 
m_size
 + 
daSize
;

1030 i(
wSize
 > 
	`cy
()) {

1031 
da
 = 
	`exndCacy
(
wSize
, data);

1032 
	`ASSERT
(
	`beg
());

1034 i(
wSize
 < 
m_size
)

1035 
	`CRASH
();

1036 
T
* 
de
 = 
	`d
();

1037 
VeCݛr
<
d
::
is_ivl
<
T
>::
vue
, 
U
>::
	`unlizedCy
(
da
, &da[
daSize
], 
de
);

1038 
m_size
 = 
wSize
;

1039 
	}
}

1041 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>eme<tym
	gU
>

1042 
bo
 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$yAd
(cڡ 
U
* 
da
, 
size_t
 
daSize
)

1044 
size_t
 
wSize
 = 
m_size
 + 
daSize
;

1045 i(
wSize
 > 
	`cy
()) {

1046 
da
 = 
	`yExndCacy
(
wSize
, data);

1047 i(!
da
)

1048  
l
;

1049 
	`ASSERT
(
	`beg
());

1051 i(
wSize
 < 
m_size
)

1052  
l
;

1053 
T
* 
de
 = 
	`d
();

1054 
VeCݛr
<
d
::
is_ivl
<
T
>::
vue
, 
U
>::
	`unlizedCy
(
da
, &da[
daSize
], 
de
);

1055 
m_size
 = 
wSize
;

1056  
ue
;

1057 
	}
}

1059 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>eme<tym
	gU
>

1060 
ALWAYS_INLINE
 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$nd
(
U
&& 
vue
)

1062 i(
	`size
(!
	`cy
()) {

1063 
	`w
 (
NNu
, 
	`d
()
	`T
(
d
::
fwd
<
U
>(
vue
));

1064 ++
m_size
;

1068 
	`ndSlowCa
(
d
::
fwd
<
U
>(
vue
));

1069 
	}
}

1071 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>eme<tym
	gU
>

1072 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$ndSlowCa
(
U
&& 
vue
)

1074 
	`ASSERT
(
	`size
(=
	`cy
());

1076 aut
r
 = 
cڡ_
<
tyme
 
d
::
move_cڡ
<tymd::
move_n
<
U
>::
ty
>::ty*>(d::
	`addssof
(
vue
));

1077 
r
 = 
	`exndCacy
(
	`size
() + 1,tr);

1078 
	`ASSERT
(
	`beg
());

1080 
	`w
 (
NNu
, 
	`d
()
	`T
(
d
::
fwd
<
U
>(*
r
));

1081 ++
m_size
;

1082 
	}
}

1087 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>eme<tym
	gU
>

1088 
le
 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$uncheckedAd
(
U
&& 
vue
)

1090 
	`ASSERT
(
	`size
(< 
	`cy
());

1092 aut
r
 = 
d
::
	`addssof
(
vue
);

1093 
	`w
 (
NNu
, 
	`d
()
	`T
(
d
::
fwd
<
U
>(*
r
));

1094 ++
m_size
;

1095 
	}
}

1097 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>eme<tym
	gU
, size_
	ghCacy
>

1098 
le
 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
ndVe
(cڡ 
Ve
<
U
, 
hCacy
>& 
v
)

1100 
nd
(
v
.
beg
(), v.
size
());

1103 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>eme<tym
	gU
>

1104 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$
(
size_t
 
posi
, cڡ 
U
* 
da
, size_
daSize
)

1106 
	`ASSERT_WITH_SECURITY_IMPLICATION
(
posi
 <
	`size
());

1107 
size_t
 
wSize
 = 
m_size
 + 
daSize
;

1108 i(
wSize
 > 
	`cy
()) {

1109 
da
 = 
	`exndCacy
(
wSize
, data);

1110 
	`ASSERT
(
	`beg
());

1112 i(
wSize
 < 
m_size
)

1113 
	`CRASH
();

1114 
T
* 

 = 
	`beg
(+ 
posi
;

1115 
TyOtis
::
	`moveOvϵg
(

, 
	`d
(), sp + 
daSize
);

1116 
VeCݛr
<
d
::
is_ivl
<
T
>::
vue
, 
U
>::
	`unlizedCy
(
da
, &da[
daSize
], 

);

1117 
m_size
 = 
wSize
;

1118 
	}
}

1120 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>eme<tym
	gU
>

1121 
le
 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$
(
size_t
 
posi
, 
U
&& 
vue
)

1123 
	`ASSERT_WITH_SECURITY_IMPLICATION
(
posi
 <
	`size
());

1125 aut
r
 = 
cڡ_
<
tyme
 
d
::
move_cڡ
<tymd::
move_n
<
U
>::
ty
>::ty*>(d::
	`addssof
(
vue
));

1126 i(
	`size
(=
	`cy
()) {

1127 
r
 = 
	`exndCacy
(
	`size
() + 1,tr);

1128 
	`ASSERT
(
	`beg
());

1131 
T
* 

 = 
	`beg
(+ 
posi
;

1132 
TyOtis
::
	`moveOvϵg
(

, 
	`d
(), spot + 1);

1133 
	`w
 (
NNu
, 


	`T
(
d
::
fwd
<
U
>(*
r
));

1134 ++
m_size
;

1135 
	}
}

1137 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>eme<tym
	gU
, size_
	gc
>

1138 
le
 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
Ve
(
size_t
 
posi
, cڡ 
Ve
<
U
, 
c
>& 
v
)

1140 

(
posi
, 
v
.
beg
(), v.
size
());

1143 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

1144 
le
 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$move
(
size_t
 
posi
)

1146 
	`ASSERT_WITH_SECURITY_IMPLICATION
(
posi
 < 
	`size
());

1147 
T
* 

 = 
	`beg
(+ 
posi
;

1148 

->~
	`T
();

1149 
TyOtis
::
	`moveOvϵg
(

 + 1, 
	`d
(), spot);

1150 --
m_size
;

1151 
	}
}

1153 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

1154 
le
 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$move
(
size_t
 
posi
, size_
ngth
)

1156 
	`ASSERT_WITH_SECURITY_IMPLICATION
(
posi
 <
	`size
());

1157 
	`ASSERT_WITH_SECURITY_IMPLICATION
(
posi
 + 
ngth
 <
	`size
());

1158 
T
* 
begSp
 = 
	`beg
(+ 
posi
;

1159 
T
* 
dSp
 = 
begSp
 + 
ngth
;

1160 
TyOtis
::
	`deru
(
begSp
, 
dSp
);

1161 
TyOtis
::
	`moveOvϵg
(
dSp
, 
	`d
(), 
begSp
);

1162 
m_size
 -
ngth
;

1163 
	}
}

1165 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

1166 
le
 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$v
()

1168 
size_t
 
i
 = 0; i < 
m_size
 / 2; ++i)

1169 
d
::
	`sw
(
	`
(
i
),t(
m_size
 - 1 - i));

1170 
	}
}

1172 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

1173 
le
 
	gMlocP
<
	gT
> 
	gVe
<T, 
	gleCacy
, 
	gOvowHdr
>::
	$aBufr
()

1175 aut
bufr
 = 
Ba
::
	`aBufr
();

1176 i(
leCacy
 && !
bufr
 && 
m_size
) {

1180 
size_t
 
bys
 = 
m_size
 * (
T
);

1181 
bufr
 = 
	`adtMlocP
(
ic_
<
T
*>(
	`Mloc
(
bys
)));

1182 
	`memy
(
bufr
.
	`g
(), 
	`da
(), 
bys
);

1184 
m_size
 = 0;

1185  
bufr
;

1186 
	}
}

1188 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

1189 
le
 
	gVe
<
	gT
, 
	gleCacy
, 
	gOvowHdr
>::
	$checkCsicy
()

1191 #i!
ASSERT_DISABLED


1192 
size_t
 
i
 = 0; i < 
	`size
(); ++i)

1193 
VueCheck
<
T
>::
	`checkCsicy
(
	`
(
i
));

1195 
	}
}

1197 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

1198 
le
 
sw
(
Ve
<
T
, 
leCacy
, 
OvowHdr
>& 
a
, Ve<T, iƚeCacy, OvowHdr>& 
b
)

1200 
	ga
.
sw
(
b
);

1203 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

1204 
bo
 
	gݔ
==(cڡ 
Ve
<
T
, 
	gleCacy
, 
	gOvowHdr
>& 
	ga
, cڡ 
	gVe
<
	gT
, iƚeCacy, OvowHdr>& 
	gb
)

1206 i(
	ga
.
size
(!
b
.size())

1207  
l
;

1209  
	gVeTyOtis
<
	gT
>::
com
(
a
.
da
(), 
b
.da(),.
size
());

1212 
	gme
<
tyme
 
	gT
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

1213 
le
 
bo
 
	gݔ
!=(cڡ 
Ve
<
T
, 
	gleCacy
, 
	gOvowHdr
>& 
	ga
, cڡ 
	gVe
<
	gT
, iƚeCacy, OvowHdr>& 
	gb
)

1215  !(
	ga
 =
b
);

1218 #i!
ASSERT_DISABLED


1219 
	gme
<
tyme
 
	gT
> 
	gVueCheck
<
	gVe
<T>> {

1220 
	gVe
<
	tT
> 
	tTTy
;

1221 
checkCsicy
(cڡ 
Ve
<
T
>& 
v
)

1223 
	gv
.
checkCsicy
();

1230 
usg
 
	gWTF
::
Ve
;

1231 
usg
 
	gWTF
::
UnVeOvow
;

1232 
usg
 
	gWTF
::
nFound
;

	@VectorTraits.h

21 #ide
WTF_VeTs_h


22 
	#WTF_VeTs_h


	)

24 
	~<wtf/OwnP.h
>

25 
	~<wtf/Ref.h
>

26 
	~<wtf/RefP.h
>

27 
	~<uty
>

28 
	~<memy
>

30 
mea
 
	gWTF
 {

32 
ass
 
	gAtomicSg
;

34 
	gme
<
bo
 
	gisPod
, 
tyme
 
	gT
>

35 
	gVeTsBa
;

37 
	gme
<
tyme
 
	gT
>

38 
	gVeTsBa
<
	gl
, 
	gT
>

40 cڡ 
bo
 
	gedsInlizi
 = 
ue
;

41 cڡ 
bo
 
	gnInlizeWhMemt
 = 
l
;

42 cڡ 
bo
 
	gnMoveWhMemy
 = 
l
;

43 cڡ 
bo
 
	gnCyWhMemy
 = 
l
;

44 cڡ 
bo
 
	gnFlWhMemt
 = 
l
;

45 cڡ 
bo
 
	gnComWhMemcmp
 = 
l
;

48 
	gme
<
tyme
 
	gT
>

49 
	gVeTsBa
<
	gue
, 
	gT
>

51 cڡ 
bo
 
	gedsInlizi
 = 
l
;

52 cڡ 
bo
 
	gnInlizeWhMemt
 = 
l
;

53 cڡ 
bo
 
	gnMoveWhMemy
 = 
ue
;

54 cڡ 
bo
 
	gnCyWhMemy
 = 
ue
;

55 cڡ 
bo
 
	gnFlWhMemt
 = (
T
) == ();

56 cڡ 
bo
 
	gnComWhMemcmp
 = 
ue
;

59 
	gme
<
tyme
 
	gT
>

60 
	gVeTs
 : 
VeTsBa
<
d
::
is_pod
<
T
>::
vue
, 
	gT
> { };

62 
	gSimeCssVeTs
 : 
VeTsBa
<
l
, >

64 cڡ 
bo
 
	gnInlizeWhMemt
 = 
ue
;

65 cڡ 
bo
 
	gnMoveWhMemy
 = 
ue
;

66 cڡ 
bo
 
	gnComWhMemcmp
 = 
ue
;

71 
	gme
<
tyme
 
	gP
>

72 
	gVeTs
<
	gRefP
<
	gP
>> : 
SimeCssVeTs
 { };

74 
	gme
<
tyme
 
	gP
>

75 
	gVeTs
<
	gOwnP
<
	gP
>> : 
SimeCssVeTs
 { };

77 
	gme
<
tyme
 
	gP
>

78 
	gVeTs
<
	gd
::
unique_r
<
P
>> : 
SimeCssVeTs
 { };

80 
	gme
<
tyme
 
	gP
>

81 
	gVeTs
<
	gRef
<
	gP
>> : 
SimeCssVeTs
 { };

83 
	gme
<>

84 
	gVeTs
<
	gAtomicSg
> : 
SimeCssVeTs
 { };

86 
	gme
<
tyme
 
	gF
,ym
	gSecd
>

87 
	gVeTs
<
	gd
::

<
F
, 
	gSecd
>>

89 
	gVeTs
<
	tF
> 
	tFTs
;

90 
	gVeTs
<
	tSecd
> 
	tSecdTs
;

92 cڡ 
bo
 
	gedsInlizi
 = 
FTs
::
edsInlizi
 || 
SecdTs
::needsInitialization;

93 cڡ 
bo
 
	gnInlizeWhMemt
 = 
FTs
::
nInlizeWhMemt
 && 
SecdTs
::canInitializeWithMemset;

94 cڡ 
bo
 
	gnMoveWhMemy
 = 
FTs
::
nMoveWhMemy
 && 
SecdTs
::canMoveWithMemcpy;

95 cڡ 
bo
 
	gnCyWhMemy
 = 
FTs
::
nCyWhMemy
 && 
SecdTs
::canCopyWithMemcpy;

96 cڡ 
bo
 
	gnFlWhMemt
 = 
l
;

97 cڡ 
bo
 
	gnComWhMemcmp
 = 
FTs
::
nComWhMemcmp
 && 
SecdTs
::canCompareWithMemcmp;

102 
usg
 
	gWTF
::
VeTs
;

103 
usg
 
	gWTF
::
SimeCssVeTs
;

	@WTFThreadData.cpp

27 
	~"cfig.h
"

28 
	~"WTFThadDa.h
"

30 
	~<wtf/xt/AtomicSgTab.h
>

32 #i
USE
(
WEB_THREAD
)

33 
	~<wtf/MaThad.h
>

36 
mea
 
	gWTF
 {

38 #i!
USE
(
PTHREAD_GETSPECIFIC_DIRECT
)

39 
	gThadScific
<
	gWTFThadDa
>* WTFThadDa::
icDa
;

42 
	gWTFThadDa
::
WTFThadDa
()

43 : 
m_iDa
(0)

44 , 
m_cutAtomicSgTab
(0)

45 , 
m_deuAtomicSgTab
(0)

46 , 
m_omicSgTabDeru
(0)

47 , 
m_ackBounds
(
SckBounds
::
cutThadSckBounds
())

48 #i
ENABLE
(
STACK_STATS
)

49 , 
m_ackSts
()

51 , 
m_vedSckPorAtVMEry
(0)

52 , 
m_vedLaSckT
(
ack
().
ig
())

54 
	gAtomicSgTab
::

(*
this
);

55 
	gm_cutAtomicSgTab
 = 
m_deuAtomicSgTab
;

58 
	gWTFThadDa
::~
WTFThadDa
()

60 i(
m_omicSgTabDeru
)

61 
m_omicSgTabDeru
(
m_deuAtomicSgTab
);

64 #i
USE
(
PTHREAD_GETSPECIFIC_DIRECT
)

65 
	gWTFThadDa
& WTFThadDa::
AndRegiFGecificDe
()

67 
WTFThadDa
* 
da
 = 
w
 WTFThreadData;

68 
_had_tecific_de
(
deKey
, 
da
);

69 
had_key__
(
deKey
, [](* 
da
){

70 
de
 
ic_
<
WTFThadDa
*>(
da
);

72  *
	gda
;

	@WTFThreadData.h

27 #ide
WTFThadDa_h


28 
	#WTFThadDa_h


	)

30 
	~<wtf/HashM.h
>

31 
	~<wtf/HashS.h
>

32 
	~<wtf/Ncyab.h
>

33 
	~<wtf/SckBounds.h
>

34 
	~<wtf/SckSts.h
>

35 
	~<wtf/xt/SgHash.h
>

37 #i
OS
(
DARWIN
)

38 #i
defed
(
__has_ude
&& __has_ude(<
Syem
/
had_machd
.
h
>)

39 
	~<Syem/had_machd.h
>

43 #i
defed
(
__PTK_FRAMEWORK_JAVASCRIPTCORE_KEY1
)

44 
	#WTF_USE_PTHREAD_GETSPECIFIC_DIRECT
 1

	)

47 #i!
USE
(
PTHREAD_GETSPECIFIC_DIRECT
)

48 
	~<wtf/ThadScific.h
>

49 
	~<wtf/Thadg.h
>

52 
mea
 
	gWTF
 {

54 
ass
 
	gAtomicSgTab
;

56 (*
	gAtomicSgTabDeru
)(
	tAtomicSgTab
*);

58 as
	cWTFThadDa
 {

59 
WTF_MAKE_NONCOPYABLE
(
WTFThadDa
);

60 
	gpublic
:

61 
WTF_EXPORT_PRIVATE
 
WTFThadDa
();

62 
	gWTF_EXPORT_PRIVATE
 ~
WTFThadDa
();

64 
AtomicSgTab
* 
omicSgTab
()

66  
	gm_cutAtomicSgTab
;

69 
AtomicSgTab
* 
tCutAtomicSgTab
(AtomicSgTab* 
omicSgTab
)

71 
AtomicSgTab
* 
	gdAtomicSgTab
 = 
m_cutAtomicSgTab
;

72 
	gm_cutAtomicSgTab
 = 
omicSgTab
;

73  
	gdAtomicSgTab
;

76 
tCutAtomicSgTab
()

78 
	gm_cutAtomicSgTab
 = 
m_deuAtomicSgTab
;

81 cڡ 
	gSckBounds
& 
ack
()

85 #i
OS
(
WINDOWS
)

86 
	gm_ackBounds
 = 
SckBounds
::
cutThadSckBounds
();

88  
	gm_ackBounds
;

91 #i
ENABLE
(
STACK_STATS
)

92 
	gSckSts
::
PThadSts
& 
ackSts
()

94  
m_ackSts
;

98 * 
vedSckPorAtVMEry
()

100  
	gm_vedSckPorAtVMEry
;

103 
tSavedSckPorAtVMEry
(* 
ackPorAtVMEry
)

105 
	gm_vedSckPorAtVMEry
 = 
ackPorAtVMEry
;

108 * 
vedLaSckT
()

110  
	gm_vedLaSckT
;

113 
tSavedLaSckT
(* 
ϡSckT
)

115 
	gm_vedLaSckT
 = 
ϡSckT
;

118 * 
	gm_iDa
;

120 
	give
:

121 
AtomicSgTab
* 
m_cutAtomicSgTab
;

122 
AtomicSgTab
* 
	gm_deuAtomicSgTab
;

123 
AtomicSgTabDeru
 
	gm_omicSgTabDeru
;

125 
SckBounds
 
	gm_ackBounds
;

126 #i
ENABLE
(
STACK_STATS
)

127 
	gSckSts
::
PThadSts
 
m_ackSts
;

129 * 
	gm_vedSckPorAtVMEry
;

130 * 
	gm_vedLaSckT
;

132 #i
USE
(
PTHREAD_GETSPECIFIC_DIRECT
)

133 cڡ 
had_key_t
 
	gdeKey
 = 
__PTK_FRAMEWORK_JAVASCRIPTCORE_KEY1
;

134 
WTF_EXPORT_PRIVATE
 
	gWTFThadDa
& 
AndRegiFGecificDe
();

136 
WTF_EXPORTDATA
 
	gThadScific
<
	gWTFThadDa
>* 
	gicDa
;

139 
nd
 
	gWTFThadDa
& 
wtfThadDa
();

140 
nd
 
ass
 
	gAtomicSgTab
;

143 
le
 
	gWTFThadDa
& 
	$wtfThadDa
()

151 #i!
	`USE
(
PTHREAD_GETSPECIFIC_DIRECT
)

152 i(!
WTFThadDa
::
icDa
)

153 
WTFThadDa
::
icDa
 = 
w
 
ThadScific
<WTFThreadData>;

154  **
WTFThadDa
::
icDa
;

156 i(
WTFThadDa
* 
da
 = 
ic_
<WTFThadDa*>(
	`_had_gecific_de
(WTFThadDa::
deKey
)))

157  *
da
;

158  
WTFThadDa
::
	`AndRegiFGecificDe
();

160 
	}
}

164 
usg
 
	gWTF
::
WTFThadDa
;

165 
usg
 
	gWTF
::
wtfThadDa
;

166 
usg
 
	gWTF
::
AtomicSgTab
;

	@WeakPtr.h

26 #ide
WTF_WkP_h


27 
	#WTF_WkP_h


	)

29 
	~<wtf/Ncyab.h
>

30 
	~<wtf/PassRefP.h
>

31 
	~<wtf/RefP.h
>

32 
	~<wtf/ThadSaRefCoued.h
>

33 
	~<wtf/Thadg.h
>

35 #i
USE
(
WEB_THREAD
)

36 
	~<wtf/MaThad.h
>

39 
mea
 
	gWTF
 {

41 
	gme
<
tyme
 
	gT
>

42 
ass
 
	gWkRen
 : 
public
 
ThadSaRefCoued
<
WkRen
<
T
>> {

43 
WTF_MAKE_NONCOPYABLE
(
WkRen
<
T
>);

44 
	gWTF_MAKE_FAST_ALLOCATED
;

45 
	gpublic
:

46 
PassRefP
<
WkRen
<
T
>> 

(T* 
r
{  
adtRef
(
w
 WeakReference(ptr)); }

47 
	gPassRefP
<
	gWkRen
<
	gT
>> 
Unbound
({  
adtRef
(
w
 
WkRen
()); }

49 
T
* 
g
() const

51 #i
USE
(
WEB_THREAD
)

52 
ASSERT
(
nAcssThadLolDaFThad
(
m_boundThad
));

54 
ASSERT
(
m_boundThad
 =
cutThad
());

56  
	gm_r
;

59 
r
()

61 #i
USE
(
WEB_THREAD
)

62 
ASSERT
(
nAcssThadLolDaFThad
(
m_boundThad
));

64 
ASSERT
(
m_boundThad
 =
cutThad
());

66 
	gm_r
 = 0;

69 
bdTo
(
T
* 
r
)

71 
ASSERT
(!
m_r
);

72 #ide
NDEBUG


73 
	gm_boundThad
 = 
cutThad
();

75 
	gm_r
 = 
r
;

78 
	give
:

79 
WkRen
(: 
m_r
(0) { }

81 
exic
 
WkRen
(
T
* 
r
)

82 : 
m_r
(
r
)

83 #ide
NDEBUG


84 , 
m_boundThad
(
cutThad
())

89 
T
* 
	gm_r
;

90 #ide
NDEBUG


91 
ThadIdtifr
 
	gm_boundThad
;

95 
	gme
<
tyme
 
	gT
>

96 as
	cWkP
 {

97 
	gWTF_MAKE_FAST_ALLOCATED
;

98 
	gpublic
:

99 
WkP
() { }

100 
WkP
(
PassRefP
<
WkRen
<
T
>> 
f
: 
m_f
(ref) { }

102 
T
* 
g
(cڡ {  
m_f
->get(); }

103 
exic
 
ݔ
 
bo
(cڡ {  
	gm_f
->
g
(); }

105 
T
* 
	gݔ
->(cڡ {  
	gm_f
->
g
(); }

107 
	give
:

108 
RefP
<
WkRen
<
T
>> 
m_f
;

111 
	gme
<
tyme
 
	gT
>

112 as
	cWkPFay
 {

113 
WTF_MAKE_NONCOPYABLE
(
WkPFay
<
T
>);

114 
	gWTF_MAKE_FAST_ALLOCATED
;

115 
	gpublic
:

116 
exic
 
WkPFay
(
T
* 
r
: 
m_f
(
WkRen
<T>::

(ptr)) { }

118 
WkPFay
(
PassRefP
<
WkRen
<
T
>> 
f
, T* 
r
)

119 : 
m_f
(
f
)

121 
m_f
->
bdTo
(
r
);

124 ~
WkPFay
({ 
	gm_f
->
r
(); }

127 
	gWkP
<
	gT
> 
WkP
({  WkP<T>(
	gm_f
); }

129 
vokeA
()

131 
T
* 
	gr
 = 
m_f
->
g
();

132 
	gm_f
->
r
();

134 
	gm_f
 = 
WkRen
<
T
>::

(
r
);

137 
	give
:

138 
RefP
<
WkRen
<
T
>> 
m_f
;

143 
usg
 
	gWTF
::
WkP
;

144 
usg
 
	gWTF
::
WkPFay
;

145 
usg
 
	gWTF
::
WkRen
;

	@WindowsExtras.h

25 #ide
WdowsExas_h


26 
	#WdowsExas_h


	)

28 #i
OS
(
WINDOWS
)

30 
	~<wdows.h
>

31 
	~<objba.h
>

32 
	~<shlwi.h
>

34 #ide
HWND_MESSAGE


35 cڡ 
HWND
 
	gHWND_MESSAGE
 = 0;

38 
mea
 
	gWTF
 {

40 
le
 
HRESULT
 
gRegiryVue
(
HKEY
 
hkey
, 
LPCWSTR
 
pszSubKey
, LPCWSTR 
pszVue
, 
LPDWORD
 
pdwTy
, 
LPVOID
 
pvDa
, LPDWORD 
pcbDa
)

42  ::
SHGVueW
(
hkey
, 
pszSubKey
, 
pszVue
, 
pdwTy
, 
pvDa
, 
pcbDa
);

45 
le
 * 
gWdowPor
(
HWND
 
hWnd
, 
dex
)

47  
	gt_
<*>(::
GWdowLgP
(
hWnd
, 
dex
));

50 
le
 * 
tWdowPor
(
HWND
 
hWnd
, 
dex
, * 
vue
)

52  
	gt_
<*>(::
SWdowLgP
(
hWnd
, 
dex
, 
t_
<
LONG_PTR
>(
vue
)));

57 
usg
 
	gWTF
::
gRegiryVue
;

58 
usg
 
	gWTF
::
gWdowPor
;

59 
usg
 
	gWTF
::
tWdowPor
;

	@cf/RunLoopCF.cpp

26 
	~"cfig.h
"

27 
	~"RunLo.h
"

29 
	~<CeFoundi/CeFoundi.h
>

30 
	~<dich/dich.h
>

31 
	~<wtf/AutodedPo.h
>

33 
mea
 
	gWTF
 {

35 
	gRunLo
::
rfmWk
(* 
cڋxt
)

37 
AutodedPo
 
po
;

38 
	gic_
<
	gRunLo
*>(
	gcڋxt
)->
rfmWk
();

41 
	gRunLo
::
RunLo
()

42 : 
m_runLo
(
CFRunLoGCut
())

43 , 
m_ágLev
(0)

45 
CFRunLoSourCڋxt
 
	gcڋxt
 = { 0, 
this
, 0, 0, 0, 0, 0, 0, 0, 
rfmWk
 };

46 
	gm_runLoSour
 = 
adtCF
(
CFRunLoSourCe
(
kCFAotDeu
, 0, &
cڋxt
));

47 
CFRunLoAddSour
(
m_runLo
.
g
(), 
m_runLoSour
.g(), 
kCFRunLoCommModes
);

50 
	gRunLo
::~
RunLo
()

52 
CFRunLoSourInvide
(
m_runLoSour
.
g
());

55 
	gRunLo
::
runFDuti
(
duti
)

57 
CFRunLoRunInMode
(
kCFRunLoDeuMode
, 
duti
, 
ue
);

60 
	gRunLo
::
wakeUp
()

62 
CFRunLoSourSigl
(
m_runLoSour
.
g
());

63 
CFRunLoWakeUp
(
m_runLo
.
g
());

66 
	gRunLo
::
run
()

68 
cut
().
m_ágLev
++;

71 
AutodedPo
 
	gpo
;

72 
CFRunLoRun
();

75 
cut
().
	gm_ágLev
--;

78 
	gRunLo
::

()

80 
ASSERT
(
m_runLo
 =
CFRunLoGCut
());

81 
CFRunLoSt
(
m_runLo
.
g
());

86 
	gRunLo
::
TimBa
::
timFed
(
CFRunLoTimRef
, * 
cڋxt
)

88 
TimBa
* 
	gtim
 = 
ic_
<TimBa*>(
cڋxt
);

90 
AutodedPo
 
	gpo
;

91 
	gtim
->
fed
();

94 
	gRunLo
::
TimBa
::TimBa(
RunLo
& 
runLo
)

95 : 
m_runLo
(
runLo
)

99 
RunLo
::
TimBa
::~TimerBase()

101 

();

104 
	gRunLo
::
TimBa
::
t
(
xtFeIv
, 
bo
 

)

106 i(
	gm_tim
)

107 

();

109 
CFRunLoTimCڋxt
 
	gcڋxt
 = { 0, 
this
, 0, 0, 0 };

110 
CFTimeIv
 
	gIv
 = 

 ? 
xtFeIv
 : 0;

111 
	gm_tim
 = 
adtCF
(
CFRunLoTimCe
(
kCFAotDeu
, 
CFAbsuTimeGCut
(+ 
xtFeIv
, 
Iv
, 0, 0, 
timFed
, &
cڋxt
));

112 
CFRunLoAddTim
(
m_runLo
.m_runLo.
g
(), 
m_tim
.g(), 
kCFRunLoCommModes
);

115 
	gRunLo
::
TimBa
::

()

117 i(!
m_tim
)

120 
CFRunLoTimInvide
(
m_tim
.
g
());

121 
	gm_tim
 = 
nuαr
;

124 
bo
 
	gRunLo
::
TimBa
::
isAive
() const

126  
m_tim
 && 
CFRunLoTimIsVid
(m_tim.
g
());

	@cf/TypeCasts.h

26 #ide
TyCas_h


27 
	#TyCas_h


	)

29 
	~<CeFoundi/CeFoundi.h
>

30 
	~<wtf/Asis.h
>

32 
mea
 
	gWTF
 {

34 
	gme
 <
	gtyme
> 
	gCFTyT
;

36 
	#DECLARE_CF_TYPE_TRAIT
(
CssName
) \

37 
me
 <> \

38 
CFTyT
<
CssName
##
Ref
> { \

39 
le
 
CFTyID
 
	`tyID
({  
CssName
##
	`GTyID
(); } \

40 };

	)

42 
DECLARE_CF_TYPE_TRAIT
(
CFAay
);

43 
DECLARE_CF_TYPE_TRAIT
(
CFBoޗn
);

44 
DECLARE_CF_TYPE_TRAIT
(
CFDa
);

45 
DECLARE_CF_TYPE_TRAIT
(
CFDiiڬy
);

46 
DECLARE_CF_TYPE_TRAIT
(
CFNumb
);

47 
DECLARE_CF_TYPE_TRAIT
(
CFSg
);

49 #unde
DECLARE_CF_TYPE_TRAIT


51 
	gme
<
tyme
 
	gT
> 
T
 
dymic_cf_
(
CFTyRef
 
obje
)

53 i(!
	gobje
)

54  
	gnuαr
;

56 i(
CFGTyID
(
obje
!
CFTyT
<
T
>::
tyID
())

57  
nuαr
;

59  
	gic_
<
	gT
>(
	gobje
);

62 
	gme
<
tyme
 
	gT
> 
T
 
checked_cf_
(
CFTyRef
 
obje
)

64 aut
	gsu
 = 
dymic_cf_
<
T
>(
obje
);

65 
ASSERT_WITH_SECURITY_IMPLICATION
(
su
);

67  
	gsu
;

72 
usg
 
	gWTF
::
checked_cf_
;

73 
usg
 
	gWTF
::
dymic_cf_
;

	@dtoa.cpp

35 
	~"cfig.h
"

36 
	~"dt.h
"

38 
	~<dio.h
>

39 
	~<wtf/MhExas.h
>

40 
	~<wtf/Thadg.h
>

41 
	~<wtf/Ve.h
>

43 #i
COMPILER
(
MSVC
)

44 #agm
wng
(
dib
: 4244)

45 #agm
wng
(
dib
: 4245)

46 #agm
wng
(
dib
: 4554)

49 #i
CPU
(
PPC64
|| CPU(
X86_64
|| CPU(
ARM64
)

52 
	#USE_LONG_LONG


	)

55 
mea
 
	gWTF
 {

57 
Mux
* 
	gs_dtP5Mux
;

60 
	gd
;

61 
ut32_t
 
	gL
[2];

62 } 
	tU
;

64 #i
CPU
(
BIG_ENDIAN
|| CPU(
MIDDLE_ENDIAN
)

65 
	#wd0
(
x
(x)->
L
[0]

	)

66 
	#wd1
(
x
(x)->
L
[1]

	)

68 
	#wd0
(
x
(x)->
L
[1]

	)

69 
	#wd1
(
x
(x)->
L
[0]

	)

71 
	#dv
(
x
(x)->
d


	)

73 #ide
USE_LONG_LONG


78 
ALWAYS_INLINE
 
ut32_t
* 
eInc
(ut32_t* 
p
, 
ut16_t
 
high
, ut16_
low
)

80 
ut16_t
* 
	gp16
 = 
t_
<ut16_t*>(
p
);

81 #i
CPU
(
BIG_ENDIAN
)

82 
	gp16
[0] = 
high
;

83 
	gp16
[1] = 
low
;

85 
	gp16
[1] = 
high
;

86 
	gp16
[0] = 
low
;

88  
	gp
 + 1;

93 
	#Exp_shi
 20

	)

94 
	#Exp_shi1
 20

	)

95 
	#Exp_msk1
 0x100000

	)

96 
	#Exp_msk11
 0x100000

	)

97 
	#Exp_mask
 0x7ff00000

	)

98 
	#P
 53

	)

99 
	#Bs
 1023

	)

100 
	#Em
 (-1022)

	)

101 
	#Exp_1
 0x3ff00000

	)

102 
	#Exp_11
 0x3ff00000

	)

103 
	#Ebs
 11

	)

104 
	#Fc_mask
 0xfffff

	)

105 
	#Fc_mask1
 0xfffff

	)

106 
	#T_pmax
 22

	)

107 
	#Btch
 0x10

	)

108 
	#Bndry_mask
 0xfffff

	)

109 
	#Bndry_mask1
 0xfffff

	)

110 
	#LSB
 1

	)

111 
	#Sign_b
 0x80000000

	)

112 
	#Log2P
 1

	)

113 
	#Ty0
 0

	)

114 
	#Ty1
 1

	)

115 
	#Quick_max
 14

	)

116 
	#I_max
 14

	)

118 
	#rounded_odu
(
a
, 
b
*
	)
b

119 
	#rounded_quٛ
(
a
, 
b
/
	)
b

121 
	#Big0
 (
Fc_mask1
 | 
Exp_msk1
 * (
DBL_MAX_EXP
 + 
Bs
 - 1))

	)

122 
	#Big1
 0xffffffff

	)

124 
	sBigI
 {

125 
BigI
(: 
sign
(0) { }

126 
sign
;

128 
r
()

130 
	gsign
 = 0;

131 
	gm_wds
.
r
();

134 
size_t
 
size
() const

136  
	gm_wds
.
size
();

139 
size
(
size_t
 
s
)

141 
	gm_wds
.
size
(
s
);

144 
ut32_t
* 
wds
()

146  
	gm_wds
.
da
();

149 cڡ 
ut32_t
* 
wds
() const

151  
	gm_wds
.
da
();

154 
nd
(
ut32_t
 
w
)

156 
	gm_wds
.
nd
(
w
);

159 
	gVe
<
	gut32_t
, 16> 
	gm_wds
;

162 
muadd
(
BigI
& 
b
, 
m
, 
a
)

164 #ifde
USE_LONG_LONG


165 
	gy
;

167 
ut32_t
 
	gy
;

170 
	gwds
 = 
b
.
size
();

171 
ut32_t
* 
	gx
 = 
b
.
wds
();

172 
	gi
 = 0;

173 
	gy
 = 
a
;

175 #ifde
USE_LONG_LONG


176 
	gy
 = *
x
 * ()
m
 + 
y
;

177 
	gy
 = 
y
 >> 32;

178 *
	gx
++ = (
ut32_t
)
y
 & 0xffffffffUL;

180 
ut32_t
 
	gxi
 = *
x
;

181 
ut32_t
 
	gy
 = (
xi
 & 0xffff* 
m
 + 
y
;

182 
ut32_t
 
	gz
 = (
xi
 >> 16* 
m
 + (
y
 >> 16);

183 
	gy
 = 
z
 >> 16;

184 *
	gx
++ = (
z
 << 16+ (
y
 & 0xffff);

186 } ++
	gi
 < 
	gwds
);

188 i(
	gy
)

189 
	gb
.
nd
((
ut32_t
)
y
);

192 
hi0bs
(
ut32_t
 
x
)

194 
	gk
 = 0;

196 i(!(
	gx
 & 0xffff0000)) {

197 
	gk
 = 16;

198 
	gx
 <<= 16;

200 i(!(
	gx
 & 0xff000000)) {

201 
	gk
 += 8;

202 
	gx
 <<= 8;

204 i(!(
	gx
 & 0xf0000000)) {

205 
	gk
 += 4;

206 
	gx
 <<= 4;

208 i(!(
	gx
 & 0xc0000000)) {

209 
	gk
 += 2;

210 
	gx
 <<= 2;

212 i(!(
	gx
 & 0x80000000)) {

213 
	gk
++;

214 i(!(
	gx
 & 0x40000000))

217  
	gk
;

220 
lo0bs
(
ut32_t
* 
y
)

222 
	gk
;

223 
ut32_t
 
	gx
 = *
y
;

225 i(
	gx
 & 7) {

226 i(
	gx
 & 1)

228 i(
	gx
 & 2) {

229 *
	gy
 = 
x
 >> 1;

232 *
	gy
 = 
x
 >> 2;

235 
	gk
 = 0;

236 i(!(
	gx
 & 0xffff)) {

237 
	gk
 = 16;

238 
	gx
 >>= 16;

240 i(!(
	gx
 & 0xff)) {

241 
	gk
 += 8;

242 
	gx
 >>= 8;

244 i(!(
	gx
 & 0xf)) {

245 
	gk
 += 4;

246 
	gx
 >>= 4;

248 i(!(
	gx
 & 0x3)) {

249 
	gk
 += 2;

250 
	gx
 >>= 2;

252 i(!(
	gx
 & 1)) {

253 
	gk
++;

254 
	gx
 >>= 1;

255 i(!
	gx
)

258 *
	gy
 = 
x
;

259  
	gk
;

262 
i2b
(
BigI
& 
b
, 
i
)

264 
	gb
.
	gsign
 = 0;

265 
	gb
.
size
(1);

266 
	gb
.
wds
()[0] = 
i
;

269 
mu
(
BigI
& 
aRef
, cڡ BigI& 
bRef
)

271 cڡ 
BigI
* 
	ga
 = &
aRef
;

272 cڡ 
BigI
* 
	gb
 = &
bRef
;

273 
BigI
 
	gc
;

274 
	gwa
, 
	gwb
, 
	gwc
;

275 cڡ 
ut32_t
* 
	gx
 = 0;

276 cڡ 
ut32_t
* 
	gxa
;

277 cڡ 
ut32_t
* 
	gxb
;

278 cڡ 
ut32_t
* 
	gx
;

279 cڡ 
ut32_t
* 
	gxbe
;

280 
ut32_t
* 
	gxc
;

281 
ut32_t
* 
	gxc0
;

282 
ut32_t
 
	gy
;

283 #ifde
USE_LONG_LONG


284 
	gy
, 
	gz
;

286 
ut32_t
 
	gy
, 
	gz
;

289 i(
	ga
->
size
(< 
	gb
->size()) {

290 cڡ 
BigI
* 
	gtmp
 = 
a
;

291 
	ga
 = 
b
;

292 
	gb
 = 
tmp
;

295 
	gwa
 = 
a
->
size
();

296 
	gwb
 = 
b
->
size
();

297 
	gwc
 = 
wa
 + 
wb
;

298 
	gc
.
size
(
wc
);

300 
	gxc
 = 
c
.
wds
(), 
	gxa
 = 
xc
 + 
wc
; xc < xa; xc++)

301 *
	gxc
 = 0;

302 
	gxa
 = 
a
->
wds
();

303 
	gx
 = 
xa
 + 
wa
;

304 
	gxb
 = 
b
->
wds
();

305 
	gxbe
 = 
xb
 + 
wb
;

306 
	gxc0
 = 
c
.
wds
();

307 #ifde
USE_LONG_LONG


308 ; 
	gxb
 < 
	gxbe
; 
	gxc0
++) {

309 i((
	gy
 = *
xb
++)) {

310 
x
 = 
xa
;

311 
	gxc
 = 
xc0
;

312 
	gy
 = 0;

314 
	gz
 = *
x
++ * ()
y
 + *
xc
 + 
y
;

315 
	gy
 = 
z
 >> 32;

316 *
	gxc
++ = (
ut32_t
)
z
 & 0xffffffffUL;

317 } 
	gx
 < 
	gx
);

318 *
	gxc
 = (
ut32_t
)
y
;

322 ; 
	gxb
 < 
	gxbe
; xb++, 
	gxc0
++) {

323 i((
	gy
 = *
xb
 & 0xffff)) {

324 
x
 = 
xa
;

325 
	gxc
 = 
xc0
;

326 
	gy
 = 0;

328 
	gz
 = (*
x
 & 0xffff* 
y
 + (*
xc
 & 0xffff+ 
y
;

329 
	gy
 = 
z
 >> 16;

330 
ut32_t
 
	gz2
 = (*
x
++ >> 16* 
y
 + (*
xc
 >> 16+ 
y
;

331 
	gy
 = 
z2
 >> 16;

332 
	gxc
 = 
eInc
(
xc
, 
z2
, 
z
);

333 } 
	gx
 < 
	gx
);

334 *
	gxc
 = 
y
;

336 i((
	gy
 = *
xb
 >> 16)) {

337 
x
 = 
xa
;

338 
	gxc
 = 
xc0
;

339 
	gy
 = 0;

340 
ut32_t
 
	gz2
 = *
xc
;

342 
	gz
 = (*
x
 & 0xffff* 
y
 + (*
xc
 >> 16+ 
y
;

343 
	gy
 = 
z
 >> 16;

344 
	gxc
 = 
eInc
(
xc
, 
z
, 
z2
);

345 
	gz2
 = (*
x
++ >> 16* 
y
 + (*
xc
 & 0xffff+ 
y
;

346 
	gy
 = 
z2
 >> 16;

347 } 
	gx
 < 
	gx
);

348 *
	gxc
 = 
z2
;

352 
	gxc0
 = 
c
.
wds
(), 
	gxc
 = 
xc0
 + 
wc
; 
	gwc
 > 0 && !*--xc; --wc) { }

353 
	gc
.
size
(
wc
);

354 
	gaRef
 = 
c
;

357 
	sP5Node
 {

358 
WTF_MAKE_NONCOPYABLE
(
P5Node
); 
	gWTF_MAKE_FAST_ALLOCATED
;

359 
	gpublic
:

360 
P5Node
() { }

361 
BigI
 
v
;

362 
P5Node
* 
	gxt
;

365 
P5Node
* 
	gp5s
;

366 
	gp5sCou
;

368 
ALWAYS_INLINE
 
pow5mu
(
BigI
& 
b
, 
k
)

370 
	gp05
[3] = { 5, 25, 125 };

372 i(
	gi
 = 
k
 & 3)

373 
muadd
(
b
, 
p05
[
i
 - 1], 0);

375 i(!(
	gk
 >>= 2))

378 
	gs_dtP5Mux
->
lock
();

379 
P5Node
* 
	gp5
 = 
p5s
;

381 i(!
	gp5
) {

383 
	gp5
 = 
w
 
P5Node
;

384 
i2b
(
p5
->
v
, 625);

385 
	gp5
->
	gxt
 = 0;

386 
	gp5s
 = 
p5
;

387 
	gp5sCou
 = 1;

390 
	gp5sCouLol
 = 
p5sCou
;

391 
	gs_dtP5Mux
->
uock
();

392 
	gp5sUd
 = 0;

395 i(
	gk
 & 1)

396 
mu
(
b
, 
p5
->
v
);

398 i(!(
	gk
 >>= 1))

401 i(++
	gp5sUd
 =
p5sCouLol
) {

402 
s_dtP5Mux
->
lock
();

403 i(
	gp5sUd
 =
p5sCou
) {

404 
ASSERT
(!
p5
->
xt
);

405 
	gp5
->
	gxt
 = 
w
 
P5Node
;

406 
	gp5
->
	gxt
->next = 0;

407 
	gp5
->
	gxt
->
	gv
 = 
p5
->
v
;

408 
mu
(
p5
->
xt
->
v
,5->next->val);

409 ++
	gp5sCou
;

412 
	gp5sCouLol
 = 
p5sCou
;

413 
	gs_dtP5Mux
->
uock
();

415 
	gp5
 = 
p5
->
xt
;

419 
ALWAYS_INLINE
 
lshi
(
BigI
& 
b
, 
k
)

421 
	gn
 = 
k
 >> 5;

423 
	gigSize
 = 
b
.
size
();

424 
	gn1
 = 
n
 + 
igSize
 + 1;

426 i(
	gk
 &= 0x1f)

427 
b
.
size
(b.
size
(+ 
n
 + 1);

429 
	gb
.
size
(
b
.
size
(+ 
n
);

431 cڡ 
ut32_t
* 
	gcS
 = 
b
.
wds
();

432 
ut32_t
* 
	gdS
 = 
b
.
wds
();

433 cڡ 
ut32_t
* 
	gc
 = 
cS
 + 
igSize
 - 1;

434 
ut32_t
* 
	gd
 = 
dS
 + 
n1
 - 1;

435 i(
	gk
) {

436 
ut32_t
 
	ghiSubwd
 = 0;

437 
	gs
 = 32 - 
k
;

438 ; 
	gc
 >
cS
; --src) {

439 *
	gd
-- = 
hiSubwd
 | *
c
 >> 
s
;

440 
	ghiSubwd
 = *
c
 << 
k
;

442 *
	gd
 = 
hiSubwd
;

443 
ASSERT
(
d
 =
dS
 + 
n
);

445 
	gb
.
size
(
igSize
 + 
n
 + !!
b
.
wds
()[
n1
 - 1]);

449 *--
	gd
 = *
c
--;

450 } 
	gc
 >
cS
);

452 
	gd
 = 
dS
 + 
n
; dst != dstStart; )

453 *--
	gd
 = 0;

455 
ASSERT
(
b
.
size
(<1 || b.
wds
()[b.size() - 1]);

458 
cmp
(cڡ 
BigI
& 
a
, cڡ BigI& 
b
)

460 cڡ 
ut32_t
 *
	gxa
, *
	gxa0
, *
	gxb
, *
	gxb0
;

461 
	gi
, 
	gj
;

463 
	gi
 = 
a
.
size
();

464 
	gj
 = 
b
.
size
();

465 
ASSERT
(
i
 <1 || 
a
.
wds
()[i - 1]);

466 
ASSERT
(
j
 <1 || 
b
.
wds
()[j - 1]);

467 i(
	gi
 -
j
)

468  
i
;

469 
	gxa0
 = 
a
.
wds
();

470 
	gxa
 = 
xa0
 + 
j
;

471 
	gxb0
 = 
b
.
wds
();

472 
	gxb
 = 
xb0
 + 
j
;

474 i(*--
	gxa
 !*--
xb
)

475  *
xa
 < *
xb
 ? -1 : 1;

476 i(
	gxa
 <
xa0
)

482 
ALWAYS_INLINE
 
diff
(
BigI
& 
c
, cڡ BigI& 
aRef
, cڡ BigI& 
bRef
)

484 cڡ 
BigI
* 
	ga
 = &
aRef
;

485 cڡ 
BigI
* 
	gb
 = &
bRef
;

486 
	gi
, 
	gwa
, 
	gwb
;

487 
ut32_t
* 
	gxc
;

489 
	gi
 = 
cmp
(*
a
, *
b
);

490 i(!
	gi
) {

491 
	gc
.
	gsign
 = 0;

492 
	gc
.
size
(1);

493 
	gc
.
wds
()[0] = 0;

496 i(
	gi
 < 0) {

497 cڡ 
BigI
* 
	gtmp
 = 
a
;

498 
	ga
 = 
b
;

499 
	gb
 = 
tmp
;

500 
	gi
 = 1;

502 
	gi
 = 0;

504 
	gwa
 = 
a
->
size
();

505 cڡ 
ut32_t
* 
	gxa
 = 
a
->
wds
();

506 cڡ 
ut32_t
* 
	gx
 = 
xa
 + 
wa
;

507 
	gwb
 = 
b
->
size
();

508 cڡ 
ut32_t
* 
	gxb
 = 
b
->
wds
();

509 cڡ 
ut32_t
* 
	gxbe
 = 
xb
 + 
wb
;

511 
	gc
.
size
(
wa
);

512 
	gc
.
	gsign
 = 
i
;

513 
	gxc
 = 
c
.
wds
();

514 #ifde
USE_LONG_LONG


515 
	gbrow
 = 0;

517 
	gy
 = ()*
xa
++ - *
xb
++ - 
brow
;

518 
	gbrow
 = 
y
 >> 32 & (
ut32_t
)1;

519 *
	gxc
++ = (
ut32_t
)
y
 & 0xffffffffUL;

520 } 
	gxb
 < 
	gxbe
);

521 
	gxa
 < 
	gx
) {

522 
	gy
 = *
xa
++ - 
brow
;

523 
	gbrow
 = 
y
 >> 32 & (
ut32_t
)1;

524 *
	gxc
++ = (
ut32_t
)
y
 & 0xffffffffUL;

527 
ut32_t
 
	gbrow
 = 0;

529 
ut32_t
 
	gy
 = (*
xa
 & 0xffff- (*
xb
 & 0xffff- 
brow
;

530 
	gbrow
 = (
y
 & 0x10000) >> 16;

531 
ut32_t
 
	gz
 = (*
xa
++ >> 16- (*
xb
++ >> 16- 
brow
;

532 
	gbrow
 = (
z
 & 0x10000) >> 16;

533 
	gxc
 = 
eInc
(
xc
, 
z
, 
y
);

534 } 
	gxb
 < 
	gxbe
);

535 
	gxa
 < 
	gx
) {

536 
ut32_t
 
	gy
 = (*
xa
 & 0xffff- 
brow
;

537 
	gbrow
 = (
y
 & 0x10000) >> 16;

538 
ut32_t
 
	gz
 = (*
xa
++ >> 16- 
brow
;

539 
	gbrow
 = (
z
 & 0x10000) >> 16;

540 
	gxc
 = 
eInc
(
xc
, 
z
, 
y
);

543 !*--
	gxc
)

544 
	gwa
--;

545 
	gc
.
size
(
wa
);

548 
ALWAYS_INLINE
 
d2b
(
BigI
& 
b
, 
U
* 
d
, * 
e
, * 
bs
)

550 
	gde
, 
	gk
;

551 
ut32_t
* 
	gx
;

552 
ut32_t
 
	gy
, 
	gz
;

553 
	gi
;

554 
	#d0
 
	`wd0
(
d
)

	)

555 
	#d1
 
	`wd1
(
d
)

	)

557 
	gb
.
	gsign
 = 0;

558 
	gb
.
size
(1);

559 
	gx
 = 
b
.
wds
();

561 
	gz
 = 
d0
 & 
Fc_mask
;

562 
	gd0
 &= 0x7fffffff;

563 i((
	gde
 = ()(
d0
 >> 
Exp_shi
)))

564 
z
 |
Exp_msk1
;

565 i((
	gy
 = 
d1
)) {

566 i((
k
 = 
lo0bs
(&
y
))) {

567 
x
[0] = 
y
 | (
z
 << (32 - 
k
));

568 
	gz
 >>
k
;

570 
	gx
[0] = 
y
;

571 i(
	gz
) {

572 
	gb
.
size
(2);

573 
	gx
[1] = 
z
;

576 
	gi
 = 
b
.
size
();

578 
	gk
 = 
lo0bs
(&
z
);

579 
	gx
[0] = 
z
;

580 
	gi
 = 1;

581 
	gb
.
size
(1);

582 
	gk
 += 32;

584 i(
	gde
) {

585 *
	ge
 = 
de
 - 
Bs
 - (
P
 - 1+ 
k
;

586 *
	gbs
 = 
P
 - 
k
;

588 *
	ge
 = 0 - 
Bs
 - (
P
 - 1+ 1 + 
k
;

589 *
	gbs
 = (32 * 
i
- 
hi0bs
(
x
[i - 1]);

592 #unde
d0


593 #unde
d1


595 cڡ 
	gns
[] = {

601 cڡ 
	gbigns
[] = { 1e16, 1e32, 1e64, 1e128, 1e256 };

603 
	#S_B
 0x10

	)

604 
	#n_bigns
 5

	)

606 
ALWAYS_INLINE
 
quem
(
BigI
& 
b
, BigI& 
S
)

608 
size_t
 
	gn
;

609 
ut32_t
* 
	gbx
;

610 
ut32_t
* 
	gbxe
;

611 
ut32_t
 
	gq
;

612 
ut32_t
* 
	gsx
;

613 
ut32_t
* 
	gsxe
;

614 #ifde
USE_LONG_LONG


615 
	gbrow
, 
	gy
, 
	gy
, 
	gys
;

617 
ut32_t
 
	gbrow
, 
	gy
, 
	gy
, 
	gys
;

618 
ut32_t
 
	gsi
, 
	gz
, 
	gzs
;

620 
ASSERT
(
b
.
size
(<1 || b.
wds
()[b.size() - 1]);

621 
ASSERT
(
S
.
size
(<1 || S.
wds
()[S.size() - 1]);

623 
	gn
 = 
S
.
size
();

624 
ASSERT_WITH_MESSAGE
(
b
.
size
(<
n
, "oversize b in quorem");

625 i(
	gb
.
size
(< 
	gn
)

627 
	gsx
 = 
S
.
wds
();

628 
	gsxe
 = 
sx
 + --
n
;

629 
	gbx
 = 
b
.
wds
();

630 
	gbxe
 = 
bx
 + 
n
;

631 
	gq
 = *
bxe
 / (*
sxe
 + 1);

632 
ASSERT_WITH_MESSAGE
(
q
 <= 9, "oversized quotient in quorem");

633 i(
	gq
) {

634 
	gbrow
 = 0;

635 
	gy
 = 0;

637 #ifde
USE_LONG_LONG


638 
	gys
 = *
sx
++ * ()
q
 + 
y
;

639 
	gy
 = 
ys
 >> 32;

640 
	gy
 = *
bx
 - (
ys
 & 0xffffffffUL- 
brow
;

641 
	gbrow
 = 
y
 >> 32 & (
ut32_t
)1;

642 *
	gbx
++ = (
ut32_t
)
y
 & 0xffffffffUL;

644 
	gsi
 = *
sx
++;

645 
	gys
 = (
si
 & 0xffff* 
q
 + 
y
;

646 
	gzs
 = (
si
 >> 16* 
q
 + (
ys
 >> 16);

647 
	gy
 = 
zs
 >> 16;

648 
	gy
 = (*
bx
 & 0xffff- (
ys
 & 0xffff- 
brow
;

649 
	gbrow
 = (
y
 & 0x10000) >> 16;

650 
	gz
 = (*
bx
 >> 16- (
zs
 & 0xffff- 
brow
;

651 
	gbrow
 = (
z
 & 0x10000) >> 16;

652 
	gbx
 = 
eInc
(
bx
, 
z
, 
y
);

654 } 
	gsx
 <
sxe
);

655 i(!*
	gbxe
) {

656 
	gbx
 = 
b
.
wds
();

657 --
	gbxe
 > 
	gbx
 && !*bxe)

658 --
	gn
;

659 
	gb
.
size
(
n
);

662 i(
cmp
(
b
, 
S
) >= 0) {

663 
q
++;

664 
	gbrow
 = 0;

665 
	gy
 = 0;

666 
	gbx
 = 
b
.
wds
();

667 
	gsx
 = 
S
.
wds
();

669 #ifde
USE_LONG_LONG


670 
	gys
 = *
sx
++ + 
y
;

671 
	gy
 = 
ys
 >> 32;

672 
	gy
 = *
bx
 - (
ys
 & 0xffffffffUL- 
brow
;

673 
	gbrow
 = 
y
 >> 32 & (
ut32_t
)1;

674 *
	gbx
++ = (
ut32_t
)
y
 & 0xffffffffUL;

676 
	gsi
 = *
sx
++;

677 
	gys
 = (
si
 & 0xffff+ 
y
;

678 
	gzs
 = (
si
 >> 16+ (
ys
 >> 16);

679 
	gy
 = 
zs
 >> 16;

680 
	gy
 = (*
bx
 & 0xffff- (
ys
 & 0xffff- 
brow
;

681 
	gbrow
 = (
y
 & 0x10000) >> 16;

682 
	gz
 = (*
bx
 >> 16- (
zs
 & 0xffff- 
brow
;

683 
	gbrow
 = (
z
 & 0x10000) >> 16;

684 
	gbx
 = 
eInc
(
bx
, 
z
, 
y
);

686 } 
	gsx
 <
sxe
);

687 
	gbx
 = 
b
.
wds
();

688 
	gbxe
 = 
bx
 + 
n
;

689 i(!*
	gbxe
) {

690 --
	gbxe
 > 
	gbx
 && !*bxe)

691 --
	gn
;

692 
	gb
.
size
(
n
);

695  
	gq
;

733 
	gme
<
bo
 
	groundgNe
, bo 
	groundgSignifiFigus
, bo 
	groundgDecimPs
, bo 
	gright
>

734 
dt
(
DtBufr
 
su
, 
dd
, 
ndigs
, 
bo
& 
signOut
, & 
expڒtOut
, & 
ecisiOut
)

737 
ASSERT
(
roundgNe
 + 
roundgSignifiFigus
 + 
roundgDecimPs
 == 1);

739 
ASSERT
(!
roundgNe
 || 
right
);

741 
ASSERT
(
d
::
isfe
(
dd
));

743 
	gbbs
, 
	gb2
, 
	gb5
, 
	gbe
, 
	gdig
, 
	gi
, 
	gps
, 
	gim
 = 0, 
	gim0
, 
	gim1
 = 0,

744 
	gj
, 
	gj1
, 
	gk
, 
	gk0
, 
	gk_check
, 
	gm2
, 
	gm5
, 
	gs2
, 
	gs5
,

745 
	gec_
;

746 
t32_t
 
	gL
;

747 
	gdm
;

748 
ut32_t
 
	gx
;

749 
BigI
 
	gb
, 
	gd
, 
	gmlo
, 
	gmhi
, 
	gS
;

750 
U
 
	gd2
, 
	gs
, 
	gu
;

751 
	gds
;

752 * 
	gs
;

753 * 
	gs0
;

755 
	gu
.
	gd
 = 
dd
;

758 
ASSERT
((
wd0
(&
u
& 
Exp_mask
) != Exp_mask);

761 i(!
dv
(&
u
)) {

762 
	gsignOut
 = 
l
;

763 
	gexpڒtOut
 = 0;

764 
	gecisiOut
 = 1;

765 
	gsu
[0] = '0';

766 
	gsu
[1] = '\0';

770 i(
wd0
(&
u
& 
	gSign_b
) {

771 
	gsignOut
 = 
ue
;

772 
wd0
(&
u
&~
Sign_b
;

774 
	gsignOut
 = 
l
;

776 
d2b
(
b
, &
u
, &
be
, &
bbs
);

777 i((
	gi
 = ()(
wd0
(&
u
>> 
Exp_shi1
 & (
Exp_mask
 >> Exp_shift1)))) {

778 
dv
(&
d2
dv(&
u
);

779 
wd0
(&
d2
&
Fc_mask1
;

780 
wd0
(&
d2
|
Exp_11
;

804 
	gi
 -
Bs
;

805 
	gdm
 = 0;

809 
	gi
 = 
bbs
 + 
be
 + (
Bs
 + (
P
 - 1) - 1);

810 
	gx
 = (
i
 > 32? (
wd0
(&
u
<< (64 - i)| (
wd1
(&u) >> (i - 32))

811 : 
wd1
(&
u
<< (32 - 
i
);

812 
dv
(&
d2

x
;

813 
wd0
(&
d2
-31 * 
Exp_msk1
;

814 
	gi
 -(
Bs
 + (
P
 - 1) - 1) + 1;

815 
	gdm
 = 1;

817 
	gds
 = (
dv
(&
d2
- 1.5* 0.289529654602168 + 0.1760912590558 + (
i
 * 0.301029995663981);

818 
	gk
 = ()
ds
;

819 i(
	gds
 < 0. && d!
k
)

820 
k
--;

821 
	gk_check
 = 1;

822 i(
	gk
 >0 && 
k
 <
T_pmax
) {

823 i(
dv
(&
u
< 
ns
[
k
])

824 
k
--;

825 
	gk_check
 = 0;

827 
	gj
 = 
bbs
 - 
i
 - 1;

828 i(
	gj
 >= 0) {

829 
b2
 = 0;

830 
	gs2
 = 
j
;

832 
	gb2
 = -
j
;

833 
	gs2
 = 0;

835 i(
	gk
 >= 0) {

836 
b5
 = 0;

837 
	gs5
 = 
k
;

838 
	gs2
 +
k
;

840 
	gb2
 -
k
;

841 
	gb5
 = -
k
;

842 
	gs5
 = 0;

845 i(
	groundgNe
) {

846 
	gim
 = 
im1
 = -1;

847 
	gi
 = 18;

848 
	gndigs
 = 0;

850 i(
	groundgSignifiFigus
) {

851 i(
	gndigs
 <= 0)

852 
ndigs
 = 1;

853 
	gim
 = 
im1
 = 
i
 = 
ndigs
;

855 i(
	groundgDecimPs
) {

856 
	gi
 = 
ndigs
 + 
k
 + 1;

857 
	gim
 = 
i
;

858 
	gim1
 = 
i
 - 1;

859 i(
	gi
 <= 0)

860 
i
 = 1;

863 
	gs
 = 
s0
 = 
su
;

865 i(
	gim
 >0 && 
im
 <
Quick_max
) {

868 
i
 = 0;

869 
dv
(&
d2
dv(&
u
);

870 
	gk0
 = 
k
;

871 
	gim0
 = 
im
;

872 
	gps
 = 2;

873 i(
	gk
 > 0) {

874 
	gds
 = 
ns
[
k
 & 0xf];

875 
	gj
 = 
k
 >> 4;

876 i(
	gj
 & 
	gBtch
) {

878 
	gj
 &
Btch
 - 1;

879 
dv
(&
u
/
bigns
[
n_bigns
 - 1];

880 
	gps
++;

882 ; 
	gj
; j >>1, 
	gi
++) {

883 i(
	gj
 & 1) {

884 
	gps
++;

885 
	gds
 *
bigns
[
i
];

888 
dv
(&
u
/
ds
;

889 } i((
	gj1
 = -
k
)) {

890 
dv
(&
u
*
ns
[
j1
 & 0xf];

891 
	gj
 = 
j1
 >> 4; j; j >>1, 
	gi
++) {

892 i(
	gj
 & 1) {

893 
	gps
++;

894 
dv
(&
u
*
bigns
[
i
];

898 i(
	gk_check
 && 
dv
(&
u
< 1. && 
	gim
 > 0) {

899 i(
	gim1
 <= 0)

900 
Faed
;

901 
	gim
 = 
im1
;

902 
	gk
--;

903 
dv
(&
u
) *= 10.;

904 
	gps
++;

906 
dv
(&
s
(
ps
 * dv(&
u
)) + 7.;

907 
wd0
(&
s
-(
P
 - 1* 
Exp_msk1
;

908 i(!
	gim
) {

909 
	gS
.
r
();

910 
	gmhi
.
r
();

911 
dv
(&
u
) -= 5.;

912 i(
dv
(&
u
> dv(&
s
))

913 
	geDig
;

914 i(
dv
(&
u
< -dv(&
s
))

915 
	gnoDigs
;

916 
	gFaed
;

918 i(
	gright
) {

922 
dv
(&
s
(0.5 / 
ns
[
im
 - 1]) - dval(&eps);

923 
	gi
 = 0;;) {

924 
	gL
 = ()
dv
(&
u
);

925 
dv
(&
u
-
L
;

926 *
	gs
++ = '0' + ()
L
;

927 i(
dv
(&
u
< dv(&
s
))

928 
	gt
;

929 i(1. - 
dv
(&
u
< dv(&
s
))

930 
	gbumpUp
;

931 i(++
	gi
 >
im
)

933 
dv
(&
s
) *= 10.;

934 
dv
(&
u
) *= 10.;

938 
dv
(&
s
*
ns
[
im
 - 1];

939 
	gi
 = 1;; i++, 
dv
(&
u
) *= 10.) {

940 
L
 = (
t32_t
)(
dv
(&
u
));

941 i(!(
dv
(&
u
-
L
))

942 
im
 = 
i
;

943 *
	gs
++ = '0' + ()
L
;

944 i(
	gi
 =
im
) {

945 i(
dv
(&
u
> 0.5 + dv(&
s
))

946 
bumpUp
;

947 i(
dv
(&
u
< 0.5 - dv(&
s
)) {

948 *--
	gs
 == '0') { }

949 
s
++;

950 
	gt
;

956 
	gFaed
:

957 
s
 = 
s0
;

958 
dv
(&
u
dv(&
d2
);

959 
	gk
 = 
k0
;

960 
	gim
 = 
im0
;

965 i(
	gbe
 >0 && 
k
 <
I_max
) {

967 
ds
 = 
ns
[
k
];

968 i(
	gndigs
 < 0 && 
	gim
 <= 0) {

969 
S
.
r
();

970 
	gmhi
.
r
();

971 i(
	gim
 < 0 || 
dv
(&
u
<5 * 
ds
)

972 
noDigs
;

973 
	geDig
;

975 
	gi
 = 1;; i++, 
dv
(&
u
) *= 10.) {

976 
L
 = (
t32_t
)(
dv
(&
u
/ 
ds
);

977 
dv
(&
u
-
L
 * 
ds
;

978 *
	gs
++ = '0' + ()
L
;

979 i(!
dv
(&
u
)) {

982 i(
	gi
 =
im
) {

983 
dv
(&
u
) += dval(&u);

984 i(
dv
(&
u
> 
	gds
 || (dv(&u=
ds
 && (
L
 & 1))) {

985 
bumpUp
:

986 *--
s
 == '9')

987 i(
s
 =
s0
) {

988 
k
++;

989 *
	gs
 = '0';

992 ++*
	gs
++;

997 
	gt
;

1000 
	gm2
 = 
b2
;

1001 
	gm5
 = 
b5
;

1002 
	gmhi
.
r
();

1003 
	gmlo
.
r
();

1004 i(
	gright
) {

1005 
	gi
 = 
dm
 ? 
be
 + (
Bs
 + (
P
 - 1- 1 + 1: 1 + P - 
bbs
;

1006 
	gb2
 +
i
;

1007 
	gs2
 +
i
;

1008 
i2b
(
mhi
, 1);

1010 i(
	gm2
 > 0 && 
	gs2
 > 0) {

1011 
	gi
 = 
m2
 < 
s2
 ? m2 : s2;

1012 
	gb2
 -
i
;

1013 
	gm2
 -
i
;

1014 
	gs2
 -
i
;

1016 i(
	gb5
 > 0) {

1017 i(
	gright
) {

1018 i(
	gm5
 > 0) {

1019 
pow5mu
(
mhi
, 
m5
);

1020 
mu
(
b
, 
mhi
);

1022 i((
	gj
 = 
b5
 - 
m5
))

1023 
pow5mu
(
b
, 
j
);

1025 
pow5mu
(
b
, 
b5
);

1027 
i2b
(
S
, 1);

1028 i(
	gs5
 > 0)

1029 
pow5mu
(
S
, 
s5
);

1033 
	gec_
 = 0;

1034 i((
	groundgNe
 || 
	gright
&& (!
wd1
(&
u
&& !(
wd0
(&u& 
	gBndry_mask
&& wd0(&u& (
	gExp_mask
 & ~
	gExp_msk1
))) {

1036 
	gb2
 +
Log2P
;

1037 
	gs2
 +
Log2P
;

1038 
	gec_
 = 1;

1048 i((
	gi
 = ((
s5
 ? 32 - 
hi0bs
(
S
.
wds
()[S.
size
(- 1]: 1+ 
s2
) & 0x1f))

1049 
i
 = 32 - i;

1050 i(
	gi
 > 4) {

1051 
	gi
 -= 4;

1052 
	gb2
 +
i
;

1053 
	gm2
 +
i
;

1054 
	gs2
 +
i
;

1055 } i(
	gi
 < 4) {

1056 
	gi
 += 28;

1057 
	gb2
 +
i
;

1058 
	gm2
 +
i
;

1059 
	gs2
 +
i
;

1061 i(
	gb2
 > 0)

1062 
lshi
(
b
, 
b2
);

1063 i(
	gs2
 > 0)

1064 
lshi
(
S
, 
s2
);

1065 i(
	gk_check
) {

1066 i(
cmp
(
b
, 
S
) < 0) {

1067 
	gk
--;

1068 
muadd
(
b
, 10, 0);

1069 i(
	gright
)

1070 
muadd
(
mhi
, 10, 0);

1071 
	gim
 = 
im1
;

1074 i(
	gim
 <0 && 
roundgDecimPs
) {

1075 i(
im
 < 0)

1076 
noDigs
;

1077 
muadd
(
S
, 5, 0);

1079 i(
cmp
(
b
, 
S
) < 0)

1080 
	gnoDigs
;

1081 
	geDig
;

1083 i(
	gright
) {

1084 i(
	gm2
 > 0)

1085 
lshi
(
mhi
, 
m2
);

1091 
	gmlo
 = 
mhi
;

1092 i(
	gec_
)

1093 
lshi
(
mhi
, 
Log2P
);

1095 
	gi
 = 1;;i++) {

1096 
	gdig
 = 
quem
(
b
, 
S
) + '0';

1100 
	gj
 = 
cmp
(
b
, 
mlo
);

1101 
diff
(
d
, 
S
, 
mhi
);

1102 
	gj1
 = 
d
.
sign
 ? 1 : 
cmp
(
b
, delta);

1103 #ifde
DTOA_ROUND_BIASED


1104 i(
	gj
 < 0 || !j) {

1118 i(!
	gj1
 && !(
wd1
(&
u
) & 1)) {

1119 i(
	gdig
 == '9')

1120 
round9up
;

1121 i(
	gj
 > 0)

1122 
	gdig
++;

1123 *
	gs
++ = 
dig
;

1124 
	gt
;

1126 i(
	gj
 < 0 || (!j && !(
wd1
(&
u
) & 1))) {

1128 i((
	gb
.
wds
()[0] || b.
size
(> 1&& (
	gj1
 > 0)) {

1129 
lshi
(
b
, 1);

1130 
	gj1
 = 
cmp
(
b
, 
S
);

1134 i(
	gj1
 >= 0) {

1135 i(
dig
 == '9')

1136 
round9up
;

1137 
	gdig
++;

1140 *
	gs
++ = 
dig
;

1141 
	gt
;

1143 i(
	gj1
 > 0) {

1144 i(
	gdig
 == '9') {

1145 
round9up
:

1146 *
s
++ = '9';

1147 
	groundoff
;

1149 *
	gs
++ = 
dig
 + 1;

1150 
	gt
;

1152 *
	gs
++ = 
dig
;

1153 i(
	gi
 =
im
)

1155 
muadd
(
b
, 10, 0);

1156 
muadd
(
mlo
, 10, 0);

1157 
muadd
(
mhi
, 10, 0);

1160 
	gi
 = 1;; i++) {

1161 *
	gs
++ = 
dig
 = 
quem
(
b
, 
S
) + '0';

1162 i(!
	gb
.
wds
()[0] && b.
size
() <= 1)

1163 
t
;

1164 i(
	gi
 >
im
)

1166 
muadd
(
b
, 10, 0);

1172 
lshi
(
b
, 1);

1173 
	gj
 = 
cmp
(
b
, 
S
);

1177 i(
	gj
 >= 0) {

1178 
roundoff
:

1179 *--
s
 == '9')

1180 i(
s
 =
s0
) {

1181 
k
++;

1182 *
	gs
++ = '1';

1183 
	gt
;

1185 ++*
	gs
++;

1187 *--
	gs
 == '0') { }

1188 
s
++;

1190 
	gt
;

1191 
	gnoDigs
:

1192 
expڒtOut
 = 0;

1193 
	gecisiOut
 = 1;

1194 
	gsu
[0] = '0';

1195 
	gsu
[1] = '\0';

1197 
	geDig
:

1198 *
s
++ = '1';

1199 
	gk
++;

1200 
	gt
;

1201 
	gt
:

1202 
ASSERT
(
s
 > 
su
);

1203 *
	gs
 = 0;

1204 
	gexpڒtOut
 = 
k
;

1205 
	gecisiOut
 = 
s
 - 
su
;

1208 
dt
(
DtBufr
 
su
, 
dd
, 
bo
& 
sign
, & 
expڒt
, & 
ecisi
)

1211 
	gdt
<
	gue
, 
	gl
, f,rue>(
	gsu
, 
	gdd
, 0, 
	gsign
, 
	gexpڒt
, 
	gecisi
);

1214 
dtRoundSF
(
DtBufr
 
su
, 
dd
, 
ndigs
, 
bo
& 
sign
, & 
expڒt
, & 
ecisi
)

1217 
	gdt
<
	gl
, 
	gue
, f, f>(
	gsu
, 
	gdd
, 
	gndigs
, 
	gsign
, 
	gexpڒt
, 
	gecisi
);

1220 
dtRoundDP
(
DtBufr
 
su
, 
dd
, 
ndigs
, 
bo
& 
sign
, & 
expڒt
, & 
ecisi
)

1223 
	gdt
<
	gl
, f, 
	gue
, f>(
	gsu
, 
	gdd
, 
	gndigs
, 
	gsign
, 
	gexpڒt
, 
	gecisi
);

1226 cڡ * 
numbToSg
(
d
, 
NumbToSgBufr
 
bufr
)

1228 
	gdoub_cvsi
::
SgBud
 
bud
(
bufr
, 
NumbToSgBufrLgth
);

1229 cڡ 
	gdoub_cvsi
::
DoubToSgCvr
& 
cvr
 = 
doub_cvsi
::DoubToSgCvr::
EcmaStCvr
();

1230 
	gcvr
.
ToSh܋
(
d
, &
bud
);

1231  
	gbud
.
Fize
();

1234 
le
 cڡ * 
fmSgTruntgTgZosIfNded
(
NumbToSgBufr
 
bufr
, 
doub_cvsi
::
SgBud
& 
bud
)

1236 
size_t
 
ngth
 = 
bud
.
posi
();

1237 
size_t
 
	gdecimPotPosi
 = 0;

1238 ; 
	gdecimPotPosi
 < 
	gngth
; ++decimalPointPosition) {

1239 i(
	gbufr
[
decimPotPosi
] == '.')

1244 i(
	gdecimPotPosi
 =
ngth
)

1245  
bud
.
Fize
();

1247 
size_t
 
	gundLgth
 = 
ngth
 - 1;

1248 ; 
	gundLgth
 > 
	gdecimPotPosi
; --truncatedLength) {

1249 i(
	gbufr
[
undLgth
] != '0')

1254 i(
	gundLgth
 =
ngth
 - 1)

1255  
bud
.
Fize
();

1258 i(
	gundLgth
 =
decimPotPosi
) {

1259 
ASSERT
(
undLgth
 > 0);

1260 --
	gundLgth
;

1264 
	gbud
.
SPosi
(
undLgth
 + 1);

1265  
	gbud
.
Fize
();

1268 cڡ * 
numbToFixedPcisiSg
(
d
, 
signifiFigus
, 
NumbToSgBufr
 
bufr
, 
bo
 
unTgZos
)

1275 
	gdoub_cvsi
::
SgBud
 
bud
(
bufr
, 
NumbToSgBufrLgth
);

1276 cڡ 
	gdoub_cvsi
::
DoubToSgCvr
& 
cvr
 = 
doub_cvsi
::DoubToSgCvr::
EcmaStCvr
();

1277 
	gcvr
.
ToPcisi
(
d
, 
signifiFigus
, &
bud
);

1278 i(!
	gunTgZos
)

1279  
	gbud
.
Fize
();

1280  
fmSgTruntgTgZosIfNded
(
bufr
, 
bud
);

1283 cڡ * 
numbToFixedWidthSg
(
d
, 
decimPs
, 
NumbToSgBufr
 
bufr
)

1292 
	gdoub_cvsi
::
SgBud
 
bud
(
bufr
, 
NumbToSgBufrLgth
);

1293 cڡ 
	gdoub_cvsi
::
DoubToSgCvr
& 
cvr
 = 
doub_cvsi
::DoubToSgCvr::
EcmaStCvr
();

1294 
	gcvr
.
ToFixed
(
d
, 
decimPs
, &
bud
);

1295  
	gbud
.
Fize
();

1298 
mea
 
	gIl
 {

1300 
rDoubFromLgSg
(cڡ 
UCh
* 
rg
, 
size_t
 
ngth
, size_t& 
rdLgth
)

1302 
	gVe
<
	gLCh
> 
cvsiBufr
(
ngth
);

1303 
size_t
 
	gi
 = 0; i < 
	gngth
; ++i)

1304 
	gcvsiBufr
[
i
] = 
isASCII
(
rg
[i]) ? string[i] : 0;

1305  
rDoub
(
cvsiBufr
.
da
(), 
ngth
, 
rdLgth
);

	@dtoa.h

21 #ide
WTF_dt_h


22 
	#WTF_dt_h


	)

24 
	~<unicode/utys.h
>

25 
	~<wtf/ASCIICTy.h
>

26 
	~<wtf/dt/doub-cvsi.h
>

27 
	~<wtf/xt/SgVw.h
>

29 
mea
 
	gWTF
 {

31 
ass
 
	gMux
;

33 
Mux
* 
s_dtP5Mux
;

35 
	tDtBufr
[80];

37 
WTF_EXPORT_PRIVATE
 
dt
(
DtBufr
 
su
, 
dd
, 
bo
& 
sign
, & 
expڒt
, & 
ecisi
);

38 
WTF_EXPORT_PRIVATE
 
dtRoundSF
(
DtBufr
 
su
, 
dd
, 
ndigs
, 
bo
& 
sign
, & 
expڒt
, & 
ecisi
);

39 
WTF_EXPORT_PRIVATE
 
dtRoundDP
(
DtBufr
 
su
, 
dd
, 
ndigs
, 
bo
& 
sign
, & 
expڒt
, & 
ecisi
);

42 cڡ 
	gNumbToSgBufrLgth
 = 96;

43 
	tNumbToSgBufr
[
NumbToSgBufrLgth
];

44 
LCh
 
	tNumbToLSgBufr
[
NumbToSgBufrLgth
];

46 
WTF_EXPORT_PRIVATE
 cڡ * 
numbToSg
(, 
NumbToSgBufr
);

47 
WTF_EXPORT_PRIVATE
 cڡ * 
numbToFixedPcisiSg
(, 
signifiFigus
, 
NumbToSgBufr
, 
bo
 
unTgZos
 = 
l
);

48 
WTF_EXPORT_PRIVATE
 cڡ * 
numbToFixedWidthSg
(, 
decimPs
, 
NumbToSgBufr
);

50 
rDoub
(cڡ 
LCh
* 
rg
, 
size_t
 
ngth
, size_t& 
rdLgth
);

51 
rDoub
(cڡ 
UCh
* 
rg
, 
size_t
 
ngth
, size_t& 
rdLgth
);

52 
rDoub
(
SgVw
, 
size_t
& 
rdLgth
);

54 
mea
 
	gIl
 {

55 
WTF_EXPORT_PRIVATE
 
rDoubFromLgSg
(cڡ 
UCh
* 
rg
, 
size_t
 
ngth
, size_t& 
rdLgth
);

58 
le
 
rDoub
(cڡ 
LCh
* 
rg
, 
size_t
 
ngth
, size_t& 
rdLgth
)

60  
	gdoub_cvsi
::
SgToDoubCvr
::
SgToDoub
(
t_
<cڡ *>(
rg
), 
ngth
, &
rdLgth
);

63 
le
 
rDoub
(cڡ 
UCh
* 
rg
, 
size_t
 
ngth
, size_t& 
rdLgth
)

65 cڡ 
size_t
 
	gcvsiBufrSize
 = 64;

66 i(
	gngth
 > 
	gcvsiBufrSize
)

67  
	gIl
::
rDoubFromLgSg
(
rg
, 
ngth
, 
rdLgth
);

68 
LCh
 
	gcvsiBufr
[
cvsiBufrSize
];

69 
	gi
 = 0; i < 
	gic_
<>(
	gngth
); ++i)

70 
	gcvsiBufr
[
i
] = 
isASCII
(
rg
[i]) ? string[i] : 0;

71  
rDoub
(
cvsiBufr
, 
ngth
, 
rdLgth
);

74 
le
 
rDoub
(
SgVw
 
rg
, 
size_t
& 
rdLgth
)

76 i(
	grg
.
is8B
())

77  
rDoub
(
rg
.
chas8
(), sg.
ngth
(), 
rdLgth
);

78  
rDoub
(
rg
.
chas16
(), sg.
ngth
(), 
rdLgth
);

83 
usg
 
	gWTF
::
NumbToSgBufr
;

84 
usg
 
	gWTF
::
NumbToLSgBufr
;

85 
usg
 
	gWTF
::
numbToSg
;

86 
usg
 
	gWTF
::
numbToFixedPcisiSg
;

87 
usg
 
	gWTF
::
numbToFixedWidthSg
;

88 
usg
 
	gWTF
::
rDoub
;

	@dtoa/bignum-dtoa.cc

28 
	~"cfig.h
"

30 
	~<mh.h
>

32 
	~"bignum-dt.h
"

34 
	~"bignum.h
"

35 
	~"doub.h
"

37 
mea
 
	gWTF
 {

39 
mea
 
	gdoub_cvsi
 {

41 
NmizedExpڒt
(
ut64_t
 
signifind
, 
expڒt
) {

42 
ASSERT
(
signifind
 != 0);

43 (
	gsignifind
 & 
	gDoub
::
kHiddB
) == 0) {

44 
signifind
 = significand << 1;

45 
	gexpڒt
 = 
expڒt
 - 1;

47  
	gexpڒt
;

53 
EimePow
(
expڒt
);

56 
InlSdSVues
(
v
,

57 
eimed_pow
,

58 
bo
 
ed_boundy_ds
,

59 
Bignum
* 
num
,

60 
Bignum
* 
dom
,

61 
Bignum
* 
d_mus
,

62 
Bignum
* 
d_us
);

68 
FixupMuɝly10
(
eimed_pow
, 
bo
 
is_ev
,

69 * 
decim_pot
,

70 
Bignum
* 
num
, Bignum* 
dom
,

71 
Bignum
* 
d_mus
, Bignum* 
d_us
);

74 
GeSh܋Digs
(
Bignum
* 
num
, Bignum* 
dom
,

75 
Bignum
* 
d_mus
, Bignum* 
d_us
,

76 
bo
 
is_ev
,

77 
BufrRen
<> 
bufr
, * 
ngth
);

79 
BignumToFixed
(
queed_digs
, * 
decim_pot
,

80 
Bignum
* 
num
, Bignum* 
dom
,

81 
BufrRen
<>(
bufr
), * 
ngth
);

86 
GeCouedDigs
(
cou
, * 
decim_pot
,

87 
Bignum
* 
num
, Bignum* 
dom
,

88 
BufrRen
<>(
bufr
), * 
ngth
);

91 
BignumDt
(
v
, 
BignumDtMode
 
mode
, 
queed_digs
,

92 
BufrRen
<> 
bufr
, * 
ngth
, * 
decim_pot
) {

93 
ASSERT
(
v
 > 0);

94 
ASSERT
(!
Doub
(
v
).
IsScl
());

95 
ut64_t
 
	gsignifind
 = 
Doub
(
v
).
Signifind
();

96 
bo
 
	gis_ev
 = (
signifind
 & 1) == 0;

97 
	gexpڒt
 = 
Doub
(
v
).
Expڒt
();

98 
	gnmized_expڒt
 = 
NmizedExpڒt
(
signifind
, 
expڒt
);

100 
	geimed_pow
 = 
EimePow
(
nmized_expڒt
);

106 i(
	gmode
 =
BIGNUM_DTOA_FIXED
 && -
eimed_pow
 - 1 > 
queed_digs
) {

107 
bufr
[0] = '\0';

108 *
	gngth
 = 0;

112 *
	gdecim_pot
 = -
queed_digs
;

116 
Bignum
 
	gnum
;

117 
Bignum
 
	gdom
;

118 
Bignum
 
	gd_mus
;

119 
Bignum
 
	gd_us
;

124 
ASSERT
(
Bignum
::
kMaxSignifiBs
 >= 324*4);

125 
bo
 
	ged_boundy_ds
 = (
mode
 =
BIGNUM_DTOA_SHORTEST
);

126 
InlSdSVues
(
v
, 
eimed_pow
, 
ed_boundy_ds
,

127 &
num
, &
dom
,

128 &
d_mus
, &
d_us
);

130 
FixupMuɝly10
(
eimed_pow
, 
is_ev
, 
decim_pot
,

131 &
num
, &
dom
,

132 &
d_mus
, &
d_us
);

135 
	gmode
) {

136 
	gBIGNUM_DTOA_SHORTEST
:

137 
GeSh܋Digs
(&
num
, &
dom
,

138 &
d_mus
, &
d_us
,

139 
is_ev
, 
bufr
, 
ngth
);

141 
	gBIGNUM_DTOA_FIXED
:

142 
BignumToFixed
(
queed_digs
, 
decim_pot
,

143 &
num
, &
dom
,

144 
bufr
, 
ngth
);

146 
	gBIGNUM_DTOA_PRECISION
:

147 
GeCouedDigs
(
queed_digs
, 
decim_pot
,

148 &
num
, &
dom
,

149 
bufr
, 
ngth
);

152 
UNREACHABLE
();

154 
	gbufr
[*
ngth
] = '\0';

171 
GeSh܋Digs
(
Bignum
* 
num
, Bignum* 
dom
,

172 
Bignum
* 
d_mus
, Bignum* 
d_us
,

173 
bo
 
is_ev
,

174 
BufrRen
<> 
bufr
, * 
ngth
) {

177 i(
	gBignum
::
Equ
(*
d_mus
, *
d_us
)) {

178 
	gd_us
 = 
d_mus
;

180 *
	gngth
 = 0;

181 
	gue
) {

182 
ut16_t
 
	gdig
;

183 
	gdig
 = 
num
->
DivideModuloIBignum
(*
dom
);

184 
ASSERT
(
dig
 <= 9);

187 
	gbufr
[(*
ngth
)++] = 
dig
 + '0';

194 
bo
 
	g_d_room_mus
;

195 
bo
 
	g_d_room_us
;

196 i(
	gis_ev
) {

197 
	g_d_room_mus
 = 
Bignum
::
LessEqu
(*
num
, *
d_mus
);

199 
	g_d_room_mus
 = 
Bignum
::
Less
(*
num
, *
d_mus
);

201 i(
	gis_ev
) {

202 
	g_d_room_us
 =

203 
Bignum
::
PlusCom
(*
num
, *
d_us
, *
dom
) >= 0;

205 
	g_d_room_us
 =

206 
Bignum
::
PlusCom
(*
num
, *
d_us
, *
dom
) > 0;

208 i(!
	g_d_room_mus
 && !
	g_d_room_us
) {

210 
	gnum
->
Times10
();

211 
	gd_mus
->
Times10
();

215 i(
	gd_mus
 !
d_us
) {

216 
d_us
->
Times10
();

218 } i(
	g_d_room_mus
 && 
	g_d_room_us
) {

221 
	gcom
 = 
Bignum
::
PlusCom
(*
num
, *num, *
dom
);

222 i(
	gcom
 < 0) {

224 } i(
	gcom
 > 0) {

230 
ASSERT
(
bufr
[(*
ngth
) - 1] != '9');

231 
	gbufr
[(*
ngth
) - 1]++;

238 i((
	gbufr
[(*
ngth
) - 1] - '0') % 2 == 0) {

241 
ASSERT
(
bufr
[(*
ngth
) - 1] != '9');

242 
	gbufr
[(*
ngth
) - 1]++;

246 } i(
	g_d_room_mus
) {

255 
ASSERT
(
bufr
[(*
ngth
) -1] != '9');

256 
	gbufr
[(*
ngth
) - 1]++;

269 
GeCouedDigs
(
cou
, * 
decim_pot
,

270 
Bignum
* 
num
, Bignum* 
dom
,

271 
BufrRen
<>(
bufr
), * 
ngth
) {

272 
ASSERT
(
cou
 >= 0);

273 
	gi
 = 0; i < 
	gcou
 - 1; ++i) {

274 
ut16_t
 
	gdig
;

275 
	gdig
 = 
num
->
DivideModuloIBignum
(*
dom
);

276 
ASSERT
(
dig
 <= 9);

279 
	gbufr
[
i
] = 
dig
 + '0';

281 
	gnum
->
Times10
();

284 
ut16_t
 
	gdig
;

285 
	gdig
 = 
num
->
DivideModuloIBignum
(*
dom
);

286 i(
	gBignum
::
PlusCom
(*
num
, *num, *
dom
) >= 0) {

287 
dig
++;

289 
	gbufr
[
cou
 - 1] = 
dig
 + '0';

292 
	gi
 = 
cou
 - 1; i > 0; --i) {

293 i(
	gbufr
[
i
] != '0' + 10) ;

294 
	gbufr
[
i
] = '0';

295 
	gbufr
[
i
 - 1]++;

297 i(
	gbufr
[0] == '0' + 10) {

299 
bufr
[0] = '1';

300 (*
	gdecim_pot
)++;

302 *
	gngth
 = 
cou
;

311 
BignumToFixed
(
queed_digs
, * 
decim_pot
,

312 
Bignum
* 
num
, Bignum* 
dom
,

313 
BufrRen
<>(
bufr
), * 
ngth
) {

317 i(-(*
	gdecim_pot
> 
	gqueed_digs
) {

323 *
	gdecim_pot
 = -
queed_digs
;

324 *
	gngth
 = 0;

326 } i(-(*
	gdecim_pot
=
queed_digs
) {

329 
ASSERT
(*
decim_pot
 =-
queed_digs
);

332 
	gdom
->
Times10
();

333 i(
	gBignum
::
PlusCom
(*
num
, *num, *
dom
) >= 0) {

336 
bufr
[0] = '1';

337 *
	gngth
 = 1;

338 (*
	gdecim_pot
)++;

341 *
	gngth
 = 0;

347 
	geded_digs
 = (*
decim_pot
+ 
queed_digs
;

348 
GeCouedDigs
(
eded_digs
, 
decim_pot
,

349 
num
, 
dom
,

350 
bufr
, 
ngth
);

370 
EimePow
(
expڒt
) {

392 cڡ 
	gk1Log10
 = 0.30102999566398114;

395 cڡ 
	gkSignifindSize
 = 53;

396 
	geime
 = 

((
expڒt
 + 
kSignifindSize
 - 1* 
k1Log10
 - 1e-10);

397  
	gic_
<>(
	geime
);

402 
InlSdSVuesPosiveExpڒt
(

403 
v
, 
eimed_pow
, 
bo
 
ed_boundy_ds
,

404 
Bignum
* 
num
, Bignum* 
dom
,

405 
Bignum
* 
d_mus
, Bignum* 
d_us
) {

407 
ASSERT
(
eimed_pow
 >= 0);

412 
	gnum
->
AssignUI64
(
Doub
(
v
).
Signifind
());

413 
	gnum
->
ShiLe
(
Doub
(
v
).
Expڒt
());

415 
	gdom
->
AssignPowUI16
(10, 
eimed_pow
);

417 i(
	ged_boundy_ds
) {

420 
	gdom
->
ShiLe
(1);

421 
	gnum
->
ShiLe
(1);

424 
	gd_us
->
AssignUI16
(1);

425 
	gd_us
->
ShiLe
(
Doub
(
v
).
Expڒt
());

427 
	gd_mus
->
AssignUI16
(1);

428 
	gd_mus
->
ShiLe
(
Doub
(
v
).
Expڒt
());

435 
ut64_t
 
	gv_bs
 = 
Doub
(
v
).
AsUt64
();

436 i((
	gv_bs
 & 
	gDoub
::
kSignifindMask
) == 0) {

439 
dom
->
ShiLe
(1);

440 
	gnum
->
ShiLe
(1);

441 
	gd_us
->
ShiLe
(1);

448 
InlSdSVuesNegiveExpڒtPosivePow
(

449 
v
, 
eimed_pow
, 
bo
 
ed_boundy_ds
,

450 
Bignum
* 
num
, Bignum* 
dom
,

451 
Bignum
* 
d_mus
, Bignum* 
d_us
) {

452 
ut64_t
 
	gsignifind
 = 
Doub
(
v
).
Signifind
();

453 
	gexpڒt
 = 
Doub
(
v
).
Expڒt
();

461 
	gnum
->
AssignUI64
(
signifind
);

463 
	gdom
->
AssignPowUI16
(10, 
eimed_pow
);

464 
	gdom
->
ShiLe
(-
expڒt
);

466 i(
	ged_boundy_ds
) {

469 
	gdom
->
ShiLe
(1);

470 
	gnum
->
ShiLe
(1);

475 
	gd_us
->
AssignUI16
(1);

477 
	gd_mus
->
AssignUI16
(1);

485 
ut64_t
 
	gv_bs
 = 
Doub
(
v
).
AsUt64
();

486 i((
	gv_bs
 & 
	gDoub
::
kSignifindMask
) == 0) {

489 
dom
->
ShiLe
(1);

490 
	gnum
->
ShiLe
(1);

491 
	gd_us
->
ShiLe
(1);

498 
InlSdSVuesNegiveExpڒtNegivePow
(

499 
v
, 
eimed_pow
, 
bo
 
ed_boundy_ds
,

500 
Bignum
* 
num
, Bignum* 
dom
,

501 
Bignum
* 
d_mus
, Bignum* 
d_us
) {

502 cڡ 
ut64_t
 
	gkMimNmizedExpڒt
 =

503 
UINT64_2PART_C
(0x00100000, 00000000);

504 
ut64_t
 
	gsignifind
 = 
Doub
(
v
).
Signifind
();

505 
	gexpڒt
 = 
Doub
(
v
).
Expڒt
();

510 
Bignum
* 
	gpow_n
 = 
num
;

511 
	gpow_n
->
AssignPowUI16
(10, -
eimed_pow
);

513 i(
	ged_boundy_ds
) {

517 
	gd_us
->
AssignBignum
(*
pow_n
);

518 
	gd_mus
->
AssignBignum
(*
pow_n
);

526 
ASSERT
(
num
 =
pow_n
);

527 
	gnum
->
MuɝlyByUI64
(
signifind
);

530 
	gdom
->
AssignUI16
(1);

531 
	gdom
->
ShiLe
(-
expڒt
);

533 i(
	ged_boundy_ds
) {

536 
	gnum
->
ShiLe
(1);

537 
	gdom
->
ShiLe
(1);

545 
ut64_t
 
	gv_bs
 = 
Doub
(
v
).
AsUt64
();

546 i((
	gv_bs
 & 
	gDoub
::
kSignifindMask
) == 0 &&

549 (
v_bs
 & 
Doub
::
kExpڒtMask
!
kMimNmizedExpڒt
) {

550 
num
->
ShiLe
(1);

551 
	gdom
->
ShiLe
(1);

552 
	gd_us
->
ShiLe
(1);

594 
InlSdSVues
(
v
,

595 
eimed_pow
,

596 
bo
 
ed_boundy_ds
,

597 
Bignum
* 
num
,

598 
Bignum
* 
dom
,

599 
Bignum
* 
d_mus
,

600 
Bignum
* 
d_us
) {

601 i(
Doub
(
v
).
Expڒt
() >= 0) {

602 
InlSdSVuesPosiveExpڒt
(

603 
v
, 
eimed_pow
, 
ed_boundy_ds
,

604 
num
, 
dom
, 
d_mus
, 
d_us
);

605 } i(
	geimed_pow
 >= 0) {

606 
InlSdSVuesNegiveExpڒtPosivePow
(

607 
v
, 
eimed_pow
, 
ed_boundy_ds
,

608 
num
, 
dom
, 
d_mus
, 
d_us
);

610 
InlSdSVuesNegiveExpڒtNegivePow
(

611 
v
, 
eimed_pow
, 
ed_boundy_ds
,

612 
num
, 
dom
, 
d_mus
, 
d_us
);

628 
FixupMuɝly10
(
eimed_pow
, 
bo
 
is_ev
,

629 * 
decim_pot
,

630 
Bignum
* 
num
, Bignum* 
dom
,

631 
Bignum
* 
d_mus
, Bignum* 
d_us
) {

632 
bo
 
	g_nge
;

633 i(
	gis_ev
) {

636 
	g_nge
 = 
Bignum
::
PlusCom
(*
num
, *
d_us
, *
dom
) >= 0;

638 
	g_nge
 = 
Bignum
::
PlusCom
(*
num
, *
d_us
, *
dom
) > 0;

640 i(
	g_nge
) {

643 *
	gdecim_pot
 = 
eimed_pow
 + 1;

645 *
	gdecim_pot
 = 
eimed_pow
;

646 
	gnum
->
Times10
();

647 i(
	gBignum
::
Equ
(*
d_mus
, *
d_us
)) {

648 
	gd_mus
->
Times10
();

649 
	gd_us
->
AssignBignum
(*
d_mus
);

651 
	gd_mus
->
Times10
();

652 
	gd_us
->
Times10
();

	@dtoa/bignum-dtoa.h

28 #ide
DOUBLE_CONVERSION_BIGNUM_DTOA_H_


29 
	#DOUBLE_CONVERSION_BIGNUM_DTOA_H_


	)

31 
	~"uts.h
"

33 
mea
 
	gWTF
 {

35 
mea
 
	gdoub_cvsi
 {

37 
	eBignumDtMode
 {

41 
	gBIGNUM_DTOA_SHORTEST
,

45 
	gBIGNUM_DTOA_FIXED
,

47 
	gBIGNUM_DTOA_PRECISION


79 
BignumDt
(
v
, 
BignumDtMode
 
mode
, 
queed_digs
,

80 
BufrRen
<> 
bufr
, * 
ngth
, * 
pot
);

	@dtoa/bignum.cc

28 
	~"cfig.h
"

30 
	~"bignum.h
"

31 
	~"uts.h
"

33 
mea
 
	gWTF
 {

35 
mea
 
	gdoub_cvsi
 {

37 
	gBignum
::
Bignum
()

38 : 
bigs_
(
bigs_bufr_
, 
kBigCacy
), 
ud_digs_
(0), 
expڒt_
(0) {

39 
	gi
 = 0; i < 
	gkBigCacy
; ++i) {

40 
	gbigs_
[
i
] = 0;

45 
	gme
<
tyme
 
	gS
>

46 
BSize
(
S
 
vue
) {

47  8 * (
	gvue
);

51 
	gBignum
::
AssignUI16
(
ut16_t
 
vue
) {

52 
ASSERT
(
kBigSize
 >
BSize
(
vue
));

53 
Zo
();

54 i(
	gvue
 == 0) ;

56 
EnsuCacy
(1);

57 
	gbigs_
[0] = 
vue
;

58 
	gud_digs_
 = 1;

62 
	gBignum
::
AssignUI64
(
ut64_t
 
vue
) {

63 cڡ 
kUI64Size
 = 64;

65 
Zo
();

66 i(
	gvue
 == 0) ;

68 
	geded_bigs
 = 
kUI64Size
 / 
kBigSize
 + 1;

69 
EnsuCacy
(
eded_bigs
);

70 
	gi
 = 0; i < 
	geded_bigs
; ++i) {

71 
	gbigs_
[
i
] = 
ic_
<
Chunk
>(
vue
 & 
kBigMask
);

72 
	gvue
 = 
vue
 >> 
kBigSize
;

74 
	gud_digs_
 = 
eded_bigs
;

75 
Cmp
();

79 
	gBignum
::
AssignBignum
(cڡ 
Bignum
& 
h
) {

80 
expڒt_
 = 
h
.exponent_;

81 
	gi
 = 0; i < 
	gh
.
	gud_digs_
; ++i) {

82 
	gbigs_
[
i
] = 
h
.
bigs_
[i];

85 
	gi
 = 
h
.
ud_digs_
; i < 
	gud_digs_
; ++i) {

86 
	gbigs_
[
i
] = 0;

88 
	gud_digs_
 = 
h
.
ud_digs_
;

92 
ut64_t
 
RdUI64
(
BufrRen
<cڡ > 
bufr
,

93 
om
,

94 
digs_to_ad
) {

95 
ut64_t
 
	gsu
 = 0;

96 
	gi
 = 
om
; i < 
	gom
 + 
	gdigs_to_ad
; ++i) {

97 
	gdig
 = 
bufr
[
i
] - '0';

98 
ASSERT
(0 <
dig
 && digit <= 9);

99 
	gsu
 = 
su
 * 10 + 
dig
;

101  
	gsu
;

105 
	gBignum
::
AssignDecimSg
(
BufrRen
<cڡ > 
vue
) {

107 cڡ 
kMaxUt64DecimDigs
 = 19;

108 
Zo
();

109 
	gngth
 = 
vue
.
ngth
();

110 
	gpos
 = 0;

112 
	gngth
 >
kMaxUt64DecimDigs
) {

113 
ut64_t
 
digs
 = 
RdUI64
(
vue
, 
pos
, 
kMaxUt64DecimDigs
);

114 
	gpos
 +
kMaxUt64DecimDigs
;

115 
	gngth
 -
kMaxUt64DecimDigs
;

116 
MuɝlyByPowOfT
(
kMaxUt64DecimDigs
);

117 
AddUI64
(
digs
);

119 
ut64_t
 
	gdigs
 = 
RdUI64
(
vue
, 
pos
, 
ngth
);

120 
MuɝlyByPowOfT
(
ngth
);

121 
AddUI64
(
digs
);

122 
Cmp
();

126 
HexChVue
(
c
) {

127 i('0' <
c
 && c <= '9')  c - '0';

128 i('a' <
c
 && c <= 'f')  10 + c - 'a';

129 i('A' <
c
 && c <= 'F')  10 + c - 'A';

130 
UNREACHABLE
();

135 
	gBignum
::
AssignHexSg
(
BufrRen
<cڡ > 
vue
) {

136 
Zo
();

137 
	gngth
 = 
vue
.
ngth
();

139 
	geded_bigs
 = 
ngth
 * 4 / 
kBigSize
 + 1;

140 
EnsuCacy
(
eded_bigs
);

141 
	grg_dex
 = 
ngth
 - 1;

142 
	gi
 = 0; i < 
	geded_bigs
 - 1; ++i) {

144 
Chunk
 
	gcut_big
 = 0;

145 
	gj
 = 0; j < 
	gkBigSize
 / 4; j++) {

146 
	gcut_big
 +
HexChVue
(
vue
[
rg_dex
--]<< (
j
 * 4);

148 
	gbigs_
[
i
] = 
cut_big
;

150 
	gud_digs_
 = 
eded_bigs
 - 1;

152 
Chunk
 
	gmo_signifi_big
 = 0;

153 
	gj
 = 0; j <
rg_dex
; ++j) {

154 
	gmo_signifi_big
 <<= 4;

155 
	gmo_signifi_big
 +
HexChVue
(
vue
[
j
]);

157 i(
	gmo_signifi_big
 != 0) {

158 
bigs_
[
ud_digs_
] = 
mo_signifi_big
;

159 
	gud_digs_
++;

161 
Cmp
();

165 
	gBignum
::
AddUI64
(
ut64_t
 
ݔd
) {

166 i(
ݔd
 == 0) ;

167 
Bignum
 
	gh
;

168 
	gh
.
AssignUI64
(
ݔd
);

169 
AddBignum
(
h
);

173 
	gBignum
::
AddBignum
(cڡ 
Bignum
& 
h
) {

174 
ASSERT
(
IsCmd
());

175 
ASSERT
(
h
.
IsCmd
());

179 
Align
(
h
);

193 
EnsuCacy
(1 + 
Max
(
BigLgth
(), 
h
.BigLgth()- 
expڒt_
);

194 
Chunk
 
	gy
 = 0;

195 
	gbig_pos
 = 
h
.
expڒt_
 -xponent_;

196 
ASSERT
(
big_pos
 >= 0);

197 
	gi
 = 0; i < 
	gh
.
	gud_digs_
; ++i) {

198 
Chunk
 
	gsum
 = 
bigs_
[
big_pos
] + 
h
.bigs_[
i
] + 
y
;

199 
	gbigs_
[
big_pos
] = 
sum
 & 
kBigMask
;

200 
	gy
 = 
sum
 >> 
kBigSize
;

201 
	gbig_pos
++;

204 
	gy
 != 0) {

205 
Chunk
 
sum
 = 
bigs_
[
big_pos
] + 
y
;

206 
	gbigs_
[
big_pos
] = 
sum
 & 
kBigMask
;

207 
	gy
 = 
sum
 >> 
kBigSize
;

208 
	gbig_pos
++;

210 
	gud_digs_
 = 
Max
(
big_pos
, 
ud_digs_
);

211 
ASSERT
(
IsCmd
());

215 
	gBignum
::
SubaBignum
(cڡ 
Bignum
& 
h
) {

216 
ASSERT
(
IsCmd
());

217 
ASSERT
(
h
.
IsCmd
());

219 
ASSERT
(
LessEqu
(
h
, *
this
));

221 
Align
(
h
);

223 
	gofft
 = 
h
.
expڒt_
 -xponent_;

224 
Chunk
 
	gbrow
 = 0;

225 
	gi
;

226 
	gi
 = 0; i < 
	gh
.
	gud_digs_
; ++i) {

227 
ASSERT
((
brow
 == 0) || (borrow == 1));

228 
Chunk
 
	gdifn
 = 
bigs_
[
i
 + 
offt
] - 
h
.bigs_[i] - 
brow
;

229 
	gbigs_
[
i
 + 
offt
] = 
difn
 & 
kBigMask
;

230 
	gbrow
 = 
difn
 >> (
kChunkSize
 - 1);

232 
	gbrow
 != 0) {

233 
Chunk
 
difn
 = 
bigs_
[
i
 + 
offt
] - 
brow
;

234 
	gbigs_
[
i
 + 
offt
] = 
difn
 & 
kBigMask
;

235 
	gbrow
 = 
difn
 >> (
kChunkSize
 - 1);

236 ++
	gi
;

238 
Cmp
();

242 
	gBignum
::
ShiLe
(
shi_amou
) {

243 i(
ud_digs_
 == 0) ;

244 
	gexpڒt_
 +
shi_amou
 / 
kBigSize
;

245 
	glol_shi
 = 
shi_amou
 % 
kBigSize
;

246 
EnsuCacy
(
ud_digs_
 + 1);

247 
BigsShiLe
(
lol_shi
);

251 
	gBignum
::
MuɝlyByUI32
(
ut32_t
 

) {

252 i(

 == 1) ;

253 i(
	g
 == 0) {

254 
Zo
();

257 i(
	gud_digs_
 == 0) ;

261 
ASSERT
(
kDoubChunkSize
 >
kBigSize
 + 32 + 1);

262 
DoubChunk
 
	gy
 = 0;

263 
	gi
 = 0; i < 
	gud_digs_
; ++i) {

264 
DoubChunk
 
	godu
 = 
ic_
<DoubChunk>(

* 
bigs_
[
i
] + 
y
;

265 
	gbigs_
[
i
] = 
ic_
<
Chunk
>(
odu
 & 
kBigMask
);

266 
	gy
 = (
odu
 >> 
kBigSize
);

268 
	gy
 != 0) {

269 
EnsuCacy
(
ud_digs_
 + 1);

270 
	gbigs_
[
ud_digs_
] = 
ic_
<
Chunk
>(
y
 & 
kBigMask
);

271 
	gud_digs_
++;

272 
	gy
 >>
kBigSize
;

277 
	gBignum
::
MuɝlyByUI64
(
ut64_t
 

) {

278 i(

 == 1) ;

279 i(
	g
 == 0) {

280 
Zo
();

283 
ASSERT
(
kBigSize
 < 32);

284 
ut64_t
 
	gy
 = 0;

285 
ut64_t
 
	glow
 = 

 & 0xFFFFFFFF;

286 
ut64_t
 
	ghigh
 = 

 >> 32;

287 
	gi
 = 0; i < 
	gud_digs_
; ++i) {

288 
ut64_t
 
	godu_low
 = 
low
 * 
bigs_
[
i
];

289 
ut64_t
 
	godu_high
 = 
high
 * 
bigs_
[
i
];

290 
ut64_t
 
	gtmp
 = (
y
 & 
kBigMask
+ 
odu_low
;

291 
	gbigs_
[
i
] = 
ic_
<
Chunk
>(
tmp
 & 
kBigMask
);

292 
	gy
 = (
y
 >> 
kBigSize
+ (
tmp
 >> kBigitSize) +

293 (
odu_high
 << (32 - 
kBigSize
));

295 
	gy
 != 0) {

296 
EnsuCacy
(
ud_digs_
 + 1);

297 
	gbigs_
[
ud_digs_
] = 
ic_
<
Chunk
>(
y
 & 
kBigMask
);

298 
	gud_digs_
++;

299 
	gy
 >>
kBigSize
;

304 
	gBignum
::
MuɝlyByPowOfT
(
expڒt
) {

305 cڡ 
ut64_t
 
kFive27
 = 
UINT64_2PART_C
(0x6765c793, 
10079d
);

306 cڡ 
ut16_t
 
	gkFive1
 = 5;

307 cڡ 
ut16_t
 
	gkFive2
 = 
kFive1
 * 5;

308 cڡ 
ut16_t
 
	gkFive3
 = 
kFive2
 * 5;

309 cڡ 
ut16_t
 
	gkFive4
 = 
kFive3
 * 5;

310 cڡ 
ut16_t
 
	gkFive5
 = 
kFive4
 * 5;

311 cڡ 
ut16_t
 
	gkFive6
 = 
kFive5
 * 5;

312 cڡ 
ut32_t
 
	gkFive7
 = 
kFive6
 * 5;

313 cڡ 
ut32_t
 
	gkFive8
 = 
kFive7
 * 5;

314 cڡ 
ut32_t
 
	gkFive9
 = 
kFive8
 * 5;

315 cڡ 
ut32_t
 
	gkFive10
 = 
kFive9
 * 5;

316 cڡ 
ut32_t
 
	gkFive11
 = 
kFive10
 * 5;

317 cڡ 
ut32_t
 
	gkFive12
 = 
kFive11
 * 5;

318 cڡ 
ut32_t
 
	gkFive13
 = 
kFive12
 * 5;

319 cڡ 
ut32_t
 
	gkFive1_to_12
[] =

320 { 
kFive1
, 
kFive2
, 
kFive3
, 
kFive4
, 
kFive5
, 
kFive6
,

321 
kFive7
, 
kFive8
, 
kFive9
, 
kFive10
, 
kFive11
, 
kFive12
 };

323 
ASSERT
(
expڒt
 >= 0);

324 i(
	gexpڒt
 == 0) ;

325 i(
	gud_digs_
 == 0) ;

328 
	gmag_expڒt
 = 
expڒt
;

329 
	gmag_expڒt
 >= 27) {

330 
MuɝlyByUI64
(
kFive27
);

331 
	gmag_expڒt
 -= 27;

333 
	gmag_expڒt
 >= 13) {

334 
MuɝlyByUI32
(
kFive13
);

335 
	gmag_expڒt
 -= 13;

337 i(
	gmag_expڒt
 > 0) {

338 
MuɝlyByUI32
(
kFive1_to_12
[
mag_expڒt
 - 1]);

340 
ShiLe
(
expڒt
);

344 
	gBignum
::
Sque
() {

345 
ASSERT
(
IsCmd
());

346 
	godu_ngth
 = 2 * 
ud_digs_
;

347 
EnsuCacy
(
odu_ngth
);

361 i((1 << (2 * (
	gkChunkSize
 - 
	gkBigSize
))<
ud_digs_
) {

362 
UNIMPLEMENTED
();

364 
DoubChunk
 
	gaccumut
 = 0;

366 
	gcy_offt
 = 
ud_digs_
;

367 
	gi
 = 0; i < 
	gud_digs_
; ++i) {

368 
	gbigs_
[
cy_offt
 + 
i
] = 
bigs_
[i];

371 
	gi
 = 0; i < 
	gud_digs_
; ++i) {

374 
	gbig_dex1
 = 
i
;

375 
	gbig_dex2
 = 0;

377 
	gbig_dex1
 >= 0) {

378 
Chunk
 
chunk1
 = 
bigs_
[
cy_offt
 + 
big_dex1
];

379 
Chunk
 
	gchunk2
 = 
bigs_
[
cy_offt
 + 
big_dex2
];

380 
	gaccumut
 +
ic_
<
DoubChunk
>(
chunk1
* 
chunk2
;

381 
	gbig_dex1
--;

382 
	gbig_dex2
++;

384 
	gbigs_
[
i
] = 
ic_
<
Chunk
>(
accumut
& 
kBigMask
;

385 
	gaccumut
 >>
kBigSize
;

387 
	gi
 = 
ud_digs_
; i < 
	godu_ngth
; ++i) {

388 
	gbig_dex1
 = 
ud_digs_
 - 1;

389 
	gbig_dex2
 = 
i
 - 
big_dex1
;

392 
	gbig_dex2
 < 
	gud_digs_
) {

393 
Chunk
 
	gchunk1
 = 
bigs_
[
cy_offt
 + 
big_dex1
];

394 
Chunk
 
	gchunk2
 = 
bigs_
[
cy_offt
 + 
big_dex2
];

395 
	gaccumut
 +
ic_
<
DoubChunk
>(
chunk1
* 
chunk2
;

396 
	gbig_dex1
--;

397 
	gbig_dex2
++;

402 
	gbigs_
[
i
] = 
ic_
<
Chunk
>(
accumut
& 
kBigMask
;

403 
	gaccumut
 >>
kBigSize
;

407 
ASSERT
(
accumut
 == 0);

410 
	gud_digs_
 = 
odu_ngth
;

411 
	gexpڒt_
 *= 2;

412 
Cmp
();

416 
	gBignum
::
AssignPowUI16
(
ut16_t
 
ba
, 
pow_expڒt
) {

417 
ASSERT
(
ba
 != 0);

418 
ASSERT
(
pow_expڒt
 >= 0);

419 i(
	gpow_expڒt
 == 0) {

420 
AssignUI16
(1);

423 
Zo
();

424 
	gshis
 = 0;

428 (
	gba
 & 1) == 0) {

429 
ba
 >>= 1;

430 
	gshis
++;

432 
	gb_size
 = 0;

433 
	gtmp_ba
 = 
ba
;

434 
	gtmp_ba
 != 0) {

435 
tmp_ba
 >>= 1;

436 
	gb_size
++;

438 
	gf_size
 = 
b_size
 * 
pow_expڒt
;

440 
EnsuCacy
(
f_size
 / 
kBigSize
 + 2);

443 
	gmask
 = 1;

444 
	gpow_expڒt
 >
mask
) mask <<= 1;

449 
	gmask
 >>= 2;

450 
ut64_t
 
	gthis_vue
 = 
ba
;

452 
bo
 
	gdayed_muɝlicti
 = 
l
;

453 cڡ 
ut64_t
 
	gmax_32bs
 = 0xFFFFFFFF;

454 
	gmask
 !0 && 
this_vue
 <
max_32bs
) {

455 
this_vue
 =his_value *his_value;

458 i((
	gpow_expڒt
 & 
	gmask
) != 0) {

459 
ut64_t
 
ba_bs_mask
 =

460 ~((
ic_
<
ut64_t
>(1<< (64 - 
b_size
)) - 1);

461 
bo
 
	ghigh_bs_zo
 = (
this_vue
 & 
ba_bs_mask
) == 0;

462 i(
	ghigh_bs_zo
) {

463 
	gthis_vue
 *
ba
;

465 
	gdayed_muɝlicti
 = 
ue
;

468 
	gmask
 >>= 1;

470 
AssignUI64
(
this_vue
);

471 i(
	gdayed_muɝlicti
) {

472 
MuɝlyByUI32
(
ba
);

476 
	gmask
 != 0) {

477 
Sque
();

478 i((
	gpow_expڒt
 & 
	gmask
) != 0) {

479 
MuɝlyByUI32
(
ba
);

481 
	gmask
 >>= 1;

485 
ShiLe
(
shis
 * 
pow_expڒt
);

490 
ut16_t
 
	gBignum
::
DivideModuloIBignum
(cڡ 
Bignum
& 
h
) {

491 
ASSERT
(
IsCmd
());

492 
ASSERT
(
h
.
IsCmd
());

493 
ASSERT
(
h
.
ud_digs_
 > 0);

497 i(
BigLgth
(< 
	gh
.BigitLength()) {

501 
Align
(
h
);

503 
ut16_t
 
	gsu
 = 0;

507 
BigLgth
(> 
	gh
.BigitLength()) {

511 
ASSERT
(
h
.
bigs_
[h.
ud_digs_
 - 1] >((1 << 
kBigSize
) / 16));

514 
	gsu
 +
bigs_
[
ud_digs_
 - 1];

515 
SubaTimes
(
h
, 
bigs_
[
ud_digs_
 - 1]);

518 
ASSERT
(
BigLgth
(=
h
.BigitLength());

523 
Chunk
 
	gthis_big
 = 
bigs_
[
ud_digs_
 - 1];

524 
Chunk
 
	gh_big
 = 
h
.
bigs_
[h.
ud_digs_
 - 1];

526 i(
	gh
.
	gud_digs_
 == 1) {

528 
quٛ
 = 
this_big
 / 
h_big
;

529 
	gbigs_
[
ud_digs_
 - 1] = 
this_big
 - 
h_big
 * 
quٛ
;

530 
	gsu
 +
quٛ
;

531 
Cmp
();

532  
	gsu
;

535 
	gdivisi_eime
 = 
this_big
 / (
h_big
 + 1);

536 
	gsu
 +
divisi_eime
;

537 
SubaTimes
(
h
, 
divisi_eime
);

539 i(
	gh_big
 * (
	gdivisi_eime
 + 1> 
	gthis_big
) {

542  
	gsu
;

545 
LessEqu
(
h
, *
this
)) {

546 
SubaBignum
(
h
);

547 
	gsu
++;

549  
	gsu
;

553 
	gme
<
tyme
 
	gS
>

554 
SizeInHexChs
(
S
 
numb
) {

555 
ASSERT
(
numb
 > 0);

556 
	gsu
 = 0;

557 
	gnumb
 != 0) {

558 
numb
 >>= 4;

559 
	gsu
++;

561  
	gsu
;

565 
HexChOfVue
(
vue
) {

566 
ASSERT
(0 <
vue
 && value <= 16);

567 i(
	gvue
 < 10)  value + '0';

568  
	gvue
 - 10 + 'A';

572 
bo
 
	gBignum
::
ToHexSg
(* 
bufr
, 
bufr_size
) const {

573 
ASSERT
(
IsCmd
());

575 
ASSERT
(
kBigSize
 % 4 == 0);

576 cڡ 
	gkHexChsPBig
 = 
kBigSize
 / 4;

578 i(
	gud_digs_
 == 0) {

579 i(
bufr_size
 < 2 
l
;

580 
	gbufr
[0] = '0';

581 
	gbufr
[1] = '\0';

582  
	gue
;

585 
	geded_chs
 = (
BigLgth
(- 1* 
kHexChsPBig
 +

586 
SizeInHexChs
(
bigs_
[
ud_digs_
 - 1]) + 1;

587 i(
	geded_chs
 > 
	gbufr_size
 
	gl
;

588 
	grg_dex
 = 
eded_chs
 - 1;

589 
	gbufr
[
rg_dex
--] = '\0';

590 
	gi
 = 0; i < 
	gexpڒt_
; ++i) {

591 
	gj
 = 0; j < 
	gkHexChsPBig
; ++j) {

592 
	gbufr
[
rg_dex
--] = '0';

595 
	gi
 = 0; i < 
	gud_digs_
 - 1; ++i) {

596 
Chunk
 
	gcut_big
 = 
bigs_
[
i
];

597 
	gj
 = 0; j < 
	gkHexChsPBig
; ++j) {

598 
	gbufr
[
rg_dex
--] = 
HexChOfVue
(
cut_big
 & 0xF);

599 
	gcut_big
 >>= 4;

603 
Chunk
 
	gmo_signifi_big
 = 
bigs_
[
ud_digs_
 - 1];

604 
	gmo_signifi_big
 != 0) {

605 
bufr
[
rg_dex
--] = 
HexChOfVue
(
mo_signifi_big
 & 0xF);

606 
	gmo_signifi_big
 >>= 4;

608  
	gue
;

612 
	gBignum
::
Chunk
 
Bignum
::
BigAt
(
dex
) const {

613 i(
dex
 >
BigLgth
())  0;

614 i(
	gdex
 < 
	gexpڒt_
)  0;

615  
	gbigs_
[
dex
 - 
expڒt_
];

619 
	gBignum
::
Com
(cڡ 
Bignum
& 
a
, cڡ Bignum& 
b
) {

620 
ASSERT
(
a
.
IsCmd
());

621 
ASSERT
(
b
.
IsCmd
());

622 
	gbig_ngth_a
 = 
a
.
BigLgth
();

623 
	gbig_ngth_b
 = 
b
.
BigLgth
();

624 i(
	gbig_ngth_a
 < 
	gbig_ngth_b
)  -1;

625 i(
	gbig_ngth_a
 > 
	gbig_ngth_b
)  +1;

626 
	gi
 = 
big_ngth_a
 - 1; i >
M
(
a
.
expڒt_
, 
b
.exponent_); --i) {

627 
Chunk
 
	gbig_a
 = 
a
.
BigAt
(
i
);

628 
Chunk
 
	gbig_b
 = 
b
.
BigAt
(
i
);

629 i(
	gbig_a
 < 
	gbig_b
)  -1;

630 i(
	gbig_a
 > 
	gbig_b
)  +1;

637 
	gBignum
::
PlusCom
(cڡ 
Bignum
& 
a
, cڡ Bignum& 
b
, cڡ Bignum& 
c
) {

638 
ASSERT
(
a
.
IsCmd
());

639 
ASSERT
(
b
.
IsCmd
());

640 
ASSERT
(
c
.
IsCmd
());

641 i(
	ga
.
BigLgth
(< 
	gb
.BigitLength()) {

642  
PlusCom
(
b
, 
a
, 
c
);

644 i(
	ga
.
BigLgth
(+ 1 < 
	gc
.BigitLength())  -1;

645 i(
	ga
.
BigLgth
(> 
	gc
.BigitLength())  +1;

649 i(
	ga
.
	gexpڒt_
 >
b
.
BigLgth
(&& 
a
.BigLgth(< 
c
.BigitLength()) {

653 
Chunk
 
	gbrow
 = 0;

655 
	gm_expڒt
 = 
M
(M(
a
.
expڒt_
, 
b
.expڒt_), 
c
.exponent_);

656 
	gi
 = 
c
.
BigLgth
(- 1; i >
m_expڒt
; --i) {

657 
Chunk
 
	gchunk_a
 = 
a
.
BigAt
(
i
);

658 
Chunk
 
	gchunk_b
 = 
b
.
BigAt
(
i
);

659 
Chunk
 
	gchunk_c
 = 
c
.
BigAt
(
i
);

660 
Chunk
 
	gsum
 = 
chunk_a
 + 
chunk_b
;

661 i(
	gsum
 > 
	gchunk_c
 + 
	gbrow
) {

664 
	gbrow
 = 
chunk_c
 + 
brow
 - 
sum
;

665 i(
	gbrow
 > 1)  -1;

666 
	gbrow
 <<
kBigSize
;

669 i(
	gbrow
 == 0)  0;

674 
	gBignum
::
Cmp
() {

675 
ud_digs_
 > 0 && 
bigs_
[used_digits_ - 1] == 0) {

676 
ud_digs_
--;

678 i(
	gud_digs_
 == 0) {

680 
expڒt_
 = 0;

685 
bo
 
	gBignum
::
IsCmd
() const {

686  
ud_digs_
 =0 || 
bigs_
[used_digits_ - 1] != 0;

690 
	gBignum
::
Zo
() {

691 
i
 = 0; 
	gi
 < 
	gud_digs_
; ++i) {

692 
	gbigs_
[
i
] = 0;

694 
	gud_digs_
 = 0;

695 
	gexpڒt_
 = 0;

699 
	gBignum
::
Align
(cڡ 
Bignum
& 
h
) {

700 i(
expڒt_
 > 
h
.exponent_) {

707 
zo_digs
 = 
expڒt_
 - 
h
.exponent_;

708 
EnsuCacy
(
ud_digs_
 + 
zo_digs
);

709 
	gi
 = 
ud_digs_
 - 1; i >= 0; --i) {

710 
	gbigs_
[
i
 + 
zo_digs
] = 
bigs_
[i];

712 
	gi
 = 0; i < 
	gzo_digs
; ++i) {

713 
	gbigs_
[
i
] = 0;

715 
	gud_digs_
 +
zo_digs
;

716 
	gexpڒt_
 -
zo_digs
;

717 
ASSERT
(
ud_digs_
 >= 0);

718 
ASSERT
(
expڒt_
 >= 0);

723 
	gBignum
::
BigsShiLe
(
shi_amou
) {

724 
ASSERT
(
shi_amou
 < 
kBigSize
);

725 
ASSERT
(
shi_amou
 >= 0);

726 
Chunk
 
	gy
 = 0;

727 
	gi
 = 0; i < 
	gud_digs_
; ++i) {

728 
Chunk
 
	gw_y
 = 
bigs_
[
i
] >> (
kBigSize
 - 
shi_amou
);

729 
	gbigs_
[
i
] = ((
bigs_
[i] << 
shi_amou
+ 
y
& 
kBigMask
;

730 
	gy
 = 
w_y
;

732 i(
	gy
 != 0) {

733 
bigs_
[
ud_digs_
] = 
y
;

734 
	gud_digs_
++;

739 
	gBignum
::
SubaTimes
(cڡ 
Bignum
& 
h
, 

) {

740 #ide
NDEBUG


741 
Bignum
 
	ga
, 
	gb
;

742 
	ga
.
AssignBignum
(*
this
);

743 
	gb
.
AssignBignum
(
h
);

744 
	gb
.
MuɝlyByUI32
(

);

745 
	ga
.
SubaBignum
(
b
);

747 
ASSERT
(
expڒt_
 <
h
.exponent_);

748 i(
	g
 < 3) {

749 
	gi
 = 0; i < 
	g
; ++i) {

750 
SubaBignum
(
h
);

754 
Chunk
 
	gbrow
 = 0;

755 
	gexpڒt_diff
 = 
h
.
expڒt_
 -xponent_;

756 
	gi
 = 0; i < 
	gh
.
	gud_digs_
; ++i) {

757 
DoubChunk
 
	godu
 = 
ic_
<DoubChunk>(

* 
h
.
bigs_
[
i
];

758 
DoubChunk
 
	gmove
 = 
brow
 + 
odu
;

759 
Chunk
 
	gdifn
 =

760 
bigs_
[
i
 + 
expڒt_diff
] - 
ic_
<
Chunk
>(
move
 & 
kBigMask
);

761 
	gbigs_
[
i
 + 
expڒt_diff
] = 
difn
 & 
kBigMask
;

762 
	gbrow
 = 
ic_
<
Chunk
>((
difn
 >> (
kChunkSize
 - 1)) +

763 (
move
 >> 
kBigSize
));

765 
	gi
 = 
h
.
ud_digs_
 + 
expڒt_diff
; i < 
	gud_digs_
; ++i) {

766 i(
	gbrow
 == 0) ;

767 
Chunk
 
	gdifn
 = 
bigs_
[
i
] - 
brow
;

768 
	gbigs_
[
i
] = 
difn
 & 
kBigMask
;

769 
	gbrow
 = 
difn
 >> (
kChunkSize
 - 1);

771 
Cmp
();

772 
ASSERT
(
Bignum
::
Equ
(
a
, *
this
));

	@dtoa/bignum.h

28 #ide
DOUBLE_CONVERSION_BIGNUM_H_


29 
	#DOUBLE_CONVERSION_BIGNUM_H_


	)

31 
	~"uts.h
"

33 
mea
 
	gWTF
 {

35 
mea
 
	gdoub_cvsi
 {

37 as
	cBignum
 {

38 
	gpublic
:

42 cڡ 
kMaxSignifiBs
 = 3584;

44 
Bignum
();

45 
AssignUI16
(
ut16_t
 
vue
);

46 
AssignUI64
(
ut64_t
 
vue
);

47 
AssignBignum
(cڡ 
Bignum
& 
h
);

49 
AssignDecimSg
(
BufrRen
<cڡ > 
vue
);

50 
AssignHexSg
(
BufrRen
<cڡ > 
vue
);

52 
AssignPowUI16
(
ut16_t
 
ba
, 
expڒt
);

54 
AddUI16
(
ut16_t
 
ݔd
);

55 
AddUI64
(
ut64_t
 
ݔd
);

56 
AddBignum
(cڡ 
Bignum
& 
h
);

58 
SubaBignum
(cڡ 
Bignum
& 
h
);

60 
Sque
();

61 
ShiLe
(
shi_amou
);

62 
MuɝlyByUI32
(
ut32_t
 

);

63 
MuɝlyByUI64
(
ut64_t
 

);

64 
MuɝlyByPowOfT
(
expڒt
);

65 
Times10
({  
MuɝlyByUI32
(10); }

70 
ut16_t
 
DivideModuloIBignum
(cڡ 
Bignum
& 
h
);

72 
bo
 
ToHexSg
(* 
bufr
, 
bufr_size
) const;

74 
Com
(cڡ 
Bignum
& 
a
, cڡ Bignum& 
b
);

75 
bo
 
Equ
(cڡ 
Bignum
& 
a
, cڡ Bignum& 
b
) {

76  
Com
(
a
, 
b
) == 0;

78 
bo
 
LessEqu
(cڡ 
Bignum
& 
a
, cڡ Bignum& 
b
) {

79  
Com
(
a
, 
b
) <= 0;

81 
bo
 
Less
(cڡ 
Bignum
& 
a
, cڡ Bignum& 
b
) {

82  
Com
(
a
, 
b
) < 0;

85 
PlusCom
(cڡ 
Bignum
& 
a
, cڡ Bignum& 
b
, cڡ Bignum& 
c
);

87 
bo
 
PlusEqu
(cڡ 
Bignum
& 
a
, cڡ Bignum& 
b
, cڡ Bignum& 
c
) {

88  
PlusCom
(
a
, 
b
, 
c
) == 0;

91 
bo
 
PlusLessEqu
(cڡ 
Bignum
& 
a
, cڡ Bignum& 
b
, cڡ Bignum& 
c
) {

92  
PlusCom
(
a
, 
b
, 
c
) <= 0;

95 
bo
 
PlusLess
(cڡ 
Bignum
& 
a
, cڡ Bignum& 
b
, cڡ Bignum& 
c
) {

96  
PlusCom
(
a
, 
b
, 
c
) < 0;

98 
	give
:

99 
ut32_t
 
	tChunk
;

100 
ut64_t
 
	tDoubChunk
;

102 cڡ 
	gkChunkSize
 = (
Chunk
) * 8;

103 cڡ 
	gkDoubChunkSize
 = (
DoubChunk
) * 8;

106 cڡ 
	gkBigSize
 = 28;

107 cڡ 
Chunk
 
	gkBigMask
 = (1 << 
kBigSize
) - 1;

110 cڡ 
	gkBigCacy
 = 
kMaxSignifiBs
 / 
kBigSize
;

112 
EnsuCacy
(
size
) {

113 i(
	gsize
 > 
	gkBigCacy
) {

114 
UNREACHABLE
();

117 
Align
(cڡ 
Bignum
& 
h
);

118 
Cmp
();

119 
bo
 
IsCmd
() const;

120 
Zo
();

124 
BigsShiLe
(
shi_amou
);

126 
BigLgth
(cڡ {  
	gud_digs_
 + 
	gexpڒt_
; }

127 
Chunk
 
BigAt
(
dex
) const;

128 
SubaTimes
(cڡ 
Bignum
& 
h
, 

);

130 
Chunk
 
	gbigs_bufr_
[
kBigCacy
];

133 
	gBufrRen
<
	gChunk
> 
	gbigs_
;

134 
	gud_digs_
;

136 
	gexpڒt_
;

138 
DISALLOW_COPY_AND_ASSIGN
(
Bignum
);

	@dtoa/cached-powers.cc

28 
	~"cfig.h
"

30 
	~<dg.h
>

31 
	~<lims.h
>

32 
	~<mh.h
>

34 
	~"uts.h
"

35 
	~"ched-pows.h
"

37 
mea
 
	gWTF
 {

39 
mea
 
	gdoub_cvsi
 {

41 
	sCachedPow
 {

42 
ut64_t
 
	gsignifind
;

43 
t16_t
 
	gby_expڒt
;

44 
t16_t
 
	gdecim_expڒt
;

47 
	gkCachedPowsLgth
 = 1;

48 
	gkCachedPowsOfft
 = 1;

49 cڡ 
	gkD_1_LOG2_10
 = 0.30102999566398114;

50 cڡ 
CachedPow
* 
	gkCachedPows
 = 0;

52 
	gPowsOfTCache
::
kDecimExpڒtDi
 = 1;

53 
	gPowsOfTCache
::
kMDecimExpڒt
 = 1;

54 
	gPowsOfTCache
::
kMaxDecimExpڒt
 = 1;

56 
lize
() {

57 i(
	gkCachedPows
)

59 cڡ 
CachedPow
 
	gchedPows
[] = {

60 {
UINT64_2PART_C
(0xfa8fd5a0, 081c0288), -1220, -348},

61 {
UINT64_2PART_C
(0xb17f, 
a23ebf76
), -1193, -340},

62 {
UINT64_2PART_C
(0x8b16fb20, 3055ac76), -1166, -332},

63 {
UINT64_2PART_C
(0xcf42894a, 5dce35ea), -1140, -324},

64 {
UINT64_2PART_C
(0x9a6bb0aa, 55653b2d), -1113, -316},

65 {
UINT64_2PART_C
(0xe61acf03, 3d1a45df), -1087, -308},

66 {
UINT64_2PART_C
(0xab7017, 
c79ac6
), -1060, -300},

67 {
UINT64_2PART_C
(0xff77b1fc, 
bebcdc4f
), -1034, -292},

68 {
UINT64_2PART_C
(0xbe5691ef, 416bd60c), -1007, -284},

69 {
UINT64_2PART_C
(0x8dd01fad, 907ffc3c), -980, -276},

70 {
UINT64_2PART_C
(0xd3515c28, 31559a83), -954, -268},

71 {
UINT64_2PART_C
(0x9d71ac8f, 
ada6c9b5
), -927, -260},

72 {
UINT64_2PART_C
(0xea9c2277, 23ee8bcb), -901, -252},

73 {
UINT64_2PART_C
(0xaecc4991, 4078536d), -874, -244},

74 {
UINT64_2PART_C
(0x823c1279, 5db6ce57), -847, -236},

75 {
UINT64_2PART_C
(0xc2109436, 4dfb5637), -821, -228},

76 {
UINT64_2PART_C
(0x9096ea6f, 3848984f), -794, -220},

77 {
UINT64_2PART_C
(0xd77485cb, 25823ac7), -768, -212},

78 {
UINT64_2PART_C
(0xa086cfcd, 97bf97f4), -741, -204},

79 {
UINT64_2PART_C
(0xef340a98, 172aace5), -715, -196},

80 {
UINT64_2PART_C
(0xb23867fb, 2a35b28e), -688, -188},

81 {
UINT64_2PART_C
(0x84c8d4df, 
d2c63f3b
), -661, -180},

82 {
UINT64_2PART_C
(0xc5dd4427, 1ad3cdba), -635, -172},

83 {
UINT64_2PART_C
(0x936b9f, 
bb25c996
), -608, -164},

84 {
UINT64_2PART_C
(0xdbac6c24, 7d62a584), -582, -156},

85 {
UINT64_2PART_C
(0xa3ab6658, 0d5fdaf6), -555, -148},

86 {
UINT64_2PART_C
(0xf3e2f893, 
dec3f126
), -529, -140},

87 {
UINT64_2PART_C
(0xb5b5ada8, 
ff80b8
), -502, -132},

88 {
UINT64_2PART_C
(0x87625f05, 6c7c4a8b), -475, -124},

89 {
UINT64_2PART_C
(0xc9bcff60, 34c13053), -449, -116},

90 {
UINT64_2PART_C
(0x964e858c, 91ba2655), -422, -108},

91 {
UINT64_2PART_C
(0xdff97724, 70297ebd), -396, -100},

92 {
UINT64_2PART_C
(0xa6dfbd9f, 
b8e5b88f
), -369, -92},

93 {
UINT64_2PART_C
(0xf8a95fcf, 88747d94), -343, -84},

94 {
UINT64_2PART_C
(0xb9447093, 8fa89bcf), -316, -76},

95 {
UINT64_2PART_C
(0x8a08f0f8, 
bf0f156b
), -289, -68},

96 {
UINT64_2PART_C
(0xcdb02555, 653131b6), -263, -60},

97 {
UINT64_2PART_C
(0x9932c6, 
d07b7c
), -236, -52},

98 {
UINT64_2PART_C
(0xe45c10c4, 2a2b3b06), -210, -44},

99 {
UINT64_2PART_C
(0xaa242499, 697392d3), -183, -36},

100 {
UINT64_2PART_C
(0xfd87b5f2, 8300ca0e), -157, -28},

101 {
UINT64_2PART_C
(0xbce50864, 92111aeb), -130, -20},

102 {
UINT64_2PART_C
(0x8cbccc09, 6f5088cc), -103, -12},

103 {
UINT64_2PART_C
(0xd1b71758, 
e219652c
), -77, -4},

104 {
UINT64_2PART_C
(0x9c400000, 00000000), -50, 4},

105 {
UINT64_2PART_C
(0xe8d4a510, 00000000), -24, 12},

106 {
UINT64_2PART_C
(0xad78ebc5, 
ac620000
), 3, 20},

107 {
UINT64_2PART_C
(0x813f3978, 
f8940984
), 30, 28},

108 {
UINT64_2PART_C
(0xc0977b, 
c90715b3
), 56, 36},

109 {
UINT64_2PART_C
(0x8f7e32ce, 7bea5c70), 83, 44},

110 {
UINT64_2PART_C
(0xd5d238a4, 
abe98068
), 109, 52},

111 {
UINT64_2PART_C
(0x9f4f2726, 179a2245), 136, 60},

112 {
UINT64_2PART_C
(0xed63a231, 
d4c4fb27
), 162, 68},

113 {
UINT64_2PART_C
(0xb0de6538, 8cc8ada8), 189, 76},

114 {
UINT64_2PART_C
(0x83c7088e, 1aab65db), 216, 84},

115 {
UINT64_2PART_C
(0xc45d1df9, 42711d9a), 242, 92},

116 {
UINT64_2PART_C
(0x924d692c, 
a61be758
), 269, 100},

117 {
UINT64_2PART_C
(0xda01ee64, 1a708dea), 295, 108},

118 {
UINT64_2PART_C
(0xa26da399, 9aef774a), 322, 116},

119 {
UINT64_2PART_C
(0xf209787b, 
b47d6b85
), 348, 124},

120 {
UINT64_2PART_C
(0xb454e4a1, 79dd1877), 375, 132},

121 {
UINT64_2PART_C
(0x865b8692, 5b9bc5c2), 402, 140},

122 {
UINT64_2PART_C
(0xc83553c5, 
c8965d3d
), 428, 148},

123 {
UINT64_2PART_C
(0x952ab45c, 
97a0b3
), 455, 156},

124 {
UINT64_2PART_C
(0xde469fbd, 99a05fe3), 481, 164},

125 {
UINT64_2PART_C
(0xa59bc234, 
db398c25
), 508, 172},

126 {
UINT64_2PART_C
(0xf6c69a72, 
a3989f5c
), 534, 180},

127 {
UINT64_2PART_C
(0xb7dcbf53, 54e9bece), 561, 188},

128 {
UINT64_2PART_C
(0x88fcf317, 
f22241e2
), 588, 196},

129 {
UINT64_2PART_C
(0xcc209b, 
d35c78a5
), 614, 204},

130 {
UINT64_2PART_C
(0x98165af3, 7b2153df), 641, 212},

131 {
UINT64_2PART_C
(0xe2a0b5dc, 971f303a), 667, 220},

132 {
UINT64_2PART_C
(0xa8d9d153, 5ce3b396), 694, 228},

133 {
UINT64_2PART_C
(0xfb9b7cd9, 
a4a7443c
), 720, 236},

134 {
UINT64_2PART_C
(0xbb764c4c, 
a7a44410
), 747, 244},

135 {
UINT64_2PART_C
(0x8bab8f, 
b6409c1a
), 774, 252},

136 {
UINT64_2PART_C
(0xd01f10, 
a657842c
), 800, 260},

137 {
UINT64_2PART_C
(0x9b10a4e5, 
e9913129
), 827, 268},

138 {
UINT64_2PART_C
(0xe7109bfb, 
a19c0c9d
), 853, 276},

139 {
UINT64_2PART_C
(0xac2820d9, 623bf429), 880, 284},

140 {
UINT64_2PART_C
(0x80444b5e, 7aa7cf85), 907, 292},

141 {
UINT64_2PART_C
(0xbf21e440, 03acdd2d), 933, 300},

142 {
UINT64_2PART_C
(0x8e679c2f, 5e44ff8f), 960, 308},

143 {
UINT64_2PART_C
(0xd433179d, 9c8cb841), 986, 316},

144 {
UINT64_2PART_C
(0x9e19db92, 
b4e31ba9
), 1013, 324},

145 {
UINT64_2PART_C
(0xeb96bf6e, 
badf77d9
), 1039, 332},

146 {
UINT64_2PART_C
(0xaf87023b, 9bf0ee6b), 1066, 340},

148 
	gkCachedPows
 = 
chedPows
;

149 
	gkCachedPowsLgth
 = 
ARRAY_SIZE
(
chedPows
);

150 
	gkCachedPowsOfft
 = -
chedPows
[0].
decim_expڒt
;

151 
	gPowsOfTCache
::
kDecimExpڒtDi
 = 
kCachedPows
[1].
decim_expڒt
 - kCachedPowers[0].decimal_exponent;

152 
	gPowsOfTCache
::
kMDecimExpڒt
 = 
kCachedPows
[0].
decim_expڒt
;

153 
	gPowsOfTCache
::
kMaxDecimExpڒt
 = 
kCachedPows
[
kCachedPowsLgth
 - 1].
decim_expڒt
;

156 
	gPowsOfTCache
::
GCachedPowFByExpڒtRge
(

157 
m_expڒt
,

158 
max_expڒt
,

159 
DiyFp
* 
pow
,

160 * 
decim_expڒt
) {

161 
UNUSED_PARAM
(
max_expڒt
);

162 
	gkQ
 = 
DiyFp
::
kSignifindSize
;

163 
	gk
 = 

((
m_expڒt
 + 
kQ
 - 1* 
kD_1_LOG2_10
);

164 
	gfoo
 = 
kCachedPowsOfft
;

165 
	gdex
 =

166 (
foo
 + 
ic_
<>(
k
- 1/ 
kDecimExpڒtDi
 + 1;

167 
ASSERT
(0 <
dex
 && index < 
kCachedPowsLgth
);

168 
CachedPow
 
	gched_pow
 = 
kCachedPows
[
dex
];

169 
ASSERT
(
m_expڒt
 <
ched_pow
.
by_expڒt
);

170 
ASSERT
(
ched_pow
.
by_expڒt
 <
max_expڒt
);

171 *
	gdecim_expڒt
 = 
ched_pow
.
decim_expڒt
;

172 *
	gpow
 = 
DiyFp
(
ched_pow
.
signifind
, cached_pow.
by_expڒt
);

176 
	gPowsOfTCache
::
GCachedPowFDecimExpڒt
(
queed_expڒt
,

177 
DiyFp
* 
pow
,

178 * 
found_expڒt
) {

179 
ASSERT
(
kMDecimExpڒt
 <
queed_expڒt
);

180 
ASSERT
(
queed_expڒt
 < 
kMaxDecimExpڒt
 + 
kDecimExpڒtDi
);

181 
	gdex
 =

182 (
queed_expڒt
 + 
kCachedPowsOfft
/ 
kDecimExpڒtDi
;

183 
CachedPow
 
	gched_pow
 = 
kCachedPows
[
dex
];

184 *
	gpow
 = 
DiyFp
(
ched_pow
.
signifind
, cached_pow.
by_expڒt
);

185 *
	gfound_expڒt
 = 
ched_pow
.
decim_expڒt
;

186 
ASSERT
(*
found_expڒt
 <
queed_expڒt
);

187 
ASSERT
(
queed_expڒt
 < *
found_expڒt
 + 
kDecimExpڒtDi
);

	@dtoa/cached-powers.h

28 #ide
DOUBLE_CONVERSION_CACHED_POWERS_H_


29 
	#DOUBLE_CONVERSION_CACHED_POWERS_H_


	)

31 
	~"diy-.h
"

33 
mea
 
	gWTF
 {

35 
mea
 
	gdoub_cvsi
 {

37 as
	cPowsOfTCache
 {

38 
	gpublic
:

42 
kDecimExpڒtDi
;

44 
	gkMDecimExpڒt
;

45 
	gkMaxDecimExpڒt
;

49 
GCachedPowFByExpڒtRge
(
m_expڒt
,

50 
max_expڒt
,

51 
DiyFp
* 
pow
,

52 * 
decim_expڒt
);

59 
GCachedPowFDecimExpڒt
(
queed_expڒt
,

60 
DiyFp
* 
pow
,

61 * 
found_expڒt
);

66 
WTF_EXPORT_PRIVATE
 
lize
();

	@dtoa/diy-fp.cc

28 
	~"cfig.h
"

30 
	~"diy-.h
"

31 
	~"uts.h
"

33 
mea
 
	gWTF
 {

35 
mea
 
	gdoub_cvsi
 {

37 
	gDiyFp
::
Muɝly
(cڡ 
DiyFp
& 
h
) {

42 cڡ 
ut64_t
 
kM32
 = 0xFFFFFFFFU;

43 
ut64_t
 
	ga
 = 
f_
 >> 32;

44 
ut64_t
 
	gb
 = 
f_
 & 
kM32
;

45 
ut64_t
 
	gc
 = 
h
.
f_
 >> 32;

46 
ut64_t
 
	gd
 = 
h
.
f_
 & 
kM32
;

47 
ut64_t
 
	gac
 = 
a
 * 
c
;

48 
ut64_t
 
	gbc
 = 
b
 * 
c
;

49 
ut64_t
 
	gad
 = 
a
 * 
d
;

50 
ut64_t
 
	gbd
 = 
b
 * 
d
;

51 
ut64_t
 
	gtmp
 = (
bd
 >> 32+ (
ad
 & 
kM32
+ (
bc
 & kM32);

54 
	gtmp
 += 1U << 31;

55 
ut64_t
 
	gsu_f
 = 
ac
 + (
ad
 >> 32+ (
bc
 >> 32+ (
tmp
 >> 32);

56 
	ge_
 +
h
.
e_
 + 64;

57 
	gf_
 = 
su_f
;

	@dtoa/diy-fp.h

28 #ide
DOUBLE_CONVERSION_DIY_FP_H_


29 
	#DOUBLE_CONVERSION_DIY_FP_H_


	)

31 
	~"uts.h
"

33 
mea
 
	gWTF
 {

35 
mea
 
	gdoub_cvsi
 {

42 as
	cDiyFp
 {

43 
	gpublic
:

44 cڡ 
kSignifindSize
 = 64;

46 
DiyFp
(: 
f_
(0), 
e_
(0) {}

47 
DiyFp
(
ut64_t
 
f
, 
e
: 
f_
(f), 
e_
(e) {}

53 
Suba
(cڡ 
DiyFp
& 
h
) {

54 
ASSERT
(
e_
 =
h
.e_);

55 
ASSERT
(
f_
 >
h
.f_);

56 
	gf_
 -
h
.
f_
;

62 
DiyFp
 
Mus
(cڡ DiyFp& 
a
, cڡ DiyFp& 
b
) {

63 
DiyFp
 
	gsu
 = 
a
;

64 
	gsu
.
Suba
(
b
);

65  
	gsu
;

70 
Muɝly
(cڡ 
DiyFp
& 
h
);

73 
DiyFp
 
Times
(cڡ DiyFp& 
a
, cڡ DiyFp& 
b
) {

74 
DiyFp
 
	gsu
 = 
a
;

75 
	gsu
.
Muɝly
(
b
);

76  
	gsu
;

79 
Nmize
() {

80 
ASSERT
(
f_
 != 0);

81 
ut64_t
 
	gf
 = 
f_
;

82 
	ge
 = 
e_
;

86 cڡ 
ut64_t
 
	gk10MSBs
 = 
UINT64_2PART_C
(0xFFC00000, 00000000);

87 (
	gf
 & 
	gk10MSBs
) == 0) {

88 
f
 <<= 10;

89 
	ge
 -= 10;

91 (
	gf
 & 
	gkUt64MSB
) == 0) {

92 
f
 <<= 1;

93 
	ge
--;

95 
	gf_
 = 
f
;

96 
	ge_
 = 
e
;

99 
DiyFp
 
Nmize
(cڡ DiyFp& 
a
) {

100 
DiyFp
 
	gsu
 = 
a
;

101 
	gsu
.
Nmize
();

102  
	gsu
;

105 
ut64_t
 
f
(cڡ {  
	gf_
; }

106 
e
(cڡ {  
	ge_
; }

108 
t_f
(
ut64_t
 
w_vue
{ 
	gf_
 =ew_value; }

109 
t_e
(
w_vue
{ 
	ge_
 =ew_value; }

111 
	give
:

112 cڡ 
ut64_t
 
kUt64MSB
 = 
UINT64_2PART_C
(0x80000000, 00000000);

114 
ut64_t
 
	gf_
;

115 
	ge_
;

	@dtoa/double-conversion.cc

28 
	~"cfig.h
"

30 
	~<lims.h
>

31 
	~<mh.h
>

33 
	~"doub-cvsi.h
"

35 
	~"bignum-dt.h
"

36 
	~"doub.h
"

37 
	~"-dt.h
"

38 
	~"fixed-dt.h
"

39 
	~"od.h
"

40 
	~"uts.h
"

42 
mea
 
	gWTF
 {

44 
mea
 
	gdoub_cvsi
 {

46 cڡ 
	gDoubToSgCvr
& DoubToSgCvr::
EcmaStCvr
() {

47 
ags
 = 
UNIQUE_ZERO
 | 
EMIT_POSITIVE_EXPONENT_SIGN
;

48 
DoubToSgCvr
 
cvr
(
ags
,

54  
	gcvr
;

58 
bo
 
	gDoubToSgCvr
::
HdSclVues
(

59 
vue
,

60 
SgBud
* 
su_bud
) const {

61 
Doub
 
doub_e
(
vue
);

62 i(
	gdoub_e
.
IsInfe
()) {

63 i(
	gfy_symb_
 =
NULL
 
l
;

64 i(
	gvue
 < 0) {

65 
	gsu_bud
->
AddCha
('-');

67 
	gsu_bud
->
AddSg
(
fy_symb_
);

68  
	gue
;

70 i(
	gdoub_e
.
IsN
()) {

71 i(
	gn_symb_
 =
NULL
 
l
;

72 
	gsu_bud
->
AddSg
(
n_symb_
);

73  
	gue
;

75  
	gl
;

79 
	gDoubToSgCvr
::
CeExpڒtlRi
(

80 cڡ * 
decim_digs
,

81 
ngth
,

82 
expڒt
,

83 
SgBud
* 
su_bud
) const {

84 
ASSERT
(
ngth
 != 0);

85 
	gsu_bud
->
AddCha
(
decim_digs
[0]);

86 i(
	gngth
 != 1) {

87 
su_bud
->
AddCha
('.');

88 
	gsu_bud
->
AddSubrg
(&
decim_digs
[1], 
ngth
-1);

90 
	gsu_bud
->
AddCha
(
expڒt_cha_
);

91 i(
	gexpڒt
 < 0) {

92 
	gsu_bud
->
AddCha
('-');

93 
	gexpڒt
 = -
expڒt
;

95 i((
	gags_
 & 
	gEMIT_POSITIVE_EXPONENT_SIGN
) != 0) {

96 
su_bud
->
AddCha
('+');

99 i(
	gexpڒt
 == 0) {

100 
su_bud
->
AddCha
('0');

103 
ASSERT
(
expڒt
 < 1e4);

104 cڡ 
	gkMaxExpڒtLgth
 = 5;

105 
	gbufr
[
kMaxExpڒtLgth
 + 1];

106 
	gf_ch_pos
 = 
kMaxExpڒtLgth
;

107 
	gbufr
[
f_ch_pos
] = '\0';

108 
	gexpڒt
 > 0) {

109 
	gbufr
[--
f_ch_pos
] = '0' + (
expڒt
 % 10);

110 
	gexpڒt
 /= 10;

112 
	gsu_bud
->
AddSubrg
(&
bufr
[
f_ch_pos
],

113 
kMaxExpڒtLgth
 - 
f_ch_pos
);

117 
	gDoubToSgCvr
::
CeDecimRi
(

118 cڡ * 
decim_digs
,

119 
ngth
,

120 
decim_pot
,

121 
digs_a_pot
,

122 
SgBud
* 
su_bud
) const {

124 i(
	gdecim_pot
 <= 0) {

126 
su_bud
->
AddCha
('0');

127 i(
	gdigs_a_pot
 > 0) {

128 
	gsu_bud
->
AddCha
('.');

129 
	gsu_bud
->
AddPaddg
('0', -
decim_pot
);

130 
ASSERT
(
ngth
 <
digs_a_pot
 - (-
decim_pot
));

131 
	gsu_bud
->
AddSubrg
(
decim_digs
, 
ngth
);

132 
	gmag_digs
 = 
digs_a_pot
 - (-
decim_pot
- 
ngth
;

133 
	gsu_bud
->
AddPaddg
('0', 
mag_digs
);

135 } i(
	gdecim_pot
 >
ngth
) {

137 
su_bud
->
AddSubrg
(
decim_digs
, 
ngth
);

138 
	gsu_bud
->
AddPaddg
('0', 
decim_pot
 - 
ngth
);

139 i(
	gdigs_a_pot
 > 0) {

140 
	gsu_bud
->
AddCha
('.');

141 
	gsu_bud
->
AddPaddg
('0', 
digs_a_pot
);

145 
ASSERT
(
digs_a_pot
 > 0);

146 
	gsu_bud
->
AddSubrg
(
decim_digs
, 
decim_pot
);

147 
	gsu_bud
->
AddCha
('.');

148 
ASSERT
(
ngth
 - 
decim_pot
 <
digs_a_pot
);

149 
	gsu_bud
->
AddSubrg
(&
decim_digs
[
decim_pot
],

150 
ngth
 - 
decim_pot
);

151 
	gmag_digs
 = 
digs_a_pot
 - (
ngth
 - 
decim_pot
);

152 
	gsu_bud
->
AddPaddg
('0', 
mag_digs
);

154 i(
	gdigs_a_pot
 == 0) {

155 i((
ags_
 & 
EMIT_TRAILING_DECIMAL_POINT
) != 0) {

156 
su_bud
->
AddCha
('.');

158 i((
	gags_
 & 
	gEMIT_TRAILING_ZERO_AFTER_POINT
) != 0) {

159 
su_bud
->
AddCha
('0');

165 
bo
 
	gDoubToSgCvr
::
ToSh܋
(
vue
,

166 
SgBud
* 
su_bud
) const {

167 i(
Doub
(
vue
).
IsScl
()) {

168  
HdSclVues
(
vue
, 
su_bud
);

171 
	gdecim_pot
;

172 
bo
 
	gsign
;

173 cڡ 
	gkDecimRCacy
 = 
kBa10MaximLgth
 + 1;

174 
	gdecim_p
[
kDecimRCacy
];

175 
	gdecim_p_ngth
;

177 
DoubToAscii
(
vue
, 
SHORTEST
, 0, 
decim_p
, 
kDecimRCacy
,

178 &
sign
, &
decim_p_ngth
, &
decim_pot
);

180 
bo
 
	gunique_zo
 = (
ags_
 & 
UNIQUE_ZERO
) != 0;

181 i(
	gsign
 && (
	gvue
 !0.0 || !
unique_zo
)) {

182 
su_bud
->
AddCha
('-');

185 
	gexpڒt
 = 
decim_pot
 - 1;

186 i((
	gdecim__sh܋_low_
 <
expڒt
) &&

187 (
expڒt
 < 
decim__sh܋_high_
)) {

188 
CeDecimRi
(
decim_p
, 
decim_p_ngth
,

189 
decim_pot
,

190 
Max
(0, 
decim_p_ngth
 - 
decim_pot
),

191 
su_bud
);

193 
CeExpڒtlRi
(
decim_p
, 
decim_p_ngth
, 
expڒt
,

194 
su_bud
);

196  
	gue
;

200 
bo
 
	gDoubToSgCvr
::
ToFixed
(
vue
,

201 
queed_digs
,

202 
SgBud
* 
su_bud
) const {

203 
ASSERT
(
kMaxFixedDigsBefePot
 == 60);

204 cڡ 
	gkFNFixed
 = 1e60;

206 i(
Doub
(
vue
).
IsScl
()) {

207  
HdSclVues
(
vue
, 
su_bud
);

210 i(
	gqueed_digs
 > 
	gkMaxFixedDigsAPot
 
	gl
;

211 i(
	gvue
 >
kFNFixed
 || 
vue
 <-kFNFixed 
l
;

214 
	gdecim_pot
;

215 
bo
 
	gsign
;

217 cڡ 
	gkDecimRCacy
 =

218 
kMaxFixedDigsBefePot
 + 
kMaxFixedDigsAPot
 + 1;

219 
	gdecim_p
[
kDecimRCacy
];

220 
	gdecim_p_ngth
;

221 
DoubToAscii
(
vue
, 
FIXED
, 
queed_digs
,

222 
decim_p
, 
kDecimRCacy
,

223 &
sign
, &
decim_p_ngth
, &
decim_pot
);

225 
bo
 
	gunique_zo
 = ((
ags_
 & 
UNIQUE_ZERO
) != 0);

226 i(
	gsign
 && (
	gvue
 !0.0 || !
unique_zo
)) {

227 
su_bud
->
AddCha
('-');

230 
CeDecimRi
(
decim_p
, 
decim_p_ngth
, 
decim_pot
,

231 
queed_digs
, 
su_bud
);

232  
	gue
;

236 
bo
 
	gDoubToSgCvr
::
ToExpڒtl
(

237 
vue
,

238 
queed_digs
,

239 
SgBud
* 
su_bud
) const {

240 i(
Doub
(
vue
).
IsScl
()) {

241  
HdSclVues
(
vue
, 
su_bud
);

244 i(
	gqueed_digs
 < -1 
	gl
;

245 i(
	gqueed_digs
 > 
	gkMaxExpڒtlDigs
 
	gl
;

247 
	gdecim_pot
;

248 
bo
 
	gsign
;

250 cڡ 
	gkDecimRCacy
 = 
kMaxExpڒtlDigs
 + 2;

251 
ASSERT
(
kDecimRCacy
 > 
kBa10MaximLgth
);

252 
	gdecim_p
[
kDecimRCacy
];

253 
	gdecim_p_ngth
;

255 i(
	gqueed_digs
 == -1) {

256 
DoubToAscii
(
vue
, 
SHORTEST
, 0,

257 
decim_p
, 
kDecimRCacy
,

258 &
sign
, &
decim_p_ngth
, &
decim_pot
);

260 
DoubToAscii
(
vue
, 
PRECISION
, 
queed_digs
 + 1,

261 
decim_p
, 
kDecimRCacy
,

262 &
sign
, &
decim_p_ngth
, &
decim_pot
);

263 
ASSERT
(
decim_p_ngth
 <
queed_digs
 + 1);

265 
	gi
 = 
decim_p_ngth
; i < 
	gqueed_digs
 + 1; ++i) {

266 
	gdecim_p
[
i
] = '0';

268 
	gdecim_p_ngth
 = 
queed_digs
 + 1;

271 
bo
 
	gunique_zo
 = ((
ags_
 & 
UNIQUE_ZERO
) != 0);

272 i(
	gsign
 && (
	gvue
 !0.0 || !
unique_zo
)) {

273 
su_bud
->
AddCha
('-');

276 
	gexpڒt
 = 
decim_pot
 - 1;

277 
CeExpڒtlRi
(
decim_p
,

278 
decim_p_ngth
,

279 
expڒt
,

280 
su_bud
);

281  
	gue
;

285 
bo
 
	gDoubToSgCvr
::
ToPcisi
(
vue
,

286 
ecisi
,

287 
SgBud
* 
su_bud
) const {

288 i(
Doub
(
vue
).
IsScl
()) {

289  
HdSclVues
(
vue
, 
su_bud
);

292 i(
	gecisi
 < 
	gkMPcisiDigs
 ||cisi > 
	gkMaxPcisiDigs
) {

293  
	gl
;

297 
	gdecim_pot
;

298 
bo
 
	gsign
;

300 cڡ 
	gkDecimRCacy
 = 
kMaxPcisiDigs
 + 1;

301 
	gdecim_p
[
kDecimRCacy
];

302 
	gdecim_p_ngth
;

304 
DoubToAscii
(
vue
, 
PRECISION
, 
ecisi
,

305 
decim_p
, 
kDecimRCacy
,

306 &
sign
, &
decim_p_ngth
, &
decim_pot
);

307 
ASSERT
(
decim_p_ngth
 <
ecisi
);

309 
bo
 
	gunique_zo
 = ((
ags_
 & 
UNIQUE_ZERO
) != 0);

310 i(
	gsign
 && (
	gvue
 !0.0 || !
unique_zo
)) {

311 
su_bud
->
AddCha
('-');

316 
	gexpڒt
 = 
decim_pot
 - 1;

318 
	gexa_zo
 = ((
ags_
 & 
EMIT_TRAILING_ZERO_AFTER_POINT
) != 0) ? 1 : 0;

319 i((-
	gdecim_pot
 + 1 > 
	gmax_adg_ddg_zs__ecisi_mode_
) ||

320 (
	gdecim_pot
 - 
	gecisi
 + 
	gexa_zo
 >

321 
	gmax_ag_ddg_zs__ecisi_mode_
)) {

325 
	gi
 = 
decim_p_ngth
; i < 
	gecisi
; ++i) {

326 
	gdecim_p
[
i
] = '0';

329 
CeExpڒtlRi
(
decim_p
,

330 
ecisi
,

331 
expڒt
,

332 
su_bud
);

334 
CeDecimRi
(
decim_p
, 
decim_p_ngth
, 
decim_pot
,

335 
Max
(0, 
ecisi
 - 
decim_pot
),

336 
su_bud
);

338  
	gue
;

342 
BignumDtMode
 
DtToBignumDtMode
(

343 
DoubToSgCvr
::
DtMode
 
dt_mode
) {

344 
dt_mode
) {

345 
DoubToSgCvr
::
SHORTEST
:  
BIGNUM_DTOA_SHORTEST
;

346 
	gDoubToSgCvr
::
FIXED
:  
BIGNUM_DTOA_FIXED
;

347 
	gDoubToSgCvr
::
PRECISION
:  
BIGNUM_DTOA_PRECISION
;

349 
UNREACHABLE
();

350  
	gBIGNUM_DTOA_SHORTEST
;

355 
	gDoubToSgCvr
::
DoubToAscii
(
v
,

356 
DtMode
 
mode
,

357 
queed_digs
,

358 * 
bufr
,

359 
bufr_ngth
,

360 
bo
* 
sign
,

361 * 
ngth
,

362 * 
pot
) {

363 
	gBufrRen
<> 
ve
(
bufr
, 
bufr_ngth
);

364 
ASSERT
(!
Doub
(
v
).
IsScl
());

365 
ASSERT
(
mode
 =
SHORTEST
 || 
queed_digs
 >= 0);

367 i(
Doub
(
v
).
Sign
() < 0) {

368 *
	gsign
 = 
ue
;

369 
	gv
 = -
v
;

371 *
	gsign
 = 
l
;

374 i(
	gmode
 =
PRECISION
 && 
queed_digs
 == 0) {

375 
ve
[0] = '\0';

376 *
	gngth
 = 0;

380 i(
	gv
 == 0) {

381 
ve
[0] = '0';

382 
	gve
[1] = '\0';

383 *
	gngth
 = 1;

384 *
	gpot
 = 1;

388 
bo
 
	g_wked
;

389 
	gmode
) {

390 
	gSHORTEST
:

391 
_wked
 = 
FaDt
(
v
, 
FAST_DTOA_SHORTEST
, 0, 
ve
, 
ngth
, 
pot
);

393 
	gFIXED
:

394 
_wked
 = 
FaFixedDt
(
v
, 
queed_digs
, 
ve
, 
ngth
, 
pot
);

396 
	gPRECISION
:

397 
_wked
 = 
FaDt
(
v
, 
FAST_DTOA_PRECISION
, 
queed_digs
,

398 
ve
, 
ngth
, 
pot
);

401 
UNREACHABLE
();

402 
	g_wked
 = 
l
;

404 i(
	g_wked
) ;

407 
BignumDtMode
 
	gbignum_mode
 = 
DtToBignumDtMode
(
mode
);

408 
BignumDt
(
v
, 
bignum_mode
, 
queed_digs
, 
ve
, 
ngth
, 
pot
);

409 
	gve
[*
ngth
] = '\0';

420 cڡ 
	gkMaxSignifiDigs
 = 772;

423 
SigdZo
(
bo
 
sign
) {

424  
	gsign
 ? -0.0 : 0.0;

428 
	gSgToDoubCvr
::
SgToDoub
(

429 cڡ * 
put
,

430 
size_t
 
ngth
,

431 
size_t
* 
osd_chas_cou
) {

432 cڡ * 
	gcut
 = 
put
;

433 cڡ * 
	gd
 = 
put
 + 
ngth
;

435 *
	gosd_chas_cou
 = 0;

444 i(
	gcut
 =
d
)  0.0;

447 cڡ 
	gkBufrSize
 = 
kMaxSignifiDigs
 + 10;

448 
	gbufr
[
kBufrSize
];

449 
	gbufr_pos
 = 0;

453 
	gexpڒt
 = 0;

454 
	gsignifi_digs
 = 0;

455 
	gsignifi_digs
 = 0;

456 
bo
 
	gnzo_dig_drݳd
 = 
l
;

457 
bo
 
	gsign
 = 
l
;

459 i(*
	gcut
 ='+' || *
cut
 == '-') {

460 
sign
 = (*
cut
 == '-');

461 ++
	gcut
;

462 i(
	gcut
 =
d
)  0.0;

465 
bo
 
	gadg_zo
 = 
l
;

466 i(*
	gcut
 == '0') {

467 ++
cut
;

468 i(
	gcut
 =
d
) {

469 *
osd_chas_cou
 = 
cut
 - 
put
;

470  
SigdZo
(
sign
);

473 
	gadg_zo
 = 
ue
;

476 *
	gcut
 == '0') {

477 ++
cut
;

478 i(
	gcut
 =
d
) {

479 *
osd_chas_cou
 = 
cut
 - 
put
;

480  
SigdZo
(
sign
);

486 *
	gcut
 >'0' && *
cut
 <= '9') {

487 i(
signifi_digs
 < 
kMaxSignifiDigs
) {

488 
ASSERT
(
bufr_pos
 < 
kBufrSize
);

489 
	gbufr
[
bufr_pos
++] = 
ic_
<>(*
cut
);

490 
	gsignifi_digs
++;

492 
	gsignifi_digs
++;

493 
	gnzo_dig_drݳd
 = 
nzo_dig_drݳd
 || *
cut
 != '0';

495 ++
	gcut
;

496 i(
	gcut
 =
d

rsg_de
;

499 i(*
	gcut
 == '.') {

500 ++
cut
;

501 i(
	gcut
 =
d
) {

502 i(
signifi_digs
 =0 && !
adg_zo
) {

505 
	grsg_de
;

509 i(
	gsignifi_digs
 == 0) {

512 *
cut
 == '0') {

513 ++
cut
;

514 i(
	gcut
 =
d
) {

515 *
osd_chas_cou
 = 
cut
 - 
put
;

516  
SigdZo
(
sign
);

518 
	gexpڒt
--;

523 *
	gcut
 >'0' && *
cut
 <= '9') {

524 i(
signifi_digs
 < 
kMaxSignifiDigs
) {

525 
ASSERT
(
bufr_pos
 < 
kBufrSize
);

526 
	gbufr
[
bufr_pos
++] = 
ic_
<>(*
cut
);

527 
	gsignifi_digs
++;

528 
	gexpڒt
--;

531 
	gnzo_dig_drݳd
 = 
nzo_dig_drݳd
 || *
cut
 != '0';

533 ++
	gcut
;

534 i(
	gcut
 =
d

rsg_de
;

538 i(!
	gadg_zo
 && 
	gexpڒt
 =0 && 
signifi_digs
 == 0) {

547 i(*
	gcut
 ='e' || *
cut
 == 'E') {

548 ++
cut
;

549 i(
	gcut
 =
d
) {

550 --
cut
;

551 
	grsg_de
;

553 
	gsign
 = 0;

554 i(*
	gcut
 ='+' || *
cut
 == '-') {

555 
sign
 = 
ic_
<>(*
cut
);

556 ++
	gcut
;

557 i(
	gcut
 =
d
) {

558 
cut
 -= 2;

559 
	grsg_de
;

563 i(*
	gcut
 < '0' || *current > '9') {

564 i(
	gsign
)

565 --
	gcut
;

566 --
	gcut
;

567 
	grsg_de
;

570 cڡ 
	gmax_expڒt
 = 
INT_MAX
 / 2;

571 
ASSERT
(-
max_expڒt
 / 2 <
expڒt
 &&xponent <= max_exponent / 2);

572 
	gnum
 = 0;

575 
	gdig
 = *
cut
 - '0';

576 i(
	gnum
 >
max_expڒt
 / 10

577 && !(
num
 =
max_expڒt
 / 10 && 
dig
 <= max_exponent % 10)) {

578 
num
 = 
max_expڒt
;

580 
	gnum
 = 
num
 * 10 + 
dig
;

582 ++
	gcut
;

583 } 
	gcut
 !
d
 && *
cut
 >= '0' && *current <= '9');

585 
	gexpڒt
 +(
sign
 ='-' ? -
num
 :um);

588 
	grsg_de
:

589 
expڒt
 +
signifi_digs
;

591 i(
	gnzo_dig_drݳd
) {

592 
	gbufr
[
bufr_pos
++] = '1';

593 
	gexpڒt
--;

596 
ASSERT
(
bufr_pos
 < 
kBufrSize
);

597 
	gbufr
[
bufr_pos
] = '\0';

599 
	gcvd
 = 
Stod
(
BufrRen
<cڡ >(
bufr
, 
bufr_pos
), 
expڒt
);

600 *
	gosd_chas_cou
 = 
cut
 - 
put
;

601  
	gsign
? -
	gcvd
: 
cvd
;

	@dtoa/double-conversion.h

28 #ide
DOUBLE_CONVERSION_DOUBLE_CONVERSION_H_


29 
	#DOUBLE_CONVERSION_DOUBLE_CONVERSION_H_


	)

31 
	~<wtf/dt/uts.h
>

33 
mea
 
	gWTF
 {

35 
mea
 
	gdoub_cvsi
 {

37 as
	cDoubToSgCvr
 {

38 
	gpublic
:

42 cڡ 
kMaxFixedDigsBefePot
 = 60;

43 cڡ 
	gkMaxFixedDigsAPot
 = 60;

47 cڡ 
	gkMaxExpڒtlDigs
 = 120;

52 cڡ 
	gkMPcisiDigs
 = 1;

53 cڡ 
	gkMaxPcisiDigs
 = 120;

55 
	eFgs
 {

56 
	gNO_FLAGS
 = 0,

57 
	gEMIT_POSITIVE_EXPONENT_SIGN
 = 1,

58 
	gEMIT_TRAILING_DECIMAL_POINT
 = 2,

59 
	gEMIT_TRAILING_ZERO_AFTER_POINT
 = 4,

60 
	gUNIQUE_ZERO
 = 8

109 
DoubToSgCvr
(
ags
,

110 cڡ * 
fy_symb
,

111 cڡ * 
n_symb
,

112 
expڒt_cha
,

113 
decim__sh܋_low
,

114 
decim__sh܋_high
,

115 
max_adg_ddg_zs__ecisi_mode
,

116 
max_ag_ddg_zs__ecisi_mode
)

117 : 
ags_
(
ags
),

118 
fy_symb_
(
fy_symb
),

119 
n_symb_
(
n_symb
),

120 
expڒt_cha_
(
expڒt_cha
),

121 
decim__sh܋_low_
(
decim__sh܋_low
),

122 
decim__sh܋_high_
(
decim__sh܋_high
),

123 
max_adg_ddg_zs__ecisi_mode_
(

124 
max_adg_ddg_zs__ecisi_mode
),

125 
max_ag_ddg_zs__ecisi_mode_
(

126 
max_ag_ddg_zs__ecisi_mode
) {

129 
ASSERT
(((
ags
 & 
EMIT_TRAILING_DECIMAL_POINT
) != 0) ||

130 !((
ags
 & 
EMIT_TRAILING_ZERO_AFTER_POINT
) != 0));

134 
WTF_EXPORT_PRIVATE
 cڡ 
	gDoubToSgCvr
& 
EcmaStCvr
();

159 
bo
 
ToSh܋
(
vue
, 
SgBud
* 
su_bud
) const;

195 
bo
 
ToFixed
(
vue
,

196 
queed_digs
,

197 
SgBud
* 
su_bud
) const;

227 
WTF_EXPORT_PRIVATE
 
bo
 
ToExpڒtl
(
vue
,

228 
queed_digs
,

229 
SgBud
* 
su_bud
) const;

265 
bo
 
ToPcisi
(
vue
,

266 
ecisi
,

267 
SgBud
* 
su_bud
) const;

269 
	eDtMode
 {

273 
	gSHORTEST
,

277 
	gFIXED
,

279 
	gPRECISION


288 cڡ 
	gkBa10MaximLgth
 = 17;

321 
DoubToAscii
(
v
,

322 
DtMode
 
mode
,

323 
queed_digs
,

324 * 
bufr
,

325 
bufr_ngth
,

326 
bo
* 
sign
,

327 * 
ngth
,

328 * 
pot
);

330 
	give
:

335 
bo
 
HdSclVues
(
vue
, 
SgBud
* 
su_bud
) const;

338 
CeExpڒtlRi
(cڡ * 
decim_digs
,

339 
ngth
,

340 
expڒt
,

341 
SgBud
* 
su_bud
) const;

343 
CeDecimRi
(cڡ * 
decim_digs
,

344 
ngth
,

345 
decim_pot
,

346 
digs_a_pot
,

347 
SgBud
* 
su_bud
) const;

349 cڡ 
	gags_
;

350 cڡ * cڡ 
	gfy_symb_
;

351 cڡ * cڡ 
	gn_symb_
;

352 cڡ 
	gexpڒt_cha_
;

353 cڡ 
	gdecim__sh܋_low_
;

354 cڡ 
	gdecim__sh܋_high_
;

355 cڡ 
	gmax_adg_ddg_zs__ecisi_mode_
;

356 cڡ 
	gmax_ag_ddg_zs__ecisi_mode_
;

358 
DISALLOW_IMPLICIT_CONSTRUCTORS
(
DoubToSgCvr
);

362 as
	cSgToDoubCvr
 {

363 
	gpublic
:

367 
WTF_EXPORT_PRIVATE
 
SgToDoub
(cڡ * 
bufr
, 
size_t
 
ngth
, size_t* 
osd_chas_cou
);

369 
	give
:

370 
DISALLOW_IMPLICIT_CONSTRUCTORS
(
SgToDoubCvr
);

	@dtoa/double.h

28 #ide
DOUBLE_CONVERSION_DOUBLE_H_


29 
	#DOUBLE_CONVERSION_DOUBLE_H_


	)

31 
	~"diy-.h
"

33 
mea
 
	gWTF
 {

35 
mea
 
	gdoub_cvsi
 {

38 
ut64_t
 
doub_to_ut64
(
d
{  
	gBCa
<
	gut64_t
>(
	gd
); }

39 
ut64_to_doub
(
ut64_t
 
d64
{  
	gBCa
<>(
	gd64
); }

42 as
	cDoub
 {

43 
	gpublic
:

44 cڡ 
ut64_t
 
kSignMask
 = 
UINT64_2PART_C
(0x80000000, 00000000);

45 cڡ 
ut64_t
 
	gkExpڒtMask
 = 
UINT64_2PART_C
(0x7FF00000, 00000000);

46 cڡ 
ut64_t
 
	gkSignifindMask
 = 
UINT64_2PART_C
(0x000FFFFF, 
FFFFFFFF
);

47 cڡ 
ut64_t
 
	gkHiddB
 = 
UINT64_2PART_C
(0x00100000, 00000000);

48 cڡ 
	gkPhysilSignifindSize
 = 52;

49 cڡ 
	gkSignifindSize
 = 53;

51 
Doub
(: 
d64_
(0) {}

52 
exic
 
Doub
(
d
: 
d64_
(
doub_to_ut64
(d)) {}

53 
exic
 
Doub
(
ut64_t
 
d64
: 
d64_
(d64) {}

54 
exic
 
Doub
(
DiyFp
 
diy_
)

55 : 
d64_
(
DiyFpToUt64
(
diy_
)) {}

59 
DiyFp
 
AsDiyFp
() const {

60 
ASSERT
(
Sign
() > 0);

61 
ASSERT
(!
IsScl
());

62  
DiyFp
(
Signifind
(), 
Expڒt
());

66 
DiyFp
 
AsNmizedDiyFp
() const {

67 
ASSERT
(
vue
() > 0.0);

68 
ut64_t
 
	gf
 = 
Signifind
();

69 
	ge
 = 
Expڒt
();

72 (
	gf
 & 
	gkHiddB
) == 0) {

73 
f
 <<= 1;

74 
	ge
--;

77 
	gf
 <<
DiyFp
::
kSignifindSize
 - kSignificandSize;

78 
	ge
 -
DiyFp
::
kSignifindSize
 - kSignificandSize;

79  
DiyFp
(
f
, 
e
);

83 
ut64_t
 
AsUt64
() const {

84  
	gd64_
;

88 
NextDoub
() const {

89 i(
	gd64_
 =
kInfy
 
Doub
(kInfy).
vue
();

90 i(
Sign
(< 0 && 
Signifind
() == 0) {

94 i(
Sign
() < 0) {

95  
Doub
(
d64_
 - 1).
vue
();

97  
Doub
(
d64_
 + 1).
vue
();

101 
Expڒt
() const {

102 i(
IsDm
() 
	gkDmExpڒt
;

104 
ut64_t
 
	gd64
 = 
AsUt64
();

105 
	gbd_e
 =

106 
ic_
<>((
d64
 & 
kExpڒtMask
>> 
kPhysilSignifindSize
);

107  
	gbd_e
 - 
	gkExpڒtBs
;

110 
ut64_t
 
Signifind
() const {

111 
ut64_t
 
	gd64
 = 
AsUt64
();

112 
ut64_t
 
	gsignifind
 = 
d64
 & 
kSignifindMask
;

113 i(!
IsDm
()) {

114  
	gsignifind
 + 
	gkHiddB
;

116  
	gsignifind
;

121 
bo
 
IsDm
() const {

122 
ut64_t
 
	gd64
 = 
AsUt64
();

123  (
	gd64
 & 
	gkExpڒtMask
) == 0;

128 
bo
 
IsScl
() const {

129 
ut64_t
 
	gd64
 = 
AsUt64
();

130  (
	gd64
 & 
	gkExpڒtMask
=
kExpڒtMask
;

133 
bo
 
IsN
() const {

134 
ut64_t
 
	gd64
 = 
AsUt64
();

135  ((
	gd64
 & 
	gkExpڒtMask
=
kExpڒtMask
) &&

136 ((
d64
 & 
kSignifindMask
) != 0);

139 
bo
 
IsInfe
() const {

140 
ut64_t
 
	gd64
 = 
AsUt64
();

141  ((
	gd64
 & 
	gkExpڒtMask
=
kExpڒtMask
) &&

142 ((
d64
 & 
kSignifindMask
) == 0);

145 
Sign
() const {

146 
ut64_t
 
	gd64
 = 
AsUt64
();

147  (
	gd64
 & 
	gkSignMask
) == 0? 1: -1;

152 
DiyFp
 
UBoundy
() const {

153 
ASSERT
(
Sign
() > 0);

154  
DiyFp
(
Signifind
(* 2 + 1, 
Expڒt
() - 1);

161 
NmizedBounds
(
DiyFp
* 
out_m_mus
, DiyFp* 
out_m_us
) const {

162 
ASSERT
(
vue
() > 0.0);

163 
DiyFp
 
	gv
 = 
this
->
AsDiyFp
();

164 
bo
 
	gsignifind_is_zo
 = (
v
.
f
(=
kHiddB
);

165 
DiyFp
 
	gm_us
 = DiyFp::
Nmize
(DiyFp((
v
.
f
(<< 1+ 1, v.
e
() - 1));

166 
DiyFp
 
	gm_mus
;

167 i(
	gsignifind_is_zo
 && 
	gv
.
e
(!
kDmExpڒt
) {

174 
m_mus
 = 
DiyFp
((
v
.
f
(<< 2- 1, v.
e
() - 2);

176 
	gm_mus
 = 
DiyFp
((
v
.
f
(<< 1- 1, v.
e
() - 1);

178 
	gm_mus
.
t_f
(
m_mus
.
f
(<< (m_mus.
e
(- 
m_us
.e()));

179 
	gm_mus
.
t_e
(
m_us
.
e
());

180 *
	gout_m_us
 = 
m_us
;

181 *
	gout_m_mus
 = 
m_mus
;

184 
vue
(cڡ {  
ut64_to_doub
(
d64_
); }

192 
SignifindSizeFOrdOfMagnude
(
d
) {

193 i(
	gd
 >(
kDmExpڒt
 + 
kSignifindSize
)) {

194  
kSignifindSize
;

196 i(
	gd
 <
kDmExpڒt
)  0;

197  
	gd
 - 
	gkDmExpڒt
;

200 
Infy
() {

201  
Doub
(
kInfy
).
vue
();

204 
NaN
() {

205  
Doub
(
kNaN
).
vue
();

208 
	give
:

209 cڡ 
kExpڒtBs
 = 0x3FF + 
kPhysilSignifindSize
;

210 cڡ 
	gkDmExpڒt
 = -
kExpڒtBs
 + 1;

211 cڡ 
	gkMaxExpڒt
 = 0x7FF - 
kExpڒtBs
;

212 cڡ 
ut64_t
 
	gkInfy
 = 
UINT64_2PART_C
(0x7FF00000, 00000000);

213 cڡ 
ut64_t
 
	gkNaN
 = 
UINT64_2PART_C
(0x7FF80000, 00000000);

215 cڡ 
ut64_t
 
	gd64_
;

217 
ut64_t
 
DiyFpToUt64
(
DiyFp
 
diy_
) {

218 
ut64_t
 
	gsignifind
 = 
diy_
.
f
();

219 
	gexpڒt
 = 
diy_
.
e
();

220 
	gsignifind
 > 
	gkHiddB
 + 
	gkSignifindMask
) {

221 
	gsignifind
 >>= 1;

222 
	gexpڒt
++;

224 i(
	gexpڒt
 >
kMaxExpڒt
) {

225  
kInfy
;

227 i(
	gexpڒt
 < 
	gkDmExpڒt
) {

230 
	gexpڒt
 > 
	gkDmExpڒt
 && (
	gsignifind
 & 
	gkHiddB
) == 0) {

231 
signifind
 <<= 1;

232 
	gexpڒt
--;

234 
ut64_t
 
	gbd_expڒt
;

235 i(
	gexpڒt
 =
kDmExpڒt
 && (
signifind
 & 
kHiddB
) == 0) {

236 
bd_expڒt
 = 0;

238 
	gbd_expڒt
 = 
ic_
<
ut64_t
>(
expڒt
 + 
kExpڒtBs
);

240  (
	gsignifind
 & 
	gkSignifindMask
) |

241 (
	gbd_expڒt
 << 
	gkPhysilSignifindSize
);

	@dtoa/fast-dtoa.cc

28 
	~"cfig.h
"

30 
	~"-dt.h
"

32 
	~"ched-pows.h
"

33 
	~"diy-.h
"

34 
	~"doub.h
"

36 
mea
 
	gWTF
 {

38 
mea
 
	gdoub_cvsi
 {

46 cڡ 
	gkMimTgExpڒt
 = -60;

47 cڡ 
	gkMaximTgExpڒt
 = -32;

65 
bo
 
RoundWd
(
BufrRen
<> 
bufr
,

66 
ngth
,

67 
ut64_t
 
di_too_high_w
,

68 
ut64_t
 
un_rv
,

69 
ut64_t
 

,

70 
ut64_t
 
n_k
,

71 
ut64_t
 
un
) {

72 
ut64_t
 
	gsml_di
 = 
di_too_high_w
 - 
un
;

73 
ut64_t
 
	gbig_di
 = 
di_too_high_w
 + 
un
;

145 
ASSERT
(

 <
un_rv
);

146 
	g
 < 
	gsml_di
 &&

147 
	gun_rv
 - 
	g
 >
n_k
 &&

148 (

 + 
n_k
 < 
sml_di
 ||

149 
sml_di
 - 

 > + 
n_k
 - small_distance)) {

150 
bufr
[
ngth
 - 1]--;

151 
	g
 +
n_k
;

157 i(
	g
 < 
	gbig_di
 &&

158 
	gun_rv
 - 
	g
 >
n_k
 &&

159 (

 + 
n_k
 < 
big_di
 ||

160 
big_di
 - 

 >e + 
n_k
 - big_distance)) {

161  
l
;

169  (2 * 
	gun
 <

&& ( <
un_rv
 - 4 * 
un
);

185 
bo
 
RoundWdCoued
(
BufrRen
<> 
bufr
,

186 
ngth
,

187 
ut64_t
 

,

188 
ut64_t
 
n_k
,

189 
ut64_t
 
un
,

190 * 
k
) {

191 
ASSERT
(

 < 
n_k
);

198 i(
	gun
 >
n_k
 
l
;

202 i(
	gn_k
 - 
	gun
 <
un
 
l
;

204 i((
	gn_k
 - 
	g
 >e&& (n_k - 2 *e >2 * 
un
)) {

205  
ue
;

208 i((
	g
 > 
	gun
&& (
	gn_k
 - ( - un<(

 - 
un
))) {

210 
bufr
[
ngth
 - 1]++;

211 
	gi
 = 
ngth
 - 1; i > 0; --i) {

212 i(
	gbufr
[
i
] != '0' + 10) ;

213 
	gbufr
[
i
] = '0';

214 
	gbufr
[
i
 - 1]++;

220 i(
	gbufr
[0] == '0' + 10) {

221 
bufr
[0] = '1';

222 (*
	gk
) += 1;

224  
	gue
;

226  
	gl
;

230 cڡ 
ut32_t
 
	gkT4
 = 10000;

231 cڡ 
ut32_t
 
	gkT5
 = 100000;

232 cڡ 
ut32_t
 
	gkT6
 = 1000000;

233 cڡ 
ut32_t
 
	gkT7
 = 10000000;

234 cڡ 
ut32_t
 
	gkT8
 = 100000000;

235 cڡ 
ut32_t
 
	gkT9
 = 1000000000;

242 
BiggePowT
(
ut32_t
 
numb
,

243 
numb_bs
,

244 
ut32_t
* 
pow
,

245 * 
expڒt
) {

246 
ASSERT
(
numb
 < (
ut32_t
)(1 << (
numb_bs
 + 1)));

248 
	gnumb_bs
) {

252 i(
kT9
 <
numb
) {

253 *
pow
 = 
kT9
;

254 *
	gexpڒt
 = 9;

257 
	gFALLTHROUGH
;

261 i(
kT8
 <
numb
) {

262 *
pow
 = 
kT8
;

263 *
	gexpڒt
 = 8;

266 
	gFALLTHROUGH
;

270 i(
kT7
 <
numb
) {

271 *
pow
 = 
kT7
;

272 *
	gexpڒt
 = 7;

275 
	gFALLTHROUGH
;

280 i(
kT6
 <
numb
) {

281 *
pow
 = 
kT6
;

282 *
	gexpڒt
 = 6;

285 
	gFALLTHROUGH
;

289 i(
kT5
 <
numb
) {

290 *
pow
 = 
kT5
;

291 *
	gexpڒt
 = 5;

294 
	gFALLTHROUGH
;

298 i(
kT4
 <
numb
) {

299 *
pow
 = 
kT4
;

300 *
	gexpڒt
 = 4;

303 
	gFALLTHROUGH
;

308 i(1000 <
numb
) {

309 *
pow
 = 1000;

310 *
	gexpڒt
 = 3;

313 
	gFALLTHROUGH
;

317 i(100 <
numb
) {

318 *
pow
 = 100;

319 *
	gexpڒt
 = 2;

322 
	gFALLTHROUGH
;

326 i(10 <
numb
) {

327 *
pow
 = 10;

328 *
	gexpڒt
 = 1;

331 
	gFALLTHROUGH
;

335 i(1 <
numb
) {

336 *
pow
 = 1;

337 *
	gexpڒt
 = 0;

340 
	gFALLTHROUGH
;

342 *
pow
 = 0;

343 *
	gexpڒt
 = -1;

347 *
pow
 = 0;

348 *
	gexpڒt
 = 0;

349 
UNREACHABLE
();

396 
bo
 
DigG
(
DiyFp
 
low
,

397 
DiyFp
 
w
,

398 
DiyFp
 
high
,

399 
BufrRen
<> 
bufr
,

400 * 
ngth
,

401 * 
k
) {

402 
ASSERT
(
low
.
e
(=
w
.e(&& w.e(=
high
.e());

403 
ASSERT
(
low
.
f
(+ 1 <
high
.f() - 1);

404 
ASSERT
(
kMimTgExpڒt
 <
w
.
e
(&& w.e(<
kMaximTgExpڒt
);

416 
ut64_t
 
	gun
 = 1;

417 
DiyFp
 
	gtoo_low
 = DiyFp(
low
.
f
(- 
un
,ow.
e
());

418 
DiyFp
 
	gtoo_high
 = DiyFp(
high
.
f
(+ 
un
, high.
e
());

421 
DiyFp
 
	gun_rv
 = DiyFp::
Mus
(
too_high
, 
too_low
);

429 
DiyFp
 
	ge
 = DiyFp(
ic_
<
ut64_t
>(1<< -
w
.
e
(), w.e());

431 
ut32_t
 
	ggls
 = 
ic_
<ut32_t>(
too_high
.
f
(>> -
e
.
e
());

433 
ut64_t
 
	gaiڮs
 = 
too_high
.
f
(& (
e
.f() - 1);

434 
ut32_t
 
	gdivis
;

435 
	gdivis_expڒt
;

436 
BiggePowT
(
gls
, 
DiyFp
::
kSignifindSize
 - (-
e
.
e
()),

437 &
divis
, &
divis_expڒt
);

438 *
	gk
 = 
divis_expڒt
 + 1;

439 *
	gngth
 = 0;

444 *
	gk
 > 0) {

445 
	gdig
 = 
gls
 / 
divis
;

446 
	gbufr
[*
ngth
] = '0' + 
dig
;

447 (*
	gngth
)++;

448 
	ggls
 %
divis
;

449 (*
	gk
)--;

452 
ut64_t
 
	g
 =

453 (
ic_
<
ut64_t
>(
gls
<< -
e
.
e
()+ 
aiڮs
;

456 i(
	g
 < 
	gun_rv
.
f
()) {

459  
RoundWd
(
bufr
, *
ngth
, 
DiyFp
::
Mus
(
too_high
, 
w
).
f
(),

460 
un_rv
.
f
(), 

,

461 
ic_
<
ut64_t
>(
divis
<< -
e
.
e
(), 
un
);

463 
	gdivis
 /= 10;

472 
ASSERT
(
e
.
e
() >= -60);

473 
ASSERT
(
aiڮs
 < 
e
.
f
());

474 
ASSERT
(
UINT64_2PART_C
(0xFFFFFFFF, 
FFFFFFFF
/ 10 >
e
.
f
());

475 
	gue
) {

476 
	gaiڮs
 *= 10;

477 
	gun
 *= 10;

478 
	gun_rv
.
t_f
(
un_rv
.
f
() * 10);

480 
	gdig
 = 
ic_
<>(
aiڮs
 >> -
e
.
e
());

481 
	gbufr
[*
ngth
] = '0' + 
dig
;

482 (*
	gngth
)++;

483 
	gaiڮs
 &
e
.
f
() - 1;

484 (*
	gk
)--;

485 i(
	gaiڮs
 < 
	gun_rv
.
f
()) {

486  
RoundWd
(
bufr
, *
ngth
, 
DiyFp
::
Mus
(
too_high
, 
w
).
f
(* 
un
,

487 
un_rv
.
f
(), 
aiڮs
, 
e
.f(), 
un
);

522 
bo
 
DigGCoued
(
DiyFp
 
w
,

523 
queed_digs
,

524 
BufrRen
<> 
bufr
,

525 * 
ngth
,

526 * 
k
) {

527 
ASSERT
(
kMimTgExpڒt
 <
w
.
e
(&& w.e(<
kMaximTgExpڒt
);

528 
ASSERT
(
kMimTgExpڒt
 >= -60);

529 
ASSERT
(
kMaximTgExpڒt
 <= -32);

532 
ut64_t
 
	gw_r
 = 1;

537 
DiyFp
 
	ge
 = DiyFp(
ic_
<
ut64_t
>(1<< -
w
.
e
(), w.e());

539 
ut32_t
 
	ggls
 = 
ic_
<ut32_t>(
w
.
f
(>> -
e
.
e
());

541 
ut64_t
 
	gaiڮs
 = 
w
.
f
(& (
e
.f() - 1);

542 
ut32_t
 
	gdivis
;

543 
	gdivis_expڒt
;

544 
BiggePowT
(
gls
, 
DiyFp
::
kSignifindSize
 - (-
e
.
e
()),

545 &
divis
, &
divis_expڒt
);

546 *
	gk
 = 
divis_expڒt
 + 1;

547 *
	gngth
 = 0;

553 *
	gk
 > 0) {

554 
	gdig
 = 
gls
 / 
divis
;

555 
	gbufr
[*
ngth
] = '0' + 
dig
;

556 (*
	gngth
)++;

557 
	gqueed_digs
--;

558 
	ggls
 %
divis
;

559 (*
	gk
)--;

562 i(
	gqueed_digs
 == 0) ;

563 
	gdivis
 /= 10;

566 i(
	gqueed_digs
 == 0) {

567 
ut64_t
 

 =

568 (
ic_
<
ut64_t
>(
gls
<< -
e
.
e
()+ 
aiڮs
;

569  
RoundWdCoued
(
bufr
, *
ngth
, 

,

570 
ic_
<
ut64_t
>(
divis
<< -
e
.
e
(), 
w_r
,

571 
k
);

580 
ASSERT
(
e
.
e
() >= -60);

581 
ASSERT
(
aiڮs
 < 
e
.
f
());

582 
ASSERT
(
UINT64_2PART_C
(0xFFFFFFFF, 
FFFFFFFF
/ 10 >
e
.
f
());

583 
	gqueed_digs
 > 0 && 
	gaiڮs
 > 
	gw_r
) {

584 
	gaiڮs
 *= 10;

585 
	gw_r
 *= 10;

587 
	gdig
 = 
ic_
<>(
aiڮs
 >> -
e
.
e
());

588 
	gbufr
[*
ngth
] = '0' + 
dig
;

589 (*
	gngth
)++;

590 
	gqueed_digs
--;

591 
	gaiڮs
 &
e
.
f
() - 1;

592 (*
	gk
)--;

594 i(
	gqueed_digs
 !0 
l
;

595  
RoundWdCoued
(
bufr
, *
ngth
, 
aiڮs
, 
e
.
f
(), 
w_r
,

596 
k
);

611 
bo
 
Grisu3
(
v
,

612 
BufrRen
<> 
bufr
,

613 * 
ngth
,

614 * 
decim_expڒt
) {

615 
DiyFp
 
	gw
 = 
Doub
(
v
).
AsNmizedDiyFp
();

620 
DiyFp
 
	gboundy_mus
, 
	gboundy_us
;

621 
Doub
(
v
).
NmizedBounds
(&
boundy_mus
, &
boundy_us
);

622 
ASSERT
(
boundy_us
.
e
(=
w
.e());

623 
DiyFp
 
	gn_mk
;

624 
	gmk
;

625 
	gn_mk_mim_by_expڒt
 =

626 
kMimTgExpڒt
 - (
w
.
e
(+ 
DiyFp
::
kSignifindSize
);

627 
	gn_mk_maxim_by_expڒt
 =

628 
kMaximTgExpڒt
 - (
w
.
e
(+ 
DiyFp
::
kSignifindSize
);

629 
	gPowsOfTCache
::
GCachedPowFByExpڒtRge
(

630 
n_mk_mim_by_expڒt
,

631 
n_mk_maxim_by_expڒt
,

632 &
n_mk
, &
mk
);

633 
ASSERT
((
kMimTgExpڒt
 <
w
.
e
(+ 
n_mk
.e() +

634 
DiyFp
::
kSignifindSize
) &&

635 (
kMaximTgExpڒt
 >
w
.
e
(+ 
n_mk
.e() +

636 
DiyFp
::
kSignifindSize
));

646 
DiyFp
 
	gsd_w
 = DiyFp::
Times
(
w
, 
n_mk
);

647 
ASSERT
(
sd_w
.
e
() ==

648 
boundy_us
.
e
(+ 
n_mk
.e(+ 
DiyFp
::
kSignifindSize
);

654 
DiyFp
 
	gsd_boundy_mus
 = DiyFp::
Times
(
boundy_mus
, 
n_mk
);

655 
DiyFp
 
	gsd_boundy_us
 = DiyFp::
Times
(
boundy_us
, 
n_mk
);

663 
	gk
;

664 
bo
 
	gsu
 = 
DigG
(
sd_boundy_mus
, 
sd_w
, 
sd_boundy_us
,

665 
bufr
, 
ngth
, &
k
);

666 *
	gdecim_expڒt
 = -
mk
 + 
k
;

667  
	gsu
;

676 
bo
 
Grisu3Coued
(
v
,

677 
queed_digs
,

678 
BufrRen
<> 
bufr
,

679 * 
ngth
,

680 * 
decim_expڒt
) {

681 
DiyFp
 
	gw
 = 
Doub
(
v
).
AsNmizedDiyFp
();

682 
DiyFp
 
	gn_mk
;

683 
	gmk
;

684 
	gn_mk_mim_by_expڒt
 =

685 
kMimTgExpڒt
 - (
w
.
e
(+ 
DiyFp
::
kSignifindSize
);

686 
	gn_mk_maxim_by_expڒt
 =

687 
kMaximTgExpڒt
 - (
w
.
e
(+ 
DiyFp
::
kSignifindSize
);

688 
	gPowsOfTCache
::
GCachedPowFByExpڒtRge
(

689 
n_mk_mim_by_expڒt
,

690 
n_mk_maxim_by_expڒt
,

691 &
n_mk
, &
mk
);

692 
ASSERT
((
kMimTgExpڒt
 <
w
.
e
(+ 
n_mk
.e() +

693 
DiyFp
::
kSignifindSize
) &&

694 (
kMaximTgExpڒt
 >
w
.
e
(+ 
n_mk
.e() +

695 
DiyFp
::
kSignifindSize
));

705 
DiyFp
 
	gsd_w
 = DiyFp::
Times
(
w
, 
n_mk
);

712 
	gk
;

713 
bo
 
	gsu
 = 
DigGCoued
(
sd_w
, 
queed_digs
,

714 
bufr
, 
ngth
, &
k
);

715 *
	gdecim_expڒt
 = -
mk
 + 
k
;

716  
	gsu
;

720 
bo
 
FaDt
(
v
,

721 
FaDtMode
 
mode
,

722 
queed_digs
,

723 
BufrRen
<> 
bufr
,

724 * 
ngth
,

725 * 
decim_pot
) {

726 
ASSERT
(
v
 > 0);

727 
ASSERT
(!
Doub
(
v
).
IsScl
());

729 
bo
 
	gsu
 = 
l
;

730 
	gdecim_expڒt
 = 0;

731 
	gmode
) {

732 
	gFAST_DTOA_SHORTEST
:

733 
su
 = 
Grisu3
(
v
, 
bufr
, 
ngth
, &
decim_expڒt
);

735 
	gFAST_DTOA_PRECISION
:

736 
su
 = 
Grisu3Coued
(
v
, 
queed_digs
,

737 
bufr
, 
ngth
, &
decim_expڒt
);

740 
UNREACHABLE
();

742 i(
	gsu
) {

743 *
	gdecim_pot
 = *
ngth
 + 
decim_expڒt
;

744 
	gbufr
[*
ngth
] = '\0';

746  
	gsu
;

	@dtoa/fast-dtoa.h

28 #ide
DOUBLE_CONVERSION_FAST_DTOA_H_


29 
	#DOUBLE_CONVERSION_FAST_DTOA_H_


	)

31 
	~"uts.h
"

33 
mea
 
	gWTF
 {

35 
mea
 
	gdoub_cvsi
 {

37 
	eFaDtMode
 {

41 
	gFAST_DTOA_SHORTEST
,

44 
	gFAST_DTOA_PRECISION


49 cڡ 
	gkFaDtMaximLgth
 = 17;

77 
bo
 
FaDt
(
d
,

78 
FaDtMode
 
mode
,

79 
queed_digs
,

80 
BufrRen
<> 
bufr
,

81 * 
ngth
,

82 * 
decim_pot
);

	@dtoa/fixed-dtoa.cc

28 
	~"cfig.h
"

30 
	~<mh.h
>

32 
	~"fixed-dt.h
"

33 
	~"doub.h
"

35 
mea
 
	gWTF
 {

37 
mea
 
	gdoub_cvsi
 {

41 as
	cUI128
 {

42 
	gpublic
:

43 
UI128
(: 
high_bs_
(0), 
low_bs_
(0) { }

44 
UI128
(
ut64_t
 
high
, ut64_
low
: 
high_bs_
(high), 
low_bs_
(low) { }

46 
Muɝly
(
ut32_t
 
muɝlind
) {

47 
ut64_t
 
	gaccumut
;

49 
	gaccumut
 = (
low_bs_
 & 
kMask32
* 
muɝlind
;

50 
ut32_t
 
	g
 = 
ic_
<ut32_t>(
accumut
 & 
kMask32
);

51 
	gaccumut
 >>= 32;

52 
	gaccumut
 = 
accumut
 + (
low_bs_
 >> 32* 
muɝlind
;

53 
	glow_bs_
 = (
accumut
 << 32+ 

;

54 
	gaccumut
 >>= 32;

55 
	gaccumut
 = 
accumut
 + (
high_bs_
 & 
kMask32
* 
muɝlind
;

56 
	g
 = 
ic_
<
ut32_t
>(
accumut
 & 
kMask32
);

57 
	gaccumut
 >>= 32;

58 
	gaccumut
 = 
accumut
 + (
high_bs_
 >> 32* 
muɝlind
;

59 
	ghigh_bs_
 = (
accumut
 << 32+ 

;

60 
ASSERT
((
accumut
 >> 32) == 0);

63 
Shi
(
shi_amou
) {

64 
ASSERT
(-64 <
shi_amou
 && shift_amount <= 64);

65 i(
	gshi_amou
 == 0) {

67 } i(
	gshi_amou
 == -64) {

68 
high_bs_
 = 
low_bs_
;

69 
	glow_bs_
 = 0;

70 } i(
	gshi_amou
 == 64) {

71 
low_bs_
 = 
high_bs_
;

72 
	ghigh_bs_
 = 0;

73 } i(
	gshi_amou
 <= 0) {

74 
high_bs_
 <<-
shi_amou
;

75 
	ghigh_bs_
 +
low_bs_
 >> (64 + 
shi_amou
);

76 
	glow_bs_
 <<-
shi_amou
;

78 
	glow_bs_
 >>
shi_amou
;

79 
	glow_bs_
 +
high_bs_
 << (64 - 
shi_amou
);

80 
	ghigh_bs_
 >>
shi_amou
;

86 
DivModPowOf2
(
pow
) {

87 i(
	gpow
 >= 64) {

88 
su
 = 
ic_
<>(
high_bs_
 >> (
pow
 - 64));

89 
	ghigh_bs_
 -
ic_
<
ut64_t
>(
su
<< (
pow
 - 64);

90  
	gsu
;

92 
ut64_t
 
	g_low
 = 
low_bs_
 >> 
pow
;

93 
ut64_t
 
	g_high
 = 
high_bs_
 << (64 - 
pow
);

94 
	gsu
 = 
ic_
<>(
_low
 + 
_high
);

95 
	ghigh_bs_
 = 0;

96 
	glow_bs_
 -
_low
 << 
pow
;

97  
	gsu
;

101 
bo
 
IsZo
() const {

102  
	ghigh_bs_
 =0 && 
low_bs_
 == 0;

105 
BAt
(
posi
) {

106 i(
	gposi
 >= 64) {

107  
ic_
<>(
high_bs_
 >> (
posi
 - 64)) & 1;

109  
	gic_
<>(
	glow_bs_
 >> 
	gposi
) & 1;

113 
	give
:

114 cڡ 
ut64_t
 
kMask32
 = 0xFFFFFFFF;

116 
ut64_t
 
	ghigh_bs_
;

117 
ut64_t
 
	glow_bs_
;

121 cڡ 
	gkDoubSignifindSize
 = 53;

124 
FlDigs32FixedLgth
(
ut32_t
 
numb
, 
queed_ngth
,

125 
BufrRen
<> 
bufr
, * 
ngth
) {

126 
	gi
 = 
queed_ngth
 - 1; i >= 0; --i) {

127 
	gbufr
[(*
ngth
+ 
i
] = '0' + 
numb
 % 10;

128 
	gnumb
 /= 10;

130 *
	gngth
 +
queed_ngth
;

134 
FlDigs32
(
ut32_t
 
numb
, 
BufrRen
<> 
bufr
, * 
ngth
) {

135 
	gnumb_ngth
 = 0;

137 
	gnumb
 != 0) {

138 
dig
 = 
numb
 % 10;

139 
	gnumb
 /= 10;

140 
	gbufr
[(*
ngth
+ 
numb_ngth
] = '0' + 
dig
;

141 
	gnumb_ngth
++;

144 
	gi
 = *
ngth
;

145 
	gj
 = *
ngth
 + 
numb_ngth
 - 1;

146 
	gi
 < 
	gj
) {

147 
	gtmp
 = 
bufr
[
i
];

148 
	gbufr
[
i
] = 
bufr
[
j
];

149 
	gbufr
[
j
] = 
tmp
;

150 
	gi
++;

151 
	gj
--;

153 *
	gngth
 +
numb_ngth
;

157 
FlDigs64FixedLgth
(
ut64_t
 
numb
, 
queed_ngth
,

158 
BufrRen
<> 
bufr
, * 
ngth
) {

159 
UNUSED_PARAM
(
queed_ngth
);

160 cڡ 
ut32_t
 
	gkT7
 = 10000000;

162 
ut32_t
 
	g2
 = 
ic_
<ut32_t>(
numb
 % 
kT7
);

163 
	gnumb
 /
kT7
;

164 
ut32_t
 
	g1
 = 
ic_
<ut32_t>(
numb
 % 
kT7
);

165 
ut32_t
 
	g0
 = 
ic_
<ut32_t>(
numb
 / 
kT7
);

167 
FlDigs32FixedLgth
(
0
, 3, 
bufr
, 
ngth
);

168 
FlDigs32FixedLgth
(
1
, 7, 
bufr
, 
ngth
);

169 
FlDigs32FixedLgth
(
2
, 7, 
bufr
, 
ngth
);

173 
FlDigs64
(
ut64_t
 
numb
, 
BufrRen
<> 
bufr
, * 
ngth
) {

174 cڡ 
ut32_t
 
	gkT7
 = 10000000;

176 
ut32_t
 
	g2
 = 
ic_
<ut32_t>(
numb
 % 
kT7
);

177 
	gnumb
 /
kT7
;

178 
ut32_t
 
	g1
 = 
ic_
<ut32_t>(
numb
 % 
kT7
);

179 
ut32_t
 
	g0
 = 
ic_
<ut32_t>(
numb
 / 
kT7
);

181 i(
	g0
 != 0) {

182 
FlDigs32
(
0
, 
bufr
, 
ngth
);

183 
FlDigs32FixedLgth
(
1
, 7, 
bufr
, 
ngth
);

184 
FlDigs32FixedLgth
(
2
, 7, 
bufr
, 
ngth
);

185 } i(
	g1
 != 0) {

186 
FlDigs32
(
1
, 
bufr
, 
ngth
);

187 
FlDigs32FixedLgth
(
2
, 7, 
bufr
, 
ngth
);

189 
FlDigs32
(
2
, 
bufr
, 
ngth
);

194 
RoundUp
(
BufrRen
<> 
bufr
, * 
ngth
, * 
decim_pot
) {

196 i(*
	gngth
 == 0) {

197 
bufr
[0] = '1';

198 *
	gdecim_pot
 = 1;

199 *
	gngth
 = 1;

204 
	gbufr
[(*
ngth
) - 1]++;

205 
	gi
 = (*
ngth
) - 1; i > 0; --i) {

206 i(
	gbufr
[
i
] != '0' + 10) {

209 
	gbufr
[
i
] = '0';

210 
	gbufr
[
i
 - 1]++;

217 i(
	gbufr
[0] == '0' + 10) {

218 
bufr
[0] = '1';

219 (*
	gdecim_pot
)++;

235 
FlFiڮs
(
ut64_t
 
aiڮs
, 
expڒt
,

236 
aiڮ_cou
, 
BufrRen
<> 
bufr
,

237 * 
ngth
, * 
decim_pot
) {

238 
ASSERT
(-128 <
expڒt
 &&xponent <= 0);

242 i(-
	gexpڒt
 <= 64) {

244 
ASSERT
(
aiڮs
 >> 56 == 0);

245 
	gpot
 = -
expڒt
;

246 
	gi
 = 0; i < 
	gaiڮ_cou
; ++i) {

247 i(
	gaiڮs
 == 0) ;

258 
	gaiڮs
 *= 5;

259 
	gpot
--;

260 
	gdig
 = 
ic_
<>(
aiڮs
 >> 
pot
);

261 
	gbufr
[*
ngth
] = '0' + 
dig
;

262 (*
	gngth
)++;

263 
	gaiڮs
 -
ic_
<
ut64_t
>(
dig
<< 
pot
;

266 i(((
	gaiڮs
 >> (
	gpot
 - 1)) & 1) == 1) {

267 
RoundUp
(
bufr
, 
ngth
, 
decim_pot
);

270 
ASSERT
(64 < -
expڒt
 && -exponent <= 128);

271 
UI128
 
	gaiڮs128
 = UI128(
aiڮs
, 0);

272 
	gaiڮs128
.
Shi
(-
expڒt
 - 64);

273 
	gpot
 = 128;

274 
	gi
 = 0; i < 
	gaiڮ_cou
; ++i) {

275 i(
	gaiڮs128
.
IsZo
()) ;

279 
	gaiڮs128
.
Muɝly
(5);

280 
	gpot
--;

281 
	gdig
 = 
aiڮs128
.
DivModPowOf2
(
pot
);

282 
	gbufr
[*
ngth
] = '0' + 
dig
;

283 (*
	gngth
)++;

285 i(
	gaiڮs128
.
BAt
(
pot
 - 1) == 1) {

286 
RoundUp
(
bufr
, 
ngth
, 
decim_pot
);

294 
TrimZos
(
BufrRen
<> 
bufr
, * 
ngth
, * 
decim_pot
) {

295 *
	gngth
 > 0 && 
	gbufr
[(*
ngth
) - 1] == '0') {

296 (*
ngth
)--;

298 
	gf_n_zo
 = 0;

299 
	gf_n_zo
 < *
	gngth
 && 
	gbufr
[
f_n_zo
] == '0') {

300 
f_n_zo
++;

302 i(
	gf_n_zo
 != 0) {

303 
i
 = 
f_n_zo
; 
	gi
 < *
	gngth
; ++i) {

304 
	gbufr
[
i
 - 
f_n_zo
] = 
bufr
[i];

306 *
	gngth
 -
f_n_zo
;

307 *
	gdecim_pot
 -
f_n_zo
;

312 
bo
 
FaFixedDt
(
v
,

313 
aiڮ_cou
,

314 
BufrRen
<> 
bufr
,

315 * 
ngth
,

316 * 
decim_pot
) {

317 cڡ 
ut32_t
 
	gkMaxUI32
 = 0xFFFFFFFF;

318 
ut64_t
 
	gsignifind
 = 
Doub
(
v
).
Signifind
();

319 
	gexpڒt
 = 
Doub
(
v
).
Expڒt
();

325 i(
	gexpڒt
 > 20 
	gl
;

326 i(
	gaiڮ_cou
 > 20 
	gl
;

327 *
	gngth
 = 0;

331 i(
	gexpڒt
 + 
	gkDoubSignifindSize
 > 64) {

340 cڡ 
ut64_t
 
	gkFive17
 = 
UINT64_2PART_C
(0xB1, 
A2BC2EC5
);

341 
ut64_t
 
	gdivis
 = 
kFive17
;

342 
	gdivis_pow
 = 17;

343 
ut64_t
 
	gdividd
 = 
signifind
;

344 
ut32_t
 
	gquٛ
;

345 
ut64_t
 
	gmad
;

355 i(
	gexpڒt
 > 
	gdivis_pow
) {

357 
	gdividd
 <<
expڒt
 - 
divis_pow
;

358 
	gquٛ
 = 
ic_
<
ut32_t
>(
dividd
 / 
divis
);

359 
	gmad
 = (
dividd
 % 
divis
<< 
divis_pow
;

361 
	gdivis
 <<
divis_pow
 - 
expڒt
;

362 
	gquٛ
 = 
ic_
<
ut32_t
>(
dividd
 / 
divis
);

363 
	gmad
 = (
dividd
 % 
divis
<< 
expڒt
;

365 
FlDigs32
(
quٛ
, 
bufr
, 
ngth
);

366 
FlDigs64FixedLgth
(
mad
, 
divis_pow
, 
bufr
, 
ngth
);

367 *
	gdecim_pot
 = *
ngth
;

368 } i(
	gexpڒt
 >= 0) {

370 
signifind
 <<
expڒt
;

371 
FlDigs64
(
signifind
, 
bufr
, 
ngth
);

372 *
	gdecim_pot
 = *
ngth
;

373 } i(
	gexpڒt
 > -
	gkDoubSignifindSize
) {

375 
ut64_t
 
	ggls
 = 
signifind
 >> -
expڒt
;

376 
ut64_t
 
	gaiڮs
 = 
signifind
 - (
gls
 << -
expڒt
);

377 i(
	ggls
 > 
	gkMaxUI32
) {

378 
FlDigs64
(
gls
, 
bufr
, 
ngth
);

380 
FlDigs32
(
ic_
<
ut32_t
>(
gls
), 
bufr
, 
ngth
);

382 *
	gdecim_pot
 = *
ngth
;

383 
FlFiڮs
(
aiڮs
, 
expڒt
, 
aiڮ_cou
,

384 
bufr
, 
ngth
, 
decim_pot
);

385 } i(
	gexpڒt
 < -128) {

388 
ASSERT
(
aiڮ_cou
 <= 20);

389 
	gbufr
[0] = '\0';

390 *
	gngth
 = 0;

391 *
	gdecim_pot
 = -
aiڮ_cou
;

393 *
	gdecim_pot
 = 0;

394 
FlFiڮs
(
signifind
, 
expڒt
, 
aiڮ_cou
,

395 
bufr
, 
ngth
, 
decim_pot
);

397 
TrimZos
(
bufr
, 
ngth
, 
decim_pot
);

398 
	gbufr
[*
ngth
] = '\0';

399 i((*
	gngth
) == 0) {

402 *
decim_pot
 = -
aiڮ_cou
;

404  
	gue
;

	@dtoa/fixed-dtoa.h

28 #ide
DOUBLE_CONVERSION_FIXED_DTOA_H_


29 
	#DOUBLE_CONVERSION_FIXED_DTOA_H_


	)

31 
	~"uts.h
"

33 
mea
 
	gWTF
 {

35 
mea
 
	gdoub_cvsi
 {

53 
bo
 
FaFixedDt
(
v
, 
aiڮ_cou
,

54 
BufrRen
<> 
bufr
, * 
ngth
, * 
decim_pot
);

	@dtoa/strtod.cc

28 
	~"cfig.h
"

30 
	~<dg.h
>

31 
	~<lims.h
>

33 
	~"od.h
"

34 
	~"bignum.h
"

35 
	~"ched-pows.h
"

36 
	~"doub.h
"

38 
mea
 
	gWTF
 {

40 
mea
 
	gdoub_cvsi
 {

42 #i
defed
(
DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS
)

46 cڡ 
	gkMaxExaDoubIegDecimDigs
 = 15;

49 cڡ 
	gkMaxUt64DecimDigs
 = 19;

57 cڡ 
	gkMaxDecimPow
 = 309;

58 cڡ 
	gkMDecimPow
 = -324;

61 cڡ 
ut64_t
 
	gkMaxUt64
 = 
UINT64_2PART_C
(0xFFFFFFFF, 
FFFFFFFF
);

63 #i
defed
(
DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS
)

64 cڡ 
	gexa_pows_of_n
[] = {

90 cڡ 
	gkExaPowsOfTSize
 = 
ARRAY_SIZE
(
exa_pows_of_n
);

96 cڡ 
	gkMaxSignifiDecimDigs
 = 780;

98 
	gBufrRen
<cڡ > 
TrimLdgZos
(
BufrRen
<cڡ > 
bufr
) {

99 
	gi
 = 0; i < 
	gbufr
.
ngth
(); i++) {

100 i(
	gbufr
[
i
] != '0') {

101  
bufr
.
SubBufrRen
(
i
, bufr.
ngth
());

104  
	gBufrRen
<cڡ >(
	gbufr
.
t
(), 0);

108 
	gBufrRen
<cڡ > 
TrimTgZos
(
BufrRen
<cڡ > 
bufr
) {

109 
	gi
 = 
bufr
.
ngth
() - 1; i >= 0; --i) {

110 i(
	gbufr
[
i
] != '0') {

111  
bufr
.
SubBufrRen
(0, 
i
 + 1);

114  
	gBufrRen
<cڡ >(
	gbufr
.
t
(), 0);

118 
TrimToMaxSignifiDigs
(
BufrRen
<cڡ > 
bufr
,

119 
expڒt
,

120 * 
signifi_bufr
,

121 * 
signifi_expڒt
) {

122 
	gi
 = 0; i < 
	gkMaxSignifiDecimDigs
 - 1; ++i) {

123 
	gsignifi_bufr
[
i
] = 
bufr
[i];

127 
ASSERT
(
bufr
[bufr.
ngth
() - 1] != '0');

130 
	gsignifi_bufr
[
kMaxSignifiDecimDigs
 - 1] = '1';

131 *
	gsignifi_expڒt
 =

132 
expڒt
 + (
bufr
.
ngth
(- 
kMaxSignifiDecimDigs
);

140 
ut64_t
 
RdUt64
(
BufrRen
<cڡ > 
bufr
,

141 * 
numb_of_ad_digs
) {

142 
ut64_t
 
	gsu
 = 0;

143 
	gi
 = 0;

144 
	gi
 < 
	gbufr
.
ngth
(&& 
	gsu
 <(
kMaxUt64
 / 10 - 1)) {

145 
dig
 = 
bufr
[
i
++] - '0';

146 
ASSERT
(0 <
dig
 && digit <= 9);

147 
	gsu
 = 10 * 
su
 + 
dig
;

149 *
	gnumb_of_ad_digs
 = 
i
;

150  
	gsu
;

158 
RdDiyFp
(
BufrRen
<cڡ > 
bufr
,

159 
DiyFp
* 
su
,

160 * 
mag_decims
) {

161 
	gad_digs
;

162 
ut64_t
 
	gsignifind
 = 
RdUt64
(
bufr
, &
ad_digs
);

163 i(
	gbufr
.
ngth
(=
ad_digs
) {

164 *
su
 = 
DiyFp
(
signifind
, 0);

165 *
	gmag_decims
 = 0;

168 i(
	gbufr
[
ad_digs
] >= '5') {

169 
signifind
++;

172 
	gexpڒt
 = 0;

173 *
	gsu
 = 
DiyFp
(
signifind
, 
expڒt
);

174 *
	gmag_decims
 = 
bufr
.
ngth
(- 
ad_digs
;

179 
bo
 
DoubStod
(
BufrRen
<cڡ > 
immed
,

180 
expڒt
,

181 * 
su
) {

182 #i!
defed
(
DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS
)

183 
UNUSED_PARAM
(
immed
);

184 
UNUSED_PARAM
(
expڒt
);

185 
UNUSED_PARAM
(
su
);

192  
	gl
;

194 i(
	gimmed
.
ngth
(<
kMaxExaDoubIegDecimDigs
) {

195 
ad_digs
;

202 i(
	gexpڒt
 < 0 && -expڒ< 
	gkExaPowsOfTSize
) {

204 *
	gsu
 = 
ic_
<>(
RdUt64
(
immed
, &
ad_digs
));

205 
ASSERT
(
ad_digs
 =
immed
.
ngth
());

206 *
	gsu
 /
exa_pows_of_n
[-
expڒt
];

207  
	gue
;

209 i(0 <
expڒt
 &&xpڒ< 
kExaPowsOfTSize
) {

211 *
su
 = 
ic_
<>(
RdUt64
(
immed
, &
ad_digs
));

212 
ASSERT
(
ad_digs
 =
immed
.
ngth
());

213 *
	gsu
 *
exa_pows_of_n
[
expڒt
];

214  
	gue
;

216 
	gmag_digs
 =

217 
kMaxExaDoubIegDecimDigs
 - 
immed
.
ngth
();

218 i((0 <
expڒt
) &&

219 (
expڒt
 - 
mag_digs
 < 
kExaPowsOfTSize
)) {

223 *
su
 = 
ic_
<>(
RdUt64
(
immed
, &
ad_digs
));

224 
ASSERT
(
ad_digs
 =
immed
.
ngth
());

225 *
	gsu
 *
exa_pows_of_n
[
mag_digs
];

226 *
	gsu
 *
exa_pows_of_n
[
expڒt
 - 
mag_digs
];

227  
	gue
;

230  
	gl
;

237 
DiyFp
 
AdjumtPowOfT
(
expڒt
) {

238 
ASSERT
(0 < 
expڒt
);

239 
ASSERT
(
expڒt
 < 
PowsOfTCache
::
kDecimExpڒtDi
);

242 
ASSERT
(
PowsOfTCache
::
kDecimExpڒtDi
 == 8);

243 
	gexpڒt
) {

244 1:  
DiyFp
(
UINT64_2PART_C
(0xa0000000, 00000000), -60);

245 2:  
DiyFp
(
UINT64_2PART_C
(0xc8000000, 00000000), -57);

246 3:  
DiyFp
(
UINT64_2PART_C
(0xfa000000, 00000000), -54);

247 4:  
DiyFp
(
UINT64_2PART_C
(0x9c400000, 00000000), -50);

248 5:  
DiyFp
(
UINT64_2PART_C
(0xc3500000, 00000000), -47);

249 6:  
DiyFp
(
UINT64_2PART_C
(0xf4240000, 00000000), -44);

250 7:  
DiyFp
(
UINT64_2PART_C
(0x98968000, 00000000), -40);

252 
UNREACHABLE
();

253  
DiyFp
(0, 0);

261 
bo
 
DiyFpStod
(
BufrRen
<cڡ > 
bufr
,

262 
expڒt
,

263 * 
su
) {

264 
DiyFp
 
	gput
;

265 
	gmag_decims
;

266 
RdDiyFp
(
bufr
, &
put
, &
mag_decims
);

272 cڡ 
	gkDomLog
 = 3;

273 cڡ 
	gkDom
 = 1 << 
kDomLog
;

275 
	gexpڒt
 +
mag_decims
;

276 
	gr
 = (
mag_decims
 =0 ? 0 : 
kDom
 / 2);

278 
	gd_e
 = 
put
.
e
();

279 
	gput
.
Nmize
();

280 
	gr
 <<
d_e
 - 
put
.
e
();

282 
ASSERT
(
expڒt
 <
PowsOfTCache
::
kMaxDecimExpڒt
);

283 i(
	gexpڒt
 < 
	gPowsOfTCache
::
kMDecimExpڒt
) {

284 *
su
 = 0.0;

285  
	gue
;

287 
DiyFp
 
	gched_pow
;

288 
	gched_decim_expڒt
;

289 
	gPowsOfTCache
::
GCachedPowFDecimExpڒt
(
expڒt
,

290 &
ched_pow
,

291 &
ched_decim_expڒt
);

293 i(
	gched_decim_expڒt
 !
expڒt
) {

294 
adjumt_expڒt
 = 
expڒt
 - 
ched_decim_expڒt
;

295 
DiyFp
 
	gadjumt_pow
 = 
AdjumtPowOfT
(
adjumt_expڒt
);

296 
	gput
.
Muɝly
(
adjumt_pow
);

297 i(
	gkMaxUt64DecimDigs
 - 
	gbufr
.
ngth
(>
adjumt_expڒt
) {

300 
ASSERT
(
DiyFp
::
kSignifindSize
 == 64);

303 
	gr
 +
kDom
 / 2;

307 
	gput
.
Muɝly
(
ched_pow
);

313 
	gr_b
 = 
kDom
 / 2;

314 
	gr_ab
 = (
r
 == 0 ? 0 : 1);

315 
	gfixed_r
 = 
kDom
 / 2;

316 
	gr
 +
r_b
 + 
r_ab
 + 
fixed_r
;

318 
	gd_e
 = 
put
.
e
();

319 
	gput
.
Nmize
();

320 
	gr
 <<
d_e
 - 
put
.
e
();

323 
	gd_of_magnude
 = 
DiyFp
::
kSignifindSize
 + 
put
.
e
();

324 
	gefive_signifind_size
 =

325 
Doub
::
SignifindSizeFOrdOfMagnude
(
d_of_magnude
);

326 
	gecisi_digs_cou
 =

327 
DiyFp
::
kSignifindSize
 - 
efive_signifind_size
;

328 i(
	gecisi_digs_cou
 + 
	gkDomLog
 >
DiyFp
::
kSignifindSize
) {

332 
shi_amou
 = (
ecisi_digs_cou
 + 
kDomLog
) -

333 
DiyFp
::
kSignifindSize
 + 1;

334 
	gput
.
t_f
(
put
.
f
(>> 
shi_amou
);

335 
	gput
.
t_e
(
put
.
e
(+ 
shi_amou
);

338 
	gr
 = (
r
 >> 
shi_amou
+ 1 + 
kDom
;

339 
	gecisi_digs_cou
 -
shi_amou
;

342 
ASSERT
(
DiyFp
::
kSignifindSize
 == 64);

343 
ASSERT
(
ecisi_digs_cou
 < 64);

344 
ut64_t
 
	ge64
 = 1;

345 
ut64_t
 
	gecisi_bs_mask
 = (
e64
 << 
ecisi_digs_cou
) - 1;

346 
ut64_t
 
	gecisi_bs
 = 
put
.
f
(& 
ecisi_bs_mask
;

347 
ut64_t
 
	ghf_way
 = 
e64
 << (
ecisi_digs_cou
 - 1);

348 
	gecisi_bs
 *
kDom
;

349 
	ghf_way
 *
kDom
;

350 
DiyFp
 
rounded_put
(
put
.
f
(>> 
ecisi_digs_cou
,

351 
put
.
e
(+ 
ecisi_digs_cou
);

352 i(
	gecisi_bs
 >
hf_way
 + 
r
) {

353 
rounded_put
.
t_f
ounded_put.
f
() + 1);

359 *
	gsu
 = 
Doub
(
rounded_put
).
vue
();

360 i(
	ghf_way
 - 
	gr
 < 
	gecisi_bs
 &&recision_bits < half_way +rror) {

364  
	gl
;

366  
	gue
;

378 
BignumStod
(
BufrRen
<cڡ > 
bufr
,

379 
expڒt
,

380 
guess
) {

381 i(
	gguess
 =
Doub
::
Infy
()) {

382  
guess
;

385 
DiyFp
 
	gu_boundy
 = 
Doub
(
guess
).
UBoundy
();

387 
ASSERT
(
bufr
.
ngth
(+ 
expڒt
 <
kMaxDecimPow
 + 1);

388 
ASSERT
(
bufr
.
ngth
(+ 
expڒt
 > 
kMDecimPow
);

389 
ASSERT
(
bufr
.
ngth
(<
kMaxSignifiDecimDigs
);

394 
ASSERT
(((
kMaxDecimPow
 + 1* 333 / 100< 
Bignum
::
kMaxSignifiBs
);

395 
Bignum
 
	gput
;

396 
Bignum
 
	gboundy
;

397 
	gput
.
AssignDecimSg
(
bufr
);

398 
	gboundy
.
AssignUI64
(
u_boundy
.
f
());

399 i(
	gexpڒt
 >= 0) {

400 
put
.
MuɝlyByPowOfT
(
expڒt
);

402 
	gboundy
.
MuɝlyByPowOfT
(-
expڒt
);

404 i(
	gu_boundy
.
e
() > 0) {

405 
	gboundy
.
ShiLe
(
u_boundy
.
e
());

407 
	gput
.
ShiLe
(-
u_boundy
.
e
());

409 
	gcomris
 = 
Bignum
::
Com
(
put
, 
boundy
);

410 i(
	gcomris
 < 0) {

411  
	gguess
;

412 } i(
	gcomris
 > 0) {

413  
Doub
(
guess
).
NextDoub
();

414 } i((
Doub
(
guess
).
Signifind
() & 1) == 0) {

416  
guess
;

418  
Doub
(
guess
).
NextDoub
();

423 
Stod
(
BufrRen
<cڡ > 
bufr
, 
expڒt
) {

424 
	gBufrRen
<cڡ > 
	g_immed
 = 
TrimLdgZos
(
bufr
);

425 
	gBufrRen
<cڡ > 
	gimmed
 = 
TrimTgZos
(
_immed
);

426 
	gexpڒt
 +
_immed
.
ngth
(- 
immed
.length();

427 i(
	gimmed
.
ngth
() == 0)  0.0;

428 i(
	gimmed
.
ngth
(> 
	gkMaxSignifiDecimDigs
) {

429 
	gsignifi_bufr
[
kMaxSignifiDecimDigs
];

430 
	gsignifi_expڒt
;

431 
TrimToMaxSignifiDigs
(
immed
, 
expڒt
,

432 
signifi_bufr
, &
signifi_expڒt
);

433  
Stod
(
BufrRen
<cڡ >(
signifi_bufr
,

434 
kMaxSignifiDecimDigs
),

435 
signifi_expڒt
);

437 i(
	gexpڒt
 + 
	gimmed
.
ngth
(- 1 >
kMaxDecimPow
) {

438  
Doub
::
Infy
();

440 i(
	gexpڒt
 + 
	gimmed
.
ngth
(<
kMDecimPow
) {

444 
	gguess
;

445 i(
DoubStod
(
immed
, 
expڒt
, &
guess
) ||

446 
DiyFpStod
(
immed
, 
expڒt
, &
guess
)) {

447  
	gguess
;

449  
BignumStod
(
immed
, 
expڒt
, 
guess
);

	@dtoa/strtod.h

28 #ide
DOUBLE_CONVERSION_STRTOD_H_


29 
	#DOUBLE_CONVERSION_STRTOD_H_


	)

31 
	~"uts.h
"

33 
mea
 
	gWTF
 {

35 
mea
 
	gdoub_cvsi
 {

39 
Stod
(
BufrRen
<cڡ > 
bufr
, 
expڒt
);

	@dtoa/utils.h

28 #ide
DOUBLE_CONVERSION_UTILS_H_


29 
	#DOUBLE_CONVERSION_UTILS_H_


	)

31 
	~<wtf/Asis.h
>

32 
	~<dlib.h
>

33 
	~<rg.h
>

35 
	#UNIMPLEMENTED
 
ASSERT_NOT_REACHED


	)

36 
	#UNREACHABLE
 
ASSERT_NOT_REACHED


	)

48 #i
defed
(
_M_X64
|| defed(
__x86_64__
) || \

49 
defed
(
__ARMEL__
) || \

50 
	$defed
(
_MIPS_ARCH_MIPS32R2
)

51 
	#DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS
 1

	)

52 #i
	`CPU
(
MIPS
|| CPU(
PPC
|| CPU(
PPC64
|| CPU(
PPC64LE
|| CPU(
SH4
|| CPU(
S390
|| CPU(
S390X
|| CPU(
IA64
|| CPU(
ALPHA
|| CPU(
ARM64
|| CPU(
HPPA
)

53 
	#DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS
 1

	)

54 #i
	`defed
(
_M_IX86
|| defed(
__i386__
)

55 #i
	`defed
(
_WIN32
)

57 
	#DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS
 1

	)

59 #unde
DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS


62 #r 
Tg
 
cheu
 
was
 
n
 
deed
 
as
 
su܋d
 
by
 
Doub
-
Cvsi
.

66 #i
	`defed
(
_WIN32
&& !defed(
__MINGW32__
)

68 sigd 
	tt8_t
;

69 
	tut8_t
;

70 
	tt16_t
;

71 
	tut16_t
;

72 
	tt32_t
;

73 
	tut32_t
;

74 
__t64
 
	tt64_t
;

75 
	t__t64
 
	tut64_t
;

80 
	~<dt.h
>

87 
	#UINT64_2PART_C
(
a
, 
b
(((
ic_
<
ut64_t
><< 32+ 0x##b##
u
))

	)

94 
	#ARRAY_SIZE
(
a
) \

95 (((
a
) / (*(a))) / \

96 
ic_
<
size_t
>(!((
a
% (*)))))

	)

100 
	#DISALLOW_COPY_AND_ASSIGN
(
TyName
) \

101 
	`TyName
(cڡ 
TyName
&); \

102 
ݔ
=(cڡ 
TyName
&)

	)

110 
	#DISALLOW_IMPLICIT_CONSTRUCTORS
(
TyName
) \

111 
	`TyName
(); \

112 
	`DISALLOW_COPY_AND_ASSIGN
(
TyName
)

	)

114 
mea
 
WTF
 {

116 
mea
 
doub_cvsi
 {

118 cڡ 
kChSize
 = ();

121 
me
 <
tyme
 
T
>

122 
T
 
	`Max
(T 
a
, T 
b
) {

123  
a
 < 
b
 ? b :;

128 
me
 <
tyme
 
T
>

129 
T
 
	`M
(T 
a
, T 
b
) {

130  
a
 < 
b
 ? : b;

134 
le
 
	`SLgth
(cڡ * 
rg
) {

135 
size_t
 
ngth
 = 
	`
(
rg
);

136 
	`ASSERT
(
ngth
 =
ic_
<
size_t
>(static_cast<>(length)));

137  
ic_
<>(
ngth
);

142 
me
 <
tyme
 
T
>

143 as
	cBufrRen
 {

144 
public
:

145 
	`BufrRen
(: 
	`t_
(
NULL
), 
	`ngth_
(0) {}

146 
	`BufrRen
(
T
* 
da
, 
ngth
: 
	`t_
(da), 
	`ngth_
(length) {

147 
	`ASSERT
(
ngth
 =0 || (ngth > 0 && 
da
 !
NULL
));

152 
BufrRen
<
T
> 
	`SubBufrRen
(
om
, 
to
) {

153 
	`ASSERT
(
to
 <
ngth_
);

154 
	`ASSERT_WITH_SECURITY_IMPLICATION
(
om
 < 
to
);

155 
	`ASSERT
(0 <
om
);

156  
BufrRen
<
T
>(
	`t
(+ 
om
, 
to
 - from);

160 
	`ngth
(cڡ {  
ngth_
; }

163 
bo
 
	`is_emy
(cڡ {  
ngth_
 == 0; }

166 
T
* 
	`t
(cڡ {  
t_
; }

169 
T
& 
ݔ
[](
dex
) const {

170 
	`ASSERT
(0 <
dex
 && index < 
ngth_
);

171  
t_
[
dex
];

174 
T
& 
	`f
({  
t_
[0]; }

176 
T
& 
	`ϡ
({  
t_
[
ngth_
 - 1]; }

178 
ive
:

179 
T
* 
t_
;

180 
ngth_
;

187 as
	cSgBud
 {

188 
public
:

189 
	`SgBud
(* 
bufr
, 
size
)

190 : 
	`bufr_
(
bufr
, 
size
), 
	`posi_
(0) { }

192 ~
	`SgBud
({ i(!
	`is_fized
()
	`Fize
(); }

194 
	`size
(cڡ {  
bufr_
.
	`ngth
(); }

197 
	`posi
() const {

198 
	`ASSERT
(!
	`is_fized
());

199  
posi_
;

203 
	`SPosi
(
posi
)

205 
	`ASSERT
(!
	`is_fized
());

206 
	`ASSERT_WITH_SECURITY_IMPLICATION
(
posi
 < 
	`size
());

207 
posi_
 = 
posi
;

211 
	`Ret
({ 
posi_
 = 0; }

216 
	`AddCha
(
c
) {

217 
	`ASSERT
(
c
 != '\0');

218 
	`ASSERT
(!
	`is_fized
(&& 
posi_
 < 
bufr_
.
	`ngth
());

219 
bufr_
[
posi_
++] = 
c
;

224 
	`AddSg
(cڡ * 
s
) {

225 
	`AddSubrg
(
s
, 
	`SLgth
(s));

230 
	`AddSubrg
(cڡ * 
s
, 
n
) {

231 
	`ASSERT
(!
	`is_fized
(&& 
posi_
 + 
n
 < 
bufr_
.
	`ngth
());

232 
	`ASSERT_WITH_SECURITY_IMPLICATION
(
ic_
<
size_t
>(
n
<
	`
(
s
));

233 
	`memy
(&
bufr_
[
posi_
], 
s
, 
n
 * 
kChSize
);

234 
posi_
 +
n
;

240 
	`AddPaddg
(
c
, 
cou
) {

241 
i
 = 0; i < 
cou
; i++) {

242 
	`AddCha
(
c
);

247 * 
	`Fize
() {

248 
	`ASSERT
(!
	`is_fized
(&& 
posi_
 < 
bufr_
.
	`ngth
());

249 
bufr_
[
posi_
] = '\0';

252 
	`ASSERT
(
	`
(
bufr_
.
	`t
()=
ic_
<
size_t
>(
posi_
));

253 
posi_
 = -1;

254 
	`ASSERT
(
	`is_fized
());

255  
bufr_
.
	`t
();

258 
ive
:

259 
BufrRen
<> 
bufr_
;

260 
posi_
;

262 
bo
 
	`is_fized
(cڡ {  
posi_
 < 0; }

264 
	`DISALLOW_IMPLICIT_CONSTRUCTORS
(
SgBud
);

291 
me
 <
ass
 
De
, cs
Sour
>

292 
le
 
De
 
	`BCa
(cڡ 
Sour
& 
sour
) {

295 
	tVifySizesAEqu
[(
De
=(
Sour
) ? 1 : -1];

297 
De
 
de
;

298 
	`memy
(&
de
, &
sour
, (dest));

299  
de
;

302 
me
 <
ass
 
De
, cs
Sour
>

303 
le
 
De
 
	`BCa
(
Sour
* 
sour
) {

304  
BCa
<
De
>(
t_
<
u_t
>(
sour
));

307 
	}
}

	@efl/EflTypedefs.h

28 #ide
WTF_ETydefs_h


29 
	#WTF_ETydefs_h


	)

31 #ifde
__lulus


33 #i
PLATFORM
(
EFL
)

34 
	tEce_X_ID
;

35 
Ece_X_ID
 
	tEce_X_Wdow
;

37 
	tEa_Bo
;

38 
_Evas_Pot
 
	tEvas_Pot
;

39 
_Evas_GL
 
	tEvas_GL
;

40 
_Evas_GL_Cڋxt
 
	tEvas_GL_Cڋxt
;

41 
_Evas_GL_Sur
 
	tEvas_GL_Sur
;

42 
_Ece_Evas
 
	tEce_Evas
;

43 
_Ece_Fd_Hdr
 
	tEce_Fd_Hdr
;

44 
_Ea_Li
 
	tEa_Li
;

45 
_Ea_Modu
 
	tEa_Modu
;

46 
_Ea_Reg
 
	tEa_Reg
;

47 #i
USE
(
EO
)

48 
_Eo_Oque
 
	tEvas
;

49 
_Eo_Oque
 
	tEvas_Obje
;

50 
_Eo_Oque
 
	tEce_Tim
;

52 
_Evas
 
	tEvas
;

53 
_Evas_Obje
 
	tEvas_Obje
;

54 
_Ece_Tim
 
	tEce_Tim
;

	@efl/MainThreadEfl.cpp

34 
	~"cfig.h
"

35 
	~"MaThad.h
"

37 
	~<Ece.h
>

38 
	~<wtf/StdLibExas.h
>

39 
	~<wtf/e/UniquePE.h
>

41 
mea
 
	gWTF
 {

43 
	gEUniqueP
<
	gEce_Pe
>& 
peObje
()

45 
DEPRECATED_DEFINE_STATIC_LOCAL
(
EUniqueP
<
Ece_Pe
>, 
peObje
, ());

46  
	gpeObje
;

49 
mڙDichFunis
(*, *, )

51 
dichFunisFromMaThad
();

54 
lizeMaThadPtfm
()

56 
peObje
(
EUniqueP
<
Ece_Pe
>(
ece_pe_add
(
mڙDichFunis
, 0));

59 
scheduDichFunisOnMaThad
()

61 
ece_pe_wre
(
peObje
().
g
(), "", 0);

	@efl/RunLoopEfl.cpp

27 
	~"cfig.h
"

28 
	~"RunLo.h
"

30 
	~<Ece.h
>

31 
	~<wtf/OwnP.h
>

32 
	~<wtf/PassOwnP.h
>

34 cڡ 
	gecePeMesgeSize
 = 1;

35 cڡ 
	gwakupEcePeMesge
[] = "W";

37 
mea
 
	gWTF
 {

39 
	gRunLo
::
RunLo
()

40 : 
m_wakeUpEvtRequeed
(
l
)

42 
m_pe
 = 
EUniqueP
<
Ece_Pe
>(
ece_pe_add
(
wakeUpEvt
, 
this
));

45 
	gRunLo
::~
RunLo
()

49 
RunLo
::
run
()

51 
ece_ma_lo_beg
();

54 
	gRunLo
::

()

56 
ece_ma_lo_qu
();

59 
	gRunLo
::
wakeUpEvt
(* 
da
, *, )

61 
RunLo
* 
	glo
 = 
ic_
<RunLo*>(
da
);

64 
MuxLock
 
lock
(
lo
->
m_wakeUpEvtRequeedLock
);

65 
	glo
->
	gm_wakeUpEvtRequeed
 = 
l
;

68 
	glo
->
rfmWk
();

71 
	gRunLo
::
wakeUp
()

74 
MuxLock
 
lock
(
m_wakeUpEvtRequeedLock
);

75 i(
	gm_wakeUpEvtRequeed
)

77 
	gm_wakeUpEvtRequeed
 = 
ue
;

81 
MuxLock
 
lock
(
m_peLock
);

82 
ece_pe_wre
(
m_pe
.
g
(), 
wakupEcePeMesge
, 
ecePeMesgeSize
);

86 
	gRunLo
::
TimBa
::TimBa(
RunLo
& 
runLo
)

87 : 
m_runLo
(
runLo
)

88 , 
m_tim
(0)

89 , 
m_isRtg
(
l
)

93 
	gRunLo
::
TimBa
::~TimerBase()

95 

();

98 
bo
 
	gRunLo
::
TimBa
::
timFed
(* 
da
)

100 
RunLo
::
TimBa
* 
tim
 = 
ic_
<RunLo::TimBa*>(
da
);

102 i(!
	gtim
->
	gm_isRtg
)

103 
	gtim
->
	gm_tim
 = 0;

105 
	gtim
->
fed
();

107  
	gtim
->
	gm_isRtg
 ? 
	gECORE_CALLBACK_RENEW
 : 
ECORE_CALLBACK_CANCEL
;

110 
	gRunLo
::
TimBa
::
t
(
xtFeIv
, 
bo
 

)

112 i(
isAive
())

113 

();

115 
	gm_isRtg
 = 

;

116 
ASSERT
(!
m_tim
);

117 
	gm_tim
 = 
ece_tim_add
(
xtFeIv
, 
t_
<
Ece_Task_Cb
>(
timFed
), 
this
);

120 
	gRunLo
::
TimBa
::

()

122 i(
m_tim
) {

123 
ece_tim_d
(
m_tim
);

124 
	gm_tim
 = 0;

128 
bo
 
	gRunLo
::
TimBa
::
isAive
() const

130  (
m_tim
? 
ue
 : 
l
;

	@efl/UniquePtrEfl.h

26 #ide
UniquePE_h


27 
	#UniquePE_h


	)

29 #i
PLATFORM
(
EFL
)

31 
	~<Ece.h
>

32 
	~<Ece_Evas.h
>

33 
	~<Ece_IMF.h
>

34 
	~<Ea.h
>

35 
	~<Evas.h
>

36 
	~<Evas_GL.h
>

38 
mea
 
	gWTF
 {

40 
	gme
<
tyme
 
	gT
> 
	sEPD
 {

41 
ݔ
()(
T
* 
	gr
cڡ = 
de
;

44 
	gme
<
tyme
 
	gT
>

45 
usg
 
	gEUniqueP
 = 
d
::
unique_r
<
T
, 
	gEPD
<
	gT
>>;

47 
	#FOR_EACH_EFL_DELETER
(
mao
) \

48 
	`mao
(
Ece_Evas
, 
ece_evas_
) \

49 
	`mao
(
Ece_IMF_Cڋxt
, 
ece_imf_cڋxt_d
) \

50 
	`mao
(
Ece_Pe
, 
ece_pe_d
) \

51 
	`mao
(
Ea_Hash
, 
ea_hash_
) \

52 
	`mao
(
Ea_Modu
, 
ea_modu_
) \

53 
	`mao
(
Evas_Obje
, 
evas_obje_d
) \

54 
	`mao
(
Evas_GL
, 
evas_gl_
)

	)

56 
	#WTF_DEFINE_EFLPTR_DELETER
(
tyName
, 
dFunc
) \

57 
me
<> 
EPD
<
tyName
> \

59 
	`ݔ
((
tyName
* 
r
) const \

61 i(
r
) \

62 
	`dFunc
(
r
); \

64 };

	)

66 
FOR_EACH_EFL_DELETER
(
WTF_DEFINE_EFLPTR_DELETER
)

67 #unde
FOR_EACH_EFL_DELETER


71 
usg
 
	gWTF
::
EUniqueP
;

	@gobject/GMainLoopSource.cpp

26 
	~"cfig.h
"

28 #i
USE
(
GLIB
)

30 
	~"GMaLoSour.h
"

31 
	~<gio/gio.h
>

32 
	~<wtf/gobje/GMuxLock.h
>

34 
mea
 
	gWTF
 {

36 
	gGMaLoSour
& GMaLoSour::

()

38  *
w
 
GMaLoSour
(
DeOnDeroy
);

41 
	gGMaLoSour
::
GMaLoSour
()

42 : 
m_deOnDeroy
(
DoNDeOnDeroy
)

43 , 
m_us
(
Rdy
)

45 
g_mux_
(&
m_mux
);

48 
	gGMaLoSour
::
GMaLoSour
(
DeOnDeroyTy
 
deOnDeroy
)

49 : 
m_deOnDeroy
(
deOnDeroy
)

50 , 
m_us
(
Rdy
)

52 
g_mux_
(&
m_mux
);

55 
	gGMaLoSour
::~
GMaLoSour
()

57 
nl
();

58 
g_mux_r
(&
m_mux
);

61 
bo
 
	gGMaLoSour
::
isSchedud
() const

63  
m_us
 =
Schedud
;

66 
bo
 
	gGMaLoSour
::
isAive
() const

68  
m_us
 !
Rdy
;

71 
	gGMaLoSour
::
nl
()

73 
GMuxLock
 
lock
(
m_mux
);

74 
nlWhoutLockg
();

77 
	gGMaLoSour
::
nlWhoutLockg
()

80 i(
m_deOnDeroy
 =
DeOnDeroy
)

84 
ASSERT
(!
m_cڋxt
.
sour
 || 
m_us
 =
Schedud
 || m_u=
Dichg
);

86 
ASSERT
(!
m_nab
 || 
m_us
 =
Dichg
);

88 
	gm_us
 = 
Rdy
;

93 
g_nab_nl
(
m_nab
.
g
());

94 
	gm_nab
 = 
nuαr
;

95 
g_nab_nl
(
m_cڋxt
.
sockCab
.
g
());

97 i(!
	gm_cڋxt
.
	gsour
)

100 
Cڋxt
 
	gcڋxt
 = 
WTF
::
move
(
m_cڋxt
);

101 
	gcڋxt
.
deroySour
();

104 
	gGMaLoSour
::
scheduIdSour
(cڡ * 
me
, 
GSourFunc
 
sourFuni
, 
iܙy
, 
GMaCڋxt
* 
cڋxt
)

106 
ASSERT
(
m_us
 =
Rdy
);

107 
	gm_us
 = 
Schedud
;

109 
g_sour_t_me
(
m_cڋxt
.
sour
.
g
(), 
me
);

110 i(
	giܙy
 !
G_PRIORITY_DEFAULT_IDLE
)

111 
g_sour_t_iܙy
(
m_cڋxt
.
sour
.
g
(), 
iܙy
);

112 
g_sour_t_back
(
m_cڋxt
.
sour
.
g
(), 
sourFuni
, 
this
, 
nuαr
);

113 
g_sour_ch
(
m_cڋxt
.
sour
.
g
(), 
cڋxt
);

116 
	gGMaLoSour
::
schedu
(cڡ * 
me
, 
d
::
funi
<()> funi, 
iܙy
, std::funi<()> 
deroyFuni
, 
GMaCڋxt
* 
cڋxt
)

118 
GMuxLock
 
lock
(
m_mux
);

119 
nlWhoutLockg
();

121 
ASSERT
(!
m_cڋxt
.
sour
);

122 
	gm_cڋxt
 = {

123 
adtGRef
(
g_id_sour_w
()),

124 
adtGRef
(
g_nab_w
()),

125 
nuαr
,

126 
WTF
::
move
(
funi
),

127 
nuαr
,

128 
nuαr
,

129 
WTF
::
move
(
deroyFuni
)

131 
scheduIdSour
(
me
, 
t_
<
GSourFunc
>(
voidSourClback
), 
iܙy
, 
cڋxt
);

134 
	gGMaLoSour
::
schedu
(cڡ * 
me
, 
d
::
funi
<
bo
 ()> funi, 
iܙy
, std::funi<()> 
deroyFuni
, 
GMaCڋxt
* 
cڋxt
)

136 
GMuxLock
 
lock
(
m_mux
);

137 
nlWhoutLockg
();

139 
ASSERT
(!
m_cڋxt
.
sour
);

140 
	gm_cڋxt
 = {

141 
adtGRef
(
g_id_sour_w
()),

142 
adtGRef
(
g_nab_w
()),

143 
nuαr
,

144 
nuαr
,

145 
WTF
::
move
(
funi
),

146 
nuαr
,

147 
WTF
::
move
(
deroyFuni
)

149 
scheduIdSour
(
me
, 
t_
<
GSourFunc
>(
boSourClback
), 
iܙy
, 
cڋxt
);

152 
	gGMaLoSour
::
schedu
(cڡ * 
me
, 
d
::
funi
<
bo
 (
GIOCdi
)> funi, 
GSock
* 
sock
, GIOCdi 
cdi
, std::funi<()> 
deroyFuni
, 
GMaCڋxt
* 
cڋxt
)

154 
GMuxLock
 
lock
(
m_mux
);

155 
nlWhoutLockg
();

157 
ASSERT
(!
m_cڋxt
.
sour
);

158 
GCab
* 
	gsockCab
 = 
g_nab_w
();

159 
	gm_cڋxt
 = {

160 
adtGRef
(
g_sock__sour
(
sock
, 
cdi
, 
sockCab
)),

161 
adtGRef
(
g_nab_w
()),

162 
adtGRef
(
sockCab
),

163 
nuαr
,

164 
nuαr
,

165 
WTF
::
move
(
funi
),

166 
WTF
::
move
(
deroyFuni
)

169 
ASSERT
(
m_us
 =
Rdy
);

170 
	gm_us
 = 
Schedud
;

171 
g_sour_t_me
(
m_cڋxt
.
sour
.
g
(), 
me
);

172 
g_sour_t_back
(
m_cڋxt
.
sour
.
g
(), 
t_
<
GSourFunc
>(
sockSourClback
), 
this
, 
nuαr
);

173 
g_sour_ch
(
m_cڋxt
.
sour
.
g
(), 
cڋxt
);

176 
	gGMaLoSour
::
scheduTimeoutSour
(cڡ * 
me
, 
GSourFunc
 
sourFuni
, 
iܙy
, 
GMaCڋxt
* 
cڋxt
)

178 
ASSERT
(
m_us
 =
Rdy
);

179 
	gm_us
 = 
Schedud
;

181 
g_sour_t_me
(
m_cڋxt
.
sour
.
g
(), 
me
);

182 i(
	giܙy
 !
G_PRIORITY_DEFAULT
)

183 
g_sour_t_iܙy
(
m_cڋxt
.
sour
.
g
(), 
iܙy
);

184 
g_sour_t_back
(
m_cڋxt
.
sour
.
g
(), 
sourFuni
, 
this
, 
nuαr
);

185 
g_sour_ch
(
m_cڋxt
.
sour
.
g
(), 
cڋxt
);

188 
	gGMaLoSour
::
scheduADay
(cڡ * 
me
, 
d
::
funi
<()> funi, std::
chro
::
mlicds
 
day
, 
iܙy
, std::funi<()> 
deroyFuni
, 
GMaCڋxt
* 
cڋxt
)

190 
GMuxLock
 
lock
(
m_mux
);

191 
nlWhoutLockg
();

193 
ASSERT
(!
m_cڋxt
.
sour
);

194 
	gm_cڋxt
 = {

195 
adtGRef
(
g_timeout_sour_w
(
day
.
cou
())),

196 
adtGRef
(
g_nab_w
()),

197 
nuαr
,

198 
WTF
::
move
(
funi
),

199 
nuαr
,

200 
nuαr
,

201 
WTF
::
move
(
deroyFuni
)

203 
scheduTimeoutSour
(
me
, 
t_
<
GSourFunc
>(
voidSourClback
), 
iܙy
, 
cڋxt
);

206 
	gGMaLoSour
::
scheduADay
(cڡ * 
me
, 
d
::
funi
<
bo
 ()> funi, std::
chro
::
mlicds
 
day
, 
iܙy
, std::funi<()> 
deroyFuni
, 
GMaCڋxt
* 
cڋxt
)

208 
GMuxLock
 
lock
(
m_mux
);

209 
nlWhoutLockg
();

211 
ASSERT
(!
m_cڋxt
.
sour
);

212 
	gm_cڋxt
 = {

213 
adtGRef
(
g_timeout_sour_w
(
day
.
cou
())),

214 
adtGRef
(
g_nab_w
()),

215 
nuαr
,

216 
nuαr
,

217 
WTF
::
move
(
funi
),

218 
nuαr
,

219 
WTF
::
move
(
deroyFuni
)

221 
scheduTimeoutSour
(
me
, 
t_
<
GSourFunc
>(
boSourClback
), 
iܙy
, 
cڋxt
);

224 
	gGMaLoSour
::
scheduADay
(cڡ * 
me
, 
d
::
funi
<()> funi, std::
chro
::
cds
 
day
, 
iܙy
, std::funi<()> 
deroyFuni
, 
GMaCڋxt
* 
cڋxt
)

226 
GMuxLock
 
lock
(
m_mux
);

227 
nlWhoutLockg
();

229 
ASSERT
(!
m_cڋxt
.
sour
);

230 
	gm_cڋxt
 = {

231 
adtGRef
(
g_timeout_sour_w_cds
(
day
.
cou
())),

232 
adtGRef
(
g_nab_w
()),

233 
nuαr
,

234 
WTF
::
move
(
funi
),

235 
nuαr
,

236 
nuαr
,

237 
WTF
::
move
(
deroyFuni
)

239 
scheduTimeoutSour
(
me
, 
t_
<
GSourFunc
>(
voidSourClback
), 
iܙy
, 
cڋxt
);

242 
	gGMaLoSour
::
scheduADay
(cڡ * 
me
, 
d
::
funi
<
bo
 ()> funi, std::
chro
::
cds
 
day
, 
iܙy
, std::funi<()> 
deroyFuni
, 
GMaCڋxt
* 
cڋxt
)

244 
GMuxLock
 
lock
(
m_mux
);

245 
nlWhoutLockg
();

247 
ASSERT
(!
m_cڋxt
.
sour
);

248 
	gm_cڋxt
 = {

249 
adtGRef
(
g_timeout_sour_w_cds
(
day
.
cou
())),

250 
adtGRef
(
g_nab_w
()),

251 
nuαr
,

252 
nuαr
,

253 
WTF
::
move
(
funi
),

254 
nuαr
,

255 
WTF
::
move
(
deroyFuni
)

257 
scheduTimeoutSour
(
me
, 
t_
<
GSourFunc
>(
boSourClback
), 
iܙy
, 
cڋxt
);

260 
	gGMaLoSour
::
scheduAndDeOnDeroy
(cڡ * 
me
, 
d
::
funi
<()> funi, 
iܙy
, std::funi<()> 
deroyFuni
, 
GMaCڋxt
* 
cڋxt
)

262 

().
schedu
(
me
, 
funi
, 
iܙy
, 
deroyFuni
, 
cڋxt
);

265 
	gGMaLoSour
::
scheduAndDeOnDeroy
(cڡ * 
me
, 
d
::
funi
<
bo
()> funi, 
iܙy
, std::funi<()> 
deroyFuni
, 
GMaCڋxt
* 
cڋxt
)

267 

().
schedu
(
me
, 
funi
, 
iܙy
, 
deroyFuni
, 
cڋxt
);

270 
	gGMaLoSour
::
scheduADayAndDeOnDeroy
(cڡ * 
me
, 
d
::
funi
<()> funi, std::
chro
::
mlicds
 
day
, 
iܙy
, std::funi<()> 
deroyFuni
, 
GMaCڋxt
* 
cڋxt
)

272 

().
scheduADay
(
me
, 
funi
, 
day
, 
iܙy
, 
deroyFuni
, 
cڋxt
);

275 
	gGMaLoSour
::
scheduADayAndDeOnDeroy
(cڡ * 
me
, 
d
::
funi
<
bo
()> funi, std::
chro
::
mlicds
 
day
, 
iܙy
, std::funi<()> 
deroyFuni
, 
GMaCڋxt
* 
cڋxt
)

277 

().
scheduADay
(
me
, 
funi
, 
day
, 
iܙy
, 
deroyFuni
, 
cڋxt
);

280 
	gGMaLoSour
::
scheduADayAndDeOnDeroy
(cڡ * 
me
, 
d
::
funi
<()> funi, std::
chro
::
cds
 
day
, 
iܙy
, std::funi<()> 
deroyFuni
, 
GMaCڋxt
* 
cڋxt
)

282 

().
scheduADay
(
me
, 
funi
, 
day
, 
iܙy
, 
deroyFuni
, 
cڋxt
);

285 
	gGMaLoSour
::
scheduADayAndDeOnDeroy
(cڡ * 
me
, 
d
::
funi
<
bo
()> funi, std::
chro
::
cds
 
day
, 
iܙy
, std::funi<()> 
deroyFuni
, 
GMaCڋxt
* 
cڋxt
)

287 

().
scheduADay
(
me
, 
funi
, 
day
, 
iܙy
, 
deroyFuni
, 
cڋxt
);

290 
	gGMaLoSour
::
voidClback
()

292 
Cڋxt
 
cڋxt
;

295 
GMuxLock
 
lock
(
m_mux
);

296 i(!
	gm_cڋxt
.
	gsour
)

299 
	gcڋxt
 = 
WTF
::
move
(
m_cڋxt
);

301 
ASSERT
(
cڋxt
.
voidClback
);

302 
ASSERT
(
m_us
 =
Schedud
);

303 
	gm_us
 = 
Dichg
;

305 
	gm_nab
 = 
cڋxt
.
nab
;

308 
	gcڋxt
.
voidClback
();

310 i(
g_nab_is_ned
(
cڋxt
.
nab
.
g
())) {

311 
	gcڋxt
.
deroySour
();

315 
bo
 
	gshouldSfDeru
 = 
l
;

317 
GMuxLock
 
lock
(
m_mux
);

318 
	gm_us
 = 
Rdy
;

319 
	gm_nab
 = 
nuαr
;

320 
	gshouldSfDeru
 = 
m_deOnDeroy
 =
DeOnDeroy
;

323 
	gcڋxt
.
deroySour
();

324 i(
	gshouldSfDeru
)

325 
de
 
	gthis
;

328 
bo
 
	gGMaLoSour
::
boClback
()

330 
Cڋxt
 
cڋxt
;

333 
GMuxLock
 
lock
(
m_mux
);

334 i(!
	gm_cڋxt
.
	gsour
)

335  
	gSt
;

337 
	gcڋxt
 = 
WTF
::
move
(
m_cڋxt
);

339 
ASSERT
(
cڋxt
.
boClback
);

340 
ASSERT
(
m_us
 =
Schedud
 || m_u=
Dichg
);

341 
	gm_us
 = 
Dichg
;

343 
	gm_nab
 = 
cڋxt
.
nab
;

346 
bo
 
	gtv
 = 
cڋxt
.
boClback
();

348 i(
g_nab_is_ned
(
cڋxt
.
nab
.
g
())) {

349 
	gcڋxt
.
deroySour
();

350  
	gSt
;

353 
bo
 
	gshouldSfDeru
 = 
l
;

355 
GMuxLock
 
lock
(
m_mux
);

356 
	gm_nab
 = 
nuαr
;

357 
	gshouldSfDeru
 = 
m_deOnDeroy
 =
DeOnDeroy
;

360 
ASSERT
((!
m_cڋxt
.
sour
 && 
m_us
 =
Dichg
|| m_u=
Schedud
);

361 i(
	gtv
 && !
	gm_cڋxt
.
	gsour
)

362 
	gm_cڋxt
 = 
WTF
::
move
(
cڋxt
);

363 i(!
	gtv
)

364 
	gm_us
 = 
Rdy
;

367 i(
	gcڋxt
.
	gsour
) {

368 
	gcڋxt
.
deroySour
();

369 i(
	gshouldSfDeru
)

370 
de
 
	gthis
;

373  
	gtv
;

376 
bo
 
	gGMaLoSour
::
sockClback
(
GIOCdi
 
cdi
)

378 
Cڋxt
 
cڋxt
;

381 
GMuxLock
 
lock
(
m_mux
);

382 i(!
	gm_cڋxt
.
	gsour
)

383  
	gSt
;

385 
	gcڋxt
 = 
WTF
::
move
(
m_cڋxt
);

387 
ASSERT
(
cڋxt
.
sockClback
);

388 
ASSERT
(
m_us
 =
Schedud
 || m_u=
Dichg
);

389 
	gm_us
 = 
Dichg
;

391 
	gm_nab
 = 
cڋxt
.
nab
;

394 i(
g_nab_is_ned
(
cڋxt
.
sockCab
.
g
())) {

395 
	gcڋxt
.
deroySour
();

396  
	gSt
;

399 
bo
 
	gtv
 = 
cڋxt
.
sockClback
(
cdi
);

401 i(
g_nab_is_ned
(
cڋxt
.
nab
.
g
())) {

402 
	gcڋxt
.
deroySour
();

403  
	gSt
;

407 
GMuxLock
 
lock
(
m_mux
);

408 
	gm_nab
 = 
nuαr
;

411 
ASSERT
((!
m_cڋxt
.
sour
 && 
m_us
 =
Dichg
|| m_u=
Schedud
);

413 i(
	gtv
 && !
	gm_cڋxt
.
	gsour
)

414 
	gm_cڋxt
 = 
WTF
::
move
(
cڋxt
);

415 i(!
	gtv
)

416 
	gm_us
 = 
Rdy
;

419 i(
	gcڋxt
.
	gsour
)

420 
	gcڋxt
.
deroySour
();

422  
	gtv
;

425 
gboޗn
 
	gGMaLoSour
::
voidSourClback
(
GMaLoSour
* 
sour
)

427 
sour
->
voidClback
();

428  
	gG_SOURCE_REMOVE
;

431 
gboޗn
 
	gGMaLoSour
::
boSourClback
(
GMaLoSour
* 
sour
)

433  
sour
->
boClback
(=
Ctue
;

436 
gboޗn
 
	gGMaLoSour
::
sockSourClback
(
GSock
*, 
GIOCdi
 
cdi
, 
GMaLoSour
* 
sour
)

438  
	gsour
->
sockClback
(
cdi
=
Ctue
;

441 
	gGMaLoSour
::
Cڋxt
::
deroySour
()

443 
g_sour_deroy
(
sour
.
g
());

444 i(
	gderoyClback
)

445 
deroyClback
();

	@gobject/GMainLoopSource.h

26 #ide
GMaLoSour_h


27 
	#GMaLoSour_h


	)

29 
	~<funiڮ
>

30 
	~<glib.h
>

31 
	~<wtf/Ncyab.h
>

32 
	~<wtf/gobje/GRefP.h
>

34 
_GSock
 
	tGSock
;

35 
_GMux
 
	tGMux
;

37 
mea
 
	gWTF
 {

39 as
	cGMaLoSour
 {

40 
WTF_MAKE_NONCOPYABLE
(
GMaLoSour
);

41 
	gWTF_MAKE_FAST_ALLOCATED
;

42 
	gpublic
:

43 
WTF_EXPORT_PRIVATE
 
GMaLoSour
();

44 
	gWTF_EXPORT_PRIVATE
 ~
GMaLoSour
();

46 cڡ 
bo
 
	gSt
 = 
l
;

47 cڡ 
bo
 
	gCtue
 = 
ue
;

49 
WTF_EXPORT_PRIVATE
 
bo
 
isSchedud
() const;

50 
WTF_EXPORT_PRIVATE
 
bo
 
isAive
() const;

52 
WTF_EXPORT_PRIVATE
 
schedu
(cڡ * 
me
, 
d
::
funi
<()>, 
iܙy
 = 
G_PRIORITY_DEFAULT
, std::funi<()> 
deroyFuni
 = 
nuαr
, 
GMaCڋxt
* =ullptr);

53 
WTF_EXPORT_PRIVATE
 
schedu
(cڡ * 
me
, 
d
::
funi
<
bo
()>, 
iܙy
 = 
G_PRIORITY_DEFAULT
, std::funi<()> 
deroyFuni
 = 
nuαr
, 
GMaCڋxt
* =ullptr);

54 
WTF_EXPORT_PRIVATE
 
schedu
(cڡ * 
me
, 
d
::
funi
<
bo
(
GIOCdi
)>, 
GSock
*, GIOCdi, std::funi<()> 
deroyFuni
 = 
nuαr
, 
GMaCڋxt
* =ullptr);

55 
WTF_EXPORT_PRIVATE
 
scheduADay
(cڡ * 
me
, 
d
::
funi
<()>, std::
chro
::
mlicds
, 
iܙy
 = 
G_PRIORITY_DEFAULT
, std::funi<()> 
deroyFuni
 = 
nuαr
, 
GMaCڋxt
* =ullptr);

56 
WTF_EXPORT_PRIVATE
 
scheduADay
(cڡ * 
me
, 
d
::
funi
<
bo
()>, std::
chro
::
mlicds
, 
iܙy
 = 
G_PRIORITY_DEFAULT
, std::funi<()> 
deroyFuni
 = 
nuαr
, 
GMaCڋxt
* =ullptr);

57 
WTF_EXPORT_PRIVATE
 
scheduADay
(cڡ * 
me
, 
d
::
funi
<()>, std::
chro
::
cds
, 
iܙy
 = 
G_PRIORITY_DEFAULT
, std::funi<()> 
deroyFuni
 = 
nuαr
, 
GMaCڋxt
* =ullptr);

58 
WTF_EXPORT_PRIVATE
 
scheduADay
(cڡ * 
me
, 
d
::
funi
<
bo
()>, std::
chro
::
cds
, 
iܙy
 = 
G_PRIORITY_DEFAULT
, std::funi<()> 
deroyFuni
 = 
nuαr
, 
GMaCڋxt
* =ullptr);

59 
WTF_EXPORT_PRIVATE
 
nl
();

61 
scheduAndDeOnDeroy
(cڡ * 
me
, 
d
::
funi
<()>, 
iܙy
 = 
G_PRIORITY_DEFAULT
, std::funi<()> 
deroyFuni
 = 
nuαr
, 
GMaCڋxt
* =ullptr);

62 
scheduAndDeOnDeroy
(cڡ * 
me
, 
d
::
funi
<
bo
()>, 
iܙy
 = 
G_PRIORITY_DEFAULT
, std::funi<()> 
deroyFuni
 = 
nuαr
, 
GMaCڋxt
* =ullptr);

63 
scheduADayAndDeOnDeroy
(cڡ * 
me
, 
d
::
funi
<()>, std::
chro
::
mlicds
, 
iܙy
 = 
G_PRIORITY_DEFAULT
, std::funi<()> 
deroyFuni
 = 
nuαr
, 
GMaCڋxt
* =ullptr);

64 
scheduADayAndDeOnDeroy
(cڡ * 
me
, 
d
::
funi
<
bo
()>, std::
chro
::
mlicds
, 
iܙy
 = 
G_PRIORITY_DEFAULT
, std::funi<()> 
deroyFuni
 = 
nuαr
, 
GMaCڋxt
* =ullptr);

65 
scheduADayAndDeOnDeroy
(cڡ * 
me
, 
d
::
funi
<()>, std::
chro
::
cds
, 
iܙy
 = 
G_PRIORITY_DEFAULT
, std::funi<()> 
deroyFuni
 = 
nuαr
, 
GMaCڋxt
* =ullptr);

66 
scheduADayAndDeOnDeroy
(cڡ * 
me
, 
d
::
funi
<
bo
()>, std::
chro
::
cds
, 
iܙy
 = 
G_PRIORITY_DEFAULT
, std::funi<()> 
deroyFuni
 = 
nuαr
, 
GMaCڋxt
* =ullptr);

68 
	give
:

69 
GMaLoSour
& 

();

71 
	eDeOnDeroyTy
 { 
	gDeOnDeroy
, 
	gDoNDeOnDeroy
 };

72 
GMaLoSour
(
DeOnDeroyTy
);

74 
	eStus
 { 
	gRdy
, 
	gSchedud
, 
	gDichg
 };

76 
nlWhoutLockg
();

77 
scheduIdSour
(cڡ * 
me
, 
GSourFunc
, 
iܙy
, 
GMaCڋxt
*);

78 
scheduTimeoutSour
(cڡ * 
me
, 
GSourFunc
, 
iܙy
, 
GMaCڋxt
*);

79 
voidClback
();

80 
bo
 
boClback
();

81 
bo
 
sockClback
(
GIOCdi
);

83 
deroy
();

85 
gboޗn
 
voidSourClback
(
GMaLoSour
*);

86 
gboޗn
 
boSourClback
(
GMaLoSour
*);

87 
gboޗn
 
sockSourClback
(
GSock
*, 
GIOCdi
, 
GMaLoSour
*);

89 
DeOnDeroyTy
 
	gm_deOnDeroy
;

90 
Stus
 
	gm_us
;

91 
GMux
 
	gm_mux
;

92 
	gGRefP
<
	gGCab
> 
	gm_nab
;

94 
	sCڋxt
 {

95 
Cڋxt
() = ;

96 
Cڋxt
(Context&&) = ;

97 
	gCڋxt
& 
	gݔ
=(
Cڋxt
&&) = ;

99 
deroySour
();

101 
	gGRefP
<
	gGSour
> 
	gsour
;

102 
	gGRefP
<
	gGCab
> 
	gnab
;

103 
	gGRefP
<
	gGCab
> 
	gsockCab
;

104 
	gd
::
funi
<()> 
voidClback
;

105 
	gd
::
funi
<
bo
 ()> 
boClback
;

106 
	gd
::
funi
<
bo
 (
GIOCdi
)> 
sockClback
;

107 
	gd
::
funi
<()> 
deroyClback
;

108 } 
	gm_cڋxt
;

113 
usg
 
	gWTF
::
GMaLoSour
;

	@gobject/GMutexLocker.h

20 #ide
GMuxLock_h


21 
	#GMuxLock_h


	)

23 #i
USE
(
GLIB
)

25 
	~<glib.h
>

26 
	~<wtf/Ncyab.h
>

28 
mea
 
	gWTF
 {

30 as
	cGMuxLock
 {

31 
WTF_MAKE_NONCOPYABLE
(
GMuxLock
);

32 
	gpublic
:

33 
exic
 
GMuxLock
(
GMux
& 
mux
)

34 : 
m_mux
(
mux
)

35 , 
m_locked
(
l
)

37 
lock
();

40 ~
GMuxLock
()

42 
uock
();

45 
lock
()

47 i(!
	gm_locked
) {

48 
g_mux_lock
(&
m_mux
);

49 
	gm_locked
 = 
ue
;

53 
uock
()

55 i(
	gm_locked
) {

56 
	gm_locked
 = 
l
;

57 
g_mux_uock
(&
m_mux
);

61 
	give
:

62 
GMux
& 
m_mux
;

63 
bo
 
	gm_locked
;

68 
usg
 
	gWTF
::
GMuxLock
;

	@gobject/GRefPtr.cpp

19 
	~"cfig.h
"

20 
	~"GRefP.h
"

22 #i
USE
(
GLIB
)

24 
	~<glib-obje.h
>

25 
	~<glib.h
>

27 
mea
 
	gWTF
 {

29 
	gme
 <> 
GHashTab
* 
fGP
(GHashTab* 
r
)

31 i(
	gr
)

32 
g_hash_b_f
(
r
);

33  
	gr
;

36 
	gme
 <> 
defGP
(
GHashTab
* 
r
)

38 
g_hash_b_uef
(
r
);

41 
	gme
 <> 
GMaCڋxt
* 
fGP
(GMaCڋxt* 
r
)

43 i(
	gr
)

44 
g_ma_cڋxt_f
(
r
);

45  
	gr
;

48 
	gme
 <> 
defGP
(
GMaCڋxt
* 
r
)

50 i(
	gr
)

51 
g_ma_cڋxt_uef
(
r
);

54 
	gme
 <> 
GMaLo
* 
fGP
(GMaLo* 
r
)

56 i(
	gr
)

57 
g_ma_lo_f
(
r
);

58  
	gr
;

61 
	gme
 <> 
defGP
(
GMaLo
* 
r
)

63 i(
	gr
)

64 
g_ma_lo_uef
(
r
);

67 
	gme
 <> 
GBys
* 
fGP
(GBys* 
r
)

69 i(
	gr
)

70 
g_bys_f
(
r
);

71  
	gr
;

74 
	gme
 <> 
defGP
(
GBys
* 
r
)

76 i(
	gr
)

77 
g_bys_uef
(
r
);

80 
	gme
 <> 
GV
* 
fGP
(GV* 
r
)

82 i(
	gr
)

83 
g_v_f_sk
(
r
);

84  
	gr
;

87 
	gme
 <> 
defGP
(
GV
* 
r
)

89 
g_v_uef
(
r
);

92 
	gme
 <> 
GSour
* 
fGP
(GSour* 
r
)

94 i(
	gr
)

95 
g_sour_f
(
r
);

96  
	gr
;

99 
	gme
 <> 
defGP
(
GSour
* 
r
)

101 i(
	gr
)

102 
g_sour_uef
(
r
);

105 
	gme
 <> 
GPAay
* 
fGP
(GPAay* 
r
)

107 i(
	gr
)

108 
g_r_y_f
(
r
);

109  
	gr
;

112 
	gme
 <> 
defGP
(
GPAay
* 
r
)

114 i(
	gr
)

115 
g_r_y_uef
(
r
);

118 
	gme
 <> 
GByAay
* 
fGP
(GByAay* 
r
)

120 i(
	gr
)

121 
g_by_y_f
(
r
);

122  
	gr
;

125 
	gme
 <> 
defGP
(
GByAay
* 
r
)

127 i(
	gr
)

128 
g_by_y_uef
(
r
);

131 
	gme
 <> 
GClosu
* 
fGP
(GClosu* 
r
)

133 i(
	gr
)

134 
g_osu_f
(
r
);

135  
	gr
;

138 
	gme
 <> 
defGP
(
GClosu
* 
r
)

140 i(
	gr
)

141 
g_osu_uef
(
r
);

	@gobject/GRefPtr.h

23 #ide
WTF_GRefP_h


24 
	#WTF_GRefP_h


	)

26 #i
USE
(
GLIB
)

28 
	~<wtf/GP.h
>

29 
	~<wtf/RefP.h
>

30 
	~<gܙhm
>

32 "C" 
g_obje_uef
(
gpor
);

33 "C" 
gpor
 
g_obje_f_sk
(gpointer);

35 
mea
 
	gWTF
 {

37 
	eGRefPAdtTy
 { 
	gGRefPAdt
 };

38 
	gme
 <
tyme
 
	gT
> 
le
 
T
* 
fGP
(T*);

39 
	gme
 <
tyme
 
	gT
> 
le
 
defGP
(
T
*);

40 
	gme
 <
tyme
 
	gT
> 
ass
 
	gGRefP
;

41 
	gme
 <
tyme
 
	gT
> 
	gGRefP
<T> 
adtGRef
(
T
*);

43 
	gme
 <
tyme
 
	gT
> cs
	cGRefP
 {

44 
	gpublic
:

45 
T
 
	tVueTy
;

46 
VueTy
* 
	tPTy
;

48 
GRefP
(: 
m_r
(0) { }

50 
GRefP
(
T
* 
r
)

51 : 
m_r
(
r
)

53 i(
r
)

54 
fGP
(
r
);

57 
GRefP
(cڡ GRefP& 
o
)

58 : 
m_r
(
o
.m_ptr)

60 i(
T
* 
r
 = 
m_r
)

61 
fGP
(
r
);

64 
	gme
 <
tyme
 
	gU
> 
GRefP
(cڡ GRefP<
U
>& 
o
)

65 : 
m_r
(
o
.
g
())

67 i(
T
* 
r
 = 
m_r
)

68 
fGP
(
r
);

71 
GRefP
(GRefP&& 
o
: 
m_r
(o.
akRef
()) { }

72 
me
 <
tyme
 
U
> 
GRefP
(GRefP<U>&& 
o
: 
m_r
(o.
akRef
()) { }

74 ~
GRefP
()

76 i(
T
* 
r
 = 
m_r
)

77 
defGP
(
r
);

80 
r
()

82 
T
* 
	gr
 = 
m_r
;

83 
	gm_r
 = 0;

84 i(
	gr
)

85 
defGP
(
r
);

88 
T
* 
akRef
(
	gWARN_UNUSED_RETURN


90 
T
* 
	gr
 = 
m_r
;

91 
	gm_r
 = 0;

92  
	gr
;

95 
	gT
*& 
outP
()

97 
ASSERT
(!
m_r
);

98  
	gm_r
;

102 
GRefP
(
HashTabDedVueTy
: 
m_r
(
hashTabDedVue
()) { }

103 
bo
 
isHashTabDedVue
(cڡ {  
m_r
 =
hashTabDedVue
(); }

105 
T
* 
g
(cڡ {  
	gm_r
; }

106 
	gT
& 
	gݔ
*(cڡ {  *
	gm_r
; }

107 
ALWAYS_INLINE
 
T
* 
	gݔ
->(cڡ {  
	gm_r
; }

109 
bo
 
	gݔ
!(cڡ {  !
	gm_r
; }

112 
T
* 
	tGRefP
::*
	tUnecifdBoTy
;

113 
ݔ
 
UnecifdBoTy
(cڡ {  
	gm_r
 ? &
	gGRefP
::
m_r
 : 0; }

115 
	gGRefP
& 
	gݔ
=(cڡ 
GRefP
&);

116 
	gGRefP
& 
	gݔ
=(
GRefP
&&);

117 
	gGRefP
& 
	gݔ
=(
T
*);

118 
	gme
 <
tyme
 
	gU
> 
	gGRefP
& 
	gݔ
=(cڡ 
GRefP
<
U
>&);

120 
sw
(
GRefP
&);

121 
nd
 
GRefP
 
	gadtGRef
<
	gT
>(T*);

123 
	give
:

124 
T
* 
hashTabDedVue
({  
t_
<T*>(-1); }

126 
GRefP
(
T
* 
r
, 
GRefPAdtTy
: 
m_r
(ptr) {}

128 
T
* 
m_r
;

131 
	gme
 <
tyme
 
	gT
> 
le
 
	gGRefP
<T>& GRefP<T>::
ݔ
=(cڡ 
GRefP
<
T
>& 
o
)

133 
T
* 
݌
 = 
o
.
g
();

134 i(
	g݌
)

135 
fGP
(
݌
);

136 
T
* 
	gr
 = 
m_r
;

137 
	gm_r
 = 
݌
;

138 i(
	gr
)

139 
defGP
(
r
);

140  *
	gthis
;

143 
	gme
 <
tyme
 
	gT
> 
le
 
	gGRefP
<T>& GRefP<T>::
ݔ
=(
GRefP
<
T
>&& 
o
)

145 
GRefP
 
r
 = 
WTF
::
move
(
o
);

146 
sw
(
r
);

147  *
	gthis
;

150 
	gme
 <
tyme
 
	gT
> 
le
 
	gGRefP
<T>& GRefP<T>::
ݔ
=(
T
* 
݌
)

152 
T
* 
r
 = 
m_r
;

153 i(
	g݌
)

154 
fGP
(
݌
);

155 
	gm_r
 = 
݌
;

156 i(
	gr
)

157 
defGP
(
r
);

158  *
	gthis
;

161 
	gme
 <
ass
 
	gT
> 
le
 
	gGRefP
<T>::
sw
(
GRefP
<
T
>& 
o
)

163 
d
::
sw
(
m_r
, 
o
.m_ptr);

166 
	gme
 <
ass
 
	gT
> 
le
 
sw
(
GRefP
<
T
>& 
a
, GRefP<T>& 
b
)

168 
	ga
.
sw
(
b
);

171 
	gme
 <
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
==(cڡ 
GRefP
<
T
>& 
a
, cڡ 
	gGRefP
<U>& 
	gb
)

173  
	ga
.
g
(=
b
.get();

176 
	gme
 <
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
==(cڡ 
GRefP
<
T
>& 
a
, 
U
* 
	gb
)

178  
	ga
.
g
(=
b
;

181 
	gme
 <
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
==(
T
* 
a
, cڡ 
	gGRefP
<U>& 
	gb
)

183  
	ga
 =
b
.
g
();

186 
	gme
 <
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
!=(cڡ 
GRefP
<
T
>& 
a
, cڡ 
	gGRefP
<U>& 
	gb
)

188  
	ga
.
g
(!
b
.get();

191 
	gme
 <
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
!=(cڡ 
GRefP
<
T
>& 
a
, 
U
* 
	gb
)

193  
	ga
.
g
(!
b
;

196 
	gme
 <
tyme
 
	gT
,ym
	gU
> 
le
 
bo
 
	gݔ
!=(
T
* 
a
, cڡ 
	gGRefP
<U>& 
	gb
)

198  
	ga
 !
b
.
g
();

201 
	gme
 <
tyme
 
	gT
,ym
	gU
> 
le
 
	gGRefP
<T> 
ic_por_
(cڡ 
GRefP
<
U
>& 
p
)

203  
	gGRefP
<
	gT
>(
	gic_
<T*>(
	gp
.
g
()));

206 
	gme
 <
tyme
 
	gT
,ym
	gU
> 
le
 
	gGRefP
<T> 
cڡ_por_
(cڡ 
GRefP
<
U
>& 
p
)

208  
	gGRefP
<
	gT
>(
	gcڡ_
<T*>(
	gp
.
g
()));

211 
	gme
 <
tyme
 
	gT
> 
	gIsSmtP
<
	gGRefP
<T>> {

212 cڡ 
bo
 
	gvue
 = 
ue
;

215 
	gme
 <
tyme
 
	gT
> 
	gGRefP
<T> 
	$adtGRef
(
T
* 
p
)

217  
GRefP
<
T
>(
p
, 
GRefPAdt
);

218 
	}
}

220 
	gme
 <> 
WTF_EXPORT_PRIVATE
 
GHashTab
* 
fGP
(GHashTab* 
r
);

221 
	gme
 <> 
WTF_EXPORT_PRIVATE
 
defGP
(
GHashTab
* 
r
);

222 
	gme
 <> 
WTF_EXPORT_PRIVATE
 
GMaCڋxt
* 
fGP
(GMaCڋxt* 
r
);

223 
	gme
 <> 
WTF_EXPORT_PRIVATE
 
defGP
(
GMaCڋxt
* 
r
);

224 
	gme
 <> 
WTF_EXPORT_PRIVATE
 
GMaLo
* 
fGP
(GMaLo* 
r
);

225 
	gme
 <> 
WTF_EXPORT_PRIVATE
 
defGP
(
GMaLo
* 
r
);

226 
	gme
 <> 
WTF_EXPORT_PRIVATE
 
GV
* 
fGP
(GV* 
r
);

227 
	gme
 <> 
WTF_EXPORT_PRIVATE
 
defGP
(
GV
* 
r
);

228 
	gme
 <> 
WTF_EXPORT_PRIVATE
 
GSour
* 
fGP
(GSour* 
r
);

229 
	gme
 <> 
WTF_EXPORT_PRIVATE
 
defGP
(
GSour
* 
r
);

230 
	gme
 <> 
WTF_EXPORT_PRIVATE
 
GPAay
* 
fGP
(GPtrArray*);

231 
	gme
 <> 
WTF_EXPORT_PRIVATE
 
defGP
(
GPAay
*);

232 
	gme
 <> 
WTF_EXPORT_PRIVATE
 
GByAay
* 
fGP
(GByteArray*);

233 
	gme
 <> 
WTF_EXPORT_PRIVATE
 
defGP
(
GByAay
*);

234 
	gme
 <> 
WTF_EXPORT_PRIVATE
 
GBys
* 
fGP
(GBytes*);

235 
	gme
 <> 
WTF_EXPORT_PRIVATE
 
defGP
(
GBys
*);

236 
	gme
 <> 
WTF_EXPORT_PRIVATE
 
GClosu
* 
fGP
(GClosure*);

237 
	gme
 <> 
WTF_EXPORT_PRIVATE
 
defGP
(
GClosu
*);

239 
	gme
 <
tyme
 
	gT
> 
le
 
T
* 
	$fGP
(
T
* 
r
)

241 i(
r
)

242 
	`g_obje_f_sk
(
r
);

243  
r
;

244 
	}
}

246 
	gme
 <
tyme
 
	gT
> 
le
 
	$defGP
(
T
* 
r
)

248 i(
r
)

249 
	`g_obje_uef
(
r
);

250 
	}
}

254 
usg
 
	gWTF
::
GRefP
;

255 
usg
 
	gWTF
::
adtGRef
;

	@gobject/GTypedefs.h

20 #ide
GtkTydefs_h


21 
	#GtkTydefs_h


	)

24 #ifde 
__lulus


26 
	tgch
;

27 
	tgdoub
;

28 
	tgt
;

29 
	tgt
;

30 
gt
 
	tgboޗn
;

31 
	tglg
;

32 
	tgsht
;

33 
	tguch
;

34 
	tgut
;

35 
	tgulg
;

36 
	tgusht
;

37 * 
	tgpor
;

39 
_GAsyncResu
 
	tGAsyncResu
;

40 
_GCab
 
	tGCab
;

41 
_GChtCvr
 
	tGChtCvr
;

42 
_GD
 
	tGD
;

43 
_GdkAtom
* 
	tGdkAtom
;

44 
_GdkCurs
 
	tGdkCurs
;

45 
_GdkDgCڋxt
 
	tGdkDgCڋxt
;

46 
_GdkEvtCfigu
 
	tGdkEvtCfigu
;

47 
_GdkEvtExpo
 
	tGdkEvtExpo
;

48 
_GdkPixbuf
 
	tGdkPixbuf
;

49 
_GE
 
	tGE
;

50 
_GFe
 
	tGFe
;

51 
_GHashTab
 
	tGHashTab
;

52 
_GIutSm
 
	tGIutSm
;

53 
_GLi
 
	tGLi
;

54 
_GMaCڋxt
 
	tGMaCڋxt
;

55 
_GMaLo
 
	tGMaLo
;

56 
_GPSc
 
	tGPSc
;

57 
_GPbOuutSm
 
	tGPbOuutSm
;

58 
_GSLi
 
	tGSLi
;

59 
_GSockCl
 
	tGSockCl
;

60 
_GSockCi
 
	tGSockCi
;

61 
_GSour
 
	tGSour
;

62 
_GV
 
	tGV
;

63 
_GdkEvt
 
	tGdkEvt
;

64 
_GTim
 
	tGTim
;

65 
_GKeyFe
 
	tGKeyFe
;

66 
_GPAay
 
	tGPAay
;

67 
_GByAay
 
	tGByAay
;

68 
_GBys
 
	tGBys
;

69 
_GClosu
 
	tGClosu
;

71 #i
USE
(
CAIRO
)

72 
_o_sur
 
	to_sur_t
;

73 
_o_g_t
 
	to_g_t_t
;

76 #i
USE
(
CLUTTER
)

77 
_CluA
 
	tCluA
;

78 
_GphicsLayA
 
	tGphicsLayA
;

81 #i
PLATFORM
(
GTK
)

82 
_GtkAi
 
	tGtkAi
;

83 
_GtkAdjumt
 
	tGtkAdjumt
;

84 
_GtkBd
 
	tGtkBd
;

85 
_GtkClbrd
 
	tGtkClbrd
;

86 
_GtkCڏ
 
	tGtkCڏ
;

87 
_GtkIcInfo
 
	tGtkIcInfo
;

88 
_GtkMu
 
	tGtkMu
;

89 
_GtkMuIm
 
	tGtkMuIm
;

90 
_GtkObje
 
	tGtkObje
;

91 
_GtkSeiDa
 
	tGtkSeiDa
;

92 
_GtkSty
 
	tGtkSty
;

93 
_GtkTgLi
 
	tGtkTgLi
;

94 
_GtkThemePts
 
	tGtkThemePts
;

95 
_GtkWidg
 
	tGtkWidg
;

96 
_GtkWdow
 
	tGtkWdow
;

98 #ifde
GTK_API_VERSION_2


99 
_GdkReg
 
	tGdkReg
;

100 
_GdkDwab
 
	tGdkWdow
;

102 
_GdkWdow
 
	tGdkWdow
;

103 
_GtkStyCڋxt
 
	tGtkStyCڋxt
;

	@gobject/GUniquePtr.h

21 #ide
GUniqueP_h


22 
	#GUniqueP_h


	)

24 #i
USE
(
GLIB
)

26 
	~<gio/gio.h
>

27 
	~<wtf/Ncyab.h
>

29 
mea
 
	gWTF
 {

31 
	gme
<
tyme
 
	gT
>

32 
	sGPD
 {

33 
ݔ
()(
T
* 
	gr
cڡ { 
g_
(
r
); }

36 
	gme
<
tyme
 
	gT
>

37 
usg
 
	gGUniqueP
 = 
d
::
unique_r
<
T
, 
	gGPD
<
	gT
>>;

39 
	#FOR_EACH_GLIB_DELETER
(
mao
) \

40 
	`mao
(
GE
, 
g_r_
) \

41 
	`mao
(
GLi
, 
g_li_
) \

42 
	`mao
(
GSLi
, 
g_i_
) \

43 
	`mao
(
GPSc
, 
g_n_ec_
) \

44 
	`mao
(
GD
, 
g_d_o
) \

45 
	`mao
(
GTim
, 
g_tim_deroy
) \

46 
	`mao
(
GKeyFe
, 
g_key_fe_
)

	)

48 
	#WTF_DEFINE_GPTR_DELETER
(
tyName
, 
dFunc
) \

49 
me
<> 
GPD
<
tyName
> \

51 
	`ݔ
((
tyName
* 
r
) const \

53 i(
r
) \

54 
	`dFunc
(
r
); \

56 };

	)

58 
FOR_EACH_GLIB_DELETER
(
WTF_DEFINE_GPTR_DELETER
)

59 #unde
FOR_EACH_GLIB_DELETER


61 
	gme
 <
tyme
 
	gT
> cs
	cGUniqueOutP
 {

62 
WTF_MAKE_NONCOPYABLE
(
GUniqueOutP
);

63 
	gpublic
:

64 
GUniqueOutP
()

65 : 
m_r
(
nuαr
)

69 ~
GUniqueOutP
()

71 
t
();

74 
	gT
*& 
outP
()

76 
t
();

77  
	gm_r
;

80 
	gGUniqueP
<
	gT
> 
a
()

82 
	gGUniqueP
<
	gT
> 
r
(
m_r
);

83 
	gm_r
 = 
nuαr
;

84  
	gr
;

87 
	gT
& 
	gݔ
*() const

89 
ASSERT
(
m_r
);

90  *
	gm_r
;

93 
T
* 
	gݔ
->() const

95 
ASSERT
(
m_r
);

96  
	gm_r
;

99 
T
* 
g
(cڡ {  
	gm_r
; }

101 
bo
 
	gݔ
!(cڡ {  !
	gm_r
; }

104 
T
* 
	tGUniqueOutP
::*
	tUnecifdBoTy
;

105 
ݔ
 
UnecifdBoTy
(cڡ {  
	gm_r
 ? &
	gGUniqueOutP
::
m_r
 : 0; }

107 
	give
:

108 
t
()

110 i(
m_r
) {

111 
GUniqueP
<
T
> 
deP
(
m_r
);

112 
	gm_r
 = 
nuαr
;

116 
T
* 
	gm_r
;

121 
usg
 
	gWTF
::
GUniqueP
;

122 
usg
 
	gWTF
::
GUniqueOutP
;

	@gobject/GlibUtilities.cpp

20 
	~"cfig.h
"

21 
	~"GlibUts.h
"

23 #i
OS
(
WINDOWS
)

24 
	~<wdows.h
>

25 
	~<wtf/xt/WTFSg.h
>

27 
	~<lims.h
>

28 
	~<unid.h
>

31 #i
OS
(
LINUX
)

32 
CSg
 
	$gCutExecubPh
()

34 
adLkBufr
[
PATH_MAX
];

35 
ssize_t
 
su
 = 
	`adlk
("/oc/lf/exe", 
adLkBufr
, 
PATH_MAX
);

36 i(
su
 == -1)

37  
	`CSg
();

38  
	`CSg
(
adLkBufr
, 
su
);

39 
	}
}

40 #i
OS
(
HURD
)

41 
CSg
 
	$gCutExecubPh
()

43  
	`CSg
();

44 
	}
}

45 #i
OS
(
UNIX
)

46 
CSg
 
	$gCutExecubPh
()

48 
adLkBufr
[
PATH_MAX
];

49 
ssize_t
 
su
 = 
	`adlk
("/oc/curoc/fe", 
adLkBufr
, 
PATH_MAX
);

50 i(
su
 == -1)

51  
	`CSg
();

52  
	`CSg
(
adLkBufr
, 
su
);

53 
	}
}

54 #i
OS
(
WINDOWS
)

55 
CSg
 
	$gCutExecubPh
()

57 
WCHAR
 
bufr
[
MAX_PATH
];

58 
DWORD
 
ngth
 = 
	`GModuFeNameW
(0, 
bufr
, 
MAX_PATH
);

59 i(!
ngth
 || (ngth =
MAX_PATH
 && 
	`GLaE
(=
ERROR_INSUFFICIENT_BUFFER
))

60  
	`CSg
();

62 
Sg
 
	`th
(
bufr
, 
ngth
);

63  
th
.
	`utf8
();

64 
	}
}

	@gobject/GlibUtilities.h

20 #ide
GlibUts_h


21 
	#GlibUts_h


	)

23 
	~<wtf/Asis.h
>

24 
	~<wtf/xt/CSg.h
>

26 
CSg
 
gCutExecubPh
();

	@gtk/MainThreadGtk.cpp

30 
	~"cfig.h
"

31 
	~"MaThad.h
"

33 
	~<wtf/gobje/GMaLoSour.h
>

35 
mea
 
	gWTF
 {

37 
lizeMaThadPtfm
()

41 
scheduDichFunisOnMaThad
()

43 
	gGMaLoSour
::
scheduAndDeOnDeroy
("[WebK] dichFunisFromMaThad", 
d
::
funi
<()>(
dichFunisFromMaThad
));

	@gtk/RunLoopGtk.cpp

27 
	~"cfig.h
"

28 
	~"RunLo.h
"

30 
	~<glib.h
>

31 
	~<wtf/MaThad.h
>

33 
mea
 
	gWTF
 {

35 
	gRunLo
::
RunLo
()

38 
m_runLoCڋxt
 = 
isMaThad
(? 
g_ma_cڋxt_deu
(: 
adtGRef
(
g_ma_cڋxt_w
());

39 
ASSERT
(
m_runLoCڋxt
);

40 
	gGRefP
<
	gGMaLo
> 
	grmoLo
 = 
adtGRef
(
g_ma_lo_w
(
m_runLoCڋxt
.
g
(), 
FALSE
));

41 
ASSERT
(
rmoLo
);

42 
	gm_runLoMaLos
.
nd
(
rmoLo
);

45 
	gRunLo
::~
RunLo
()

47 
i
 = 
m_runLoMaLos
.
size
(- 1; 
	gi
 >= 0; --i) {

48 i(!
g_ma_lo_is_rug
(
m_runLoMaLos
[
i
].
g
()))

50 
g_ma_lo_qu
(
m_runLoMaLos
[
i
].
g
());

54 
	gRunLo
::
run
()

56 
RunLo
& 
maRunLo
 = RunLo::
cut
();

57 
GMaLo
* 
	grmoLo
 = 
maRunLo
.
rmoLo
();

58 i(!
g_ma_lo_is_rug
(
rmoLo
)) {

59 
g_ma_lo_run
(
rmoLo
);

64 
GMaLo
* 
	gáedMaLo
 = 
g_ma_lo_w
(0, 
FALSE
);

65 
	gmaRunLo
.
pushNeedMaLo
(
áedMaLo
);

66 
g_ma_lo_run
(
áedMaLo
);

67 
	gmaRunLo
.
pNeedMaLo
();

70 
GMaLo
* 
	gRunLo
::
rmoLo
()

73 
ASSERT
(!
m_runLoMaLos
.
isEmy
());

74  
	gm_runLoMaLos
[0].
g
();

77 
	gRunLo
::
pushNeedMaLo
(
GMaLo
* 
áedLo
)

80 
ASSERT
(!
m_runLoMaLos
.
isEmy
());

81 
	gm_runLoMaLos
.
nd
(
adtGRef
(
áedLo
));

84 
	gRunLo
::
pNeedMaLo
()

87 
ASSERT
(!
m_runLoMaLos
.
isEmy
());

88 
	gm_runLoMaLos
.
moveLa
();

91 
	gRunLo
::

()

94 
ASSERT
(!
m_runLoMaLos
.
isEmy
());

95 
	gGRefP
<
	gGMaLo
> 
	gϡMaLo
 = 
m_runLoMaLos
.
ϡ
();

96 i(
g_ma_lo_is_rug
(
ϡMaLo
.
g
()))

97 
g_ma_lo_qu
(
ϡMaLo
.
g
());

100 
	gRunLo
::
wakeUp
()

102 
RefP
<
RunLo
> 
runLo
(
this
);

103 
	gGMaLoSour
::
scheduAndDeOnDeroy
("[WebK] RunLo wk", 
d
::
funi
<()>([
runLo
] {

104 
runLo
->
rfmWk
();

105 }), 
G_PRIORITY_DEFAULT
, 
nuαr
, 
m_runLoCڋxt
.
g
());

106 
g_ma_cڋxt_wakeup
(
m_runLoCڋxt
.
g
());

109 
	gRunLo
::
TimBa
::TimBa(
RunLo
& 
runLo
)

110 : 
m_runLo
(
runLo
)

114 
RunLo
::
TimBa
::~TimerBase()

116 

();

119 
	gRunLo
::
TimBa
::
t
(
feIv
, 
bo
 

)

121 
	gm_timSour
.
scheduADay
("[WebK] RunLo::Tim", 
d
::
funi
<
bo
 ()>([
this
, 

] { 
fed
(); epeat; }),

122 
d
::
chro
::
duti_
<d::chro::
mlicds
>(d::chro::
duti
<>(
feIv
)), 
G_PRIORITY_DEFAULT
, 
nuαr
, 
m_runLo
.
m_runLoCڋxt
.
g
());

125 
	gRunLo
::
TimBa
::

()

127 
m_timSour
.
nl
();

130 
bo
 
	gRunLo
::
TimBa
::
isAive
() const

132  
m_timSour
.
isSchedud
();

	@ios/WebCoreThread.cpp

26 
	~"cfig.h
"

27 
	~"WebCeThad.h
"

29 #i
USE
(
WEB_THREAD
)

30 
WTF_EXPORT_PRIVATE
 
	$bo
 (*
WebCeWebThadIsLockedOrDibd
)();

31 
WTF_EXPORT_PRIVATE
 
	$bo
 (*
WebCeWebThadIsEbd
)();

32 
WTF_EXPORT_PRIVATE
 (*
WebCeWebThadRun
)((^
block
)());

33 
WTF_EXPORT_PRIVATE
 (*
WebCeWebThadRunSync
)((^
block
)());

	@ios/WebCoreThread.h

28 #ide
WTF_WebCeThad_h


29 
	#WTF_WebCeThad_h


	)

31 #ifde
__lulus


35 
bo
 (*
WebCeWebThadIsLockedOrDibd
)();

36 
bo
 (*
WebCeWebThadIsEbd
)();

37 (*
WebCeWebThadRun
)((^
block
)());

38 (*
WebCeWebThadRunSync
)((^
block
)());

40 #ifde
__lulus


	@mbmalloc.cpp

26 
	~"cfig.h
"

27 
	~"FaMloc.h
"

29 
	#EXPORT
 
	`__ibu__
((
	`visiby
("deu")))

	)

33 
EXPORT
 * 
mbmloc
(
size_t
);

34 
EXPORT
 
mb
(*, 
size_t
);

35 
EXPORT
 * 
mbloc
(*, 
size_t
, size_t);

36 
EXPORT
 
mbsvge
();

38 * 
mbmloc
(
size_t
 
size
)

40  
WTF
::
Mloc
(
size
);

43 
mb
(* 
p
, 
size_t
)

45  
WTF
::
Fe
(
p
);

48 * 
mbloc
(* 
p
, 
size_t
, size_
size
)

50  
WTF
::
Roc
(
p
, 
size
);

53 
mbsvge
()

55 
WTF
::
aFaMlocFeMemy
();

	@text/ASCIIFastPath.h

22 #ide
ASCIIFaPh_h


23 
	#ASCIIFaPh_h


	)

25 
	~<dt.h
>

26 
	~<unicode/utys.h
>

27 
	~<wtf/StdLibExas.h
>

28 
	~<wtf/xt/LCh.h
>

30 #i
OS
(
DARWIN
&& (
CPU
(
X86
|| CPU(
X86_64
))

31 
	~<emm.h
>

34 
mea
 
	gWTF
 {

36 
	gme
 <
u_t
 
	gmask
>

37 
le
 
bo
 
isAligdTo
(cڡ * 
por
)

39  !(
	gt_
<
	gu_t
>(
	gpor
& 
	gmask
);

44 
u_t
 
	tMacheWd
;

45 cڡ 
u_t
 
	gmacheWdAlignmtMask
 = (
MacheWd
) - 1;

47 
le
 
bo
 
isAligdToMacheWd
(cڡ * 
por
)

49  
	gisAligdTo
<
	gmacheWdAlignmtMask
>(
	gpor
);

52 
	gme
<
tyme
 
	gT
> 
le
 
T
* 
ignToMacheWd
(T* 
por
)

54  
	gt_
<
	gT
*>et_<
	gu_t
>(
	gpor
& ~
	gmacheWdAlignmtMask
);

57 
	gme
<
size_t
 
	gsize
, 
tyme
 
	gChaTy
> 
	gNASCIIMask
;

58 
	gme
<> 
	gNASCIIMask
<4, 
	gUCh
> {

59 
le
 
ut32_t
 
vue
() {  0xFF80FF80U; }

61 
	gme
<> 
	gNASCIIMask
<4, 
	gLCh
> {

62 
le
 
ut32_t
 
vue
() {  0x80808080U; }

64 
	gme
<> 
	gNASCIIMask
<8, 
	gUCh
> {

65 
le
 
ut64_t
 
vue
() {  0xFF80FF80FF80FF80ULL; }

67 
	gme
<> 
	gNASCIIMask
<8, 
	gLCh
> {

68 
le
 
ut64_t
 
vue
() {  0x8080808080808080ULL; }

72 
	gme
<
tyme
 
	gChaTy
>

73 
le
 
bo
 
isAASCII
(
MacheWd
 
wd
)

75  !(
	gwd
 & 
	gNASCIIMask
<(
	gMacheWd
), 
	gChaTy
>::
vue
());

80 
	gme
<
tyme
 
	gChaTy
>

81 
le
 
bo
 
chasAAASCII
(cڡ 
ChaTy
* 
chas
, 
size_t
 
ngth
)

83 
MacheWd
 
	glChBs
 = 0;

84 cڡ 
ChaTy
* 
	gd
 = 
chas
 + 
ngth
;

87 !
isAligdToMacheWd
(
chas
&& 
	gchas
 !
d
) {

88 
lChBs
 |*
chas
;

89 ++
	gchas
;

93 cڡ 
ChaTy
* 
	gwdEnd
 = 
ignToMacheWd
(
d
);

94 cڡ 
size_t
 
	gloInemt
 = (
MacheWd
/ (
ChaTy
);

95 
	gchas
 < 
	gwdEnd
) {

96 
	glChBs
 |*(
t__r
<cڡ 
MacheWd
*>(
chas
));

97 
	gchas
 +
loInemt
;

101 
	gchas
 !
d
) {

102 
lChBs
 |*
chas
;

103 ++
	gchas
;

106 
MacheWd
 
	gnASCIIBMask
 = 
NASCIIMask
<(MacheWd), 
	gChaTy
>::
vue
();

107  !(
	glChBs
 & 
	gnASCIIBMask
);

110 
le
 
cyLChsFromUChSour
(
LCh
* 
dei
, cڡ 
UCh
* 
sour
, 
size_t
 
ngth
)

112 #i
OS
(
DARWIN
&& (
CPU
(
X86
|| CPU(
X86_64
))

113 cڡ 
u_t
 
	gmemyAcssSize
 = 16;

114 cڡ 
u_t
 
	gmemyAcssMask
 = 
memyAcssSize
 - 1;

116 
size_t
 
	gi
 = 0;

117 ;
	gi
 < 
	gngth
 && !
	gisAligdTo
<
	gmemyAcssMask
>(&
	gsour
[
i
]); ++i) {

118 
ASSERT
(!(
sour
[
i
] & 0xff00));

119 
	gdei
[
i
] = 
ic_
<
LCh
>(
sour
[i]);

122 cڡ 
u_t
 
	gsourLdSize
 = 32;

123 cڡ 
size_t
 
	guchsPLo
 = 
sourLdSize
 / (
UCh
);

124 i(
	gngth
 > 
	guchsPLo
) {

125 cڡ 
size_t
 
	gdLgth
 = 
ngth
 - 
uchsPLo
 + 1;

126 ; 
	gi
 < 
	gdLgth
; i +
uchsPLo
) {

127 #ide
NDEBUG


128 
checkIndex
 = 0; 
	gcheckIndex
 < 
	guchsPLo
; ++checkIndex)

129 
ASSERT
(!(
sour
[
i
+
checkIndex
] & 0xff00));

131 
__m128i
 
	gf8UChs
 = 
_mm_ld_si128
(
t_
<cڡ __m128i*>(&
sour
[
i
]));

132 
__m128i
 
	gcd8UChs
 = 
_mm_ld_si128
(
t_
<cڡ __m128i*>(&
sour
[
i
+8]));

133 
__m128i
 
	gckedChs
 = 
_mm_ckus_i16
(
f8UChs
, 
cd8UChs
);

134 
_mm_eu_si128
(
t_
<
__m128i
*>(&
dei
[
i
]), 
ckedChs
);

138 ; 
	gi
 < 
	gngth
; ++i) {

139 
ASSERT
(!(
sour
[
i
] & 0xff00));

140 
	gdei
[
i
] = 
ic_
<
LCh
>(
sour
[i]);

142 #i
COMPILER
(
GCC
&& 
CPU
(
ARM64
&& 
defed
(
NDEBUG
)

143 cڡ 
LCh
* cڡ 
	gd
 = 
dei
 + 
ngth
;

144 cڡ 
u_t
 
	gmemyAcssSize
 = 16;

146 i(
	gngth
 >
memyAcssSize
) {

147 cڡ 
u_t
 
memyAcssMask
 = 
memyAcssSize
 - 1;

150 cڡ 
u_t
 
	gngthLe
 = 
d
 - 
dei
;

151 cڡ 
LCh
* cڡ 
	gsimdEnd
 = 
dei
 + (
ngthLe
 & ~
memyAcssMask
);

153 
asm
("ld2 { v0.16B, v1.16B }, [%[SOURCE]], #32\n\t"

155 : [
SOURCE
]"+r" (
sour
), [
DESTINATION
]"+r" (
dei
)

158 } 
	gdei
 !
simdEnd
);

161 
	gdei
 !
d
)

162 *
dei
++ = 
ic_
<
LCh
>(*
sour
++);

163 #i
COMPILER
(
GCC
&& 
CPU
(
ARM_NEON
&& !(CPU(
BIG_ENDIAN
|| CPU(
MIDDLE_ENDIAN
)&& 
defed
(
NDEBUG
)

164 cڡ 
LCh
* cڡ 
	gd
 = 
dei
 + 
ngth
;

165 cڡ 
u_t
 
	gmemyAcssSize
 = 8;

167 i(
	gngth
 >(2 * 
memyAcssSize
) - 1) {

169 cڡ 
u_t
 
memyAcssMask
 = 
memyAcssSize
 - 1;

170 !
	gisAligdTo
<
	gmemyAcssMask
>(
	gdei
))

171 *
	gdei
++ = 
ic_
<
LCh
>(*
sour
++);

174 cڡ 
u_t
 
	gngthLe
 = 
d
 - 
dei
;

175 cڡ 
LCh
* cڡ 
	gsimdEnd
 = 
d
 - (
ngthLe
 % 
memyAcssSize
);

177 
asm
("vld2.8 { d0-d1 }, [%[SOURCE]] !\n\t"

179 : [
SOURCE
]"+r" (
sour
), [
DESTINATION
]"+r" (
dei
)

182 } 
	gdei
 !
simdEnd
);

185 
	gdei
 !
d
)

186 *
dei
++ = 
ic_
<
LCh
>(*
sour
++);

188 
size_t
 
	gi
 = 0; i < 
	gngth
; ++i) {

189 
ASSERT
(!(
sour
[
i
] & 0xff00));

190 
	gdei
[
i
] = 
ic_
<
LCh
>(
sour
[i]);

	@text/AtomicString.cpp

23 
	~"cfig.h
"

24 
	~"AtomicSg.h
"

26 
	~"AtomicSgTab.h
"

27 
	~"HashS.h
"

28 
	~"IegToSgCvsi.h
"

29 
	~"SgHash.h
"

30 
	~"Thadg.h
"

31 
	~"WTFThadDa.h
"

32 
	~"dt.h
"

33 
	~<wtf/unicode/UTF8.h
>

36 #i
USE
(
WEB_THREAD
|| 
ENABLE
(
VMOLAB
)

37 
	~"TCSpLock.h
"

40 
mea
 
	gWTF
 {

42 
usg
 
mea
 
	gUnicode
;

44 
ic_as
((
AtomicSg
=(
Sg
), "AtomicStringnd String must be same size!");

47 #i
USE
(
WEB_THREAD
|| 
ENABLE
(
VMOLAB
)

49 as
	cAtomicSgTabLock
 : 
public
 
SpLockHd
 {

50 
WTF_MAKE_NONCOPYABLE
(
AtomicSgTabLock
);

52 
SpLock
 
	gs_rgTabLock
;

53 
	gpublic
:

54 
AtomicSgTabLock
()

55 : 
SpLockHd
(&
s_rgTabLock
)

60 
SpLock
 
	gAtomicSgTabLock
::
s_rgTabLock
 = 
SPINLOCK_INITIALIZER
;

64 as
	cAtomicSgTabLock
 {

65 
WTF_MAKE_NONCOPYABLE
(
AtomicSgTabLock
);

66 
	gpublic
:

67 
AtomicSgTabLock
() { }

72 
ALWAYS_INLINE
 
	gHashS
<
	gSgIm
*>& 
	$rgTab
()

74  
	`wtfThadDa
().
	`omicSgTab
()->
	`b
();

75 
	}
}

77 
	gme
<
tyme
 
	gT
,ym
	gHashTn
>

78 
le
 
	gPassRefP
<
	gSgIm
> 
	$addToSgTab
(cڡ 
T
& 
vue
)

80 
AtomicSgTabLock
 
lock
;

82 
HashS
<
SgIm
*>::
AddResu
 
addResu
 = 
	`rgTab
().
add
<
HashTn
>(
vue
);

86  
addResu
.
isNewEry
 ? 
	`adtRef
(*addResu.

) : *addResult.iterator;

87 
	}
}

89 
	sCSgTn
 {

90 
hash
(cڡ 
LCh
* 
c
)

92  
	gSgHash
::
compuHashAndMaskT8Bs
(
c
);

95 
le
 
bo
 
equ
(
SgIm
* 
r
, cڡ 
LCh
* 
s
)

97  
	gWTF
::
equ
(
r
, 
s
);

100 
e
(
SgIm
*& 
loti
, cڡ 
LCh
* cڡ& 
c
, 
hash
)

102 
	gloti
 = &
SgIm
::

(
c
).
akRef
();

103 
	gloti
->
tHash
(
hash
);

104 
	gloti
->
tIsAtomic
(
ue
);

108 
	gPassRefP
<
	gSgIm
> 
	gAtomicSg
::
	$add
(cڡ 
LCh
* 
c
)

110 i(!
c
)

112 i(!*
c
)

113  
SgIm
::
	`emy
();

115  
addToSgTab
<cڡ 
LCh
*, 
CSgTn
>(
c
);

116 
	}
}

118 
	gme
<
tyme
 
	gChaTy
>

119 
	sHashTnChBufr
 {

120 cڡ 
ChaTy
* 
	gs
;

121 
	gngth
;

124 
	gHashTnChBufr
<
	tUCh
> 
	tUChBufr
;

125 
	sUChBufrTn
 {

126 
hash
(cڡ 
UChBufr
& 
buf
)

128  
	gSgHash
::
compuHashAndMaskT8Bs
(
buf
.
s
, buf.
ngth
);

131 
bo
 
equ
(
SgIm
* cڡ& 
r
, cڡ 
UChBufr
& 
buf
)

133  
	gWTF
::
equ
(
r
, 
buf
.
s
, buf.
ngth
);

136 
e
(
SgIm
*& 
loti
, cڡ 
UChBufr
& 
buf
, 
hash
)

138 
	gloti
 = &
SgIm
::
8BIfPossib
(
buf
.
s
, buf.
ngth
).
akRef
();

139 
	gloti
->
tHash
(
hash
);

140 
	gloti
->
tIsAtomic
(
ue
);

144 
	gme
<
tyme
 
	gChaTy
>

145 
	sHashAndChas
 {

146 
	ghash
;

147 cڡ 
ChaTy
* 
	gchas
;

148 
	gngth
;

151 
	gme
<
tyme
 
	gChaTy
>

152 
	sHashAndChasTn
 {

153 
hash
(cڡ 
HashAndChas
<
ChaTy
>& 
bufr
)

155 
ASSERT
(
bufr
.
hash
 =
SgHash
::
compuHashAndMaskT8Bs
(bufr.
chas
, bufr.
ngth
));

156  
	gbufr
.
	ghash
;

159 
bo
 
equ
(
SgIm
* cڡ& 
rg
, cڡ 
HashAndChas
<
ChaTy
>& 
bufr
)

161  
	gWTF
::
equ
(
rg
, 
bufr
.
chas
, bufr.
ngth
);

164 
e
(
SgIm
*& 
loti
, cڡ 
HashAndChas
<
ChaTy
>& 
bufr
, 
hash
)

166 
	gloti
 = &
SgIm
::

(
bufr
.
chas
, bufr.
ngth
).
akRef
();

167 
	gloti
->
tHash
(
hash
);

168 
	gloti
->
tIsAtomic
(
ue
);

172 
	sHashAndUTF8Chas
 {

173 
	ghash
;

174 cڡ * 
	gchas
;

175 
	gngth
;

176 
	gutf16Lgth
;

179 
	sHashAndUTF8ChasTn
 {

180 
hash
(cڡ 
HashAndUTF8Chas
& 
bufr
)

182  
	gbufr
.
	ghash
;

185 
bo
 
equ
(
SgIm
* cڡ& 
rg
, cڡ 
HashAndUTF8Chas
& 
bufr
)

187 i(
	gbufr
.
	gutf16Lgth
 !
rg
->
ngth
())

188  
l
;

191 i(
	gbufr
.
	gutf16Lgth
 !
bufr
.
ngth
) {

192 i(
rg
->
is8B
())

193  
equL1WhUTF8
(
rg
->
chas8
(), 
bufr
.
chas
, bufr.cha+ bufr.
ngth
);

195  
equUTF16WhUTF8
(
rg
->
chas16
(), 
bufr
.
chas
, bufr.cha+ bufr.
ngth
);

198 i(
	grg
->
is8B
()) {

199 cڡ 
LCh
* 
	grgChas
 = 
rg
->
chas8
();

201 
	gi
 = 0; i < 
	gbufr
.
	gngth
; ++i) {

202 
ASSERT
(
isASCII
(
bufr
.
chas
[
i
]));

203 i(
	grgChas
[
i
] !
bufr
.
chas
[i])

204  
l
;

207  
	gue
;

210 cڡ 
UCh
* 
	grgChas
 = 
rg
->
chas16
();

212 
	gi
 = 0; i < 
	gbufr
.
	gngth
; ++i) {

213 
ASSERT
(
isASCII
(
bufr
.
chas
[
i
]));

214 i(
	grgChas
[
i
] !
bufr
.
chas
[i])

215  
l
;

218  
	gue
;

221 
e
(
SgIm
*& 
loti
, cڡ 
HashAndUTF8Chas
& 
bufr
, 
hash
)

223 
UCh
* 
	grg
;

224 
	gRefP
<
	gSgIm
> 
	gwSg
 = 
SgIm
::
Unlized
(
bufr
.
utf16Lgth
, 
rg
);

226 
bo
 
	gisAASCII
;

227 cڡ * 
	gsour
 = 
bufr
.
chas
;

228 i(
cvtUTF8ToUTF16
(&
sour
, sour + 
bufr
.
ngth
, &
rg
,g + bufr.
utf16Lgth
, &
isAASCII
!
cvsiOK
)

229 
ASSERT_NOT_REACHED
();

231 i(
	gisAASCII
)

232 
	gwSg
 = 
SgIm
::

(
bufr
.
chas
, bufr.
ngth
);

234 
	gloti
 = 
wSg
.
a
().
akRef
();

235 
	gloti
->
tHash
(
hash
);

236 
	gloti
->
tIsAtomic
(
ue
);

240 
	gPassRefP
<
	gSgIm
> 
	gAtomicSg
::
	$add
(cڡ 
UCh
* 
s
, 
ngth
)

242 i(!
s
)

245 i(!
ngth
)

246  
SgIm
::
	`emy
();

248 
UChBufr
 
bufr
 = { 
s
, 
ngth
 };

249  
addToSgTab
<
UChBufr
, 
UChBufrTn
>(
bufr
);

250 
	}
}

252 
	gPassRefP
<
	gSgIm
> 
	gAtomicSg
::
	$add
(cڡ 
UCh
* 
s
, 
ngth
, 
exigHash
)

254 
	`ASSERT
(
s
);

255 
	`ASSERT
(
exigHash
);

257 i(!
ngth
)

258  
SgIm
::
	`emy
();

260 
HashAndChas
<
UCh
> 
bufr
 = { 
exigHash
, 
s
, 
ngth
 };

261  
addToSgTab
<
HashAndChas
<
UCh
>, 
HashAndChasTn
<UCh>>(
bufr
);

262 
	}
}

264 
	gPassRefP
<
	gSgIm
> 
	gAtomicSg
::
	$add
(cڡ 
UCh
* 
s
)

266 i(!
s
)

269 
ngth
 = 0;

270 
s
[
ngth
] !
	`UCh
(0))

271 ++
ngth
;

273 i(!
ngth
)

274  
SgIm
::
	`emy
();

276 
UChBufr
 
bufr
 = { 
s
, 
ngth
 };

277  
addToSgTab
<
UChBufr
, 
UChBufrTn
>(
bufr
);

278 
	}
}

280 
	sSubrgLoti
 {

281 
SgIm
* 
	gbaSg
;

282 
	gt
;

283 
	gngth
;

286 
	sSubrgTn
 {

287 
e
(
SgIm
*& 
loti
, cڡ 
SubrgLoti
& 
bufr
, 
hash
)

289 
	gloti
 = &
SgIm
::
SubrgShgIm
(
bufr
.
baSg
, bufr.
t
, bufr.
ngth
).
akRef
();

290 
	gloti
->
tHash
(
hash
);

291 
	gloti
->
tIsAtomic
(
ue
);

295 
	gSubrgTn8
 : 
SubrgTn
 {

296 
hash
(cڡ 
SubrgLoti
& 
bufr
)

298  
SgHash
::
compuHashAndMaskT8Bs
(
bufr
.
baSg
->
chas8
(+ bufr.
t
, bufr.
ngth
);

301 
bo
 
equ
(
SgIm
* cڡ& 
rg
, cڡ 
SubrgLoti
& 
bufr
)

303  
	gWTF
::
equ
(
rg
, 
bufr
.
baSg
->
chas8
(+ bufr.
t
, bufr.
ngth
);

307 
	gSubrgTn16
 : 
SubrgTn
 {

308 
hash
(cڡ 
SubrgLoti
& 
bufr
)

310  
SgHash
::
compuHashAndMaskT8Bs
(
bufr
.
baSg
->
chas16
(+ bufr.
t
, bufr.
ngth
);

313 
bo
 
equ
(
SgIm
* cڡ& 
rg
, cڡ 
SubrgLoti
& 
bufr
)

315  
	gWTF
::
equ
(
rg
, 
bufr
.
baSg
->
chas16
(+ bufr.
t
, bufr.
ngth
);

319 
	gPassRefP
<
	gSgIm
> 
	gAtomicSg
::
	$add
(
SgIm
* 
baSg
, 
t
, 
ngth
)

321 i(!
baSg
)

322  
nuαr
;

324 i(!
ngth
 || 
t
 >
baSg
->
	`ngth
())

325  
SgIm
::
	`emy
();

327 
maxLgth
 = 
baSg
->
	`ngth
(- 
t
;

328 i(
ngth
 >
maxLgth
) {

329 i(!
t
)

330  
	`add
(
baSg
);

331 
ngth
 = 
maxLgth
;

334 
SubrgLoti
 
bufr
 = { 
baSg
, 
t
, 
ngth
 };

335 i(
baSg
->
	`is8B
())

336  
addToSgTab
<
SubrgLoti
, 
SubrgTn8
>(
bufr
);

337  
addToSgTab
<
SubrgLoti
, 
SubrgTn16
>(
bufr
);

338 
	}
}

340 
	gHashTnChBufr
<
	tLCh
> 
	tLChBufr
;

341 
	sLChBufrTn
 {

342 
hash
(cڡ 
LChBufr
& 
buf
)

344  
	gSgHash
::
compuHashAndMaskT8Bs
(
buf
.
s
, buf.
ngth
);

347 
bo
 
equ
(
SgIm
* cڡ& 
r
, cڡ 
LChBufr
& 
buf
)

349  
	gWTF
::
equ
(
r
, 
buf
.
s
, buf.
ngth
);

352 
e
(
SgIm
*& 
loti
, cڡ 
LChBufr
& 
buf
, 
hash
)

354 
	gloti
 = &
SgIm
::

(
buf
.
s
, buf.
ngth
).
akRef
();

355 
	gloti
->
tHash
(
hash
);

356 
	gloti
->
tIsAtomic
(
ue
);

360 
	gHashTnChBufr
<> 
	tChBufr
;

361 
	sChBufrFromLDaTn
 {

362 
hash
(cڡ 
ChBufr
& 
buf
)

364  
	gSgHash
::
compuHashAndMaskT8Bs
(
t_
<cڡ 
LCh
*>(
buf
.
s
), buf.
ngth
);

367 
bo
 
equ
(
SgIm
* cڡ& 
r
, cڡ 
ChBufr
& 
buf
)

369  
	gWTF
::
equ
(
r
, 
buf
.
s
, buf.
ngth
);

372 
e
(
SgIm
*& 
loti
, cڡ 
ChBufr
& 
buf
, 
hash
)

374 
	gloti
 = &
SgIm
::
FromL
(
buf
.
s
, buf.
ngth
).
akRef
();

375 
	gloti
->
tHash
(
hash
);

376 
	gloti
->
tIsAtomic
(
ue
);

380 
	gPassRefP
<
	gSgIm
> 
	gAtomicSg
::
	$add
(cڡ 
LCh
* 
s
, 
ngth
)

382 i(!
s
)

385 i(!
ngth
)

386  
SgIm
::
	`emy
();

388 
LChBufr
 
bufr
 = { 
s
, 
ngth
 };

389  
addToSgTab
<
LChBufr
, 
LChBufrTn
>(
bufr
);

390 
	}
}

392 #i
	$ENABLE
(
VMOLAB
)

393 
PassRefP
<
SgIm
> 
AtomicSg
::
	$addSlowCa
(
AtomicSgTab
& 
rgTab
, cڡ 
LCh
* 
c
)

395 i(!
c
)

397 i(!*
c
)

398  
SgIm
::
	`emy
();

401 
AtomicSgTabLock
 
lock
;

402 
HashS
<
SgIm
*>::
AddResu
 
addResu
 = 
rgTab
.
	`b
().
add
<
CSgTn
>(
c
);

404  
addResu
.
isNewEry
 ? 
	`adtRef
(*addResu.

) : *addResult.iterator;

405 
	}
}

407 
	gPassRefP
<
	gSgIm
> 
	gAtomicSg
::
	$addSlowCa
(
AtomicSgTab
& 
rgTab
, cڡ 
LCh
* 
s
, 
ngth
)

409 i(!
s
)

411 i(!
ngth
)

412  
SgIm
::
	`emy
();

414 
LChBufr
 
bufr
 = { 
s
, 
ngth
 };

416 
AtomicSgTabLock
 
lock
;

417 
HashS
<
SgIm
*>::
AddResu
 
addResu
 = 
rgTab
.
	`b
().
add
<
LChBufrTn
>(
bufr
);

419  
addResu
.
isNewEry
 ? 
	`adtRef
(*addResu.

) : *addResult.iterator;

420 
	}
}

422 
	gPassRefP
<
	gSgIm
> 
	gAtomicSg
::
	$addSlowCa
(
AtomicSgTab
& 
rgTab
, cڡ 
UCh
* 
s
, 
ngth
)

424 i(!
s
)

426 i(!
ngth
)

427  
SgIm
::
	`emy
();

429 
UChBufr
 
bufr
 = { 
s
, 
ngth
 };

431 
AtomicSgTabLock
 
lock
;

432 
HashS
<
SgIm
*>::
AddResu
 
addResu
 = 
rgTab
.
	`b
().
add
<
UChBufrTn
>(
bufr
);

434  
addResu
.
isNewEry
 ? 
	`adtRef
(*addResu.

) : *addResult.iterator;

435 
	}
}

437 
	gPassRefP
<
	gSgIm
> 
	gAtomicSg
::
	$addSlowCa
(
AtomicSgTab
& 
rgTab
, cڡ 
UCh
* 
s
)

439 i(!
s
)

442 
ngth
 = 0;

443 
s
[
ngth
] !
	`UCh
(0))

444 ++
ngth
;

446 i(!
ngth
)

447  
SgIm
::
	`emy
();

449 
UChBufr
 
bufr
 = { 
s
, 
ngth
 };

451 
AtomicSgTabLock
 
lock
;

452 
HashS
<
SgIm
*>::
AddResu
 
addResu
 = 
rgTab
.
	`b
().
add
<
UChBufrTn
>(
bufr
);

454  
addResu
.
isNewEry
 ? 
	`adtRef
(*addResu.

) : *addResult.iterator;

455 
	}
}

458 
	gPassRefP
<
	gSgIm
> 
	gAtomicSg
::
	$addFromLDa
(cڡ * 
chas
, 
ngth
)

460 
	`ASSERT
(
chas
);

461 
	`ASSERT
(
ngth
);

463 
ChBufr
 
bufr
 = { 
chas
, 
ngth
 };

464  
addToSgTab
<
ChBufr
, 
ChBufrFromLDaTn
>(
bufr
);

465 
	}
}

467 
	gPassRefP
<
	gSgIm
> 
	gAtomicSg
::
	$addSlowCa
(
SgIm
& 
rg
)

469 i(!
rg
.
	`ngth
())

470  
SgIm
::
	`emy
();

472 
	`ASSERT_WITH_MESSAGE
(!
rg
.
	`isAtomic
(), "AtomicString shouldot hithe slow case ifhe string islreadytomic.");

474 
AtomicSgTabLock
 
lock
;

475 aut
addResu
 = 
	`rgTab
().
	`add
(&
rg
);

477 i(
addResu
.
isNewEry
) {

478 
	`ASSERT
(*
addResu
.

 =&
rg
);

479 
rg
.
	`tIsAtomic
(
ue
);

482  *
addResu
.

;

483 
	}
}

485 
	gPassRefP
<
	gSgIm
> 
	gAtomicSg
::
	$addSlowCa
(
AtomicSgTab
& 
rgTab
, 
SgIm
& 
rg
)

487 i(!
rg
.
	`ngth
())

488  
SgIm
::
	`emy
();

490 
	`ASSERT_WITH_MESSAGE
(!
rg
.
	`isAtomic
(), "AtomicString shouldot hithe slow case ifhe string islreadytomic.");

492 
AtomicSgTabLock
 
lock
;

493 aut
addResu
 = 
rgTab
.
	`b
().
	`add
(&
rg
);

495 i(
addResu
.
isNewEry
) {

496 
	`ASSERT
(*
addResu
.

 =&
rg
);

497 
rg
.
	`tIsAtomic
(
ue
);

500  *
addResu
.

;

501 
	}
}

503 
	gAtomicSg
::
	$move
(
SgIm
* 
rg
)

505 
	`ASSERT
(
rg
->
	`isAtomic
());

506 
AtomicSgTabLock
 
lock
;

507 
HashS
<
SgIm
*>& 
omicSgTab
 = 
	`rgTab
();

508 
HashS
<
SgIm
*>::

 it = 
omicSgTab
.
	`fd
(
rg
);

509 
	`ASSERT_WITH_MESSAGE
(

 !
omicSgTab
.
	`d
(), "The string beingemoved istomic inhe stringable ofn otherhread!");

510 
omicSgTab
.
	`move
(

);

511 
	}
}

513 
AtomicSg
 
	gAtomicSg
::
	$low
() const

516 
SgIm
* 
im
 = 
this
->
	`im
();

517 i(
	`UNLIKELY
(!
im
))

518  
	`AtomicSg
();

520 
RefP
<
SgIm
> 
lowdSg
 = 
im
->
	`low
();

521 i(
	`LIKELY
(
lowdSg
 =
im
))

522  *
this
;

524 
AtomicSg
 
su
;

525 
su
.
m_rg
 = 
	`addSlowCa
(*
lowdSg
);

526  
su
;

527 
	}
}

529 
AtomicSg
 
	gAtomicSg
::
	$cvtToASCIILow
() const

531 
SgIm
* 
im
 = 
this
->
	`im
();

532 i(
	`UNLIKELY
(!
im
))

533  
	`AtomicSg
();

538 
ngth
;

539 cڡ 
lolBufrSize
 = 100;

540 i(
im
->
	`is8B
(&& (
ngth
 = im->
	`ngth
()<
lolBufrSize
) {

541 cڡ 
LCh
* 
chas
 = 
im
->
	`chas8
();

542 
瞚gIndex
;

543 
i
 = 0; i < 
ngth
; ++i) {

544 i(
	`UNLIKELY
(
	`isASCIIU
(
chas
[
i
]))) {

545 
瞚gIndex
 = 
i
;

546 
SlowPh
;

549  *
this
;

550 
SlowPh
:

551 
LCh
 
lolBufr
[
lolBufrSize
];

552 
i
 = 0; i < 
瞚gIndex
; ++i)

553 
lolBufr
[
i
] = 
chas
[i];

554 
i
 = 
瞚gIndex
; i < 
ngth
; ++i)

555 
lolBufr
[
i
] = 
	`toASCIILow
(
chas
[i]);

556  
	`AtomicSg
(
lolBufr
, 
ngth
);

559 
RefP
<
SgIm
> 
cvdSg
 = 
im
->
	`cvtToASCIILow
();

560 i(
	`LIKELY
(
cvdSg
 =
im
))

561  *
this
;

563 
AtomicSg
 
su
;

564 
su
.
m_rg
 = 
	`addSlowCa
(*
cvdSg
);

565  
su
;

566 
	}
}

568 
AtomicSgIm
* 
	gAtomicSg
::
	$fdSlowCa
(
SgIm
& 
rg
)

570 
	`ASSERT_WITH_MESSAGE
(!
rg
.
	`isAtomic
(), "AtomicStringImpls shouldeturn fromhe fast case.");

572 
AtomicSgTabLock
 
lock
;

573 
HashS
<
SgIm
*>& 
omicSgTab
 = 
	`rgTab
();

574 aut

 = 
omicSgTab
.
	`fd
(&
rg
);

575 i(

 !
omicSgTab
.
	`d
())

576  
ic_
<
AtomicSgIm
*>(*

);

577  
nuαr
;

578 
	}
}

580 
AtomicSg
 
	gAtomicSg
::
	$omUTF8Il
(cڡ * 
chasS
, cڡ * 
chasEnd
)

582 
HashAndUTF8Chas
 
bufr
;

583 
bufr
.
chas
 = 
chasS
;

584 
bufr
.
hash
 = 
	`lcuϋSgHashAndLgthFromUTF8MaskgT8Bs
(
chasS
, 
chasEnd
, bufr.
ngth
, bufr.
utf16Lgth
);

586 i(!
bufr
.
hash
)

587  
nuAtom
;

589 
AtomicSg
 
omicSg
;

590 
omicSg
.
m_rg
 = 
addToSgTab
<
HashAndUTF8Chas
, 
HashAndUTF8ChasTn
>(
bufr
);

591  
omicSg
;

592 
	}
}

594 
AtomicSg
 
	gAtomicSg
::
	$numb
(
numb
)

596  
numbToSgSigd
<
AtomicSg
>(
numb
);

597 
	}
}

599 
AtomicSg
 
	gAtomicSg
::
	$numb
(
numb
)

601  
numbToSgUnsigd
<
AtomicSg
>(
numb
);

602 
	}
}

604 
AtomicSg
 
	gAtomicSg
::
	$numb
(
numb
)

606 
NumbToSgBufr
 
bufr
;

607  
	`Sg
(
	`numbToFixedPcisiSg
(
numb
, 6, 
bufr
, 
ue
));

608 
	}
}

610 
AtomicSgIm
* 
	gAtomicSg
::
	$fd
(
LCh
* 
chas
, 
ngth
)

612 
AtomicSgTabLock
 
lock
;

613 auto& 
b
 = 
	`rgTab
();

615 
LChBufr
 
bufr
 = { 
chas
, 
ngth
 };

616 aut

 = 
b
.
fd
<
LChBufrTn
>(
bufr
);

617 i(

 !
b
.
	`d
())

618  
ic_
<
AtomicSgIm
*>(*

);

619  
nuαr
;

620 
	}
}

622 
AtomicSgIm
* 
	gAtomicSg
::
	$fd
(
UCh
* 
chas
, 
ngth
)

624 
AtomicSgTabLock
 
lock
;

625 auto& 
b
 = 
	`rgTab
();

627 
UChBufr
 
bufr
 = { 
chas
, 
ngth
 };

628 aut

 = 
b
.
fd
<
UChBufrTn
>(
bufr
);

629 i(

 !
b
.
	`d
())

630  
ic_
<
AtomicSgIm
*>(*

);

631  
nuαr
;

632 
	}
}

634 #i!
ASSERT_DISABLED


635 
bo
 
	gAtomicSg
::
	$isInAtomicSgTab
(
SgIm
* 
rg
)

637 
AtomicSgTabLock
 
lock
;

638  
	`rgTab
().
	`cڏs
(
rg
);

639 
	}
}

641 #i
	$ENABLE
(
VMOLAB
)

642 
bo
 
AtomicSg
::
	$isInSgProvidTab
(
AtomicSgTab
& 
rgTab
, 
SgIm
* 
rg
)

644 
AtomicSgTabLock
 
lock
;

645  
rgTab
.
	`b
().
	`cڏs
(
rg
);

646 
	}
}

650 #ide
NDEBUG


651 
	gAtomicSg
::
	$show
() const

653 
m_rg
.
	`show
();

654 
	}
}

	@text/AtomicString.h

21 #ide
AtomicSg_h


22 
	#AtomicSg_h


	)

24 
	~<uty
>

25 
	~<wtf/xt/AtomicSgIm.h
>

26 
	~<wtf/xt/WTFSg.h
>

30 #ifde
NO_IMPLICIT_ATOMICSTRING


31 
	#ATOMICSTRING_CONVERSION
 
exic


	)

33 
	#ATOMICSTRING_CONVERSION


	)

36 
mea
 
	gWTF
 {

38 
ass
 
	gAtomicSgTab
;

39 
	gAtomicSgHash
;

41 as
	cAtomicSg
 {

42 
	gpublic
:

43 
WTF_EXPORT_PRIVATE
 

();

45 
AtomicSg
() { }

46 
AtomicSg
(cڡ 
LCh
* 
s
: 
m_rg
(
add
(s)) { }

47 
AtomicSg
(cڡ * 
s
: 
m_rg
(
add
(s)) { }

48 
AtomicSg
(cڡ 
LCh
* 
s
, 
ngth
: 
m_rg
(
add
(s,ength)) { }

49 
AtomicSg
(cڡ 
UCh
* 
s
, 
ngth
: 
m_rg
(
add
(s,ength)) { }

50 
AtomicSg
(cڡ 
UCh
* 
s
, 
ngth
, 
exigHash
: 
m_rg
(
add
(s,ength,xistingHash)) { }

51 
AtomicSg
(cڡ 
UCh
* 
s
: 
m_rg
(
add
(s)) { }

53 
me
<
size_t
 
leCacy
>

54 
exic
 
AtomicSg
(cڡ 
Ve
<
UCh
, 
leCacy
>& 
chas
)

55 : 
m_rg
(
add
(
chas
.
da
(), chas.
size
()))

59 
ATOMICSTRING_CONVERSION
 
AtomicSg
(
SgIm
* 
imp
: 
m_rg
(
add
(imp)) { }

60 
AtomicSg
(
AtomicSgIm
* 
imp
: 
m_rg
(imp) { }

61 
ATOMICSTRING_CONVERSION
 
AtomicSg
(cڡ 
Sg
& 
s
: 
m_rg
(
add
(s.
im
())) { }

62 
AtomicSg
(
SgIm
* 
baSg
, 
t
, 
ngth
: 
m_rg
(
add
(baseString, start,ength)) { }

64 
	eCڡruFromLTag
 { 
	gCڡruFromL
 };

65 
AtomicSg
(cڡ * 
chas
, 
ngth
, 
CڡruFromLTag
)

66 : 
m_rg
(
addFromLDa
(
chas
, 
ngth
))

70 
	gme
<
	gchasCou
>

71 
ALWAYS_INLINE
 
AtomicSg
(cڡ (&
chas
)[
chasCou
], 
CڡruFromLTag
)

72 : 
m_rg
(
addFromLDa
(
chas
, 
chasCou
 - 1))

74 
COMPILE_ASSERT
(
chasCou
 > 1, 
AtomicSgFromLNEmy
);

75 
COMPILE_ASSERT
((
chasCou
 - 1 <(((~0- (
SgIm
)/ (
LCh
))), 
AtomicSgFromLCnOvow
);

80 
AtomicSg
(cڡ AtomicSg& 
h
: 
m_rg
(other.m_string) { }

81 
AtomicSg
(AtomicSg&& 
h
: 
m_rg
(
WTF
::
move
(other.m_string)) { }

82 
AtomicSg
& 
ݔ
=(cڡ AtomicSg& 
h
{ 
m_rg
 = oth.m_rg;  *
	gthis
; }

83 
	gAtomicSg
& 
	gݔ
=(
AtomicSg
&& 
h
{ 
m_rg
 = 
WTF
::
move
(h.m_rg);  *
	gthis
; }

86 
AtomicSg
(
WTF
::
HashTabDedVueTy
: 
m_rg
(WTF::
HashTabDedVue
) { }

87 
bo
 
isHashTabDedVue
(cڡ {  
m_rg
.isHashTableDeletedValue(); }

89 
WTF_EXPORT_STRING_API
 
AtomicSgIm
* 
fd
(
LCh
*, 
ngth
);

90 
WTF_EXPORT_STRING_API
 
AtomicSgIm
* 
fd
(
UCh
*, 
ngth
);

91 
AtomicSgIm
* 
fd
(
SgIm
* 
rg
)

93 i(!
	grg
 || sg->
isAtomic
())

94  
	gic_
<
	gAtomicSgIm
*>(
	grg
);

95  
fdSlowCa
(*
rg
);

98 
ݔ
 cڡ 
	gSg
&(cڡ {  
	gm_rg
; }

99 cڡ 
	gSg
& 
rg
(cڡ {  
	gm_rg
; };

101 
AtomicSgIm
* 
im
(cڡ {  
	gic_
<
	gAtomicSgIm
 *>(
	gm_rg
.impl()); }

103 
bo
 
is8B
(cڡ {  
	gm_rg
.is8Bit(); }

104 cڡ 
LCh
* 
chas8
(cڡ {  
	gm_rg
.characters8(); }

105 cڡ 
UCh
* 
chas16
(cڡ {  
	gm_rg
.characters16(); }

106 
ngth
(cڡ {  
	gm_rg
.length(); }

108 
UCh
 
	gݔ
[](
	gi
cڡ {  
	gm_rg
[
i
]; }

110 
WTF_EXPORT_STRING_API
 
AtomicSg
 
numb
();

111 
WTF_EXPORT_STRING_API
 
AtomicSg
 
numb
();

112 
WTF_EXPORT_STRING_API
 
AtomicSg
 
numb
();

115 
bo
 
cڏs
(
UCh
 
c
cڡ {  
	gm_rg
.contains(c); }

116 
bo
 
cڏs
(cڡ 
LCh
* 
s
, bo 
Ssive
 = 
ue
) const

117 {  
m_rg
.
cڏs
(
s
, 
Ssive
); }

118 
bo
 
cڏs
(cڡ 
Sg
& 
s
, bo 
Ssive
 = 
ue
) const

119 {  
m_rg
.
cڏs
(
s
, 
Ssive
); }

121 
size_t
 
fd
(
UCh
 
c
, 
t
 = 0cڡ {  
m_rg
.find(c, start); }

122 
size_t
 
fd
(cڡ 
LCh
* 
s
, 
t
 = 0, 
bo
 
Stive
 = 
ue
) const

123 {  
m_rg
.
fd
(
s
, 
t
, 
Stive
); }

124 
size_t
 
fd
(cڡ 
Sg
& 
s
, 
t
 = 0, 
bo
 
Stive
 = 
ue
) const

125 {  
m_rg
.
fd
(
s
, 
t
, 
Stive
); }

126 
size_t
 
fd
(
ChaMchFuniP
 
mchFuni
, 
t
 = 0) const

127 {  
m_rg
.
fd
(
mchFuni
, 
t
); }

129 
bo
 
tsWh
(cڡ 
Sg
& 
s
, bo 
Ssive
 = 
ue
) const

130 {  
m_rg
.
tsWh
(
s
, 
Ssive
); }

131 
bo
 
tsWh
(
UCh
 
cha
) const

132 {  
	gm_rg
.
tsWh
(
cha
); }

133 
	gme
<
	gmchLgth
>

134 
bo
 
tsWh
(cڡ (&
efix
)[
mchLgth
], bo 
Ssive
 = 
ue
) const

135 {  
m_rg
.
tsWh
<
mchLgth
>(
efix
, 
Ssive
); }

137 
bo
 
dsWh
(cڡ 
Sg
& 
s
, bo 
Ssive
 = 
ue
) const

138 {  
m_rg
.
dsWh
(
s
, 
Ssive
); }

139 
bo
 
dsWh
(
UCh
 
cha
) const

140 {  
	gm_rg
.
dsWh
(
cha
); }

141 
	gme
<
	gmchLgth
>

142 
bo
 
dsWh
(cڡ (&
efix
)[
mchLgth
], bo 
Ssive
 = 
ue
) const

143 {  
m_rg
.
dsWh
<
mchLgth
>(
efix
, 
Ssive
); }

145 
WTF_EXPORT_STRING_API
 
AtomicSg
 
cvtToASCIILow
() const;

146 
WTF_EXPORT_STRING_API
 
AtomicSg
 
low
() const;

147 
AtomicSg
 
u
(cڡ {  AtomicSg(
im
()->upper()); }

149 
toI
(
bo
* 
ok
 = 0cڡ {  
m_rg
.toInt(ok); }

150 
toDoub
(
bo
* 
ok
 = 0cڡ {  
m_rg
.toDouble(ok); }

151 
toFlt
(
bo
* 
ok
 = 0cڡ {  
m_rg
.toFloat(ok); }

152 
bo
 
rage
(& 
p
cڡ {  
	gm_rg
.percentage(p); }

154 
bo
 
isNu
(cڡ {  
	gm_rg
.isNull(); }

155 
bo
 
isEmy
(cڡ {  
	gm_rg
.isEmpty(); }

157 
move
(
SgIm
*);

159 #i
USE
(
CF
)

160 
AtomicSg
(
CFSgRef
 
s
: 
m_rg
(
add
(s)) { }

162 #ifde
__OBJC__


163 
AtomicSg
(
NSSg
* 
s
: 
m_rg
(
add
((
CFSgRef
)s)) { }

164 
ݔ
 
NSSg
*(cڡ {  
m_rg
; }

169 
AtomicSg
 
omUTF8
(cڡ *, 
size_t
);

170 
AtomicSg
 
omUTF8
(const *);

172 #ide
NDEBUG


173 
show
() const;

176 
WTF_EXPORT_STRING_API
 
	gPassRefP
<
	gSgIm
> 
add
(cڡ 
LCh
*);

177 
ALWAYS_INLINE
 
	gPassRefP
<
	gSgIm
> 
add
(cڡ * 
s
{ dd(
t_
<cڡ 
LCh
*>(s)); };

178 
WTF_EXPORT_STRING_API
 
	gPassRefP
<
	gSgIm
> 
add
(cڡ 
LCh
*, 
ngth
);

179 
WTF_EXPORT_STRING_API
 
	gPassRefP
<
	gSgIm
> 
add
(cڡ 
UCh
*, 
ngth
);

180 
ALWAYS_INLINE
 
	gPassRefP
<
	gSgIm
> 
add
(cڡ * 
s
, 
ngth
{ dd(
t_
<cڡ 
LCh
*>(s),ength); };

181 
WTF_EXPORT_STRING_API
 
	gPassRefP
<
	gSgIm
> 
add
(cڡ 
UCh
*, 
ngth
, 
exigHash
);

182 
WTF_EXPORT_STRING_API
 
	gPassRefP
<
	gSgIm
> 
add
(cڡ 
UCh
*);

183 
WTF_EXPORT_STRING_API
 
	gPassRefP
<
	gSgIm
> 
add
(
SgIm
*, 
offt
, 
ngth
);

185 #i
ENABLE
(
VMOLAB
)

186 
	gme
<
tyme
 
	gSgTabProvid
>

187 
ALWAYS_INLINE
 
	gPassRefP
<
	gSgIm
> 
addIdtifr
(
SgTabProvid
& 
rgTabProvid
, cڡ * 
s
{ ddIdtifr(rgTabProvid, 
t_
<cڡ 
LCh
*>(s)); };

189 
	gme
<
tyme
 
	gSgTabProvid
>

190 
ALWAYS_INLINE
 
	gPassRefP
<
	gSgIm
> 
addIdtifr
(
SgTabProvid
& 
rgTabProvid
, cڡ * 
s
, 
ngth
{ ddIdtifr(rgTabProvid, 
t_
<cڡ 
LCh
*>(s),ength); };

192 
	gme
<
tyme
 
	gSgTabProvid
>

193 
ALWAYS_INLINE
 
	gPassRefP
<
	gSgIm
> 
addIdtifr
(
SgTabProvid
& 
rgTabProvid
, cڡ 
LCh
* 
c
)

195  
addSlowCa
(*
rgTabProvid
.
omicSgTab
(), 
c
);

198 
	gme
<
tyme
 
	gSgTabProvid
>

199 
ALWAYS_INLINE
 
	gPassRefP
<
	gSgIm
> 
addIdtifr
(
SgTabProvid
& 
rgTabProvid
, cڡ 
LCh
* 
s
, 
ngth
)

201  
addSlowCa
(*
rgTabProvid
.
omicSgTab
(), 
s
, 
ngth
);

204 
	gme
<
tyme
 
	gSgTabProvid
>

205 
ALWAYS_INLINE
 
	gPassRefP
<
	gSgIm
> 
addIdtifr
(
SgTabProvid
& 
rgTabProvid
, cڡ 
UCh
* 
s
, 
ngth
)

207  
addSlowCa
(*
rgTabProvid
.
omicSgTab
(), 
s
, 
ngth
);

210 
	gme
<
tyme
 
	gSgTabProvid
>

211 
ALWAYS_INLINE
 
	gPassRefP
<
	gSgIm
> 
addIdtifr
(
SgTabProvid
& 
rgTabProvid
, cڡ 
UCh
* 
s
)

213  
addSlowCa
(*
rgTabProvid
.
omicSgTab
(), 
s
);

216 
	gme
<
tyme
 
	gSgTabProvid
>

217 
ALWAYS_INLINE
 
	gPassRefP
<
	gSgIm
> 
addIdtifr
(
SgTabProvid
& 
rgTabProvid
, 
SgIm
* 
rg
)

219 i(!
	grg
 || sg->
isAtomic
()) {

220 
ASSERT_WITH_MESSAGE
(!
rg
 || !rg->
ngth
(|| 
isInSgProvidTab
(*
rgTabProvid
.
omicSgTab
(), string), "Thetomic string comes fromn otherhread!");

221  
	grg
;

223  
addSlowCa
(*
rgTabProvid
.
omicSgTab
(), *
rg
);

227 
ALWAYS_INLINE
 
	gPassRefP
<
	gSgIm
> 
add
(
SgIm
* 
rg
)

229 i(!
	grg
 || sg->
isAtomic
()) {

230 
ASSERT_WITH_MESSAGE
(!
rg
 || !rg->
ngth
(|| 
isInAtomicSgTab
(string), "Thetomic string comes fromn otherhread!");

231  
	grg
;

233  
addSlowCa
(*
rg
);

235 
WTF_EXPORT_STRING_API
 
	gPassRefP
<
	gSgIm
> 
addFromLDa
(cڡ * 
chas
, 
ngth
);

236 #i
USE
(
CF
)

237 
WTF_EXPORT_STRING_API
 
	gPassRefP
<
	gSgIm
> 
add
(
CFSgRef
);

240 
	gme
<
tyme
 
	gSgTabProvid
>

241 
ALWAYS_INLINE
 
	gPassRefP
<
	gSgIm
> 
addWhSgTabProvid
(
SgTabProvid
& 
rgTabProvid
, 
SgIm
* 
rg
)

243 i(!
	grg
 || sg->
isAtomic
()) {

244 
ASSERT_WITH_MESSAGE
(!
rg
 || !rg->
ngth
(|| 
isInAtomicSgTab
(string), "Thetomic string comes fromn otherhread!");

245  
	grg
;

247  
addSlowCa
(*
rgTabProvid
.
omicSgTab
(), *
rg
);

250 
	give
:

252 
AtomicSg
(
ASCIIL
);

254 
Sg
 
	gm_rg
;

256 
WTF_EXPORT_STRING_API
 
	gPassRefP
<
	gSgIm
> 
addSlowCa
(
SgIm
&);

257 
WTF_EXPORT_STRING_API
 
	gPassRefP
<
	gSgIm
> 
addSlowCa
(
AtomicSgTab
&, 
SgIm
&);

259 #i
ENABLE
(
VMOLAB
)

260 
WTF_EXPORT_STRING_API
 
	gPassRefP
<
	gSgIm
> 
addSlowCa
(
AtomicSgTab
&, cڡ 
LCh
*);

261 
WTF_EXPORT_STRING_API
 
	gPassRefP
<
	gSgIm
> 
addSlowCa
(
AtomicSgTab
&, cڡ 
LCh
*, );

262 
WTF_EXPORT_STRING_API
 
	gPassRefP
<
	gSgIm
> 
addSlowCa
(
AtomicSgTab
&, cڡ 
UCh
*, );

263 
WTF_EXPORT_STRING_API
 
	gPassRefP
<
	gSgIm
> 
addSlowCa
(
AtomicSgTab
&, cڡ 
UCh
*);

266 
WTF_EXPORT_STRING_API
 
AtomicSgIm
* 
fdSlowCa
(
SgIm
&);

267 
WTF_EXPORT_STRING_API
 
AtomicSg
 
omUTF8Il
(const *, const *);

269 #i!
ASSERT_DISABLED


270 
WTF_EXPORT_STRING_API
 
bo
 
isInAtomicSgTab
(
SgIm
*);

271 
WTF_EXPORT_STRING_API
 
bo
 
isInSgProvidTab
(
AtomicSgTab
&, 
SgIm
*);

275 
le
 
bo
 
	gݔ
==(cڡ 
AtomicSg
& 
a
, cڡ 
	gAtomicSg
& 
	gb
{  
	ga
.
im
(=
b
.impl(); }

276 
bo
 
	gݔ
==(cڡ 
AtomicSg
&, cڡ 
	gLCh
*);

277 
le
 
bo
 
	gݔ
==(cڡ 
AtomicSg
& 
a
, cڡ * 
	gb
{  
	gWTF
::
equ
.
im
(), 
t_
<cڡ 
LCh
*>(
b
)); }

278 
le
 
bo
 
	gݔ
==(cڡ 
AtomicSg
& 
a
, cڡ 
	gVe
<
	gUCh
>& 
	gb
{  
	ga
.
im
(&& 
equ
.im(), 
b
.
da
(), b.
size
()); }

279 
le
 
bo
 
	gݔ
==(cڡ 
AtomicSg
& 
a
, cڡ 
	gSg
& 
	gb
{  
equ
.
im
(), 
b
.impl()); }

280 
le
 
bo
 
	gݔ
==(cڡ 
LCh
* 
a
, cڡ 
	gAtomicSg
& 
	gb
) {  b ==; }

281 
le
 
bo
 
	gݔ
==(cڡ 
Sg
& 
a
, cڡ 
	gAtomicSg
& 
	gb
{  
equ
.
im
(), 
b
.impl()); }

282 
le
 
bo
 
	gݔ
==(cڡ 
Ve
<
UCh
>& 
a
, cڡ 
	gAtomicSg
& 
	gb
) {  b ==; }

284 
le
 
bo
 
	gݔ
!=(cڡ 
AtomicSg
& 
a
, cڡ 
	gAtomicSg
& 
	gb
{  
	ga
.
im
(!
b
.impl(); }

285 
le
 
bo
 
	gݔ
!=(cڡ 
AtomicSg
& 
a
, cڡ 
LCh
* 
	gb
{  !(
	ga
 =
b
); }

286 
le
 
bo
 
	gݔ
!=(cڡ 
AtomicSg
& 
a
, cڡ * 
	gb
{  !(
	ga
 =
b
); }

287 
le
 
bo
 
	gݔ
!=(cڡ 
AtomicSg
& 
a
, cڡ 
	gSg
& 
	gb
{  !
equ
.
im
(), 
b
.impl()); }

288 
le
 
bo
 
	gݔ
!=(cڡ 
AtomicSg
& 
a
, cڡ 
	gVe
<
	gUCh
>& 
	gb
{  !(
	ga
 =
b
); }

289 
le
 
bo
 
	gݔ
!=(cڡ 
LCh
* 
a
, cڡ 
	gAtomicSg
& 
	gb
) {  !(b ==); }

290 
le
 
bo
 
	gݔ
!=(cڡ 
Sg
& 
a
, cڡ 
	gAtomicSg
& 
	gb
{  !
equ
.
im
(), 
b
.impl()); }

291 
le
 
bo
 
	gݔ
!=(cڡ 
Ve
<
UCh
>& 
a
, cڡ 
	gAtomicSg
& 
	gb
{  !(
	ga
 =
b
); }

293 
le
 
bo
 
	$equIgnܚgCa
(cڡ 
AtomicSg
& 
a
, cڡ AtomicSg& 
b
{  
	`equIgnܚgCa
.
	`im
(), b.im()); 
	}
}

294 
le
 
bo
 
	$equIgnܚgCa
(cڡ 
AtomicSg
& 
a
, cڡ 
LCh
* 
b
{  
	`equIgnܚgCa
.
	`im
(), b); 
	}
}

295 
le
 
bo
 
	$equIgnܚgCa
(cڡ 
AtomicSg
& 
a
, cڡ * 
b
{  
	`equIgnܚgCa
.
	`im
(), 
t_
<cڡ 
LCh
*>(b)); 
	}
}

296 
le
 
bo
 
	$equIgnܚgCa
(cڡ 
AtomicSg
& 
a
, cڡ 
Sg
& 
b
{  
	`equIgnܚgCa
.
	`im
(), b.im()); 
	}
}

297 
le
 
bo
 
	$equIgnܚgCa
(cڡ 
LCh
* 
a
, cڡ 
AtomicSg
& 
b
{  
	`equIgnܚgCa
, b.
	`im
()); 
	}
}

298 
le
 
bo
 
	$equIgnܚgCa
(cڡ * 
a
, cڡ 
AtomicSg
& 
b
{  
	`equIgnܚgCa
(
t_
<cڡ 
LCh
*>), b.
	`im
()); 
	}
}

299 
le
 
bo
 
	$equIgnܚgCa
(cڡ 
Sg
& 
a
, cڡ 
AtomicSg
& 
b
{  
	`equIgnܚgCa
.
	`im
(), b.im()); 
	}
}

303 #ide
ATOMICSTRING_HIDE_GLOBALS


304 cڡ 
WTF_EXPORTDATA
 
AtomicSg
 
nuAtom
;

305 cڡ 
WTF_EXPORTDATA
 
AtomicSg
 
emyAtom
;

306 cڡ 
WTF_EXPORTDATA
 
AtomicSg
 
xtAtom
;

307 cڡ 
WTF_EXPORTDATA
 
AtomicSg
 
commtAtom
;

308 cڡ 
WTF_EXPORTDATA
 
AtomicSg
 
Atom
;

309 cڡ 
WTF_EXPORTDATA
 
AtomicSg
 
xmlAtom
;

310 cڡ 
WTF_EXPORTDATA
 
AtomicSg
 
xmsAtom
;

311 cڡ 
WTF_EXPORTDATA
 
AtomicSg
 
xlkAtom
;

313 
le
 
AtomicSg
 
	gAtomicSg
::
	$omUTF8
(cڡ * 
chas
, 
size_t
 
ngth
)

315 i(!
chas
)

316  
nuAtom
;

317 i(!
ngth
)

318  
emyAtom
;

319  
	`omUTF8Il
(
chas
, cha+ 
ngth
);

320 
	}
}

322 
le
 
AtomicSg
 
	gAtomicSg
::
	$omUTF8
(cڡ * 
chas
)

324 i(!
chas
)

325  
nuAtom
;

326 i(!*
chas
)

327  
emyAtom
;

328  
	`omUTF8Il
(
chas
, 0);

329 
	}
}

333 
	gme
<
tyme
 
	gT
> 
	gDeuHash
;

334 
	gme
<> 
	gDeuHash
<
	gAtomicSg
> {

335 
AtomicSgHash
 
	tHash
;

340 #ide
ATOMICSTRING_HIDE_GLOBALS


341 
usg
 
	gWTF
::
AtomicSg
;

342 
usg
 
	gWTF
::
nuAtom
;

343 
usg
 
	gWTF
::
emyAtom
;

344 
usg
 
	gWTF
::
xtAtom
;

345 
usg
 
	gWTF
::
commtAtom
;

346 
usg
 
	gWTF
::
Atom
;

347 
usg
 
	gWTF
::
xmlAtom
;

348 
usg
 
	gWTF
::
xmsAtom
;

349 
usg
 
	gWTF
::
xlkAtom
;

352 
	~<wtf/xt/SgCǋ.h
>

	@text/AtomicStringHash.h

29 #ide
AtomicSgHash_h


30 
	#AtomicSgHash_h


	)

32 
	~<wtf/xt/AtomicSg.h
>

33 
	~<wtf/HashTs.h
>

35 
mea
 
	gWTF
 {

37 
	sAtomicSgHash
 {

38 
hash
(cڡ 
AtomicSg
& 
key
)

40  
	gkey
.
im
()->
exigHash
();

43 
bo
 
equ
(cڡ 
AtomicSg
& 
a
, cڡ AtomicSg& 
b
)

45  
	ga
 =
b
;

48 cڡ 
bo
 
	gToComToEmyOrDed
 = 
l
;

52 
	gme
<> 
	gHashTs
<
	gWTF
::
AtomicSg
> : 
GicHashTs
<
WTF
::AtomicString> {

53 cڡ 
bo
 
emyVueIsZo
 = 
ue
;

54 
cڡruDedVue
(
WTF
::
AtomicSg
& 

{ 
w
 (
NNu
, &
	gWTF
::AtomicSg(
HashTabDedVue
); }

55 
bo
 
isDedVue
(cڡ 
WTF
::
AtomicSg
& 

{  sl.
isHashTabDedVue
(); }

60 
usg
 
	gWTF
::
AtomicSgHash
;

	@text/AtomicStringImpl.h

21 #ide
AtomicSgIm_h


22 
	#AtomicSgIm_h


	)

24 
	~<wtf/xt/SgIm.h
>

26 
mea
 
	gWTF
 {

28 as
	cAtomicSgIm
 : 
public
 
SgIm


30 
public
:

31 
AtomicSgIm
(: 
SgIm
(0) {}

34 #i!
ASSERT_DISABLED


40 
	gme
<> 

41 
	gVueCheck
<
	gAtomicSgIm
*> {

42 
checkCsicy
(cڡ 
AtomicSgIm
*) { }

45 
	gme
<> 

46 
	gVueCheck
<cڡ 
	gAtomicSgIm
*> {

47 
checkCsicy
(cڡ 
AtomicSgIm
*) { }

53 
usg
 
	gWTF
::
AtomicSgIm
;

	@text/AtomicStringTable.cpp

23 
	~"cfig.h
"

24 
	~"AtomicSgTab.h
"

26 
	~<wtf/HashS.h
>

27 
	~<wtf/MaThad.h
>

28 
	~<wtf/WTFThadDa.h
>

30 
mea
 
	gWTF
 {

32 
	gAtomicSgTab
::

(
WTFThadDa
& 
da
)

34 #i
USE
(
WEB_THREAD
)

36 
AtomicSgTab
* 
shedSgTab
 = 
w
 AtomicStringTable;

38 
bo
 
	gcutThadIsWebThad
 = 
isWebThad
();

39 i(
	gcutThadIsWebThad
 || 
isUIThad
())

40 
	gda
.
	gm_deuAtomicSgTab
 = 
shedSgTab
;

42 
	gda
.
	gm_deuAtomicSgTab
 = 
w
 
AtomicSgTab
;

46 i(!
	gcutThadIsWebThad
)

47 
	gda
.
	gm_omicSgTabDeru
 = 
AtomicSgTab
::
deroy
;

49 
	gda
.
	gm_deuAtomicSgTab
 = 
w
 
AtomicSgTab
;

50 
	gda
.
	gm_omicSgTabDeru
 = 
AtomicSgTab
::
deroy
;

54 
	gAtomicSgTab
::~
AtomicSgTab
()

56 auto* 
rg
 : 
m_b
)

57 
rg
->
tIsAtomic
(
l
);

60 
	gAtomicSgTab
::
deroy
(
AtomicSgTab
* 
b
)

62 
de
 
b
;

	@text/AtomicStringTable.h

23 #ide
WTF_AtomicSgTab_h


24 
	#WTF_AtomicSgTab_h


	)

26 
	~<wtf/HashS.h
>

27 
	~<wtf/WTFThadDa.h
>

29 
mea
 
	gWTF
 {

31 
ass
 
	gSgIm
;

33 as
	cAtomicSgTab
 {

34 
	gWTF_MAKE_FAST_ALLOCATED
;

35 
	gpublic
:

36 
WTF_EXPORT_PRIVATE
 ~
AtomicSgTab
();

38 

(
WTFThadDa
&);

39 
	gHashS
<
	gSgIm
*>& 
b
({  
	gm_b
; }

41 
	give
:

42 
deroy
(
AtomicSgTab
*);

44 
	gHashS
<
	gSgIm
*> 
	gm_b
;

	@text/Base64.cpp

24 
	~"cfig.h
"

25 
	~"Ba64.h
"

27 
	~<lims.h
>

28 
	~<wtf/SgExas.h
>

29 
	~<wtf/xt/WTFSg.h
>

31 
mea
 
	gWTF
 {

33 cڡ 
	gnAhab
 = -1;

35 cڡ 
	gba64EncM
[64] = {

46 cڡ 
	gba64DecM
[128] = {

47 
nAhab
,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,

48 
nAhab
,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,

49 
nAhab
,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,

50 
nAhab
,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,

51 
nAhab
,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,

52 
nAhab
,onAlphabet,onAlphabet, 0x3E,onAlphabet,onAlphabet,onAlphabet, 0x3F,

54 0x3C, 0x3D, 
nAhab
,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,

55 
nAhab
, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,

58 0x17, 0x18, 0x19, 
nAhab
,onAlphabet,onAlphabet,onAlphabet,onAlphabet,

59 
nAhab
, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,

62 0x31, 0x32, 0x33, 
nAhab
,onAlphabet,onAlphabet,onAlphabet,onAlphabet

65 cڡ 
	gba64URLEncM
[64] = {

76 cڡ 
	gba64URLDecM
[128] = {

77 
nAhab
,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,

78 
nAhab
,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,

79 
nAhab
,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,

80 
nAhab
,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,

81 
nAhab
,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,

82 
nAhab
,onAlphabet,onAlphabet,onAlphabet,onAlphabet, 0x3E,onAlphabet,onAlphabet,

84 0x3C, 0x3D, 
nAhab
,onAlphabet,onAlphabet,onAlphabet,onAlphabet,onAlphabet,

85 
nAhab
, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,

88 0x17, 0x18, 0x19, 
nAhab
,onAlphabet,onAlphabet,onAlphabet, 0x3F,

89 
nAhab
, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,

92 0x31, 0x32, 0x33, 
nAhab
,onAlphabet,onAlphabet,onAlphabet,onAlphabet

95 
le
 
ba64EncodeIl
(cڡ * 
da
, 
n
, 
Ve
<>& 
out
, 
Ba64EncodePicy
 
picy
, cڡ (&
codeM
)[64])

97 
	gout
.
r
();

98 i(!
	gn
)

104 cڡ 
	gmaxIutBufrSize
 = 
UINT_MAX
 / 77 * 76 / 4 * 3 - 2;

105 i(
	gn
 > 
	gmaxIutBufrSize
)

108 
	gsidx
 = 0;

109 
	gdidx
 = 0;

111 
	goutLgth
 = ((
n
 + 2) / 3) * 4;

114 
bo
 
	gLFs
 = (
picy
 =
Ba64InLFs
 && 
outLgth
 > 76);

115 i(
	gLFs
)

116 
	goutLgth
 +((
outLgth
 - 1) / 76);

118 
	gcou
 = 0;

119 
	gout
.
grow
(
outLgth
);

122 i(
	gn
 > 1) {

123 
	gsidx
 < 
	gn
 - 2) {

124 i(
	gLFs
) {

125 i(
	gcou
 && !(count % 76))

126 
	gout
[
didx
++] = '\n';

127 
	gcou
 += 4;

129 
	gout
[
didx
++] = 
codeM
[(
da
[
sidx
] >> 2) & 077];

130 
	gout
[
didx
++] = 
codeM
[((
da
[
sidx
 + 1] >> 4) & 017) | ((data[sidx] << 4) & 077)];

131 
	gout
[
didx
++] = 
codeM
[((
da
[
sidx
 + 2] >> 6) & 003) | ((data[sidx + 1] << 2) & 077)];

132 
	gout
[
didx
++] = 
codeM
[
da
[
sidx
 + 2] & 077];

133 
	gsidx
 += 3;

137 i(
	gsidx
 < 
	gn
) {

138 i(
	gLFs
 && (
	gcou
 > 0) && !(count % 76))

139 
	gout
[
didx
++] = '\n';

141 
	gout
[
didx
++] = 
codeM
[(
da
[
sidx
] >> 2) & 077];

142 i(
	gsidx
 < 
	gn
 - 1) {

143 
	gout
[
didx
++] = 
codeM
[((
da
[
sidx
 + 1] >> 4) & 017) | ((data[sidx] << 4) & 077)];

144 
	gout
[
didx
++] = 
codeM
[(
da
[
sidx
 + 1] << 2) & 077];

146 
	gout
[
didx
++] = 
codeM
[(
da
[
sidx
] << 4) & 077];

150 i(
	gpicy
 =
Ba64URLPicy
)

151 
out
.
size
(
didx
);

153 
	gdidx
 < 
	gout
.
size
()) {

154 
	gout
[
didx
] = '=';

155 ++
	gdidx
;

160 
Sg
 
ba64Encode
(cڡ * 
da
, 
ngth
, 
Ba64EncodePicy
 
picy
)

162 
	gVe
<> 
	gsu
;

163 
ba64EncodeIl
(
ic_
<cڡ *>(
da
), 
ngth
, 
su
, 
picy
, 
ba64EncM
);

164  
Sg
(
su
.
da
(),esu.
size
());

167 
ba64Encode
(cڡ * 
da
, 
n
, 
Ve
<>& 
out
, 
Ba64EncodePicy
 
picy
)

169 
ba64EncodeIl
(
ic_
<cڡ *>(
da
), 
n
, 
out
, 
picy
, 
ba64EncM
);

172 
Sg
 
ba64URLEncode
(cڡ * 
da
, 
ngth
)

174 
	gVe
<> 
	gsu
;

175 
ba64EncodeIl
(
ic_
<cڡ *>(
da
), 
ngth
, 
su
, 
Ba64URLPicy
, 
ba64URLEncM
);

176  
Sg
(
su
.
da
(),esu.
size
());

179 
ba64URLEncode
(cڡ * 
da
, 
n
, 
Ve
<>& 
out
)

181 
ba64EncodeIl
(
ic_
<cڡ *>(
da
), 
n
, 
out
, 
Ba64URLPicy
, 
ba64URLEncM
);

184 
	gme
<
tyme
 
	gT
>

185 
le
 
bo
 
ba64DecodeIl
(cڡ 
T
* 
da
, 
ngth
, 
Ve
<>& 
out
, 
Ba64DecodePicy
 
picy
, cڡ (&
decodeM
)[128])

187 
	gout
.
r
();

188 i(!
	gngth
)

189  
	gue
;

191 
	gout
.
grow
(
ngth
);

193 
	gequsSignCou
 = 0;

194 
	goutLgth
 = 0;

195 
	gidx
 = 0; idx < 
	gngth
; ++idx) {

196 
	gch
 = 
da
[
idx
];

197 i(
	gch
 == '=') {

198 ++
equsSignCou
;

201 i(
	gpicy
 =
Ba64FaOnInvidChaOrExssPaddg
 && (
ngth
 % 4 || 
equsSignCou
 > 2))

202  
l
;

204 
	gdecodedCha
 = 
ch
 < 
WTF_ARRAY_LENGTH
(
decodeM
? decodeM[ch] : 
nAhab
;

205 i(
	gdecodedCha
 !
nAhab
) {

206 i(
equsSignCou
)

207  
l
;

208 
	gout
[
outLgth
] = 
decodedCha
;

209 ++
	goutLgth
;

210 } i(
	gpicy
 =
Ba64FaOnInvidChaOrExssPaddg
 || 
picy
 =
Ba64FaOnInvidCha
 || (picy =
Ba64IgneWhea
 && !
isSOrNewle
(
ch
)))

211  
l
;

215 i(!
	goutLgth
)

216  !
	gequsSignCou
;

219 i((
	goutLgth
 % 4) == 1)

220  
l
;

223 
	goutLgth
 -(
outLgth
 + 3) / 4;

224 i(!
	goutLgth
)

225  
	gl
;

227 
	gsidx
 = 0;

228 
	gdidx
 = 0;

229 i(
	goutLgth
 > 1) {

230 
	gdidx
 < 
	goutLgth
 - 2) {

231 
	gout
[
didx
] = (((
out
[
sidx
] << 2) & 255) | ((out[sidx + 1] >> 4) & 003));

232 
	gout
[
didx
 + 1] = (((
out
[
sidx
 + 1] << 4) & 255) | ((out[sidx + 2] >> 2) & 017));

233 
	gout
[
didx
 + 2] = (((
out
[
sidx
 + 2] << 6) & 255) | (out[sidx + 3] & 077));

234 
	gsidx
 += 4;

235 
	gdidx
 += 3;

239 i(
	gdidx
 < 
	goutLgth
)

240 
	gout
[
didx
] = (((
out
[
sidx
] << 2) & 255) | ((out[sidx + 1] >> 4) & 003));

242 i(++
	gdidx
 < 
	goutLgth
)

243 
	gout
[
didx
] = (((
out
[
sidx
 + 1] << 4) & 255) | ((out[sidx + 2] >> 2) & 017));

245 i(
	goutLgth
 < 
	gout
.
size
())

246 
	gout
.
shrk
(
outLgth
);

248  
	gue
;

251 
bo
 
ba64Decode
(cڡ 
Sg
& 

, 
SigdOrUnsigdChVeAdr
 
out
, 
Ba64DecodePicy
 
picy
)

253 
	gngth
 = 

.
ngth
();

254 i(!
	gngth
 || 
	g
.
is8B
())

255  
ba64DecodeIl
(

.
chas8
(), 
ngth
, 
out
, 
picy
, 
ba64DecM
);

256  
ba64DecodeIl
(

.
chas16
(), 
ngth
, 
out
, 
picy
, 
ba64DecM
);

259 
bo
 
ba64Decode
(cڡ 
Ve
<>& 

, 
SigdOrUnsigdChVeAdr
 
out
, 
Ba64DecodePicy
 
picy
)

261 
	gout
.
r
();

264 i(
	g
.
size
(> 
	gUINT_MAX
)

265  
	gl
;

267  
ba64DecodeIl
(
t_
<cڡ 
LCh
*>(

.
da
()), in.
size
(), 
out
, 
picy
, 
ba64DecM
);

270 
bo
 
ba64Decode
(cڡ * 
da
, 
n
, 
SigdOrUnsigdChVeAdr
 
out
, 
Ba64DecodePicy
 
picy
)

272  
ba64DecodeIl
(
t_
<cڡ 
LCh
*>(
da
), 
n
, 
out
, 
picy
, 
ba64DecM
);

275 
bo
 
ba64URLDecode
(cڡ 
Sg
& 

, 
SigdOrUnsigdChVeAdr
 
out
)

277 
	gngth
 = 

.
ngth
();

278 i(!
	gngth
 || 
	g
.
is8B
())

279  
ba64DecodeIl
(

.
chas8
(), 
ngth
, 
out
, 
Ba64FaOnInvidCha
, 
ba64URLDecM
);

280  
ba64DecodeIl
(

.
chas16
(), 
ngth
, 
out
, 
Ba64FaOnInvidCha
, 
ba64URLDecM
);

283 
bo
 
ba64URLDecode
(cڡ 
Ve
<>& 

, 
SigdOrUnsigdChVeAdr
 
out
)

285 
	gout
.
r
();

288 i(
	g
.
size
(> 
	gUINT_MAX
)

289  
	gl
;

291  
ba64DecodeIl
(
t_
<cڡ 
LCh
*>(

.
da
()), in.
size
(), 
out
, 
Ba64FaOnInvidCha
, 
ba64URLDecM
);

294 
bo
 
ba64URLDecode
(cڡ * 
da
, 
n
, 
SigdOrUnsigdChVeAdr
 
out
)

296  
ba64DecodeIl
(
t_
<cڡ 
LCh
*>(
da
), 
n
, 
out
, 
Ba64FaOnInvidCha
, 
ba64URLDecM
);

	@text/Base64.h

28 #ide
Ba64_h


29 
	#Ba64_h


	)

31 
	~<wtf/Ve.h
>

32 
	~<wtf/xt/CSg.h
>

33 
	~<wtf/xt/WTFSg.h
>

35 
mea
 
	gWTF
 {

37 
	eBa64EncodePicy
 {

38 
	gBa64DoNInLFs
,

39 
	gBa64InLFs
,

40 
	gBa64URLPicy


43 
	eBa64DecodePicy
 {

44 
	gBa64FaOnInvidChaOrExssPaddg
,

45 
	gBa64FaOnInvidCha
,

46 
	gBa64IgneWhea
,

47 
	gBa64IgneInvidChas


50 as
	cSigdOrUnsigdChVeAdr
 {

51 
	gpublic
:

52 
SigdOrUnsigdChVeAdr
(
Ve
<>& 
ve
{ 
m_ve
.
c
 = &vector; }

53 
SigdOrUnsigdChVeAdr
(
Ve
<
ut8_t
>& 
ve
{ 
	gm_ve
.
	gu
 = &vector; }

55 
ݔ
 
	gVe
<>&({  *
	gm_ve
.
	gc
; }

56 
r
({ 
	gm_ve
.
	gc
->clear(); }

58 
	give
:

60 
Ve
<>* 
c
;

61 
	gVe
<
	gut8_t
>* 
	gu
;

62 } 
	gm_ve
;

65 as
	cCڡSigdOrUnsigdChVeAdr
 {

66 
	gpublic
:

67 
CڡSigdOrUnsigdChVeAdr
(cڡ 
Ve
<>& 
ve
{ 
m_ve
.
c
 = &vector; }

68 
CڡSigdOrUnsigdChVeAdr
(cڡ 
Ve
<
ut8_t
>& 
ve
{ 
	gm_ve
.
	gu
 = &vector; }

70 
ݔ
 cڡ 
	gVe
<>&({  *
	gm_ve
.
	gc
; }

71 cڡ * 
da
(cڡ {  
	gm_ve
.
	gc
->data(); }

72 
size_t
 
size
(cڡ {  
	gm_ve
.
	gc
->size(); }

74 
	give
:

76 cڡ 
Ve
<>* 
c
;

77 cڡ 
	gVe
<
	gut8_t
>* 
	gu
;

78 } 
	gm_ve
;

81 
WTF_EXPORT_PRIVATE
 
ba64Encode
(cڡ *, , 
Ve
<>&, 
Ba64EncodePicy
 = 
Ba64DoNInLFs
);

82 
ba64Encode
(
CڡSigdOrUnsigdChVeAdr
, 
Ve
<>&, 
Ba64EncodePicy
 = 
Ba64DoNInLFs
);

83 
ba64Encode
(cڡ 
CSg
&, 
Ve
<>&, 
Ba64EncodePicy
 = 
Ba64DoNInLFs
);

84 
WTF_EXPORT_PRIVATE
 
Sg
 
ba64Encode
(cڡ *, , 
Ba64EncodePicy
 = 
Ba64DoNInLFs
);

85 
Sg
 
ba64Encode
(
CڡSigdOrUnsigdChVeAdr
, 
Ba64EncodePicy
 = 
Ba64DoNInLFs
);

86 
Sg
 
ba64Encode
(cڡ 
CSg
&, 
Ba64EncodePicy
 = 
Ba64DoNInLFs
);

88 
WTF_EXPORT_PRIVATE
 
bo
 
ba64Decode
(cڡ 
Sg
&, 
SigdOrUnsigdChVeAdr
, 
Ba64DecodePicy
 = 
Ba64FaOnInvidCha
);

89 
WTF_EXPORT_PRIVATE
 
bo
 
ba64Decode
(cڡ 
Ve
<>&, 
SigdOrUnsigdChVeAdr
, 
Ba64DecodePicy
 = 
Ba64FaOnInvidCha
);

90 
WTF_EXPORT_PRIVATE
 
bo
 
ba64Decode
(cڡ *, , 
SigdOrUnsigdChVeAdr
, 
Ba64DecodePicy
 = 
Ba64FaOnInvidCha
);

92 
le
 
ba64Encode
(
CڡSigdOrUnsigdChVeAdr
 

, 
Ve
<>& 
out
, 
Ba64EncodePicy
 
picy
)

94 
ba64Encode
(

.
da
(), in.
size
(), 
out
, 
picy
);

97 
le
 
ba64Encode
(cڡ 
CSg
& 

, 
Ve
<>& 
out
, 
Ba64EncodePicy
 
picy
)

99 
ba64Encode
(

.
da
(), in.
ngth
(), 
out
, 
picy
);

102 
le
 
Sg
 
	$ba64Encode
(
CڡSigdOrUnsigdChVeAdr
 

, 
Ba64EncodePicy
 
picy
)

104  
	`ba64Encode
(

.
	`da
(), in.
	`size
(), 
picy
);

105 
	}
}

107 
le
 
Sg
 
	$ba64Encode
(cڡ 
CSg
& 

, 
Ba64EncodePicy
 
picy
)

109  
	`ba64Encode
(

.
	`da
(), in.
	`ngth
(), 
picy
);

110 
	}
}

117 
WTF_EXPORT_PRIVATE
 
ba64URLEncode
(cڡ *, , 
Ve
<>&);

118 
ba64URLEncode
(
CڡSigdOrUnsigdChVeAdr
, 
Ve
<>&);

119 
ba64URLEncode
(cڡ 
CSg
&, 
Ve
<>&);

121 
WTF_EXPORT_PRIVATE
 
Sg
 
ba64URLEncode
(const *, );

122 
Sg
 
ba64URLEncode
(
CڡSigdOrUnsigdChVeAdr
);

123 
Sg
 
ba64URLEncode
(cڡ 
CSg
&);

125 
WTF_EXPORT_PRIVATE
 
bo
 
ba64URLDecode
(cڡ 
Sg
&, 
SigdOrUnsigdChVeAdr
);

126 
WTF_EXPORT_PRIVATE
 
bo
 
ba64URLDecode
(cڡ 
Ve
<>&, 
SigdOrUnsigdChVeAdr
);

127 
WTF_EXPORT_PRIVATE
 
bo
 
ba64URLDecode
(cڡ *, , 
SigdOrUnsigdChVeAdr
);

129 
le
 
ba64URLEncode
(
CڡSigdOrUnsigdChVeAdr
 

, 
Ve
<>& 
out
)

131 
ba64URLEncode
(

.
da
(), in.
size
(), 
out
);

134 
le
 
ba64URLEncode
(cڡ 
CSg
& 

, 
Ve
<>& 
out
)

136 
ba64URLEncode
(

.
da
(), in.
ngth
(), 
out
);

139 
le
 
Sg
 
	$ba64URLEncode
(
CڡSigdOrUnsigdChVeAdr
 

)

141  
	`ba64URLEncode
(

.
	`da
(), in.
	`size
());

142 
	}
}

144 
le
 
Sg
 
	$ba64URLEncode
(cڡ 
CSg
& 

)

146  
	`ba64URLEncode
(

.
	`da
(), in.
	`ngth
());

147 
	}
}

151 
usg
 
	gWTF
::
Ba64EncodePicy
;

152 
usg
 
	gWTF
::
Ba64DoNInLFs
;

153 
usg
 
	gWTF
::
Ba64InLFs
;

154 
usg
 
	gWTF
::
Ba64DecodePicy
;

155 
usg
 
	gWTF
::
Ba64FaOnInvidChaOrExssPaddg
;

156 
usg
 
	gWTF
::
Ba64FaOnInvidCha
;

157 
usg
 
	gWTF
::
Ba64IgneWhea
;

158 
usg
 
	gWTF
::
Ba64IgneInvidChas
;

159 
usg
 
	gWTF
::
ba64Encode
;

160 
usg
 
	gWTF
::
ba64Decode
;

161 
usg
 
	gWTF
::
ba64URLDecode
;

	@text/CString.cpp

27 
	~"cfig.h
"

28 
	~"CSg.h
"

30 
	~<rg.h
>

31 
	~<wtf/SgHash.h
>

33 
mea
 
	gWTF
 {

35 
	gPassRefP
<
	gCSgBufr
> CSgBufr::
Unlized
(
size_t
 
ngth
)

37 
RELEASE_ASSERT
(
ngth
 < (
d
::
numic_lims
<>::
max
(- (
CSgBufr
)));

40 
size_t
 
	gsize
 = (
CSgBufr
+ 
ngth
 + 1;

41 
CSgBufr
* 
	grgBufr
 = 
ic_
<CSgBufr*>(
Mloc
(
size
));

42  
adtRef
(
w
 (
NNu
, 
rgBufr

CSgBufr
(
ngth
));

45 
	gCSg
::
CSg
(cڡ * 
r
)

47 i(!
r
)

50 

(
r
, 

(str));

53 
	gCSg
::
CSg
(cڡ * 
r
, 
size_t
 
ngth
)

55 i(!
	gr
) {

56 
ASSERT
(!
ngth
);

60 

(
r
, 
ngth
);

63 
	gCSg
::

(cڡ * 
r
, 
size_t
 
ngth
)

65 
ASSERT
(
r
);

67 
	gm_bufr
 = 
CSgBufr
::
Unlized
(
ngth
);

68 
memy
(
m_bufr
->
mubDa
(), 
r
, 
ngth
);

69 
	gm_bufr
->
mubDa
()[
ngth
] = '\0';

72 * 
	gCSg
::
mubDa
()

74 
cyBufrIfNded
();

75 i(!
	gm_bufr
)

77  
	gm_bufr
->
mubDa
();

80 
CSg
 
	gCSg
::
wUnlized
(
size_t
 
ngth
, *& 
chaBufr
)

82 
CSg
 
	gsu
;

83 
	gsu
.
	gm_bufr
 = 
CSgBufr
::
Unlized
(
ngth
);

84 * 
	gbys
 = 
su
.
m_bufr
->
mubDa
();

85 
	gbys
[
ngth
] = '\0';

86 
	gchaBufr
 = 
bys
;

87  
	gsu
;

90 
	gCSg
::
cyBufrIfNded
()

92 i(!
m_bufr
 || m_bufr->
hasORef
())

95 
	gRefP
<
	gCSgBufr
> 
	gbufr
 = 
m_bufr
.
a
();

96 
size_t
 
	gngth
 = 
bufr
->
ngth
();

97 
	gm_bufr
 = 
CSgBufr
::
Unlized
(
ngth
);

98 
memy
(
m_bufr
->
mubDa
(), 
bufr
->
da
(), 
ngth
 + 1);

101 
bo
 
	gCSg
::
isSaToSdToAnhThad
() const

103  !
m_bufr
 || m_bufr->
hasORef
();

106 
bo
 
	gݔ
==(cڡ 
CSg
& 
a
, cڡ 
	gCSg
& 
	gb
)

108 i(
	ga
.
isNu
(!
b
.isNull())

109  
l
;

110 i(
	ga
.
ngth
(!
b
.length())

111  
l
;

112  !
memcmp
(
a
.
da
(), 
b
.da(),.
ngth
());

115 
bo
 
	gݔ
==(cڡ 
CSg
& 
a
, cڡ * 
	gb
)

117 i(
	ga
.
isNu
(!!
b
)

118  
l
;

119 i(!
	gb
)

120  
	gue
;

121  !
rcmp
(
a
.
da
(), 
b
);

124 
	gCSg
::
hash
() const

126 i(
isNu
())

128 
SgHash
 
	ghash
;

129 cڡ * 
	gr
 = 
da
(); *ptr; ++ptr)

130 
	ghash
.
addCha
(*
r
);

131  
	ghash
.
hash
();

134 
bo
 
	gݔ
<(cڡ 
	gCSg
& 
	ga
, cڡ CSg& 
	gb
)

136 i(
	ga
.
isNu
())

137  !
	gb
.
isNu
();

138 i(
	gb
.
isNu
())

139  
	gl
;

140  
rcmp
(
a
.
da
(), 
b
.data()) < 0;

143 
bo
 
	gCSgHash
::
equ
(cڡ 
CSg
& 
a
, cڡ CSg& 
b
)

145 i(
	ga
.
isHashTabDedVue
())

146  
	gb
.
isHashTabDedVue
();

147 i(
	gb
.
isHashTabDedVue
())

148  
	gl
;

149  
	ga
 =
b
;

	@text/CString.h

26 #ide
CSg_h


27 
	#CSg_h


	)

29 
	~<wtf/HashFunis.h
>

30 
	~<wtf/HashTs.h
>

31 
	~<wtf/PassRefP.h
>

32 
	~<wtf/RefCoued.h
>

34 
mea
 
	gWTF
 {

38 
ass
 
	gCSgBufr
 : 
public
 
RefCoued
<
CSgBufr
> {

39 
public
:

40 cڡ * 
da
({  
mubDa
(); }

41 
size_t
 
ngth
(cڡ {  
	gm_ngth
; }

43 
	give
:

44 
nd
 
ass
 
CSg
;

46 
	gPassRefP
<
	gCSgBufr
> 
Unlized
(
size_t
 
ngth
);

48 
CSgBufr
(
size_t
 
ngth
: 
m_ngth
(length) { }

49 * 
mubDa
({  
t__r
<*>(
this
 + 1); }

51 cڡ 
size_t
 
	gm_ngth
;

56 as
	cCSg
 {

57 
	gpublic
:

58 
CSg
() { }

59 
WTF_EXPORT_PRIVATE
 
CSg
(const *);

60 
WTF_EXPORT_PRIVATE
 
CSg
(cڡ *, 
size_t
 
ngth
);

61 
CSg
(
CSgBufr
* 
bufr
: 
m_bufr
(buffer) { }

62 
WTF_EXPORT_PRIVATE
 
CSg
 
wUnlized
(
size_t
 
ngth
, *& 
chaBufr
);

63 
CSg
(
HashTabDedVueTy
: 
m_bufr
(
HashTabDedVue
) { }

65 cڡ * 
da
() const

67  
m_bufr
 ? m_bufr->
da
() : 0;

69 
WTF_EXPORT_PRIVATE
 * 
mubDa
();

70 
size_t
 
ngth
() const

72  
	gm_bufr
 ? m_bufr->
ngth
() : 0;

75 
bo
 
isNu
(cڡ {  !
	gm_bufr
; }

76 
bo
 
isSaToSdToAnhThad
() const;

78 
CSgBufr
* 
bufr
(cڡ {  
	gm_bufr
.
g
(); }

80 
bo
 
isHashTabDedVue
(cڡ {  
	gm_bufr
.isHashTableDeletedValue(); }

82 
WTF_EXPORT_PRIVATE
 
hash
() const;

84 
	give
:

85 
cyBufrIfNded
();

86 

(cڡ *, 
size_t
 
ngth
);

87 
	gRefP
<
	gCSgBufr
> 
	gm_bufr
;

90 
WTF_EXPORT_PRIVATE
 
bo
 
	gݔ
==(cڡ 
CSg
& 
a
, cڡ 
	gCSg
& 
	gb
);

91 
le
 
bo
 
	gݔ
!=(cڡ 
CSg
& 
a
, cڡ 
	gCSg
& 
	gb
{  !(
	ga
 =
b
); }

92 
WTF_EXPORT_PRIVATE
 
bo
 
	gݔ
==(cڡ 
CSg
& 
a
, cڡ * 
	gb
);

93 
le
 
bo
 
	gݔ
!=(cڡ 
CSg
& 
a
, cڡ * 
	gb
{  !(
	ga
 =
b
); }

94 
WTF_EXPORT_PRIVATE
 
bo
 
	gݔ
<(cڡ 
	gCSg
& 
	ga
, cڡ CSg& 
	gb
);

96 
	sCSgHash
 {

97 
hash
(cڡ 
CSg
& 
rg
{  
	grg
.hash(); }

98 
WTF_EXPORT_PRIVATE
 
bo
 
equ
(cڡ 
CSg
& 
a
, cڡ CSg& 
b
);

99 cڡ 
bo
 
	gToComToEmyOrDed
 = 
ue
;

102 
	gme
<
tyme
 
	gT
> 
	gDeuHash
;

103 
	gme
<> 
	gDeuHash
<
	gCSg
> {

104 
CSgHash
 
	tHash
;

107 
	gme
<
tyme
 
	gT
> 
	gHashTs
;

108 
	gme
<> 
	gHashTs
<
	gCSg
> : 
SimeCssHashTs
<
CSg
> { };

112 
usg
 
	gWTF
::
CSg
;

	@text/ConversionMode.h

26 #ide
CvsiMode_h


27 
	#CvsiMode_h


	)

29 
mea
 
	gWTF
 {

32 
	gLCvsi
,

33 
	gSiCvsi
,

34 
	gSiCvsiRcgUaedSuogesWhFFFD
,

35 } 
	tCvsiMode
;

39 
usg
 
	gWTF
::
CvsiMode
;

40 
usg
 
	gWTF
::
LCvsi
;

41 
usg
 
	gWTF
::
SiCvsi
;

42 
usg
 
	gWTF
::
SiCvsiRcgUaedSuogesWhFFFD
;

	@text/IntegerToStringConversion.h

22 #ide
IegToSgCvsi_h


23 
	#IegToSgCvsi_h


	)

25 
	~"SgBud.h
"

27 
mea
 
	gWTF
 {

29 
	ePosiveOrNegiveNumb
 {

30 
	gPosiveNumb
,

31 
	gNegiveNumb


34 
	gme
<
tyme
 
	gT
> 
	gIegToSgCvsiT
;

36 
	gme
<> 
	gIegToSgCvsiT
<
	gAtomicSg
> {

37 
AtomicSg
 
	tRuTy
;

38 
	tAddiڮArgumtTy
;

39 
RuTy
 
ush
(
LCh
* 
chas
, 
ngth
, *{  
AtomicSg
(characters,ength); }

41 
	gme
<> 
	gIegToSgCvsiT
<
	gSg
> {

42 
Sg
 
	tRuTy
;

43 
	tAddiڮArgumtTy
;

44 
RuTy
 
ush
(
LCh
* 
chas
, 
ngth
, *{  
Sg
(characters,ength); }

46 
	gme
<> 
	gIegToSgCvsiT
<
	gSgBud
> {

47 
	tRuTy
;

48 
SgBud
 
	tAddiڮArgumtTy
;

49 
RuTy
 
ush
(
LCh
* 
chas
, 
ngth
, 
SgBud
* 
rgBud
{ 
	grgBud
->
nd
(characters,ength); }

52 
	gme
<
tyme
 
	gT
,ym
	gUnsigdIegTy
, 
PosiveOrNegiveNumb
 
	gNumbTy
,ym
	gAddiڮArgumtTy
>

53 
tyme
 
	gIegToSgCvsiT
<
	gT
>::
RuTy
 
numbToSgIm
(
UnsigdIegTy
 
numb
, 
AddiڮArgumtTy
 
addiڮArgumt
)

55 
LCh
 
	gbuf
[(
UnsigdIegTy
) * 3 + 1];

56 
LCh
* 
	gd
 = 
buf
 + 
WTF_ARRAY_LENGTH
(buf);

57 
LCh
* 
	gp
 = 
d
;

60 *--
	gp
 = 
ic_
<
LCh
>((
numb
 % 10) + '0');

61 
	gnumb
 /= 10;

62 } 
	gnumb
);

64 i(
	gNumbTy
 =
NegiveNumb
)

65 *--
p
 = '-';

67  
	gIegToSgCvsiT
<
	gT
>::
ush
(
p
, 
ic_
<>(
d
 -), 
addiڮArgumt
);

70 
	gme
<
tyme
 
	gT
,ym
	gSigdIegTy
>

71 
le
 
tyme
 
	gIegToSgCvsiT
<
	gT
>::
RuTy
 
numbToSgSigd
(
SigdIegTy
 
numb
,ym
IegToSgCvsiT
<
T
>::
AddiڮArgumtTy
* 
addiڮArgumt
 = 
nuαr
)

73 i(
numb
 < 0)

74  
numbToSgIm
<
T
, 
tyme
 
d
::
make_unsigd
<
SigdIegTy
>::
ty
, 
NegiveNumb
>(-
numb
, 
addiڮArgumt
);

75  
	gnumbToSgIm
<
	gT
, 
tyme
 
	gd
::
make_unsigd
<
SigdIegTy
>::
ty
, 
	gPosiveNumb
>(
	gnumb
, 
	gaddiڮArgumt
);

78 
	gme
<
tyme
 
	gT
,ym
	gUnsigdIegTy
>

79 
le
 
tyme
 
	gIegToSgCvsiT
<
	gT
>::
RuTy
 
numbToSgUnsigd
(
UnsigdIegTy
 
numb
,ym
IegToSgCvsiT
<
T
>::
AddiڮArgumtTy
* 
addiڮArgumt
 = 
nuαr
)

81  
numbToSgIm
<
T
, 
UnsigdIegTy
, 
PosiveNumb
>(
numb
, 
addiڮArgumt
);

	@text/LChar.h

27 #ide
LCh_h


28 
	#LCh_h


	)

33 
	tLCh
;

	@text/StringBuffer.h

29 #ide
SgBufr_h


30 
	#SgBufr_h


	)

32 
	~<wtf/Asis.h
>

33 
	~<lims
>

34 
	~<unicode/utys.h
>

36 
mea
 
	gWTF
 {

38 
	gme
 <
tyme
 
	gChTy
>

39 as
	cSgBufr
 {

40 
WTF_MAKE_NONCOPYABLE
(
SgBufr
);

41 
	gpublic
:

42 
exic
 
SgBufr
(
ngth
)

43 : 
m_ngth
(
ngth
)

44 , 
m_da
(
m_ngth
 ? 
ic_
<
ChTy
*>(
Mloc
((
Checked
<
size_t
>(m_ngth* (ChTy)).
unG
()): 
nuαr
)

48 ~
SgBufr
()

50 
Fe
(
m_da
);

53 
shrk
(
wLgth
)

55 
ASSERT
(
wLgth
 <
m_ngth
);

56 
	gm_ngth
 = 
wLgth
;

59 
size
(
wLgth
)

61 i(
	gwLgth
 > 
	gm_ngth
) {

62 i(
	gwLgth
 > 
	gd
::
numic_lims
<>::
max
(/ (
UCh
))

63 
CRASH
();

64 
	gm_da
 = 
ic_
<
UCh
*>(
Roc
(
m_da
, 
wLgth
 * (UChar)));

66 
	gm_ngth
 = 
wLgth
;

69 
ngth
(cڡ {  
	gm_ngth
; }

70 
ChTy
* 
chas
({  
	gm_da
; }

72 
	gChTy
& 
	gݔ
[](
	gi
{ 
ASSERT_WITH_SECURITY_IMPLICATION
(
i
 < 
m_ngth
);  
	gm_da
[i]; }

74 
	gMlocP
<
	gChTy
> 
a
()

76 
ChTy
* 
	gda
 = 
m_da
;

77 
	gm_da
 = 0;

78  
adtMlocP
(
da
);

81 
	give
:

82 
m_ngth
;

83 
ChTy
* 
	gm_da
;

88 
usg
 
	gWTF
::
SgBufr
;

	@text/StringBuilder.cpp

27 
	~"cfig.h
"

28 
	~"SgBud.h
"

30 
	~"IegToSgCvsi.h
"

31 
	~"WTFSg.h
"

32 
	~<wtf/dt.h
>

34 
mea
 
	gWTF
 {

36 
exndedCacy
(
cy
, 
quedLgth
)

38 cڡ 
	gmimumCacy
 = 16;

39  
	gd
::
max
(
quedLgth
, 
d
::max(
mimumCacy
, 
cy
 * 2));

42 
	gSgBud
::
ifySg
() const

45 i(!
m_rg
.
isNu
()) {

46 
ASSERT
(
m_rg
.
ngth
(=
m_ngth
);

51 i(!
	gm_ngth
) {

52 
	gm_rg
 = 
SgIm
::
emy
();

57 
ASSERT
(
m_bufr
 && 
m_ngth
 <m_bufr->
ngth
());

58 i(
	gm_ngth
 =
m_bufr
->
ngth
())

59 
m_rg
 = 
m_bufr
.
g
();

61 
	gm_rg
 = 
SgIm
::
SubrgShgIm
(
m_bufr
, 0, 
m_ngth
);

64 
	gSgBud
::
size
(
wSize
)

67 
ASSERT
(
wSize
 <
m_ngth
);

68 i(
	gwSize
 =
m_ngth
)

70 
ASSERT
(
m_ngth
);

73 i(
	gm_bufr
) {

74 
	gm_rg
 = 
Sg
();

75 i(!
	gm_bufr
->
hasORef
()) {

76 i(
	gm_bufr
->
is8B
())

77 
loBufr
(
m_bufr
->
chas8
(), m_bufr->
ngth
());

79 
loBufr
(
m_bufr
->
chas16
(), m_bufr->
ngth
());

81 
	gm_ngth
 = 
wSize
;

86 
ASSERT
(!
m_rg
.
isEmy
());

87 
ASSERT
(
m_ngth
 =
m_rg
.
ngth
());

88 
ASSERT
(
wSize
 < 
m_rg
.
ngth
());

89 
	gm_ngth
 = 
wSize
;

90 
	gm_rg
 = 
SgIm
::
SubrgShgIm
(
m_rg
.
im
(), 0, 
wSize
);

95 
	gSgBud
::
loBufr
(cڡ 
LCh
* 
cutChas
, 
quedLgth
)

97 
ASSERT
(
m_is8B
);

99 
	gRefP
<
	gSgIm
> 
	gbufr
 = 
SgIm
::
Unlized
(
quedLgth
, 
m_bufrChas8
);

100 
memy
(
m_bufrChas8
, 
cutChas
, 
ic_
<
size_t
>(
m_ngth
* (
LCh
));

103 
	gm_bufr
 = 
bufr
.
a
();

104 
	gm_rg
 = 
Sg
();

109 
	gSgBud
::
loBufr
(cڡ 
UCh
* 
cutChas
, 
quedLgth
)

111 
ASSERT
(!
m_is8B
);

113 
	gRefP
<
	gSgIm
> 
	gbufr
 = 
SgIm
::
Unlized
(
quedLgth
, 
m_bufrChas16
);

114 
memy
(
m_bufrChas16
, 
cutChas
, 
ic_
<
size_t
>(
m_ngth
* (
UCh
));

117 
	gm_bufr
 = 
bufr
.
a
();

118 
	gm_rg
 = 
Sg
();

123 
	gSgBud
::
loBufrUpCvt
(cڡ 
LCh
* 
cutChas
, 
quedLgth
)

125 
ASSERT
(
m_is8B
);

127 
	gRefP
<
	gSgIm
> 
	gbufr
 = 
SgIm
::
Unlized
(
quedLgth
, 
m_bufrChas16
);

128 
	gi
 = 0; i < 
	gm_ngth
; ++i)

129 
	gm_bufrChas16
[
i
] = 
cutChas
[i];

131 
	gm_is8B
 = 
l
;

134 
	gm_bufr
 = 
bufr
.
a
();

135 
	gm_rg
 = 
Sg
();

138 
	gme
 <>

139 
	gSgBud
::
loBufr
<
LCh
>(
quedLgth
)

143 
m_rg
 = 
Sg
();

145 
ASSERT
(
m_is8B
);

146 
ASSERT
(
m_bufr
->
is8B
());

148 i(
	gm_bufr
->
hasORef
())

149 
	gm_bufr
 = 
SgIm
::
lo
(
m_bufr
.
a
(), 
quedLgth
, 
m_bufrChas8
);

151 
loBufr
(
m_bufr
->
chas8
(), 
quedLgth
);

154 
	gme
 <>

155 
	gSgBud
::
loBufr
<
UCh
>(
quedLgth
)

159 
m_rg
 = 
Sg
();

161 i(
	gm_bufr
->
is8B
())

162 
loBufrUpCvt
(
m_bufr
->
chas8
(), 
quedLgth
);

163 i(
	gm_bufr
->
hasORef
())

164 
	gm_bufr
 = 
SgIm
::
lo
(
m_bufr
.
a
(), 
quedLgth
, 
m_bufrChas16
);

166 
loBufr
(
m_bufr
->
chas16
(), 
quedLgth
);

169 
	gSgBud
::
rveCacy
(
wCacy
)

171 i(
m_bufr
) {

173 i(
wCacy
 > 
m_bufr
->
ngth
()) {

174 i(
m_bufr
->
is8B
())

175 
loBufr
<
LCh
>(
wCacy
);

177 
	gloBufr
<
	gUCh
>(
	gwCacy
);

181 i(
	gwCacy
 > 
	gm_ngth
) {

182 i(!
	gm_ngth
) {

183 
LCh
* 
	gnuPhd
 = 0;

184 
loBufr
(
nuPhd
, 
wCacy
);

185 } i(
	gm_rg
.
is8B
())

186 
loBufr
(
m_rg
.
chas8
(), 
wCacy
);

188 
loBufr
(
m_rg
.
chas16
(), 
wCacy
);

195 
	gme
 <
tyme
 
	gChTy
>

196 
ALWAYS_INLINE
 
ChTy
* 
	gSgBud
::
ndUnlized
(
ngth
)

198 
ASSERT
(
ngth
);

201 
	gquedLgth
 = 
ngth
 + 
m_ngth
;

202 i(
	gquedLgth
 < 
	gngth
)

203 
CRASH
();

205 i((
	gm_bufr
&& (
	gquedLgth
 <
m_bufr
->
ngth
())) {

207 
ASSERT
(
m_bufr
->
ngth
(>
m_ngth
);

208 
	gcutLgth
 = 
m_ngth
;

209 
	gm_rg
 = 
Sg
();

210 
	gm_ngth
 = 
quedLgth
;

211  
	ggBufrChas
<
	gChTy
>(+ 
	gcutLgth
;

214  
	gndUnlizedSlow
<
	gChTy
>(
	gquedLgth
);

219 
	gme
 <
tyme
 
	gChTy
>

220 
ChTy
* 
	gSgBud
::
ndUnlizedSlow
(
quedLgth
)

222 
ASSERT
(
quedLgth
);

224 i(
	gm_bufr
) {

226 
ASSERT
(
m_bufr
->
ngth
(>
m_ngth
);

228 
	gloBufr
<
	gChTy
>(
exndedCacy
(
cy
(), 
quedLgth
));

230 
ASSERT
(
m_rg
.
ngth
(=
m_ngth
);

231 
loBufr
(
m_ngth
 ? 
m_rg
.
chas
<
ChTy
>(: 0, 
exndedCacy
(
cy
(), 
quedLgth
));

234 
ChTy
* 
	gsu
 = 
gBufrChas
<ChTy>(+ 
m_ngth
;

235 
	gm_ngth
 = 
quedLgth
;

236  
	gsu
;

239 
	gSgBud
::
nd
(cڡ 
UCh
* 
chas
, 
ngth
)

241 i(!
	gngth
)

244 
ASSERT
(
chas
);

246 i(
	gm_is8B
) {

247 i(
	gngth
 =1 && !(*
chas
 & ~0xff)) {

249 
LCh
 
lCh
 = 
ic_
<LCh>(*
chas
);

250 
nd
(&
lCh
, 1);

255 
	gquedLgth
 = 
ngth
 + 
m_ngth
;

256 i(
	gquedLgth
 < 
	gngth
)

257 
CRASH
();

259 i(
	gm_bufr
) {

261 
ASSERT
(
m_bufr
->
ngth
(>
m_ngth
);

263 
loBufrUpCvt
(
m_bufr
->
chas8
(), 
exndedCacy
(
cy
(), 
quedLgth
));

265 
ASSERT
(
m_rg
.
ngth
(=
m_ngth
);

266 
loBufrUpCvt
(
m_rg
.
isNu
(? 0 : m_rg.
chas8
(), 
exndedCacy
(
cy
(), 
quedLgth
));

269 
memy
(
m_bufrChas16
 + 
m_ngth
, 
chas
, 
ic_
<
size_t
>(
ngth
* (
UCh
));

270 
	gm_ngth
 = 
quedLgth
;

272 
memy
(
ndUnlized
<
UCh
>(
ngth
), 
chas
, 
ic_
<
size_t
>(length) * (UChar));

275 
	gSgBud
::
nd
(cڡ 
LCh
* 
chas
, 
ngth
)

277 i(!
	gngth
)

279 
ASSERT
(
chas
);

281 i(
	gm_is8B
) {

282 
LCh
* 
	gde
 = 
ndUnlized
<LCh>(
ngth
);

283 i(
	gngth
 > 8)

284 
memy
(
de
, 
chas
, 
ic_
<
size_t
>(
ngth
* (
LCh
));

286 cڡ 
LCh
* 
	gd
 = 
chas
 + 
ngth
;

287 
	gchas
 < 
	gd
)

288 *(
	gde
++*(
chas
++);

291 
UCh
* 
	gde
 = 
ndUnlized
<UCh>(
ngth
);

292 cڡ 
LCh
* 
	gd
 = 
chas
 + 
ngth
;

293 
	gchas
 < 
	gd
)

294 *(
	gde
++*(
chas
++);

298 
	gSgBud
::
ndNumb
(
numb
)

300 
numbToSgSigd
<
SgBud
>(
numb
, 
	gthis
);

303 
	gSgBud
::
ndNumb
(
numb
)

305 
numbToSgUnsigd
<
SgBud
>(
numb
, 
	gthis
);

308 
	gSgBud
::
ndNumb
(
numb
)

310 
numbToSgSigd
<
SgBud
>(
numb
, 
	gthis
);

313 
	gSgBud
::
ndNumb
(
numb
)

315 
numbToSgUnsigd
<
SgBud
>(
numb
, 
	gthis
);

318 
	gSgBud
::
ndNumb
(
numb
)

320 
numbToSgSigd
<
SgBud
>(
numb
, 
	gthis
);

323 
	gSgBud
::
ndNumb
(
numb
)

325 
numbToSgUnsigd
<
SgBud
>(
numb
, 
	gthis
);

328 
	gSgBud
::
ndNumb
(
numb
, 
ecisi
, 
TgZosTruntgPicy
 
agZosTruntgPicy
)

330 
NumbToSgBufr
 
	gbufr
;

331 
nd
(
numbToFixedPcisiSg
(
numb
, 
ecisi
, 
bufr
, 
agZosTruntgPicy
 =
TrunTgZos
));

334 
	gSgBud
::
ndECMAStNumb
(
numb
)

336 
NumbToSgBufr
 
bufr
;

337 
nd
(
numbToSg
(
numb
, 
bufr
));

340 
	gSgBud
::
ndFixedWidthNumb
(
numb
, 
decimPs
)

342 
NumbToSgBufr
 
	gbufr
;

343 
nd
(
numbToFixedWidthSg
(
numb
, 
decimPs
, 
bufr
));

346 
bo
 
	gSgBud
::
nShrk
() const

349  
m_bufr
 && m_bufr->
ngth
(> (
m_ngth
 + (m_length >> 2));

352 
	gSgBud
::
shrkToF
()

354 i(
nShrk
()) {

355 i(
m_is8B
)

356 
loBufr
<
LCh
>(
m_ngth
);

358 
	gloBufr
<
	gUCh
>(
	gm_ngth
);

359 
	gm_rg
 = 
m_bufr
.
a
();

	@text/StringBuilder.h

27 #ide
SgBud_h


28 
	#SgBud_h


	)

30 
	~<wtf/xt/AtomicSg.h
>

31 
	~<wtf/xt/SgVw.h
>

32 
	~<wtf/xt/WTFSg.h
>

34 
mea
 
	gWTF
 {

36 as
	cSgBud
 {

38 
WTF_MAKE_NONCOPYABLE
(
SgBud
);

40 
	gpublic
:

41 
SgBud
()

42 : 
m_ngth
(0)

43 , 
m_is8B
(
ue
)

44 , 
m_bufrChas8
(0)

48 
WTF_EXPORT_PRIVATE
 
nd
(cڡ 
UCh
*, );

49 
WTF_EXPORT_PRIVATE
 
nd
(cڡ 
LCh
*, );

51 
ALWAYS_INLINE
 
nd
(cڡ * 
chas
, 
ngth
{d(
t_
<cڡ 
LCh
*>(characters),ength); }

53 
nd
(cڡ 
Sg
& 
rg
)

55 i(!
	grg
.
ngth
())

60 i(!
	gm_ngth
 && !
	gm_bufr
) {

61 
	gm_rg
 = 
rg
;

62 
	gm_ngth
 = 
rg
.
ngth
();

63 
	gm_is8B
 = 
m_rg
.
is8B
();

67 i(
	grg
.
is8B
())

68 
nd
(
rg
.
chas8
(), sg.
ngth
());

70 
nd
(
rg
.
chas16
(), sg.
ngth
());

73 
nd
(cڡ 
SgBud
& 
h
)

75 i(!
	gh
.
	gm_ngth
)

80 i(!
	gm_ngth
 && !
	gm_bufr
 && !
	gh
.
	gm_rg
.
isNu
()) {

81 
	gm_rg
 = 
h
.
m_rg
;

82 
	gm_ngth
 = 
h
.
m_ngth
;

86 i(
	gh
.
is8B
())

87 
nd
(
h
.
chas8
(), oth.
m_ngth
);

89 
nd
(
h
.
chas16
(), oth.
m_ngth
);

92 
nd
(
SgVw
 
rgVw
)

94 i(
	grgVw
.
is8B
())

95 
nd
(
rgVw
.
chas8
(), sgVw.
ngth
());

97 
nd
(
rgVw
.
chas16
(), sgVw.
ngth
());

100 
nd
(cڡ 
Sg
& 
rg
, 
offt
, 
ngth
)

102 i(!
	grg
.
ngth
())

105 i((
	gofft
 + 
	gngth
> 
	grg
.
ngth
())

108 i(
	grg
.
is8B
())

109 
nd
(
rg
.
chas8
(+ 
offt
, 
ngth
);

111 
nd
(
rg
.
chas16
(+ 
offt
, 
ngth
);

114 
nd
(cڡ * 
chas
)

116 i(
	gchas
)

117 
nd
(
chas
, 

(characters));

120 
nd
(
UCh
 
c
)

122 i(
	gm_bufr
 && 
	gm_ngth
 < m_bufr->
ngth
(&& 
	gm_rg
.
isNu
()) {

123 i(!
	gm_is8B
) {

124 
	gm_bufrChas16
[
m_ngth
++] = 
c
;

128 i(!(
	gc
 & ~0xff)) {

129 
	gm_bufrChas8
[
m_ngth
++] = 
ic_
<
LCh
>(
c
);

133 
nd
(&
c
, 1);

136 
nd
(
LCh
 
c
)

138 i(
	gm_bufr
 && 
	gm_ngth
 < m_bufr->
ngth
(&& 
	gm_rg
.
isNu
()) {

139 i(
	gm_is8B
)

140 
	gm_bufrChas8
[
m_ngth
++] = 
c
;

142 
	gm_bufrChas16
[
m_ngth
++] = 
c
;

144 
nd
(&
c
, 1);

147 
nd
(
c
)

149 
nd
(
ic_
<
LCh
>(
c
));

152 
nd
(
UCh32
 
c
)

154 i(
U_IS_BMP
(
c
)) {

155 
nd
(
ic_
<
UCh
>(
c
));

158 
nd
(
U16_LEAD
(
c
));

159 
nd
(
U16_TRAIL
(
c
));

162 
	gme
<
	gchasCou
>

163 
ALWAYS_INLINE
 
ndL
(cڡ (&
chas
)[
chasCou
]{ 
nd
(characters, charactersCount - 1); }

165 
WTF_EXPORT_PRIVATE
 
ndNumb
();

166 
WTF_EXPORT_PRIVATE
 
ndNumb
();

167 
WTF_EXPORT_PRIVATE
 
ndNumb
();

168 
WTF_EXPORT_PRIVATE
 
ndNumb
();

169 
WTF_EXPORT_PRIVATE
 
ndNumb
();

170 
WTF_EXPORT_PRIVATE
 
ndNumb
();

171 
WTF_EXPORT_PRIVATE
 
ndNumb
(, 
ecisi
 = 6, 
TgZosTruntgPicy
 = 
TrunTgZos
);

172 
WTF_EXPORT_PRIVATE
 
ndECMAStNumb
();

173 
WTF_EXPORT_PRIVATE
 
ndFixedWidthNumb
(, 
decimPs
);

175 
Sg
 
toSg
()

177 
shrkToF
();

178 i(
	gm_rg
.
isNu
())

179 
ifySg
();

180  
	gm_rg
;

183 cڡ 
	gSg
& 
toSgPrveCacy
() const

185 i(
	gm_rg
.
isNu
())

186 
ifySg
();

187  
	gm_rg
;

190 
AtomicSg
 
toAtomicSg
() const

192 i(!
	gm_ngth
)

193  
	gemyAtom
;

196 i(
nShrk
()) {

197 i(
is8B
())

198  
AtomicSg
(
chas8
(), 
ngth
());

199  
AtomicSg
(
chas16
(), 
ngth
());

202 i(!
	gm_rg
.
isNu
())

203  
AtomicSg
(
m_rg
);

205 
ASSERT
(
m_bufr
);

206  
AtomicSg
(
m_bufr
.
g
(), 0, 
m_ngth
);

209 
ngth
() const

211  
	gm_ngth
;

214 
bo
 
isEmy
(cڡ {  !
	gm_ngth
; }

216 
WTF_EXPORT_PRIVATE
 
rveCacy
(
wCacy
);

218 
cy
() const

220  
	gm_bufr
 ? m_bufr->
ngth
(: 
m_ngth
;

223 
WTF_EXPORT_PRIVATE
 
size
(
wSize
);

225 
WTF_EXPORT_PRIVATE
 
bo
 
nShrk
() const;

227 
WTF_EXPORT_PRIVATE
 
shrkToF
();

229 
UCh
 
	gݔ
[](
	gi
) const

231 
ASSERT_WITH_SECURITY_IMPLICATION
(
i
 < 
m_ngth
);

232 i(
	gm_is8B
)

233  
chas8
()[
i
];

234  
chas16
()[
i
];

237 cڡ 
LCh
* 
chas8
() const

239 
ASSERT
(
m_is8B
);

240 i(!
	gm_ngth
)

242 i(!
	gm_rg
.
isNu
())

243  
	gm_rg
.
chas8
();

244 
ASSERT
(
m_bufr
);

245  
	gm_bufr
->
chas8
();

248 cڡ 
UCh
* 
chas16
() const

250 
ASSERT
(!
m_is8B
);

251 i(!
	gm_ngth
)

253 i(!
	gm_rg
.
isNu
())

254  
	gm_rg
.
chas16
();

255 
ASSERT
(
m_bufr
);

256  
	gm_bufr
->
chas16
();

259 
bo
 
is8B
(cڡ {  
	gm_is8B
; }

261 
r
()

263 
	gm_ngth
 = 0;

264 
	gm_rg
 = 
Sg
();

265 
	gm_bufr
 = 0;

266 
	gm_bufrChas8
 = 0;

267 
	gm_is8B
 = 
ue
;

270 
sw
(
SgBud
& 
rgBud
)

272 
	gd
::
sw
(
m_ngth
, 
rgBud
.m_length);

273 
	gm_rg
.
sw
(
rgBud
.
m_rg
);

274 
	gm_bufr
.
sw
(
rgBud
.
m_bufr
);

275 
	gd
::
sw
(
m_is8B
, 
rgBud
.m_is8Bit);

276 
	gd
::
sw
(
m_bufrChas8
, 
rgBud
.m_bufferCharacters8);

279 
	give
:

280 
loBufr
(cڡ 
LCh
* 
cutChas
, 
quedLgth
);

281 
loBufr
(cڡ 
UCh
* 
cutChas
, 
quedLgth
);

282 
loBufrUpCvt
(cڡ 
LCh
* 
cutChas
, 
quedLgth
);

283 
	gme
 <
tyme
 
	gChTy
>

284 
loBufr
(
quedLgth
);

285 
	gme
 <
tyme
 
	gChTy
>

286 
ALWAYS_INLINE
 
ChTy
* 
ndUnlized
(
ngth
);

287 
	gme
 <
tyme
 
	gChTy
>

288 
ChTy
* 
ndUnlizedSlow
(
ngth
);

289 
	gme
 <
tyme
 
	gChTy
>

290 
ALWAYS_INLINE
 
ChTy
 * 
gBufrChas
();

291 
WTF_EXPORT_PRIVATE
 
ifySg
() const;

293 
	gm_ngth
;

294 
mub
 
Sg
 
	gm_rg
;

295 
	gRefP
<
	gSgIm
> 
	gm_bufr
;

296 
bo
 
	gm_is8B
;

298 
LCh
* 
	gm_bufrChas8
;

299 
UCh
* 
	gm_bufrChas16
;

303 
	gme
 <>

304 
ALWAYS_INLINE
 
LCh
* 
	gSgBud
::
gBufrChas
<LChar>()

306 
ASSERT
(
m_is8B
);

307  
	gm_bufrChas8
;

310 
	gme
 <>

311 
ALWAYS_INLINE
 
UCh
* 
	gSgBud
::
gBufrChas
<UChar>()

313 
ASSERT
(!
m_is8B
);

314  
	gm_bufrChas16
;

317 
	gme
 <
tyme
 
	gChTy
>

318 
bo
 
	$equ
(cڡ 
SgBud
& 
s
, cڡ 
ChTy
* 
bufr
, 
ngth
)

320 i(
s
.
	`ngth
(!
ngth
)

321  
l
;

323 i(
s
.
	`is8B
())

324  
	`equ
(
s
.
	`chas8
(), 
bufr
, 
ngth
);

326  
	`equ
(
s
.
	`chas16
(), 
bufr
, 
ngth
);

327 
	}
}

329 
	gme
 <
tyme
 
	gSgTy
>

330 
bo
 
	$equ
(cڡ 
SgBud
& 
a
, cڡ 
SgTy
& 
b
)

332 i(
a
.
	`ngth
(!
b
.length())

333  
l
;

335 i(!
a
.
	`ngth
())

336  
ue
;

338 i(
a
.
	`is8B
()) {

339 i(
b
.
	`is8B
())

340  
	`equ
(
a
.
	`chas8
(), 
b
.chas8(),.
	`ngth
());

341  
	`equ
(
a
.
	`chas8
(), 
b
.
	`chas16
(),.
	`ngth
());

344 i(
b
.
	`is8B
())

345  
	`equ
(
a
.
	`chas16
(), 
b
.
	`chas8
(),.
	`ngth
());

346  
	`equ
(
a
.
	`chas16
(), 
b
.chas16(),.
	`ngth
());

347 
	}
}

349 
le
 
bo
 
	gݔ
==(cڡ 
SgBud
& 
a
, cڡ 
	gSgBud
& 
	gb
{  
equ
, 
b
); }

350 
le
 
bo
 
	gݔ
!=(cڡ 
SgBud
& 
a
, cڡ 
	gSgBud
& 
	gb
{  !
equ
, 
b
); }

351 
le
 
bo
 
	gݔ
==(cڡ 
SgBud
& 
a
, cڡ 
	gSg
& 
	gb
{  
equ
, 
b
); }

352 
le
 
bo
 
	gݔ
!=(cڡ 
SgBud
& 
a
, cڡ 
	gSg
& 
	gb
{  !
equ
, 
b
); }

353 
le
 
bo
 
	gݔ
==(cڡ 
Sg
& 
a
, cڡ 
	gSgBud
& 
	gb
{  
equ
(
b
,); }

354 
le
 
bo
 
	gݔ
!=(cڡ 
Sg
& 
a
, cڡ 
	gSgBud
& 
	gb
{  !
equ
(
b
,); }

358 
usg
 
	gWTF
::
SgBud
;

	@text/StringConcatenate.h

26 #ide
SgCǋ_h


27 
	#SgCǋ_h


	)

29 
	~<rg.h
>

31 #ide
AtomicSg_h


32 
	~<wtf/xt/AtomicSg.h
>

37 #ide
WTF_STRINGTYPEADAPTER_COPIED_WTF_STRING


38 
	#WTF_STRINGTYPEADAPTER_COPIED_WTF_STRING
((()0)

	)

41 
mea
 
	gWTF
 {

43 
	gme
<
tyme
 
	gSgTy
>

44 as
	cSgTyAdr
 {

47 
	gme
<>

48 
ass
 
	gSgTyAdr
<> {

49 
	gpublic
:

50 
SgTyAdr
<>(
bufr
)

51 : 
m_bufr
(
bufr
)

55 
ngth
() {  1; }

57 
bo
 
is8B
({  
	gue
; }

59 
wreTo
(
LCh
* 
dei
)

61 *
	gdei
 = 
m_bufr
;

64 
wreTo
(
UCh
* 
dei
{ *
	gdei
 = 
m_bufr
; }

66 
	give
:

67 
m_bufr
;

70 
	gme
<>

71 
ass
 
	gSgTyAdr
<
	gLCh
> {

72 
	gpublic
:

73 
SgTyAdr
<
LCh
>(LCh 
bufr
)

74 : 
m_bufr
(
bufr
)

78 
ngth
() {  1; }

80 
bo
 
is8B
({  
	gue
; }

82 
wreTo
(
LCh
* 
dei
)

84 *
	gdei
 = 
m_bufr
;

87 
wreTo
(
UCh
* 
dei
{ *
	gdei
 = 
m_bufr
; }

89 
	give
:

90 
LCh
 
m_bufr
;

93 
	gme
<>

94 
ass
 
	gSgTyAdr
<
	gUCh
> {

95 
	gpublic
:

96 
SgTyAdr
<
UCh
>(UCh 
bufr
)

97 : 
m_bufr
(
bufr
)

101 
ngth
() {  1; }

103 
bo
 
is8B
({  
	gm_bufr
 <= 0xff; }

105 
wreTo
(
LCh
* 
dei
)

107 
ASSERT
(
is8B
());

108 *
	gdei
 = 
ic_
<
LCh
>(
m_bufr
);

111 
wreTo
(
UCh
* 
dei
{ *
	gdei
 = 
m_bufr
; }

113 
	give
:

114 
UCh
 
m_bufr
;

117 
	gme
<>

118 
ass
 
	gSgTyAdr
<*> {

119 
	gpublic
:

120 
SgTyAdr
<*>(* 
bufr
)

121 : 
m_bufr
(
bufr
)

122 , 
m_ngth
(

(
bufr
))

126 
ngth
({  
	gm_ngth
; }

128 
bo
 
is8B
({  
	gue
; }

130 
wreTo
(
LCh
* 
dei
)

132 
	gi
 = 0; i < 
	gm_ngth
; ++i)

133 
	gdei
[
i
] = 
ic_
<
LCh
>(
m_bufr
[i]);

136 
wreTo
(
UCh
* 
dei
)

138 
	gi
 = 0; i < 
	gm_ngth
; ++i) {

139 
	gc
 = 
m_bufr
[
i
];

140 
	gdei
[
i
] = 
c
;

144 
	give
:

145 cڡ * 
m_bufr
;

146 
	gm_ngth
;

149 
	gme
<>

150 
ass
 
	gSgTyAdr
<
	gLCh
*> {

151 
	gpublic
:

152 
SgTyAdr
<
LCh
*>(LCh* 
bufr
)

153 : 
m_bufr
(
bufr
)

154 , 
m_ngth
(

(
t_
<*>(
bufr
)))

158 
ngth
({  
	gm_ngth
; }

160 
bo
 
is8B
({  
	gue
; }

162 
wreTo
(
LCh
* 
dei
)

164 
memy
(
dei
, 
m_bufr
, 
m_ngth
 * (
LCh
));

167 
wreTo
(
UCh
* 
dei
)

169 
	gSgIm
::
cyChs
(
dei
, 
m_bufr
, 
m_ngth
);

172 
	give
:

173 cڡ 
LCh
* 
m_bufr
;

174 
	gm_ngth
;

177 
	gme
<>

178 
ass
 
	gSgTyAdr
<cڡ 
	gUCh
*> {

179 
	gpublic
:

180 
SgTyAdr
<cڡ 
UCh
*>(cڡ UCh* 
bufr
)

181 : 
m_bufr
(
bufr
)

183 
size_t
 
n
 = 0;

184 
	gm_bufr
[
n
] !
UCh
(0))

185 ++
n
;

187 i(
	gn
 > 
	gd
::
numic_lims
<>::
max
())

188 
CRASH
();

190 
	gm_ngth
 = 
n
;

193 
ngth
({  
	gm_ngth
; }

195 
bo
 
is8B
({  
	gl
; }

197 
NO_RETURN_DUE_TO_CRASH
 
wreTo
(
LCh
*)

199 
CRASH
();

202 
wreTo
(
UCh
* 
dei
)

204 
memy
(
dei
, 
m_bufr
, 
m_ngth
 * (
UCh
));

207 
	give
:

208 cڡ 
UCh
* 
m_bufr
;

209 
	gm_ngth
;

212 
	gme
<>

213 
ass
 
	gSgTyAdr
<const *> {

214 
	gpublic
:

215 
SgTyAdr
<cڡ *>(cڡ * 
bufr
)

216 : 
m_bufr
(
bufr
)

217 , 
m_ngth
(

(
bufr
))

221 
ngth
({  
	gm_ngth
; }

223 
bo
 
is8B
({  
	gue
; }

225 
wreTo
(
LCh
* 
dei
)

227 
memy
(
dei
, 
m_bufr
, 
ic_
<
size_t
>(
m_ngth
* (
LCh
));

230 
wreTo
(
UCh
* 
dei
)

232 
	gi
 = 0; i < 
	gm_ngth
; ++i) {

233 
	gc
 = 
m_bufr
[
i
];

234 
	gdei
[
i
] = 
c
;

238 
	give
:

239 cڡ * 
m_bufr
;

240 
	gm_ngth
;

243 
	gme
<>

244 
ass
 
	gSgTyAdr
<cڡ 
	gLCh
*> {

245 
	gpublic
:

246 
SgTyAdr
<cڡ 
LCh
*>(cڡ LCh* 
bufr
)

247 : 
m_bufr
(
bufr
)

248 , 
m_ngth
(

(
t_
<cڡ *>(
bufr
)))

252 
ngth
({  
	gm_ngth
; }

254 
bo
 
is8B
({  
	gue
; }

256 
wreTo
(
LCh
* 
dei
)

258 
memy
(
dei
, 
m_bufr
, 
ic_
<
size_t
>(
m_ngth
* (
LCh
));

261 
wreTo
(
UCh
* 
dei
)

263 
	gSgIm
::
cyChs
(
dei
, 
m_bufr
, 
m_ngth
);

266 
	give
:

267 cڡ 
LCh
* 
m_bufr
;

268 
	gm_ngth
;

271 
	gme
<>

272 
ass
 
	gSgTyAdr
<
	gASCIIL
> {

273 
	gpublic
:

274 
SgTyAdr
<
ASCIIL
>(ASCIIL 
bufr
)

275 : 
m_bufr
(
t_
<cڡ 
LCh
*>(
ic_
<cڡ *>(
bufr
)))

276 , 
m_ngth
(

(
bufr
))

280 
size_t
 
ngth
({  
	gm_ngth
; }

282 
bo
 
is8B
({  
	gue
; }

284 
wreTo
(
LCh
* 
dei
)

286 
memy
(
dei
, 
m_bufr
, 
ic_
<
size_t
>(
m_ngth
));

289 
wreTo
(
UCh
* 
dei
)

291 
	gSgIm
::
cyChs
(
dei
, 
m_bufr
, 
m_ngth
);

294 
	give
:

295 cڡ 
LCh
* 
m_bufr
;

296 
	gm_ngth
;

299 
	gme
<>

300 
ass
 
	gSgTyAdr
<
	gVe
<>> {

301 
	gpublic
:

302 
SgTyAdr
<
Ve
<>>(cڡ Ve<>& 
bufr
)

303 : 
m_bufr
(
bufr
)

307 
size_t
 
ngth
({  
m_bufr
.
size
(); }

309 
bo
 
is8B
({  
	gue
; }

311 
wreTo
(
LCh
* 
dei
)

313 
size_t
 
	gi
 = 0; i < 
	gm_bufr
.
size
(); ++i)

314 
	gdei
[
i
] = 
ic_
<>(
m_bufr
[i]);

317 
wreTo
(
UCh
* 
dei
)

319 
size_t
 
	gi
 = 0; i < 
	gm_bufr
.
size
(); ++i)

320 
	gdei
[
i
] = 
ic_
<>(
m_bufr
[i]);

323 
	give
:

324 cڡ 
Ve
<>& 
m_bufr
;

327 
	gme
<>

328 
ass
 
	gSgTyAdr
<
	gVe
<
	gLCh
>> {

329 
	gpublic
:

330 
SgTyAdr
<
Ve
<
LCh
>>(cڡ Ve<LCh>& 
bufr
)

331 : 
m_bufr
(
bufr
)

335 
size_t
 
ngth
({  
m_bufr
.
size
(); }

337 
bo
 
is8B
({  
	gue
; }

339 
wreTo
(
LCh
* 
dei
)

341 
size_t
 
	gi
 = 0; i < 
	gm_bufr
.
size
(); ++i)

342 
	gdei
[
i
] = 
m_bufr
[i];

345 
wreTo
(
UCh
* 
dei
)

347 
size_t
 
	gi
 = 0; i < 
	gm_bufr
.
size
(); ++i)

348 
	gdei
[
i
] = 
m_bufr
[i];

351 
	give
:

352 cڡ 
Ve
<
LCh
>& 
m_bufr
;

355 
	gme
<>

356 
ass
 
	gSgTyAdr
<
	gSg
> {

357 
	gpublic
:

358 
SgTyAdr
<
Sg
>(cڡ Sg& 
rg
)

359 : 
m_bufr
(
rg
)

363 
ngth
({  
m_bufr
.length(); }

365 
bo
 
is8B
({  
	gm_bufr
.
isNu
() || m_buffer.is8Bit(); }

367 
wreTo
(
LCh
* 
dei
)

369 
	gngth
 = 
m_bufr
.
ngth
();

371 
ASSERT
(
is8B
());

372 cڡ 
LCh
* 
	gda
 = 
m_bufr
.
chas8
();

373 
	gi
 = 0; i < 
	gngth
; ++i)

374 
	gdei
[
i
] = 
da
[i];

376 
WTF_STRINGTYPEADAPTER_COPIED_WTF_STRING
();

379 
wreTo
(
UCh
* 
dei
)

381 
	gngth
 = 
m_bufr
.
ngth
();

383 i(
is8B
()) {

384 cڡ 
LCh
* 
	gda
 = 
m_bufr
.
chas8
();

385 
	gi
 = 0; i < 
	gngth
; ++i)

386 
	gdei
[
i
] = 
da
[i];

388 cڡ 
UCh
* 
	gda
 = 
m_bufr
.
chas16
();

389 
	gi
 = 0; i < 
	gngth
; ++i)

390 
	gdei
[
i
] = 
da
[i];

393 
WTF_STRINGTYPEADAPTER_COPIED_WTF_STRING
();

396 
	give
:

397 cڡ 
Sg
& 
m_bufr
;

400 
	gme
<>

401 
ass
 
	gSgTyAdr
<
	gAtomicSg
> {

402 
	gpublic
:

403 
SgTyAdr
<
AtomicSg
>(cڡ AtomicSg& 
rg
)

404 : 
m_adr
(
rg
.string())

408 
ngth
({  
m_adr
.length(); }

410 
bo
 
is8B
({  
	gm_adr
.is8Bit(); }

412 
wreTo
(
LCh
* 
dei
{ 
	gm_adr
.writeTo(destination); }

413 
wreTo
(
UCh
* 
dei
{ 
	gm_adr
.writeTo(destination); }

415 
	give
:

416 
SgTyAdr
<
Sg
> 
m_adr
;

419 
le
 
	$sumWhOvow
(& 
tٮ
, 
addd
, 
bo
& 
ovow
)

421 
dTٮ
 = 
tٮ
;

422 
tٮ
 = 
dTٮ
 + 
addd
;

423 i(
tٮ
 < 
dTٮ
)

424 
ovow
 = 
ue
;

425 
	}
}

427 
	gme
<
tyme
 
	gSgTy1
,ym
	gSgTy2
>

428 
	gPassRefP
<
	gSgIm
> 
	$yMakeSg
(
SgTy1
 
rg1
, 
SgTy2
 
rg2
)

430 
SgTyAdr
<
SgTy1
> 
	`adr1
(
rg1
);

431 
SgTyAdr
<
SgTy2
> 
	`adr2
(
rg2
);

433 
bo
 
ovow
 = 
l
;

434 
ngth
 = 
adr1
.
	`ngth
();

435 
	`sumWhOvow
(
ngth
, 
adr2
.
	`ngth
(), 
ovow
);

436 i(
ovow
)

439 i(
adr1
.
	`is8B
(&& 
adr2
.is8Bit()) {

440 
LCh
* 
bufr
;

441 
RefP
<
SgIm
> 
suIm
 = SgIm::
	`yCeUnlized
(
ngth
, 
bufr
);

442 i(!
suIm
)

445 
LCh
* 
su
 = 
bufr
;

446 
adr1
.
	`wreTo
(
su
);

447 
su
 +
adr1
.
	`ngth
();

448 
adr2
.
	`wreTo
(
su
);

450  
suIm
.
	`a
();

453 
UCh
* 
bufr
;

454 
RefP
<
SgIm
> 
suIm
 = SgIm::
	`yCeUnlized
(
ngth
, 
bufr
);

455 i(!
suIm
)

458 
UCh
* 
su
 = 
bufr
;

459 
adr1
.
	`wreTo
(
su
);

460 
su
 +
adr1
.
	`ngth
();

461 
adr2
.
	`wreTo
(
su
);

463  
suIm
.
	`a
();

464 
	}
}

466 
	gme
<
tyme
 
	gSgTy1
,ym
	gSgTy2
,ym
	gSgTy3
>

467 
	gPassRefP
<
	gSgIm
> 
	$yMakeSg
(
SgTy1
 
rg1
, 
SgTy2
 
rg2
, 
SgTy3
 
rg3
)

469 
SgTyAdr
<
SgTy1
> 
	`adr1
(
rg1
);

470 
SgTyAdr
<
SgTy2
> 
	`adr2
(
rg2
);

471 
SgTyAdr
<
SgTy3
> 
	`adr3
(
rg3
);

473 
bo
 
ovow
 = 
l
;

474 
ngth
 = 
adr1
.
	`ngth
();

475 
	`sumWhOvow
(
ngth
, 
adr2
.
	`ngth
(), 
ovow
);

476 
	`sumWhOvow
(
ngth
, 
adr3
.
	`ngth
(), 
ovow
);

477 i(
ovow
)

480 i(
adr1
.
	`is8B
(&& 
adr2
.is8B(&& 
adr3
.is8Bit()) {

481 
LCh
* 
bufr
;

482 
RefP
<
SgIm
> 
suIm
 = SgIm::
	`yCeUnlized
(
ngth
, 
bufr
);

483 i(!
suIm
)

486 
LCh
* 
su
 = 
bufr
;

487 
adr1
.
	`wreTo
(
su
);

488 
su
 +
adr1
.
	`ngth
();

489 
adr2
.
	`wreTo
(
su
);

490 
su
 +
adr2
.
	`ngth
();

491 
adr3
.
	`wreTo
(
su
);

493  
suIm
.
	`a
();

496 
UCh
* 
bufr
 = 0;

497 
RefP
<
SgIm
> 
suIm
 = SgIm::
	`yCeUnlized
(
ngth
, 
bufr
);

498 i(!
suIm
)

501 
UCh
* 
su
 = 
bufr
;

502 
adr1
.
	`wreTo
(
su
);

503 
su
 +
adr1
.
	`ngth
();

504 
adr2
.
	`wreTo
(
su
);

505 
su
 +
adr2
.
	`ngth
();

506 
adr3
.
	`wreTo
(
su
);

508  
suIm
.
	`a
();

509 
	}
}

511 
	gme
<
tyme
 
	gSgTy1
,ym
	gSgTy2
,ym
	gSgTy3
,ym
	gSgTy4
>

512 
	gPassRefP
<
	gSgIm
> 
	$yMakeSg
(
SgTy1
 
rg1
, 
SgTy2
 
rg2
, 
SgTy3
 
rg3
, 
SgTy4
 
rg4
)

514 
SgTyAdr
<
SgTy1
> 
	`adr1
(
rg1
);

515 
SgTyAdr
<
SgTy2
> 
	`adr2
(
rg2
);

516 
SgTyAdr
<
SgTy3
> 
	`adr3
(
rg3
);

517 
SgTyAdr
<
SgTy4
> 
	`adr4
(
rg4
);

519 
bo
 
ovow
 = 
l
;

520 
ngth
 = 
adr1
.
	`ngth
();

521 
	`sumWhOvow
(
ngth
, 
adr2
.
	`ngth
(), 
ovow
);

522 
	`sumWhOvow
(
ngth
, 
adr3
.
	`ngth
(), 
ovow
);

523 
	`sumWhOvow
(
ngth
, 
adr4
.
	`ngth
(), 
ovow
);

524 i(
ovow
)

527 i(
adr1
.
	`is8B
(&& 
adr2
.is8B(&& 
adr3
.is8B(&& 
adr4
.is8Bit()) {

528 
LCh
* 
bufr
;

529 
RefP
<
SgIm
> 
suIm
 = SgIm::
	`yCeUnlized
(
ngth
, 
bufr
);

530 i(!
suIm
)

533 
LCh
* 
su
 = 
bufr
;

534 
adr1
.
	`wreTo
(
su
);

535 
su
 +
adr1
.
	`ngth
();

536 
adr2
.
	`wreTo
(
su
);

537 
su
 +
adr2
.
	`ngth
();

538 
adr3
.
	`wreTo
(
su
);

539 
su
 +
adr3
.
	`ngth
();

540 
adr4
.
	`wreTo
(
su
);

542  
suIm
.
	`a
();

545 
UCh
* 
bufr
;

546 
RefP
<
SgIm
> 
suIm
 = SgIm::
	`yCeUnlized
(
ngth
, 
bufr
);

547 i(!
suIm
)

550 
UCh
* 
su
 = 
bufr
;

551 
adr1
.
	`wreTo
(
su
);

552 
su
 +
adr1
.
	`ngth
();

553 
adr2
.
	`wreTo
(
su
);

554 
su
 +
adr2
.
	`ngth
();

555 
adr3
.
	`wreTo
(
su
);

556 
su
 +
adr3
.
	`ngth
();

557 
adr4
.
	`wreTo
(
su
);

559  
suIm
.
	`a
();

560 
	}
}

562 
	gme
<
tyme
 
	gSgTy1
,ym
	gSgTy2
,ym
	gSgTy3
,ym
	gSgTy4
,ym
	gSgTy5
>

563 
	gPassRefP
<
	gSgIm
> 
	$yMakeSg
(
SgTy1
 
rg1
, 
SgTy2
 
rg2
, 
SgTy3
 
rg3
, 
SgTy4
 
rg4
, 
SgTy5
 
rg5
)

565 
SgTyAdr
<
SgTy1
> 
	`adr1
(
rg1
);

566 
SgTyAdr
<
SgTy2
> 
	`adr2
(
rg2
);

567 
SgTyAdr
<
SgTy3
> 
	`adr3
(
rg3
);

568 
SgTyAdr
<
SgTy4
> 
	`adr4
(
rg4
);

569 
SgTyAdr
<
SgTy5
> 
	`adr5
(
rg5
);

571 
bo
 
ovow
 = 
l
;

572 
ngth
 = 
adr1
.
	`ngth
();

573 
	`sumWhOvow
(
ngth
, 
adr2
.
	`ngth
(), 
ovow
);

574 
	`sumWhOvow
(
ngth
, 
adr3
.
	`ngth
(), 
ovow
);

575 
	`sumWhOvow
(
ngth
, 
adr4
.
	`ngth
(), 
ovow
);

576 
	`sumWhOvow
(
ngth
, 
adr5
.
	`ngth
(), 
ovow
);

577 i(
ovow
)

580 i(
adr1
.
	`is8B
(&& 
adr2
.is8B(&& 
adr3
.is8B(&& 
adr4
.is8B(&& 
adr5
.is8Bit()) {

581 
LCh
* 
bufr
;

582 
RefP
<
SgIm
> 
suIm
 = SgIm::
	`yCeUnlized
(
ngth
, 
bufr
);

583 i(!
suIm
)

586 
LCh
* 
su
 = 
bufr
;

587 
adr1
.
	`wreTo
(
su
);

588 
su
 +
adr1
.
	`ngth
();

589 
adr2
.
	`wreTo
(
su
);

590 
su
 +
adr2
.
	`ngth
();

591 
adr3
.
	`wreTo
(
su
);

592 
su
 +
adr3
.
	`ngth
();

593 
adr4
.
	`wreTo
(
su
);

594 
su
 +
adr4
.
	`ngth
();

595 
adr5
.
	`wreTo
(
su
);

597  
suIm
.
	`a
();

600 
UCh
* 
bufr
;

601 
RefP
<
SgIm
> 
suIm
 = SgIm::
	`yCeUnlized
(
ngth
, 
bufr
);

602 i(!
suIm
)

605 
UCh
* 
su
 = 
bufr
;

606 
adr1
.
	`wreTo
(
su
);

607 
su
 +
adr1
.
	`ngth
();

608 
adr2
.
	`wreTo
(
su
);

609 
su
 +
adr2
.
	`ngth
();

610 
adr3
.
	`wreTo
(
su
);

611 
su
 +
adr3
.
	`ngth
();

612 
adr4
.
	`wreTo
(
su
);

613 
su
 +
adr4
.
	`ngth
();

614 
adr5
.
	`wreTo
(
su
);

616  
suIm
.
	`a
();

617 
	}
}

619 
	gme
<
tyme
 
	gSgTy1
,ym
	gSgTy2
,ym
	gSgTy3
,ym
	gSgTy4
,ym
	gSgTy5
,ym
	gSgTy6
>

620 
	gPassRefP
<
	gSgIm
> 
	$yMakeSg
(
SgTy1
 
rg1
, 
SgTy2
 
rg2
, 
SgTy3
 
rg3
, 
SgTy4
 
rg4
, 
SgTy5
 
rg5
, 
SgTy6
 
rg6
)

622 
SgTyAdr
<
SgTy1
> 
	`adr1
(
rg1
);

623 
SgTyAdr
<
SgTy2
> 
	`adr2
(
rg2
);

624 
SgTyAdr
<
SgTy3
> 
	`adr3
(
rg3
);

625 
SgTyAdr
<
SgTy4
> 
	`adr4
(
rg4
);

626 
SgTyAdr
<
SgTy5
> 
	`adr5
(
rg5
);

627 
SgTyAdr
<
SgTy6
> 
	`adr6
(
rg6
);

629 
bo
 
ovow
 = 
l
;

630 
ngth
 = 
adr1
.
	`ngth
();

631 
	`sumWhOvow
(
ngth
, 
adr2
.
	`ngth
(), 
ovow
);

632 
	`sumWhOvow
(
ngth
, 
adr3
.
	`ngth
(), 
ovow
);

633 
	`sumWhOvow
(
ngth
, 
adr4
.
	`ngth
(), 
ovow
);

634 
	`sumWhOvow
(
ngth
, 
adr5
.
	`ngth
(), 
ovow
);

635 
	`sumWhOvow
(
ngth
, 
adr6
.
	`ngth
(), 
ovow
);

636 i(
ovow
)

639 i(
adr1
.
	`is8B
(&& 
adr2
.is8B(&& 
adr3
.is8B(&& 
adr4
.is8B(&& 
adr5
.is8B(&& 
adr6
.is8Bit()) {

640 
LCh
* 
bufr
;

641 
RefP
<
SgIm
> 
suIm
 = SgIm::
	`yCeUnlized
(
ngth
, 
bufr
);

642 i(!
suIm
)

645 
LCh
* 
su
 = 
bufr
;

646 
adr1
.
	`wreTo
(
su
);

647 
su
 +
adr1
.
	`ngth
();

648 
adr2
.
	`wreTo
(
su
);

649 
su
 +
adr2
.
	`ngth
();

650 
adr3
.
	`wreTo
(
su
);

651 
su
 +
adr3
.
	`ngth
();

652 
adr4
.
	`wreTo
(
su
);

653 
su
 +
adr4
.
	`ngth
();

654 
adr5
.
	`wreTo
(
su
);

655 
su
 +
adr5
.
	`ngth
();

656 
adr6
.
	`wreTo
(
su
);

658  
suIm
.
	`a
();

661 
UCh
* 
bufr
;

662 
RefP
<
SgIm
> 
suIm
 = SgIm::
	`yCeUnlized
(
ngth
, 
bufr
);

663 i(!
suIm
)

666 
UCh
* 
su
 = 
bufr
;

667 
adr1
.
	`wreTo
(
su
);

668 
su
 +
adr1
.
	`ngth
();

669 
adr2
.
	`wreTo
(
su
);

670 
su
 +
adr2
.
	`ngth
();

671 
adr3
.
	`wreTo
(
su
);

672 
su
 +
adr3
.
	`ngth
();

673 
adr4
.
	`wreTo
(
su
);

674 
su
 +
adr4
.
	`ngth
();

675 
adr5
.
	`wreTo
(
su
);

676 
su
 +
adr5
.
	`ngth
();

677 
adr6
.
	`wreTo
(
su
);

679  
suIm
.
	`a
();

680 
	}
}

682 
	gme
<
tyme
 
	gSgTy1
,ym
	gSgTy2
,ym
	gSgTy3
,ym
	gSgTy4
,ym
	gSgTy5
,ym
	gSgTy6
,ym
	gSgTy7
>

683 
	gPassRefP
<
	gSgIm
> 
	$yMakeSg
(
SgTy1
 
rg1
, 
SgTy2
 
rg2
, 
SgTy3
 
rg3
, 
SgTy4
 
rg4
, 
SgTy5
 
rg5
, 
SgTy6
 
rg6
, 
SgTy7
 
rg7
)

685 
SgTyAdr
<
SgTy1
> 
	`adr1
(
rg1
);

686 
SgTyAdr
<
SgTy2
> 
	`adr2
(
rg2
);

687 
SgTyAdr
<
SgTy3
> 
	`adr3
(
rg3
);

688 
SgTyAdr
<
SgTy4
> 
	`adr4
(
rg4
);

689 
SgTyAdr
<
SgTy5
> 
	`adr5
(
rg5
);

690 
SgTyAdr
<
SgTy6
> 
	`adr6
(
rg6
);

691 
SgTyAdr
<
SgTy7
> 
	`adr7
(
rg7
);

693 
bo
 
ovow
 = 
l
;

694 
ngth
 = 
adr1
.
	`ngth
();

695 
	`sumWhOvow
(
ngth
, 
adr2
.
	`ngth
(), 
ovow
);

696 
	`sumWhOvow
(
ngth
, 
adr3
.
	`ngth
(), 
ovow
);

697 
	`sumWhOvow
(
ngth
, 
adr4
.
	`ngth
(), 
ovow
);

698 
	`sumWhOvow
(
ngth
, 
adr5
.
	`ngth
(), 
ovow
);

699 
	`sumWhOvow
(
ngth
, 
adr6
.
	`ngth
(), 
ovow
);

700 
	`sumWhOvow
(
ngth
, 
adr7
.
	`ngth
(), 
ovow
);

701 i(
ovow
)

704 i(
adr1
.
	`is8B
(&& 
adr2
.is8B(&& 
adr3
.is8B(&& 
adr4
.is8B(&& 
adr5
.is8B(&& 
adr6
.is8B(&& 
adr7
.is8Bit()) {

705 
LCh
* 
bufr
;

706 
RefP
<
SgIm
> 
suIm
 = SgIm::
	`yCeUnlized
(
ngth
, 
bufr
);

707 i(!
suIm
)

710 
LCh
* 
su
 = 
bufr
;

711 
adr1
.
	`wreTo
(
su
);

712 
su
 +
adr1
.
	`ngth
();

713 
adr2
.
	`wreTo
(
su
);

714 
su
 +
adr2
.
	`ngth
();

715 
adr3
.
	`wreTo
(
su
);

716 
su
 +
adr3
.
	`ngth
();

717 
adr4
.
	`wreTo
(
su
);

718 
su
 +
adr4
.
	`ngth
();

719 
adr5
.
	`wreTo
(
su
);

720 
su
 +
adr5
.
	`ngth
();

721 
adr6
.
	`wreTo
(
su
);

722 
su
 +
adr6
.
	`ngth
();

723 
adr7
.
	`wreTo
(
su
);

725  
suIm
.
	`a
();

728 
UCh
* 
bufr
;

729 
RefP
<
SgIm
> 
suIm
 = SgIm::
	`yCeUnlized
(
ngth
, 
bufr
);

730 i(!
suIm
)

733 
UCh
* 
su
 = 
bufr
;

734 
adr1
.
	`wreTo
(
su
);

735 
su
 +
adr1
.
	`ngth
();

736 
adr2
.
	`wreTo
(
su
);

737 
su
 +
adr2
.
	`ngth
();

738 
adr3
.
	`wreTo
(
su
);

739 
su
 +
adr3
.
	`ngth
();

740 
adr4
.
	`wreTo
(
su
);

741 
su
 +
adr4
.
	`ngth
();

742 
adr5
.
	`wreTo
(
su
);

743 
su
 +
adr5
.
	`ngth
();

744 
adr6
.
	`wreTo
(
su
);

745 
su
 +
adr6
.
	`ngth
();

746 
adr7
.
	`wreTo
(
su
);

748  
suIm
.
	`a
();

749 
	}
}

751 
	gme
<
tyme
 
	gSgTy1
,ym
	gSgTy2
,ym
	gSgTy3
,ym
	gSgTy4
,ym
	gSgTy5
,ym
	gSgTy6
,ym
	gSgTy7
,ym
	gSgTy8
>

752 
	gPassRefP
<
	gSgIm
> 
	$yMakeSg
(
SgTy1
 
rg1
, 
SgTy2
 
rg2
, 
SgTy3
 
rg3
, 
SgTy4
 
rg4
, 
SgTy5
 
rg5
, 
SgTy6
 
rg6
, 
SgTy7
 
rg7
, 
SgTy8
 
rg8
)

754 
SgTyAdr
<
SgTy1
> 
	`adr1
(
rg1
);

755 
SgTyAdr
<
SgTy2
> 
	`adr2
(
rg2
);

756 
SgTyAdr
<
SgTy3
> 
	`adr3
(
rg3
);

757 
SgTyAdr
<
SgTy4
> 
	`adr4
(
rg4
);

758 
SgTyAdr
<
SgTy5
> 
	`adr5
(
rg5
);

759 
SgTyAdr
<
SgTy6
> 
	`adr6
(
rg6
);

760 
SgTyAdr
<
SgTy7
> 
	`adr7
(
rg7
);

761 
SgTyAdr
<
SgTy8
> 
	`adr8
(
rg8
);

763 
bo
 
ovow
 = 
l
;

764 
ngth
 = 
adr1
.
	`ngth
();

765 
	`sumWhOvow
(
ngth
, 
adr2
.
	`ngth
(), 
ovow
);

766 
	`sumWhOvow
(
ngth
, 
adr3
.
	`ngth
(), 
ovow
);

767 
	`sumWhOvow
(
ngth
, 
adr4
.
	`ngth
(), 
ovow
);

768 
	`sumWhOvow
(
ngth
, 
adr5
.
	`ngth
(), 
ovow
);

769 
	`sumWhOvow
(
ngth
, 
adr6
.
	`ngth
(), 
ovow
);

770 
	`sumWhOvow
(
ngth
, 
adr7
.
	`ngth
(), 
ovow
);

771 
	`sumWhOvow
(
ngth
, 
adr8
.
	`ngth
(), 
ovow
);

772 i(
ovow
)

775 i(
adr1
.
	`is8B
(&& 
adr2
.is8B(&& 
adr3
.is8B(&& 
adr4
.is8B(&& 
adr5
.is8B(&& 
adr6
.is8B(&& 
adr7
.is8B(&& 
adr8
.is8Bit()) {

776 
LCh
* 
bufr
;

777 
RefP
<
SgIm
> 
suIm
 = SgIm::
	`yCeUnlized
(
ngth
, 
bufr
);

778 i(!
suIm
)

781 
LCh
* 
su
 = 
bufr
;

782 
adr1
.
	`wreTo
(
su
);

783 
su
 +
adr1
.
	`ngth
();

784 
adr2
.
	`wreTo
(
su
);

785 
su
 +
adr2
.
	`ngth
();

786 
adr3
.
	`wreTo
(
su
);

787 
su
 +
adr3
.
	`ngth
();

788 
adr4
.
	`wreTo
(
su
);

789 
su
 +
adr4
.
	`ngth
();

790 
adr5
.
	`wreTo
(
su
);

791 
su
 +
adr5
.
	`ngth
();

792 
adr6
.
	`wreTo
(
su
);

793 
su
 +
adr6
.
	`ngth
();

794 
adr7
.
	`wreTo
(
su
);

795 
su
 +
adr7
.
	`ngth
();

796 
adr8
.
	`wreTo
(
su
);

798  
suIm
.
	`a
();

801 
UCh
* 
bufr
;

802 
RefP
<
SgIm
> 
suIm
 = SgIm::
	`yCeUnlized
(
ngth
, 
bufr
);

803 i(!
suIm
)

806 
UCh
* 
su
 = 
bufr
;

807 
adr1
.
	`wreTo
(
su
);

808 
su
 +
adr1
.
	`ngth
();

809 
adr2
.
	`wreTo
(
su
);

810 
su
 +
adr2
.
	`ngth
();

811 
adr3
.
	`wreTo
(
su
);

812 
su
 +
adr3
.
	`ngth
();

813 
adr4
.
	`wreTo
(
su
);

814 
su
 +
adr4
.
	`ngth
();

815 
adr5
.
	`wreTo
(
su
);

816 
su
 +
adr5
.
	`ngth
();

817 
adr6
.
	`wreTo
(
su
);

818 
su
 +
adr6
.
	`ngth
();

819 
adr7
.
	`wreTo
(
su
);

820 
su
 +
adr7
.
	`ngth
();

821 
adr8
.
	`wreTo
(
su
);

823  
suIm
.
	`a
();

824 
	}
}

826 
	gme
<
tyme
 
	gSgTy1
,ym
	gSgTy2
,ym
	gSgTy3
,ym
	gSgTy4
,ym
	gSgTy5
,ym
	gSgTy6
,ym
	gSgTy7
,ym
	gSgTy8
,ym
	gSgTy9
>

827 
	gPassRefP
<
	gSgIm
> 
	$yMakeSg
(
SgTy1
 
rg1
, 
SgTy2
 
rg2
, 
SgTy3
 
rg3
, 
SgTy4
 
rg4
, 
SgTy5
 
rg5
, 
SgTy6
 
rg6
, 
SgTy7
 
rg7
, 
SgTy8
 
rg8
, 
SgTy9
 
rg9
)

829 
SgTyAdr
<
SgTy1
> 
	`adr1
(
rg1
);

830 
SgTyAdr
<
SgTy2
> 
	`adr2
(
rg2
);

831 
SgTyAdr
<
SgTy3
> 
	`adr3
(
rg3
);

832 
SgTyAdr
<
SgTy4
> 
	`adr4
(
rg4
);

833 
SgTyAdr
<
SgTy5
> 
	`adr5
(
rg5
);

834 
SgTyAdr
<
SgTy6
> 
	`adr6
(
rg6
);

835 
SgTyAdr
<
SgTy7
> 
	`adr7
(
rg7
);

836 
SgTyAdr
<
SgTy8
> 
	`adr8
(
rg8
);

837 
SgTyAdr
<
SgTy9
> 
	`adr9
(
rg9
);

839 
bo
 
ovow
 = 
l
;

840 
ngth
 = 
adr1
.
	`ngth
();

841 
	`sumWhOvow
(
ngth
, 
adr2
.
	`ngth
(), 
ovow
);

842 
	`sumWhOvow
(
ngth
, 
adr3
.
	`ngth
(), 
ovow
);

843 
	`sumWhOvow
(
ngth
, 
adr4
.
	`ngth
(), 
ovow
);

844 
	`sumWhOvow
(
ngth
, 
adr5
.
	`ngth
(), 
ovow
);

845 
	`sumWhOvow
(
ngth
, 
adr6
.
	`ngth
(), 
ovow
);

846 
	`sumWhOvow
(
ngth
, 
adr7
.
	`ngth
(), 
ovow
);

847 
	`sumWhOvow
(
ngth
, 
adr8
.
	`ngth
(), 
ovow
);

848 
	`sumWhOvow
(
ngth
, 
adr9
.
	`ngth
(), 
ovow
);

849 i(
ovow
)

852 i(
adr1
.
	`is8B
(&& 
adr2
.is8B(&& 
adr3
.is8B(&& 
adr4
.is8B(&& 
adr5
.is8B(&& 
adr6
.is8B(&& 
adr7
.is8B(&& 
adr8
.is8B(&& 
adr9
.is8Bit()) {

853 
LCh
* 
bufr
;

854 
RefP
<
SgIm
> 
suIm
 = SgIm::
	`yCeUnlized
(
ngth
, 
bufr
);

855 i(!
suIm
)

858 
LCh
* 
su
 = 
bufr
;

859 
adr1
.
	`wreTo
(
su
);

860 
su
 +
adr1
.
	`ngth
();

861 
adr2
.
	`wreTo
(
su
);

862 
su
 +
adr2
.
	`ngth
();

863 
adr3
.
	`wreTo
(
su
);

864 
su
 +
adr3
.
	`ngth
();

865 
adr4
.
	`wreTo
(
su
);

866 
su
 +
adr4
.
	`ngth
();

867 
adr5
.
	`wreTo
(
su
);

868 
su
 +
adr5
.
	`ngth
();

869 
adr6
.
	`wreTo
(
su
);

870 
su
 +
adr6
.
	`ngth
();

871 
adr7
.
	`wreTo
(
su
);

872 
su
 +
adr7
.
	`ngth
();

873 
adr8
.
	`wreTo
(
su
);

874 
su
 +
adr8
.
	`ngth
();

875 
adr9
.
	`wreTo
(
su
);

877  
suIm
.
	`a
();

880 
UCh
* 
bufr
;

881 
RefP
<
SgIm
> 
suIm
 = SgIm::
	`yCeUnlized
(
ngth
, 
bufr
);

882 i(!
suIm
)

885 
UCh
* 
su
 = 
bufr
;

886 
adr1
.
	`wreTo
(
su
);

887 
su
 +
adr1
.
	`ngth
();

888 
adr2
.
	`wreTo
(
su
);

889 
su
 +
adr2
.
	`ngth
();

890 
adr3
.
	`wreTo
(
su
);

891 
su
 +
adr3
.
	`ngth
();

892 
adr4
.
	`wreTo
(
su
);

893 
su
 +
adr4
.
	`ngth
();

894 
adr5
.
	`wreTo
(
su
);

895 
su
 +
adr5
.
	`ngth
();

896 
adr6
.
	`wreTo
(
su
);

897 
su
 +
adr6
.
	`ngth
();

898 
adr7
.
	`wreTo
(
su
);

899 
su
 +
adr7
.
	`ngth
();

900 
adr8
.
	`wreTo
(
su
);

901 
su
 +
adr8
.
	`ngth
();

902 
adr9
.
	`wreTo
(
su
);

904  
suIm
.
	`a
();

905 
	}
}

909 
	gme
<
tyme
 
	gSgTy1
>

910 
Sg
 
	$makeSg
(
SgTy1
 
rg1
)

912  
	`Sg
(
rg1
);

913 
	}
}

915 
	gme
<
tyme
 
	gSgTy1
,ym
	gSgTy2
>

916 
Sg
 
	$makeSg
(
SgTy1
 
rg1
, 
SgTy2
 
rg2
)

918 
RefP
<
SgIm
> 
suIm
 = 
	`yMakeSg
(
rg1
, 
rg2
);

919 i(!
suIm
)

920 
	`CRASH
();

921  
suIm
.
	`a
();

922 
	}
}

924 
	gme
<
tyme
 
	gSgTy1
,ym
	gSgTy2
,ym
	gSgTy3
>

925 
Sg
 
	$makeSg
(
SgTy1
 
rg1
, 
SgTy2
 
rg2
, 
SgTy3
 
rg3
)

927 
RefP
<
SgIm
> 
suIm
 = 
	`yMakeSg
(
rg1
, 
rg2
, 
rg3
);

928 i(!
suIm
)

929 
	`CRASH
();

930  
suIm
.
	`a
();

931 
	}
}

933 
	gme
<
tyme
 
	gSgTy1
,ym
	gSgTy2
,ym
	gSgTy3
,ym
	gSgTy4
>

934 
Sg
 
	$makeSg
(
SgTy1
 
rg1
, 
SgTy2
 
rg2
, 
SgTy3
 
rg3
, 
SgTy4
 
rg4
)

936 
RefP
<
SgIm
> 
suIm
 = 
	`yMakeSg
(
rg1
, 
rg2
, 
rg3
, 
rg4
);

937 i(!
suIm
)

938 
	`CRASH
();

939  
suIm
.
	`a
();

940 
	}
}

942 
	gme
<
tyme
 
	gSgTy1
,ym
	gSgTy2
,ym
	gSgTy3
,ym
	gSgTy4
,ym
	gSgTy5
>

943 
Sg
 
	$makeSg
(
SgTy1
 
rg1
, 
SgTy2
 
rg2
, 
SgTy3
 
rg3
, 
SgTy4
 
rg4
, 
SgTy5
 
rg5
)

945 
RefP
<
SgIm
> 
suIm
 = 
	`yMakeSg
(
rg1
, 
rg2
, 
rg3
, 
rg4
, 
rg5
);

946 i(!
suIm
)

947 
	`CRASH
();

948  
suIm
.
	`a
();

949 
	}
}

951 
	gme
<
tyme
 
	gSgTy1
,ym
	gSgTy2
,ym
	gSgTy3
,ym
	gSgTy4
,ym
	gSgTy5
,ym
	gSgTy6
>

952 
Sg
 
	$makeSg
(
SgTy1
 
rg1
, 
SgTy2
 
rg2
, 
SgTy3
 
rg3
, 
SgTy4
 
rg4
, 
SgTy5
 
rg5
, 
SgTy6
 
rg6
)

954 
RefP
<
SgIm
> 
suIm
 = 
	`yMakeSg
(
rg1
, 
rg2
, 
rg3
, 
rg4
, 
rg5
, 
rg6
);

955 i(!
suIm
)

956 
	`CRASH
();

957  
suIm
.
	`a
();

958 
	}
}

960 
	gme
<
tyme
 
	gSgTy1
,ym
	gSgTy2
,ym
	gSgTy3
,ym
	gSgTy4
,ym
	gSgTy5
,ym
	gSgTy6
,ym
	gSgTy7
>

961 
Sg
 
	$makeSg
(
SgTy1
 
rg1
, 
SgTy2
 
rg2
, 
SgTy3
 
rg3
, 
SgTy4
 
rg4
, 
SgTy5
 
rg5
, 
SgTy6
 
rg6
, 
SgTy7
 
rg7
)

963 
RefP
<
SgIm
> 
suIm
 = 
	`yMakeSg
(
rg1
, 
rg2
, 
rg3
, 
rg4
, 
rg5
, 
rg6
, 
rg7
);

964 i(!
suIm
)

965 
	`CRASH
();

966  
suIm
.
	`a
();

967 
	}
}

969 
	gme
<
tyme
 
	gSgTy1
,ym
	gSgTy2
,ym
	gSgTy3
,ym
	gSgTy4
,ym
	gSgTy5
,ym
	gSgTy6
,ym
	gSgTy7
,ym
	gSgTy8
>

970 
Sg
 
	$makeSg
(
SgTy1
 
rg1
, 
SgTy2
 
rg2
, 
SgTy3
 
rg3
, 
SgTy4
 
rg4
, 
SgTy5
 
rg5
, 
SgTy6
 
rg6
, 
SgTy7
 
rg7
, 
SgTy8
 
rg8
)

972 
RefP
<
SgIm
> 
suIm
 = 
	`yMakeSg
(
rg1
, 
rg2
, 
rg3
, 
rg4
, 
rg5
, 
rg6
, 
rg7
, 
rg8
);

973 i(!
suIm
)

974 
	`CRASH
();

975  
suIm
.
	`a
();

976 
	}
}

978 
	gme
<
tyme
 
	gSgTy1
,ym
	gSgTy2
,ym
	gSgTy3
,ym
	gSgTy4
,ym
	gSgTy5
,ym
	gSgTy6
,ym
	gSgTy7
,ym
	gSgTy8
,ym
	gSgTy9
>

979 
Sg
 
	$makeSg
(
SgTy1
 
rg1
, 
SgTy2
 
rg2
, 
SgTy3
 
rg3
, 
SgTy4
 
rg4
, 
SgTy5
 
rg5
, 
SgTy6
 
rg6
, 
SgTy7
 
rg7
, 
SgTy8
 
rg8
, 
SgTy9
 
rg9
)

981 
RefP
<
SgIm
> 
suIm
 = 
	`yMakeSg
(
rg1
, 
rg2
, 
rg3
, 
rg4
, 
rg5
, 
rg6
, 
rg7
, 
rg8
, 
rg9
);

982 i(!
suIm
)

983 
	`CRASH
();

984  
suIm
.
	`a
();

985 
	}
}

989 
usg
 
	gWTF
::
makeSg
;

991 
	~<wtf/xt/SgOts.h
>

	@text/StringHash.h

22 #ide
SgHash_h


23 
	#SgHash_h


	)

25 
	~<wtf/xt/AtomicSg.h
>

26 
	~<wtf/HashTs.h
>

27 
	~<wtf/SgHash.h
>

29 
mea
 
	gWTF
 {

31 
le
 
bo
 
	gHashTs
<
	gSg
>::
isEmyVue
(cڡ 
Sg
& 
vue
)

33  
vue
.
isNu
();

44 
	sSgHash
 {

45 
hash
(
SgIm
* 
key
{  
	gkey
->hash(); }

46 
le
 
bo
 
equ
(cڡ 
SgIm
* 
a
, cڡ SgIm* 
b
)

48  
	gWTF
::
equ
(*
a
, *
b
);

51 
hash
(cڡ 
RefP
<
SgIm
>& 
key
{  
	gkey
->hash(); }

52 
bo
 
equ
(cڡ 
RefP
<
SgIm
>& 
a
, cڡ RefP<SgIm>& 
b
)

54  
equ
(
a
.
g
(), 
b
.get());

56 
bo
 
equ
(cڡ 
RefP
<
SgIm
>& 
a
, cڡ SgIm* 
b
)

58  
equ
(
a
.
g
(), 
b
);

60 
bo
 
equ
(cڡ 
SgIm
* 
a
, cڡ 
RefP
<SgIm>& 
b
)

62  
equ
(
a
, 
b
.
g
());

65 
hash
(cڡ 
Sg
& 
key
{  
	gkey
.
im
()->hash(); }

66 
bo
 
equ
(cڡ 
Sg
& 
a
, cڡ Sg& 
b
)

68  
equ
(
a
.
im
(), 
b
.impl());

71 cڡ 
bo
 
	gToComToEmyOrDed
 = 
l
;

74 as
	cCaFdgHash
 {

75 
	gpublic
:

76 
me
<
tyme
 
T
> 
le
 
UCh
 
fdCa
(T 
cha
)

78 i(
d
::
is_me
<
T
, 
	gLCh
>::
vue
)

79  
SgIm
::
t1CaFdTab
[
cha
];

81  
u_fdCa
(
cha
, 
U_FOLD_CASE_DEFAULT
);

84 
hash
(cڡ 
UCh
* 
da
, 
ngth
)

86  
	gSgHash
::
compuHashAndMaskT8Bs
<
UCh
, 
	gfdCa
<
	gUCh
>>(
	gda
, 
	gngth
);

89 
hash
(
SgIm
& 
rg
)

91 i(
	grg
.
is8B
())

92  
hash
(
rg
.
chas8
(), sg.
ngth
());

93  
hash
(
rg
.
chas16
(), sg.
ngth
());

95 
hash
(
SgIm
* 
rg
)

97 
ASSERT
(
rg
);

98  
hash
(*
rg
);

101 
hash
(cڡ 
LCh
* 
da
, 
ngth
)

103  
	gSgHash
::
compuHashAndMaskT8Bs
<
LCh
, 
	gfdCa
<
	gLCh
>>(
	gda
, 
	gngth
);

106 
le
 
hash
(cڡ * 
da
, 
ngth
)

108  
	gCaFdgHash
::
hash
(
t_
<cڡ 
LCh
*>(
da
), 
ngth
);

111 
le
 
bo
 
equ
(cڡ 
SgIm
* 
a
, cڡ SgIm* 
b
)

113  
equIgnܚgCaNNu
(
a
, 
b
);

116 
hash
(cڡ 
RefP
<
SgIm
>& 
key
)

118  
hash
(*
key
);

121 
bo
 
equ
(cڡ 
RefP
<
SgIm
>& 
a
, cڡ RefP<SgIm>& 
b
)

123  
equ
(
a
.
g
(), 
b
.get());

126 
hash
(cڡ 
Sg
& 
key
)

128  
hash
(
key
.
im
());

130 
hash
(cڡ 
AtomicSg
& 
key
)

132  
hash
(
key
.
im
());

134 
bo
 
equ
(cڡ 
Sg
& 
a
, cڡ Sg& 
b
)

136  
equ
(
a
.
im
(), 
b
.impl());

138 
bo
 
equ
(cڡ 
AtomicSg
& 
a
, cڡ AtomicSg& 
b
)

142  
	ga
 =
b
 || 
equ
(
a
.
im
(), b.impl());

145 cڡ 
bo
 
	gToComToEmyOrDed
 = 
l
;

151 
	gA̗dyHashed
 : 
IHash
<> {

152 
hash
(
key
) {  key; }

158 
avoidDedVue
(
hash
)

160 
ASSERT
(
hash
);

161 
	gwHash
 = 
hash
 | (!(hash + 1) << 31);

162 
ASSERT
(
wHash
);

163 
ASSERT
(
wHash
 != 0xFFFFFFFF);

164  
	gwHash
;

170 
usg
 
	gWTF
::
A̗dyHashed
;

171 
usg
 
	gWTF
::
CaFdgHash
;

172 
usg
 
	gWTF
::
SgHash
;

	@text/StringImpl.cpp

25 
	~"cfig.h
"

26 
	~"SgIm.h
"

28 
	~"AtomicSg.h
"

29 
	~"SgBufr.h
"

30 
	~"SgHash.h
"

31 
	~<wtf/ProssID.h
>

32 
	~<wtf/StdLibExas.h
>

33 
	~<wtf/WTFThadDa.h
>

34 
	~<wtf/xt/CSg.h
>

35 
	~<wtf/xt/SgVw.h
>

36 
	~<wtf/unicode/ChaNames.h
>

37 
	~<wtf/unicode/UTF8.h
>

39 #ifde
STRING_STATS


40 
	~<unid.h
>

41 
	~<wtf/DaLog.h
>

44 
mea
 
	gWTF
 {

46 
usg
 
mea
 
	gUnicode
;

48 
COMPILE_ASSERT
((
SgIm
=2 * (+ 2 * (*), 
SgIm_should_ay_sml
);

50 #ifde
STRING_STATS


51 
SgSts
 
	gSgIm
::
m_rgSts
;

53 
	gSgSts
::
s_rgRemovesTlPrtSts
 = 
SgSts
::
s_tSgStsFqucy
;

55 
	gSgSts
::
moveSg
(
SgIm
* 
rg
)

57 
ngth
 = 
rg
->length();

58 
bo
 
	gisSubSg
 = 
rg
->
isSubSg
();

60 --
	gm_tٮNumbSgs
;

62 i(
	grg
->
has16BShadow
()) {

63 --
	gm_numbUpcvdSgs
;

64 i(!
	gisSubSg
)

65 
	gm_tٮUpcvdDa
 -
ngth
;

68 i(
	grg
->
is8B
()) {

69 --
	gm_numb8BSgs
;

70 i(!
	gisSubSg
)

71 
	gm_tٮ8BDa
 -
ngth
;

73 --
	gm_numb16BSgs
;

74 i(!
	gisSubSg
)

75 
	gm_tٮ16BDa
 -
ngth
;

78 i(!--
	gs_rgRemovesTlPrtSts
) {

79 
	gs_rgRemovesTlPrtSts
 = 
s_tSgStsFqucy
;

80 
tSts
();

84 
	gSgSts
::
tSts
()

86 
daLogF
("Sg stf܅rosid %d:\n", 
gCutProssID
());

88 
	gtٮNumbChas
 = 
m_tٮ8BDa
 + 
m_tٮ16BDa
;

89 
	gr8B
 = 
m_tٮNumbSgs
 ? (()
m_numb8BSgs
 * 100) / ()m_totalNumberStrings : 0.0;

90 
	gavage8bLgth
 = 
m_numb8BSgs
 ? ()
m_tٮ8BDa
 / ()m_number8BitStrings : 0.0;

91 
daLogF
("%8u (%5.2f%%8 b %12u ch %12u byvggth %6.1f\n", 
m_numb8BSgs
, 
r8B
, 
m_tٮ8BDa
, m_tٮ8BDa, 
avage8bLgth
);

93 
	gr16B
 = 
m_tٮNumbSgs
 ? (()
m_numb16BSgs
 * 100) / ()m_totalNumberStrings : 0.0;

94 
	gavage16bLgth
 = 
m_numb16BSgs
 ? ()
m_tٮ16BDa
 / ()m_number16BitStrings : 0.0;

95 
daLogF
("%8u (%5.2f%%16 b %12u ch %12u byvggth %6.1f\n", 
m_numb16BSgs
, 
r16B
, 
m_tٮ16BDa
, m_tٮ16BD* 2, 
avage16bLgth
);

97 
	grUpcvd
 = 
m_tٮNumbSgs
 ? (()
m_numbUpcvdSgs
 * 100/ ()
m_numb8BSgs
 : 0.0;

98 
	gavageUpcvdLgth
 = 
m_numbUpcvdSgs
 ? ()
m_tٮUpcvdDa
 / ()m_numberUpconvertedStrings : 0.0;

99 
daLogF
("%8u (%5.2f%%upcvd %12u ch %12u byvggth %6.1f\n", 
m_numbUpcvdSgs
, 
rUpcvd
, 
m_tٮUpcvdDa
, m_tٮUpcvdD* 2, 
avageUpcvdLgth
);

101 
	gavageLgth
 = 
m_tٮNumbSgs
 ? ()
tٮNumbChas
 / ()m_totalNumberStrings : 0.0;

102 
	gtٮDaBys
 = 
m_tٮ8BDa
 + (
m_tٮ16BDa
 + 
m_tٮUpcvdDa
) * 2;

103 
daLogF
("%8u Tٮ %12u ch %12u byvggth %6.1f\n", 
m_tٮNumbSgs
, 
tٮNumbChas
, 
tٮDaBys
, 
avageLgth
);

104 
	gtٮSavedBys
 = 
m_tٮ8BDa
 - 
m_tٮUpcvdDa
;

105 
	grSavgs
 = 
tٮSavedBys
 ? ((ٮSavedBy* 100/ ()(
tٮDaBys
 +otalSavedBytes) : 0.0;

106 
daLogF
(" Tٮ savg%12u by(%5.2f%%)\n", 
tٮSavedBys
, 
rSavgs
);

111 
	gSgIm
::~
SgIm
()

113 
ASSERT
(!
isStic
());

115 
STRING_STATS_REMOVE_STRING
(
this
);

117 i(
isAtomic
(&& 
	gm_ngth
)

118 
	gAtomicSg
::
move
(
this
);

120 
BufrOwrsh
 
	gowrsh
 = 
bufrOwrsh
();

122 i(
	gowrsh
 =
BufrIl
)

124 i(
	gowrsh
 =
BufrOwd
) {

126 
ASSERT
(
m_da8
);

127 
Fe
(
cڡ_
<
LCh
*>(
m_da8
));

131 
ASSERT
(
owrsh
 =
BufrSubrg
);

132 
ASSERT
(
subrgBufr
());

133 
subrgBufr
()->
def
();

136 
	gSgIm
::
deroy
(
SgIm
* 
rgIm
)

138 
rgIm
->~
SgIm
();

139 
Fe
(
rgIm
);

142 
	gPassRef
<
	gSgIm
> SgIm::
FromL
(cڡ * 
chas
, 
ngth
)

144 
ASSERT_WITH_MESSAGE
(
ngth
, "Use StringImpl::empty()o createnmpty string");

145 
ASSERT
(
chasAAASCII
<
LCh
>(
t_
<cڡ LCh*>(
chas
), 
ngth
));

146  
adtRef
(*
w
 
SgIm
(
t_
<cڡ 
LCh
*>(
chas
), 
ngth
, 
CڡruWhoutCyg
));

149 
	gPassRef
<
	gSgIm
> SgIm::
FromL
(cڡ * 
chas
)

151  
FromL
(
chas
, 

(characters));

154 
	gPassRef
<
	gSgIm
> SgIm::
WhoutCyg
(cڡ 
UCh
* 
chas
, 
ngth
)

156 i(!
	gngth
)

157  *
emy
();

159  
adtRef
(*
w
 
SgIm
(
chas
, 
ngth
, 
CڡruWhoutCyg
));

162 
	gPassRef
<
	gSgIm
> SgIm::
WhoutCyg
(cڡ 
LCh
* 
chas
, 
ngth
)

164 i(!
	gngth
)

165  *
emy
();

167  
adtRef
(*
w
 
SgIm
(
chas
, 
ngth
, 
CڡruWhoutCyg
));

170 
	gme
 <
tyme
 
	gChTy
>

171 
le
 
	gPassRef
<
	gSgIm
> SgIm::
UnlizedIl
(
ngth
, 
ChTy
*& 
da
)

173 i(!
	gngth
) {

174 
	gda
 = 0;

175  *
emy
();

177  
UnlizedIlNEmy
(
ngth
, 
da
);

180 
	gme
 <
tyme
 
	gChTy
>

181 
le
 
	gPassRef
<
	gSgIm
> SgIm::
UnlizedIlNEmy
(
ngth
, 
ChTy
*& 
da
)

183 
ASSERT
(
ngth
);

188 i(
	gngth
 > ((
	gd
::
numic_lims
<>::
max
(- (
SgIm
)/ (
ChTy
)))

189 
CRASH
();

190 
SgIm
* 
	grg
 = 
ic_
<SgIm*>(
Mloc
(
lotiSize
<
ChTy
>(
ngth
)));

192 
	gda
 = 
rg
->
Por
<
ChTy
>();

193  
	gcڡruIl
<
	gChTy
>(
	grg
, 
	gngth
);

196 
	gPassRef
<
	gSgIm
> SgIm::
Unlized
(
ngth
, 
LCh
*& 
da
)

198  
UnlizedIl
(
ngth
, 
da
);

201 
	gPassRef
<
	gSgIm
> SgIm::
Unlized
(
ngth
, 
UCh
*& 
da
)

203  
UnlizedIl
(
ngth
, 
da
);

206 
	gme
 <
tyme
 
	gChTy
>

207 
le
 
	gPassRef
<
	gSgIm
> SgIm::
loIl
(
PassRefP
<
SgIm
> 
igSg
, 
ngth
, 
ChTy
*& 
da
)

209 
ASSERT
(
igSg
->
hasORef
());

210 
ASSERT
(
igSg
->
bufrOwrsh
(=
BufrIl
);

212 i(!
	gngth
) {

213 
	gda
 = 0;

214  *
emy
();

218 i(
	gngth
 > ((
	gd
::
numic_lims
<>::
max
(- (
SgIm
)/ (
ChTy
)))

219 
CRASH
();

221 
	gigSg
->~
SgIm
();

222 
SgIm
* 
	grg
 = 
ic_
<SgIm*>(
Roc
(
igSg
.
akRef
(), 
lotiSize
<
ChTy
>(
ngth
)));

224 
	gda
 = 
rg
->
Por
<
ChTy
>();

225  
	gcڡruIl
<
	gChTy
>(
	grg
, 
	gngth
);

228 
	gPassRef
<
	gSgIm
> SgIm::
lo
(
PassRefP
<
SgIm
> 
igSg
, 
ngth
, 
LCh
*& 
da
)

230 
ASSERT
(
igSg
->
is8B
());

231  
loIl
(
igSg
, 
ngth
, 
da
);

234 
	gPassRef
<
	gSgIm
> SgIm::
lo
(
PassRefP
<
SgIm
> 
igSg
, 
ngth
, 
UCh
*& 
da
)

236 
ASSERT
(!
igSg
->
is8B
());

237  
loIl
(
igSg
, 
ngth
, 
da
);

240 
	gme
 <
tyme
 
	gChTy
>

241 
le
 
	gPassRef
<
	gSgIm
> SgIm::
Il
(cڡ 
ChTy
* 
chas
, 
ngth
)

243 i(!
	gchas
 || !
	gngth
)

244  *
emy
();

246 
ChTy
* 
	gda
;

247 aut
	grg
 = 
UnlizedIlNEmy
(
ngth
, 
da
);

248 
memy
(
da
, 
chas
, 
ngth
 * (
ChTy
));

249  
	grg
;

252 
	gPassRef
<
	gSgIm
> SgIm::

(cڡ 
UCh
* 
chas
, 
ngth
)

254  
Il
(
chas
, 
ngth
);

257 
	gPassRef
<
	gSgIm
> SgIm::

(cڡ 
LCh
* 
chas
, 
ngth
)

259  
Il
(
chas
, 
ngth
);

262 
	gPassRef
<
	gSgIm
> SgIm::
8BIfPossib
(cڡ 
UCh
* 
chas
, 
ngth
)

264 i(!
	gchas
 || !
	gngth
)

265  *
emy
();

267 
LCh
* 
	gda
;

268 
	gRefP
<
	gSgIm
> 
	grg
 = 
UnlizedIlNEmy
(
ngth
, 
da
);

270 
size_t
 
	gi
 = 0; i < 
	gngth
; ++i) {

271 i(
	gchas
[
i
] & 0xff00)

272  

(
chas
, 
ngth
);

273 
	gda
[
i
] = 
ic_
<
LCh
>(
chas
[i]);

276  
	grg
.
aNNu
();

279 
	gPassRef
<
	gSgIm
> SgIm::
8BIfPossib
(cڡ 
UCh
* 
rg
)

281  
SgIm
::
8BIfPossib
(
rg
, 
ngthOfNuTmedSg
(string));

284 
	gPassRef
<
	gSgIm
> SgIm::

(cڡ 
LCh
* 
rg
)

286 i(!
rg
)

287  *
emy
();

288 
size_t
 
	gngth
 = 

(
t_
<cڡ *>(
rg
));

289 i(
	gngth
 > 
	gd
::
numic_lims
<>::
max
())

290 
CRASH
();

291  

(
rg
, 
ngth
);

294 
bo
 
	gSgIm
::
cڏsOyWhea
()

299 i(
is8B
()) {

300 
i
 = 0; 
	gi
 < 
	gm_ngth
; ++i) {

301 
UCh
 
	gc
 = 
m_da8
[
i
];

302 i(!
isASCIIS
(
c
))

303  
	gl
;

306  
	gue
;

309 
	gi
 = 0; i < 
	gm_ngth
; ++i) {

310 
UCh
 
	gc
 = 
m_da16
[
i
];

311 i(!
isASCIIS
(
c
))

312  
	gl
;

314  
	gue
;

317 
	gPassRef
<
	gSgIm
> SgIm::
subrg
(
t
, 
ngth
)

319 i(
	gt
 >
m_ngth
)

320  *
emy
();

321 
	gmaxLgth
 = 
m_ngth
 - 
t
;

322 i(
	gngth
 >
maxLgth
) {

323 i(!
t
)

324  *
this
;

325 
	gngth
 = 
maxLgth
;

327 i(
is8B
())

328  

(
m_da8
 + 
t
, 
ngth
);

330  

(
m_da16
 + 
t
, 
ngth
);

333 
UCh32
 
	gSgIm
::
chaSgAt
(
i
)

335 i(
is8B
())

336  
m_da8
[
i
];

337 i(
U16_IS_SINGLE
(
m_da16
[
i
]))

338  
	gm_da16
[
i
];

339 i(
	gi
 + 1 < 
	gm_ngth
 && 
U16_IS_LEAD
(
m_da16
[
i
]&& 
U16_IS_TRAIL
(m_data16[i + 1]))

340  
U16_GET_SUPPLEMENTARY
(
m_da16
[
i
], m_data16[i + 1]);

344 
	gPassRef
<
	gSgIm
> SgIm::
low
()

350 i(
is8B
()) {

351 
瞚gIndex
;

352 
	gi
 = 0; i < 
	gm_ngth
; ++i) {

353 
LCh
 
	gcha
 = 
m_da8
[
i
];

354 i(
UNLIKELY
((
cha
 & ~0x7F|| 
isASCIIU
(character))) {

355 
	g瞚gIndex
 = 
i
;

356 
	gSlowPh
;

359  *
	gthis
;

361 
	gSlowPh
:

362 
LCh
* 
da8
;

363 aut
	gwIm
 = 
UnlizedIlNEmy
(
m_ngth
, 
da8
);

365 
	gi
 = 0; i < 
	g瞚gIndex
; ++i)

366 
	gda8
[
i
] = 
m_da8
[i];

368 
	gi
 = 
瞚gIndex
; i < 
	gm_ngth
; ++i) {

369 
LCh
 
	gcha
 = 
m_da8
[
i
];

370 i(!(
	gcha
 & ~0x7F))

371 
	gda8
[
i
] = 
toASCIILow
(
cha
);

373 
ASSERT
(
u_tow
(
cha
) <= 0xFF);

374 
	gda8
[
i
] = 
ic_
<
LCh
>(
u_tow
(
cha
));

378  
	gwIm
;

380 
bo
 
	gnoU
 = 
ue
;

381 
	ged
 = 0;

383 
	gi
 = 0; i < 
	gm_ngth
; ++i) {

384 
UCh
 
	gcha
 = 
m_da16
[
i
];

385 i(
UNLIKELY
(
isASCIIU
(
cha
)))

386 
	gnoU
 = 
l
;

387 
	ged
 |
cha
;

390 i(
	gnoU
 && !(
	ged
 & ~0x7F))

391  *
	gthis
;

393 i(!(
	ged
 & ~0x7F)) {

394 
UCh
* 
	gda16
;

395 aut
	gwIm
 = 
UnlizedIlNEmy
(
m_ngth
, 
da16
);

397 
	gi
 = 0; i < 
	gm_ngth
; ++i) {

398 
UCh
 
	gc
 = 
m_da16
[
i
];

399 
	gda16
[
i
] = 
toASCIILow
(
c
);

401  
	gwIm
;

404 i(
	gm_ngth
 > 
	gic_
<>(
	gd
::
numic_lims
<
t32_t
>::
max
()))

405 
CRASH
();

406 
t32_t
 
	gngth
 = 
m_ngth
;

409 
UCh
* 
	gda16
;

410 
	gRefP
<
	gSgIm
> 
	gwIm
 = 
UnlizedIlNEmy
(
m_ngth
, 
da16
);

412 
UECode
 
	gus
 = 
U_ZERO_ERROR
;

413 
t32_t
 
	gLgth
 = 
u_rToLow
(
da16
, 
ngth
, 
m_da16
, 
m_ngth
, "", &
us
);

414 i(
U_SUCCESS
(
us
&& 
	gLgth
 =
ngth
)

415  
wIm
.
aNNu
();

417 
	gwIm
 = 
Unlized
(
Lgth
, 
da16
);

418 
	gus
 = 
U_ZERO_ERROR
;

419 
u_rToLow
(
da16
, 
Lgth
, 
m_da16
, 
m_ngth
, "", &
us
);

420 i(
U_FAILURE
(
us
))

421  *
	gthis
;

422  
	gwIm
.
aNNu
();

425 
	gPassRef
<
	gSgIm
> SgIm::
u
()

431 i(
m_ngth
 > 
ic_
<>(
d
::
numic_lims
<
t32_t
>::
max
()))

432 
CRASH
();

433 
t32_t
 
	gngth
 = 
m_ngth
;

435 i(
is8B
()) {

436 
LCh
* 
	gda8
;

437 
	gRefP
<
	gSgIm
> 
	gwIm
 = 
Unlized
(
m_ngth
, 
da8
);

440 
	ged
 = 0;

441 
	gi
 = 0; i < 
	gngth
; ++i) {

442 
LCh
 
	gc
 = 
m_da8
[
i
];

443 
	ged
 |
c
;

444 #i
CPU
(
X86
&& 
defed
(
_MSC_VER
) && _MSC_VER >=1700

448 
	gda8
[
i
] = 
c
 >= 'a' && c <= 'z' ? c & ~0x20 : c;

450 
	gda8
[
i
] = 
toASCIIU
(
c
);

453 i(!(
	ged
 & ~0x7F))

454  
	gwIm
.
aNNu
();

457 
	gnumbShpSChas
 = 0;

462 
t32_t
 
	gi
 = 0; i < 
	gngth
; ++i) {

463 
LCh
 
	gc
 = 
m_da8
[
i
];

464 i(
UNLIKELY
(
c
 =
smlLrShpS
))

465 ++
numbShpSChas
;

466 
ASSERT
(
u_tou
(
c
) <= 0xFFFF);

467 
UCh
 
	gu
 = 
u_tou
(
c
);

468 i(
UNLIKELY
(
u
 > 0xff)) {

470 
	gupcvt
;

472 
	gda8
[
i
] = 
ic_
<
LCh
>(
u
);

475 i(!
	gnumbShpSChas
)

476  
	gwIm
.
aNNu
();

479 
	gwIm
 = 
Unlized
(
m_ngth
 + 
numbShpSChas
, 
da8
);

481 
LCh
* 
	gde
 = 
da8
;

483 
t32_t
 
	gi
 = 0; i < 
	gngth
; ++i) {

484 
LCh
 
	gc
 = 
m_da8
[
i
];

485 i(
	gc
 =
smlLrShpS
) {

486 *
de
++ = 'S';

487 *
	gde
++ = 'S';

489 
ASSERT
(
u_tou
(
c
) <= 0xFF);

490 *
	gde
++ = 
ic_
<
LCh
>(
u_tou
(
c
));

494  
	gwIm
.
aNNu
();

497 
	gupcvt
:

498 aut
upcvdChas
 = 
SgVw
(*
this
).upconvertedCharacters();

499 cڡ 
UCh
* 
	gsour16
 = 
upcvdChas
;

501 
UCh
* 
	gda16
;

502 
	gRefP
<
	gSgIm
> 
	gwIm
 = 
Unlized
(
m_ngth
, 
da16
);

505 
	ged
 = 0;

506 
	gi
 = 0; i < 
	gngth
; ++i) {

507 
UCh
 
	gc
 = 
sour16
[
i
];

508 
	ged
 |
c
;

509 
	gda16
[
i
] = 
toASCIIU
(
c
);

511 i(!(
	ged
 & ~0x7F))

512  
	gwIm
.
aNNu
();

515 
UECode
 
	gus
 = 
U_ZERO_ERROR
;

516 
t32_t
 
	gLgth
 = 
u_rToU
(
da16
, 
ngth
, 
sour16
, 
m_ngth
, "", &
us
);

517 i(
U_SUCCESS
(
us
&& 
	gLgth
 =
ngth
)

518  
wIm
.
aNNu
();

519 
	gwIm
 = 
Unlized
(
Lgth
, 
da16
);

520 
	gus
 = 
U_ZERO_ERROR
;

521 
u_rToU
(
da16
, 
Lgth
, 
sour16
, 
m_ngth
, "", &
us
);

522 i(
U_FAILURE
(
us
))

523  *
	gthis
;

524  
	gwIm
.
aNNu
();

527 
le
 
bo
 
edsTurkishCasgRus
(cڡ 
AtomicSg
& 
loIdtifr
)

530 
UCh
 
	gf
 = 
loIdtifr
[0];

531 
UCh
 
	gcd
 = 
loIdtifr
[1];

532  ((
isASCIIAhaCassEqu
(
f
, 't'&& isASCIIAhaCassEqu(
cd
, 'r'))

533 || (
isASCIIAhaCassEqu
(
f
, 'a'&& isASCIIAhaCassEqu(
cd
, 'z')))

534 && (
	gloIdtifr
.
ngth
(=2 || 
loIdtifr
[2] == '-');

537 
	gPassRef
<
	gSgIm
> SgIm::
low
(cڡ 
AtomicSg
& 
loIdtifr
)

543 i(!
edsTurkishCasgRus
(
loIdtifr
))

544  
low
();

550 i(
	gm_ngth
 > 
	gic_
<>(
	gd
::
numic_lims
<
t32_t
>::
max
()))

551 
CRASH
();

552 
	gngth
 = 
m_ngth
;

557 aut
	gupcvdChas
 = 
SgVw
(*
this
).
upcvdChas
();

558 cڡ 
UCh
* 
	gsour16
 = 
upcvdChas
;

559 
UCh
* 
	gda16
;

560 
	gRefP
<
	gSgIm
> 
	gwSg
 = 
Unlized
(
ngth
, 
da16
);

561 
UECode
 
	gus
 = 
U_ZERO_ERROR
;

562 
	gLgth
 = 
u_rToLow
(
da16
, 
ngth
, 
sour16
,gth, "", &
us
);

563 i(
U_SUCCESS
(
us
&& 
	gLgth
 =
ngth
)

564  
wSg
.
aNNu
();

565 
	gwSg
 = 
Unlized
(
Lgth
, 
da16
);

566 
	gus
 = 
U_ZERO_ERROR
;

567 
u_rToLow
(
da16
, 
Lgth
, 
sour16
, 
ngth
, "", &
us
);

568 i(
U_FAILURE
(
us
))

569  *
	gthis
;

570  
	gwSg
.
aNNu
();

573 
	gPassRef
<
	gSgIm
> SgIm::
u
(cڡ 
AtomicSg
& 
loIdtifr
)

578 i(!
edsTurkishCasgRus
(
loIdtifr
|| 
fd
('i'=
nFound
)

579  
u
();

581 i(
	gm_ngth
 > 
	gic_
<>(
	gd
::
numic_lims
<
t32_t
>::
max
()))

582 
CRASH
();

583 
	gngth
 = 
m_ngth
;

588 aut
	gupcvdChas
 = 
SgVw
(*
this
).
upcvdChas
();

589 cڡ 
UCh
* 
	gsour16
 = 
upcvdChas
;

590 
UCh
* 
	gda16
;

591 
	gRefP
<
	gSgIm
> 
	gwSg
 = 
Unlized
(
ngth
, 
da16
);

592 
UECode
 
	gus
 = 
U_ZERO_ERROR
;

593 
	gLgth
 = 
u_rToU
(
da16
, 
ngth
, 
sour16
,gth, "", &
us
);

594 i(
U_SUCCESS
(
us
&& 
	gLgth
 =
ngth
)

595  
wSg
.
aNNu
();

596 
	gwSg
 = 
Unlized
(
Lgth
, 
da16
);

597 
	gus
 = 
U_ZERO_ERROR
;

598 
u_rToU
(
da16
, 
Lgth
, 
sour16
, 
ngth
, "", &
us
);

599 i(
U_FAILURE
(
us
))

600  *
	gthis
;

601  
	gwSg
.
aNNu
();

604 
	gPassRef
<
	gSgIm
> SgIm::
fl
(
UCh
 
cha
)

606 i(!(
cha
 & ~0x7F)) {

607 
LCh
* 
da
;

608 aut
	gwIm
 = 
Unlized
(
m_ngth
, 
da
);

609 
	gi
 = 0; i < 
	gm_ngth
; ++i)

610 
	gda
[
i
] = 
cha
;

611  
	gwIm
;

613 
UCh
* 
	gda
;

614 aut
	gwIm
 = 
Unlized
(
m_ngth
, 
da
);

615 
	gi
 = 0; i < 
	gm_ngth
; ++i)

616 
	gda
[
i
] = 
cha
;

617  
	gwIm
;

620 
	gPassRef
<
	gSgIm
> SgIm::
fdCa
()

624 i(
m_ngth
 > 
ic_
<>(
d
::
numic_lims
<
t32_t
>::
max
()))

625 
CRASH
();

626 
t32_t
 
	gngth
 = 
m_ngth
;

628 i(
is8B
()) {

630 
LCh
* 
	gda
;

631 aut
	gwIm
 = 
Unlized
(
m_ngth
, 
da
);

632 
LCh
 
	ged
 = 0;

634 
t32_t
 
	gi
 = 0; i < 
	gngth
; ++i) {

635 
LCh
 
	gc
 = 
m_da8
[
i
];

636 
	gda
[
i
] = 
toASCIILow
(
c
);

637 
	ged
 |
c
;

640 i(!(
	ged
 & ~0x7F))

641  
	gwIm
;

645 
t32_t
 
	gi
 = 0; i < 
	gngth
; ++i) {

646 
ASSERT
(
u_tow
(
m_da8
[
i
]) <= 0xFF);

647 
	gda
[
i
] = 
ic_
<
LCh
>(
u_tow
(
m_da8
[i]));

650  
	gwIm
;

654 
UCh
* 
	gda
;

655 
	gRefP
<
	gSgIm
> 
	gwIm
 = 
Unlized
(
m_ngth
, 
da
);

656 
UCh
 
	ged
 = 0;

657 
t32_t
 
	gi
 = 0; i < 
	gngth
; ++i) {

658 
UCh
 
	gc
 = 
m_da16
[
i
];

659 
	ged
 |
c
;

660 
	gda
[
i
] = 
toASCIILow
(
c
);

662 i(!(
	ged
 & ~0x7F))

663  
	gwIm
.
aNNu
();

666 
UECode
 
	gus
 = 
U_ZERO_ERROR
;

667 
t32_t
 
	gLgth
 = 
u_rFdCa
(
da
, 
ngth
, 
m_da16
, 
m_ngth
, 
U_FOLD_CASE_DEFAULT
, &
us
);

668 i(
U_SUCCESS
(
us
&& 
	gLgth
 =
ngth
)

669  
wIm
.
aNNu
();

670 
	gwIm
 = 
Unlized
(
Lgth
, 
da
);

671 
	gus
 = 
U_ZERO_ERROR
;

672 
u_rFdCa
(
da
, 
Lgth
, 
m_da16
, 
m_ngth
, 
U_FOLD_CASE_DEFAULT
, &
us
);

673 i(
U_FAILURE
(
us
))

674  *
	gthis
;

675  
	gwIm
.
aNNu
();

678 
	gPassRef
<
	gSgIm
> SgIm::
cvtToASCIILow
()

680 i(
is8B
()) {

681 
瞚gIndex
;

682 
	gi
 = 0; i < 
	gm_ngth
; ++i) {

683 
LCh
 
	gcha
 = 
m_da8
[
i
];

684 i(
UNLIKELY
(
isASCIIU
(
cha
))) {

685 
	g瞚gIndex
 = 
i
;

686 
	gSlowPh
;

689  *
	gthis
;

691 
	gSlowPh
:

692 
LCh
* 
da8
;

693 
	gPassRef
<
	gSgIm
> 
	gwIm
 = 
UnlizedIlNEmy
(
m_ngth
, 
da8
);

694 
	gi
 = 0; i < 
	g瞚gIndex
; ++i)

695 
	gda8
[
i
] = 
m_da8
[i];

696 
	gi
 = 
瞚gIndex
; i < 
	gm_ngth
; ++i)

697 
	gda8
[
i
] = 
toASCIILow
(
m_da8
[i]);

698  
	gwIm
;

701 
bo
 
	gnoU
 = 
ue
;

702 
	gi
 = 0; i < 
	gm_ngth
; ++i) {

703 i(
UNLIKELY
(
isASCIIU
(
m_da16
[
i
])))

704 
	gnoU
 = 
l
;

706 i(
	gnoU
)

707  *
	gthis
;

709 
UCh
* 
	gda16
;

710 
	gPassRef
<
	gSgIm
> 
	gwIm
 = 
UnlizedIlNEmy
(
m_ngth
, 
da16
);

711 
	gi
 = 0; i < 
	gm_ngth
; ++i)

712 
	gda16
[
i
] = 
toASCIILow
(
m_da16
[i]);

713  
	gwIm
;

716 
	gme
 <
ass
 
	gUChPdi
>

717 
le
 
	gPassRef
<
	gSgIm
> SgIm::
rMchedChas
(
UChPdi
 
edi
)

719 i(!
m_ngth
)

720  *
this
;

722 
	gt
 = 0;

723 
	gd
 = 
m_ngth
 - 1;

726 
	gt
 <
d
 && 
edi
(
is8B
(? 
m_da8
[
t
] : 
m_da16
[start]))

727 ++
t
;

730 i(
	gt
 > 
	gd
)

731  *
emy
();

734 
	gd
 && 
edi
(
is8B
(? 
m_da8
[
d
] : 
m_da16
[end]))

735 --
d
;

737 i(!
	gt
 && 
	gd
 =
m_ngth
 - 1)

738  *
this
;

739 i(
is8B
())

740  

(
m_da8
 + 
t
, 
d
 + 1 - start);

741  

(
m_da16
 + 
t
, 
d
 + 1 - start);

744 as
	cUChPdi
 {

745 
	gpublic
:

746 
le
 
UChPdi
(
ChaMchFuniP
 
funi
): 
m_funi
(function) { }

748 
le
 
bo
 
ݔ
()(
UCh
 
ch
) const

750  
m_funi
(
ch
);

753 
	give
:

754 cڡ 
ChaMchFuniP
 
m_funi
;

757 as
	cSOrNewlePdi
 {

758 
	gpublic
:

759 
le
 
bo
 
ݔ
()(
UCh
 
ch
) const

761  
isSOrNewle
(
ch
);

765 
	gPassRef
<
	gSgIm
> SgIm::
	$rWheS
()

767  
	`rMchedChas
(
	`SOrNewlePdi
());

768 
	}
}

770 
	gPassRef
<
	gSgIm
> SgIm::
	$rWheS
(
IsWheSFuniP
 
isWheS
)

772  
	`rMchedChas
(
	`UChPdi
(
isWheS
));

773 
	}
}

775 
	gme
 <
tyme
 
	gChTy
>

776 
ALWAYS_INLINE
 
	gPassRef
<
	gSgIm
> SgIm::
	$moveChas
(cڡ 
ChTy
* 
chas
, 
ChaMchFuniP
 
fdMch
)

778 cڡ 
ChTy
* 
om
 = 
chas
;

779 cڡ 
ChTy
* 
omd
 = 
om
 + 
m_ngth
;

782 
om
 !
omd
 && !
	`fdMch
(*from))

783 ++
om
;

784 i(
om
 =
omd
)

785  *
this
;

787 
SgBufr
<
ChTy
> 
	`da
(
m_ngth
);

788 
ChTy
* 
to
 = 
da
.
	`chas
();

789 
outc
 = 
om
 - 
chas
;

791 i(
outc
)

792 
	`memy
(
to
, 
chas
, 
outc
 * (
ChTy
));

794 
ue
) {

795 
om
 !
omd
 && 
	`fdMch
(*from))

796 ++
om
;

797 
om
 !
omd
 && !
	`fdMch
(*from))

798 
to
[
outc
++] = *
om
++;

799 i(
om
 =
omd
)

803 
da
.
	`shrk
(
outc
);

805  
	`adt
(
da
);

806 
	}
}

808 
	gPassRef
<
	gSgIm
> SgIm::
	$moveChas
(
ChaMchFuniP
 
fdMch
)

810 i(
	`is8B
())

811  
	`moveChas
(
	`chas8
(), 
fdMch
);

812  
	`moveChas
(
	`chas16
(), 
fdMch
);

813 
	}
}

815 
	gme
 <
tyme
 
	gChTy
, 
ass
 
	gUChPdi
>

816 
le
 
	gPassRef
<
	gSgIm
> SgIm::
	$simifyMchedChasToS
(
UChPdi
 
edi
)

818 
SgBufr
<
ChTy
> 
	`da
(
m_ngth
);

820 cڡ 
ChTy
* 
om
 = 
chas
<CharType>();

821 cڡ 
ChTy
* 
omd
 = 
om
 + 
m_ngth
;

822 
outc
 = 0;

823 
bo
 
chgedToS
 = 
l
;

825 
ChTy
* 
to
 = 
da
.
	`chas
();

827 
ue
) {

828 
om
 !
omd
 && 
	`edi
(*from)) {

829 i(*
om
 != ' ')

830 
chgedToS
 = 
ue
;

831 ++
om
;

833 
om
 !
omd
 && !
	`edi
(*from))

834 
to
[
outc
++] = *
om
++;

835 i(
om
 !
omd
)

836 
to
[
outc
++] = ' ';

841 i(
outc
 > 0 && 
to
[outc - 1] == ' ')

842 --
outc
;

844 i(
ic_
<>(
outc
=
m_ngth
 && !
chgedToS
)

845  *
this
;

847 
da
.
	`shrk
(
outc
);

849  
	`adt
(
da
);

850 
	}
}

852 
	gPassRef
<
	gSgIm
> SgIm::
	$simifyWheS
()

854 i(
	`is8B
())

855  
SgIm
::
simifyMchedChasToS
<
LCh
>(
	`SOrNewlePdi
());

856  
SgIm
::
simifyMchedChasToS
<
UCh
>(
	`SOrNewlePdi
());

857 
	}
}

859 
	gPassRef
<
	gSgIm
> SgIm::
	$simifyWheS
(
IsWheSFuniP
 
isWheS
)

861 i(
	`is8B
())

862  
SgIm
::
simifyMchedChasToS
<
LCh
>(
	`UChPdi
(
isWheS
));

863  
SgIm
::
simifyMchedChasToS
<
UCh
>(
	`UChPdi
(
isWheS
));

864 
	}
}

866 
	gSgIm
::
	$toISi
(
bo
* 
ok
, 
ba
)

868 i(
	`is8B
())

869  
	`chasToISi
(
	`chas8
(), 
m_ngth
, 
ok
, 
ba
);

870  
	`chasToISi
(
	`chas16
(), 
m_ngth
, 
ok
, 
ba
);

871 
	}
}

873 
	gSgIm
::
	$toUISi
(
bo
* 
ok
, 
ba
)

875 i(
	`is8B
())

876  
	`chasToUISi
(
	`chas8
(), 
m_ngth
, 
ok
, 
ba
);

877  
	`chasToUISi
(
	`chas16
(), 
m_ngth
, 
ok
, 
ba
);

878 
	}
}

880 
t64_t
 
	gSgIm
::
	$toI64Si
(
bo
* 
ok
, 
ba
)

882 i(
	`is8B
())

883  
	`chasToI64Si
(
	`chas8
(), 
m_ngth
, 
ok
, 
ba
);

884  
	`chasToI64Si
(
	`chas16
(), 
m_ngth
, 
ok
, 
ba
);

885 
	}
}

887 
ut64_t
 
	gSgIm
::
	$toUI64Si
(
bo
* 
ok
, 
ba
)

889 i(
	`is8B
())

890  
	`chasToUI64Si
(
	`chas8
(), 
m_ngth
, 
ok
, 
ba
);

891  
	`chasToUI64Si
(
	`chas16
(), 
m_ngth
, 
ok
, 
ba
);

892 
	}
}

894 
_t
 
	gSgIm
::
	$toIPSi
(
bo
* 
ok
, 
ba
)

896 i(
	`is8B
())

897  
	`chasToIPSi
(
	`chas8
(), 
m_ngth
, 
ok
, 
ba
);

898  
	`chasToIPSi
(
	`chas16
(), 
m_ngth
, 
ok
, 
ba
);

899 
	}
}

901 
	gSgIm
::
	$toI
(
bo
* 
ok
)

903 i(
	`is8B
())

904  
	`chasToI
(
	`chas8
(), 
m_ngth
, 
ok
);

905  
	`chasToI
(
	`chas16
(), 
m_ngth
, 
ok
);

906 
	}
}

908 
	gSgIm
::
	$toUI
(
bo
* 
ok
)

910 i(
	`is8B
())

911  
	`chasToUI
(
	`chas8
(), 
m_ngth
, 
ok
);

912  
	`chasToUI
(
	`chas16
(), 
m_ngth
, 
ok
);

913 
	}
}

915 
t64_t
 
	gSgIm
::
	$toI64
(
bo
* 
ok
)

917 i(
	`is8B
())

918  
	`chasToI64
(
	`chas8
(), 
m_ngth
, 
ok
);

919  
	`chasToI64
(
	`chas16
(), 
m_ngth
, 
ok
);

920 
	}
}

922 
ut64_t
 
	gSgIm
::
	$toUI64
(
bo
* 
ok
)

924 i(
	`is8B
())

925  
	`chasToUI64
(
	`chas8
(), 
m_ngth
, 
ok
);

926  
	`chasToUI64
(
	`chas16
(), 
m_ngth
, 
ok
);

927 
	}
}

929 
_t
 
	gSgIm
::
	$toIP
(
bo
* 
ok
)

931 i(
	`is8B
())

932  
	`chasToIP
(
	`chas8
(), 
m_ngth
, 
ok
);

933  
	`chasToIP
(
	`chas16
(), 
m_ngth
, 
ok
);

934 
	}
}

936 
	gSgIm
::
	$toDoub
(
bo
* 
ok
)

938 i(
	`is8B
())

939  
	`chasToDoub
(
	`chas8
(), 
m_ngth
, 
ok
);

940  
	`chasToDoub
(
	`chas16
(), 
m_ngth
, 
ok
);

941 
	}
}

943 
	gSgIm
::
	$toFlt
(
bo
* 
ok
)

945 i(
	`is8B
())

946  
	`chasToFlt
(
	`chas8
(), 
m_ngth
, 
ok
);

947  
	`chasToFlt
(
	`chas16
(), 
m_ngth
, 
ok
);

948 
	}
}

950 
bo
 
	$equIgnܚgCa
(cڡ 
LCh
* 
a
, cڡ LCh* 
b
, 
ngth
)

952 
ngth
--) {

953 i(
SgIm
::
t1CaFdTab
[*
a
++] !SgIm::t1CaFdTab[*
b
++])

954  
l
;

956  
ue
;

957 
	}
}

959 
bo
 
	$equIgnܚgCa
(cڡ 
UCh
* 
a
, cڡ 
LCh
* 
b
, 
ngth
)

961 
ngth
--) {

962 i(
	`u_fdCa
(*
a
++, 
U_FOLD_CASE_DEFAULT
!
SgIm
::
t1CaFdTab
[*
b
++])

963  
l
;

965  
ue
;

966 
	}
}

968 
size_t
 
	gSgIm
::
	$fd
(
ChaMchFuniP
 
mchFuni
, 
t
)

970 i(
	`is8B
())

971  
WTF
::
	`fd
(
	`chas8
(), 
m_ngth
, 
mchFuni
, 
t
);

972  
WTF
::
	`fd
(
	`chas16
(), 
m_ngth
, 
mchFuni
, 
t
);

973 
	}
}

975 
size_t
 
	gSgIm
::
	$fd
(cڡ 
LCh
* 
mchSg
, 
dex
)

978 i(!
mchSg
)

979  
nFound
;

980 
size_t
 
mchSgLgth
 = 
	`
(
t_
<cڡ *>(
mchSg
));

981 i(
mchSgLgth
 > 
d
::
numic_lims
<>::
	`max
())

982 
	`CRASH
();

983 
mchLgth
 = 
mchSgLgth
;

984 i(!
mchLgth
)

985  
d
::
	`m
(
dex
, 
	`ngth
());

988 i(
mchLgth
 == 1) {

989 i(
	`is8B
())

990  
WTF
::
	`fd
(
	`chas8
(), 
	`ngth
(), 
mchSg
[0], 
dex
);

991  
WTF
::
	`fd
(
	`chas16
(), 
	`ngth
(), *
mchSg
, 
dex
);

995 i(
dex
 > 
	`ngth
())

996  
nFound
;

997 
chLgth
 = 
	`ngth
(- 
dex
;

998 i(
mchLgth
 > 
chLgth
)

999  
nFound
;

1001 
d
 = 
chLgth
 - 
mchLgth
;

1006 i(
	`is8B
()) {

1007 cڡ 
LCh
* 
chChas
 = 
	`chas8
(+ 
dex
;

1009 
chHash
 = 0;

1010 
mchHash
 = 0;

1011 
i
 = 0; i < 
mchLgth
; ++i) {

1012 
chHash
 +
chChas
[
i
];

1013 
mchHash
 +
mchSg
[
i
];

1016 
i
 = 0;

1017 
chHash
 !
mchHash
 || !
	`equ
(
chChas
 + 
i
, 
mchSg
, 
mchLgth
)) {

1018 i(
i
 =
d
)

1019  
nFound
;

1020 
chHash
 +
chChas
[
i
 + 
mchLgth
];

1021 
chHash
 -
chChas
[
i
];

1022 ++
i
;

1024  
dex
 + 
i
;

1027 cڡ 
UCh
* 
chChas
 = 
	`chas16
(+ 
dex
;

1029 
chHash
 = 0;

1030 
mchHash
 = 0;

1031 
i
 = 0; i < 
mchLgth
; ++i) {

1032 
chHash
 +
chChas
[
i
];

1033 
mchHash
 +
mchSg
[
i
];

1036 
i
 = 0;

1037 
chHash
 !
mchHash
 || !
	`equ
(
chChas
 + 
i
, 
mchSg
, 
mchLgth
)) {

1038 i(
i
 =
d
)

1039  
nFound
;

1040 
chHash
 +
chChas
[
i
 + 
mchLgth
];

1041 
chHash
 -
chChas
[
i
];

1042 ++
i
;

1044  
dex
 + 
i
;

1045 
	}
}

1047 
size_t
 
	gSgIm
::
	$fdIgnܚgCa
(cڡ 
LCh
* 
mchSg
, 
dex
)

1050 i(!
mchSg
)

1051  
nFound
;

1052 
size_t
 
mchSgLgth
 = 
	`
(
t_
<cڡ *>(
mchSg
));

1053 i(
mchSgLgth
 > 
d
::
numic_lims
<>::
	`max
())

1054 
	`CRASH
();

1055 
mchLgth
 = 
mchSgLgth
;

1056 i(!
mchLgth
)

1057  
d
::
	`m
(
dex
, 
	`ngth
());

1060 i(
dex
 > 
	`ngth
())

1061  
nFound
;

1062 
chLgth
 = 
	`ngth
(- 
dex
;

1063 i(
mchLgth
 > 
chLgth
)

1064  
nFound
;

1066 
d
 = 
chLgth
 - 
mchLgth
;

1068 i(
	`is8B
()) {

1069 cڡ 
LCh
* 
chChas
 = 
	`chas8
(+ 
dex
;

1071 
i
 = 0;

1072 !
	`equIgnܚgCa
(
chChas
 + 
i
, 
mchSg
, 
mchLgth
)) {

1073 i(
i
 =
d
)

1074  
nFound
;

1075 ++
i
;

1077  
dex
 + 
i
;

1080 cڡ 
UCh
* 
chChas
 = 
	`chas16
(+ 
dex
;

1082 
i
 = 0;

1083 !
	`equIgnܚgCa
(
chChas
 + 
i
, 
mchSg
, 
mchLgth
)) {

1084 i(
i
 =
d
)

1085  
nFound
;

1086 ++
i
;

1088  
dex
 + 
i
;

1089 
	}
}

1091 
	gme
 <
tyme
 
	gSrchChaTy
,ym
	gMchChaTy
>

1092 
ALWAYS_INLINE
 
size_t
 
	$fdI
(cڡ 
SrchChaTy
* 
chChas
, cڡ 
MchChaTy
* 
mchChas
, 
dex
, 
chLgth
, 
mchLgth
)

1098 
d
 = 
chLgth
 - 
mchLgth
;

1100 
chHash
 = 0;

1101 
mchHash
 = 0;

1103 
i
 = 0; i < 
mchLgth
; ++i) {

1104 
chHash
 +
chChas
[
i
];

1105 
mchHash
 +
mchChas
[
i
];

1108 
i
 = 0;

1110 
chHash
 !
mchHash
 || !
	`equ
(
chChas
 + 
i
, 
mchChas
, 
mchLgth
)) {

1111 i(
i
 =
d
)

1112  
nFound
;

1113 
chHash
 +
chChas
[
i
 + 
mchLgth
];

1114 
chHash
 -
chChas
[
i
];

1115 ++
i
;

1117  
dex
 + 
i
;

1118 
	}
}

1120 
size_t
 
	gSgIm
::
	$fd
(
SgIm
* 
mchSg
)

1123 i(
	`UNLIKELY
(!
mchSg
))

1124  
nFound
;

1125 
mchLgth
 = 
mchSg
->
	`ngth
();

1128 i(
mchLgth
 == 1) {

1129 i(
	`is8B
()) {

1130 i(
mchSg
->
	`is8B
())

1131  
WTF
::
	`fd
(
	`chas8
(), 
	`ngth
(), 
mchSg
->characters8()[0]);

1132  
WTF
::
	`fd
(
	`chas8
(), 
	`ngth
(), 
mchSg
->
	`chas16
()[0]);

1134 i(
mchSg
->
	`is8B
())

1135  
WTF
::
	`fd
(
	`chas16
(), 
	`ngth
(), 
mchSg
->
	`chas8
()[0]);

1136  
WTF
::
	`fd
(
	`chas16
(), 
	`ngth
(), 
mchSg
->characters16()[0]);

1140 i(
mchLgth
 > 
	`ngth
())

1141  
nFound
;

1144 i(
	`UNLIKELY
(!
mchLgth
))

1147 i(
	`is8B
()) {

1148 i(
mchSg
->
	`is8B
())

1149  
	`fdI
(
	`chas8
(), 
mchSg
->chas8(), 0, 
	`ngth
(), 
mchLgth
);

1150  
	`fdI
(
	`chas8
(), 
mchSg
->
	`chas16
(), 0, 
	`ngth
(), 
mchLgth
);

1153 i(
mchSg
->
	`is8B
())

1154  
	`fdI
(
	`chas16
(), 
mchSg
->
	`chas8
(), 0, 
	`ngth
(), 
mchLgth
);

1156  
	`fdI
(
	`chas16
(), 
mchSg
->chas16(), 0, 
	`ngth
(), 
mchLgth
);

1157 
	}
}

1159 
size_t
 
	gSgIm
::
	$fd
(
SgIm
* 
mchSg
, 
dex
)

1162 i(
	`UNLIKELY
(!
mchSg
))

1163  
nFound
;

1165 
mchLgth
 = 
mchSg
->
	`ngth
();

1168 i(
mchLgth
 == 1) {

1169 i(
	`is8B
())

1170  
WTF
::
	`fd
(
	`chas8
(), 
	`ngth
(), (*
mchSg
)[0], 
dex
);

1171  
WTF
::
	`fd
(
	`chas16
(), 
	`ngth
(), (*
mchSg
)[0], 
dex
);

1174 i(
	`UNLIKELY
(!
mchLgth
))

1175  
d
::
	`m
(
dex
, 
	`ngth
());

1178 i(
dex
 > 
	`ngth
())

1179  
nFound
;

1180 
chLgth
 = 
	`ngth
(- 
dex
;

1181 i(
mchLgth
 > 
chLgth
)

1182  
nFound
;

1184 i(
	`is8B
()) {

1185 i(
mchSg
->
	`is8B
())

1186  
	`fdI
(
	`chas8
(+ 
dex
, 
mchSg
->chas8(), index, 
chLgth
, 
mchLgth
);

1187  
	`fdI
(
	`chas8
(+ 
dex
, 
mchSg
->
	`chas16
(), index, 
chLgth
, 
mchLgth
);

1190 i(
mchSg
->
	`is8B
())

1191  
	`fdI
(
	`chas16
(+ 
dex
, 
mchSg
->
	`chas8
(), index, 
chLgth
, 
mchLgth
);

1193  
	`fdI
(
	`chas16
(+ 
dex
, 
mchSg
->chas16(), index, 
chLgth
, 
mchLgth
);

1194 
	}
}

1196 
	gme
 <
tyme
 
	gSrchChaTy
,ym
	gMchChaTy
>

1197 
ALWAYS_INLINE
 
size_t
 
	$fdIgnܚgCaI
(cڡ 
SrchChaTy
* 
chChas
, cڡ 
MchChaTy
* 
mchChas
, 
dex
, 
chLgth
, 
mchLgth
)

1200 
d
 = 
chLgth
 - 
mchLgth
;

1202 
i
 = 0;

1204 !
	`equIgnܚgCa
(
chChas
 + 
i
, 
mchChas
, 
mchLgth
)) {

1205 i(
i
 =
d
)

1206  
nFound
;

1207 ++
i
;

1209  
dex
 + 
i
;

1210 
	}
}

1212 
size_t
 
	gSgIm
::
	$fdIgnܚgCa
(
SgIm
* 
mchSg
, 
dex
)

1215 i(!
mchSg
)

1216  
nFound
;

1217 
mchLgth
 = 
mchSg
->
	`ngth
();

1218 i(!
mchLgth
)

1219  
d
::
	`m
(
dex
, 
	`ngth
());

1222 i(
dex
 > 
	`ngth
())

1223  
nFound
;

1224 
chLgth
 = 
	`ngth
(- 
dex
;

1225 i(
mchLgth
 > 
chLgth
)

1226  
nFound
;

1228 i(
	`is8B
()) {

1229 i(
mchSg
->
	`is8B
())

1230  
	`fdIgnܚgCaI
(
	`chas8
(+ 
dex
, 
mchSg
->chas8(), index, 
chLgth
, 
mchLgth
);

1231  
	`fdIgnܚgCaI
(
	`chas8
(+ 
dex
, 
mchSg
->
	`chas16
(), index, 
chLgth
, 
mchLgth
);

1234 i(
mchSg
->
	`is8B
())

1235  
	`fdIgnܚgCaI
(
	`chas16
(+ 
dex
, 
mchSg
->
	`chas8
(), index, 
chLgth
, 
mchLgth
);

1237  
	`fdIgnܚgCaI
(
	`chas16
(+ 
dex
, 
mchSg
->chas16(), index, 
chLgth
, 
mchLgth
);

1238 
	}
}

1240 
size_t
 
	gSgIm
::
	$fdNextLeS
(
dex
)

1242 i(
	`is8B
())

1243  
WTF
::
	`fdNextLeS
(
	`chas8
(), 
m_ngth
, 
dex
);

1244  
WTF
::
	`fdNextLeS
(
	`chas16
(), 
m_ngth
, 
dex
);

1245 
	}
}

1247 
size_t
 
	gSgIm
::
	$vFd
(
UCh
 
c
, 
dex
)

1249 i(
	`is8B
())

1250  
WTF
::
	`vFd
(
	`chas8
(), 
m_ngth
, 
c
, 
dex
);

1251  
WTF
::
	`vFd
(
	`chas16
(), 
m_ngth
, 
c
, 
dex
);

1252 
	}
}

1254 
	gme
 <
tyme
 
	gSrchChaTy
,ym
	gMchChaTy
>

1255 
ALWAYS_INLINE
 
size_t
 
	$vFdI
(cڡ 
SrchChaTy
* 
chChas
, cڡ 
MchChaTy
* 
mchChas
, 
dex
, 
ngth
, 
mchLgth
)

1261 
d
 = 
d
::
	`m
(
dex
, 
ngth
 - 
mchLgth
);

1263 
chHash
 = 0;

1264 
mchHash
 = 0;

1265 
i
 = 0; i < 
mchLgth
; ++i) {

1266 
chHash
 +
chChas
[
d
 + 
i
];

1267 
mchHash
 +
mchChas
[
i
];

1271 
chHash
 !
mchHash
 || !
	`equ
(
chChas
 + 
d
, 
mchChas
, 
mchLgth
)) {

1272 i(!
d
)

1273  
nFound
;

1274 --
d
;

1275 
chHash
 -
chChas
[
d
 + 
mchLgth
];

1276 
chHash
 +
chChas
[
d
];

1278  
d
;

1279 
	}
}

1281 
size_t
 
	gSgIm
::
	$vFd
(
SgIm
* 
mchSg
, 
dex
)

1284 i(!
mchSg
)

1285  
nFound
;

1286 
mchLgth
 = 
mchSg
->
	`ngth
();

1287 
ourLgth
 = 
	`ngth
();

1288 i(!
mchLgth
)

1289  
d
::
	`m
(
dex
, 
ourLgth
);

1292 i(
mchLgth
 == 1) {

1293 i(
	`is8B
())

1294  
WTF
::
	`vFd
(
	`chas8
(), 
ourLgth
, (*
mchSg
)[0], 
dex
);

1295  
WTF
::
	`vFd
(
	`chas16
(), 
ourLgth
, (*
mchSg
)[0], 
dex
);

1299 i(
mchLgth
 > 
ourLgth
)

1300  
nFound
;

1302 i(
	`is8B
()) {

1303 i(
mchSg
->
	`is8B
())

1304  
	`vFdI
(
	`chas8
(), 
mchSg
->chas8(), 
dex
, 
ourLgth
, 
mchLgth
);

1305  
	`vFdI
(
	`chas8
(), 
mchSg
->
	`chas16
(), 
dex
, 
ourLgth
, 
mchLgth
);

1308 i(
mchSg
->
	`is8B
())

1309  
	`vFdI
(
	`chas16
(), 
mchSg
->
	`chas8
(), 
dex
, 
ourLgth
, 
mchLgth
);

1311  
	`vFdI
(
	`chas16
(), 
mchSg
->chas16(), 
dex
, 
ourLgth
, 
mchLgth
);

1312 
	}
}

1314 
	gme
 <
tyme
 
	gSrchChaTy
,ym
	gMchChaTy
>

1315 
ALWAYS_INLINE
 
size_t
 
	$vFdIgnܚgCaI
(cڡ 
SrchChaTy
* 
chChas
, cڡ 
MchChaTy
* 
mchChas
, 
dex
, 
ngth
, 
mchLgth
)

1318 
d
 = 
d
::
	`m
(
dex
, 
ngth
 - 
mchLgth
);

1321 !
	`equIgnܚgCa
(
chChas
 + 
d
, 
mchChas
, 
mchLgth
)) {

1322 i(!
d
)

1323  
nFound
;

1324 --
d
;

1326  
d
;

1327 
	}
}

1329 
size_t
 
	gSgIm
::
	$vFdIgnܚgCa
(
SgIm
* 
mchSg
, 
dex
)

1332 i(!
mchSg
)

1333  
nFound
;

1334 
mchLgth
 = 
mchSg
->
	`ngth
();

1335 
ourLgth
 = 
	`ngth
();

1336 i(!
mchLgth
)

1337  
d
::
	`m
(
dex
, 
ourLgth
);

1340 i(
mchLgth
 > 
ourLgth
)

1341  
nFound
;

1343 i(
	`is8B
()) {

1344 i(
mchSg
->
	`is8B
())

1345  
	`vFdIgnܚgCaI
(
	`chas8
(), 
mchSg
->chas8(), 
dex
, 
ourLgth
, 
mchLgth
);

1346  
	`vFdIgnܚgCaI
(
	`chas8
(), 
mchSg
->
	`chas16
(), 
dex
, 
ourLgth
, 
mchLgth
);

1349 i(
mchSg
->
	`is8B
())

1350  
	`vFdIgnܚgCaI
(
	`chas16
(), 
mchSg
->
	`chas8
(), 
dex
, 
ourLgth
, 
mchLgth
);

1352  
	`vFdIgnܚgCaI
(
	`chas16
(), 
mchSg
->chas16(), 
dex
, 
ourLgth
, 
mchLgth
);

1353 
	}
}

1355 
ALWAYS_INLINE
 
bo
 
	$equI
(cڡ 
SgIm
* 
rgIm
, 
tOfft
, cڡ * 
mchSg
, 
mchLgth
, 
bo
 
Ssive
)

1357 
	`ASSERT
(
rgIm
);

1358 
	`ASSERT
(
mchLgth
 <
rgIm
->
	`ngth
());

1359 
	`ASSERT
(
tOfft
 + 
mchLgth
 <
rgIm
->
	`ngth
());

1361 i(
Ssive
) {

1362 i(
rgIm
->
	`is8B
())

1363  
	`equ
(
rgIm
->
	`chas8
(+ 
tOfft
, 
t_
<cڡ 
LCh
*>(
mchSg
), 
mchLgth
);

1364  
	`equ
(
rgIm
->
	`chas16
(+ 
tOfft
, 
t_
<cڡ 
LCh
*>(
mchSg
), 
mchLgth
);

1366 i(
rgIm
->
	`is8B
())

1367  
	`equIgnܚgCa
(
rgIm
->
	`chas8
(+ 
tOfft
, 
t_
<cڡ 
LCh
*>(
mchSg
), 
mchLgth
);

1368  
	`equIgnܚgCa
(
rgIm
->
	`chas16
(+ 
tOfft
, 
t_
<cڡ 
LCh
*>(
mchSg
), 
mchLgth
);

1369 
	}
}

1371 
ALWAYS_INLINE
 
bo
 
	$equI
(
SgIm
& 
rgIm
, 
tOfft
, SgIm& 
mchSg
, 
bo
 
Ssive
)

1373 i(
tOfft
 > 
rgIm
.
	`ngth
())

1374  
l
;

1375 i(
mchSg
.
	`ngth
(> 
rgIm
.length())

1376  
l
;

1377 i(
mchSg
.
	`ngth
(+ 
tOfft
 > 
rgIm
.length())

1378  
l
;

1380 i(
Ssive
) {

1381 i(
rgIm
.
	`is8B
())

1382  
	`equ
(
rgIm
.
	`chas8
(+ 
tOfft
, 
mchSg
.chas8(), mchSg.
	`ngth
());

1383  
	`equ
(
rgIm
.
	`chas16
(+ 
tOfft
, 
mchSg
.chas16(), mchSg.
	`ngth
());

1385 i(
rgIm
.
	`is8B
())

1386  
	`equIgnܚgCa
(
rgIm
.
	`chas8
(+ 
tOfft
, 
mchSg
.chas8(), mchSg.
	`ngth
());

1387  
	`equIgnܚgCa
(
rgIm
.
	`chas16
(+ 
tOfft
, 
mchSg
.chas16(), mchSg.
	`ngth
());

1388 
	}
}

1390 
bo
 
	gSgIm
::
	$tsWh
(cڡ 
SgIm
* 
r
) const

1392 i(!
r
)

1393  
l
;

1395 i(
r
->
	`ngth
() >ength())

1396  
l
;

1398 i(
	`is8B
()) {

1399 i(
r
->
	`is8B
())

1400  
	`equ
(
	`chas8
(), 
r
->chas8(), s->
	`ngth
());

1401  
	`equ
(
	`chas8
(), 
r
->
	`chas16
(), s->
	`ngth
());

1403 i(
r
->
	`is8B
())

1404  
	`equ
(
	`chas16
(), 
r
->
	`chas8
(), s->
	`ngth
());

1405  
	`equ
(
	`chas16
(), 
r
->chas16(), s->
	`ngth
());

1406 
	}
}

1408 
bo
 
	gSgIm
::
	$tsWh
(
UCh
 
cha
) const

1410  
m_ngth
 && (*
this
)[0] =
cha
;

1411 
	}
}

1413 
bo
 
	gSgIm
::
	$tsWh
(cڡ * 
mchSg
, 
mchLgth
, 
bo
 
Ssive
) const

1415 
	`ASSERT
(
mchLgth
);

1416 i(
mchLgth
 > 
	`ngth
())

1417  
l
;

1418  
	`equI
(
this
, 0, 
mchSg
, 
mchLgth
, 
Ssive
);

1419 
	}
}

1421 
bo
 
	gSgIm
::
	$tsWh
(
SgIm
& 
mchSg
, 
tOfft
, 
bo
 
Ssive
) const

1423  
	`equI
(
cڡ_
<
SgIm
&>(*
this
), 
tOfft
, 
mchSg
, 
Ssive
);

1424 
	}
}

1426 
bo
 
	gSgIm
::
	$dsWh
(
SgIm
* 
mchSg
, 
bo
 
Ssive
)

1428 
	`ASSERT
(
mchSg
);

1429 i(
m_ngth
 >
mchSg
->m_length) {

1430 
t
 = 
m_ngth
 - 
mchSg
->m_length;

1431  (
Ssive
 ? 
	`fd
(
mchSg
, 
t
: 
	`fdIgnܚgCa
(matchString, start)) == start;

1433  
l
;

1434 
	}
}

1436 
bo
 
	gSgIm
::
	$dsWh
(
UCh
 
cha
) const

1438  
m_ngth
 && (*
this
)[m_ngth - 1] =
cha
;

1439 
	}
}

1441 
bo
 
	gSgIm
::
	$dsWh
(cڡ * 
mchSg
, 
mchLgth
, 
bo
 
Ssive
) const

1443 
	`ASSERT
(
mchLgth
);

1444 i(
mchLgth
 > 
	`ngth
())

1445  
l
;

1446 
tOfft
 = 
	`ngth
(- 
mchLgth
;

1447  
	`equI
(
this
, 
tOfft
, 
mchSg
, 
mchLgth
, 
Ssive
);

1448 
	}
}

1450 
bo
 
	gSgIm
::
	$dsWh
(
SgIm
& 
mchSg
, 
dOfft
, 
bo
 
Ssive
) const

1452 i(
dOfft
 < 
mchSg
.
	`ngth
())

1453  
l
;

1454  
	`equI
(
cڡ_
<
SgIm
&>(*
this
), 
dOfft
 - 
mchSg
.
	`ngth
(), mchSg, 
Ssive
);

1455 
	}
}

1457 
	gPassRef
<
	gSgIm
> SgIm::
	$a
(
UCh
 
dC
, UCh 
wC
)

1459 i(
dC
 =
wC
)

1460  *
this
;

1461 
i
;

1462 
i
 = 0; i !
m_ngth
; ++i) {

1463 
UCh
 
c
 = 
	`is8B
(? 
m_da8
[
i
] : 
m_da16
[i];

1464 i(
c
 =
dC
)

1467 i(
i
 =
m_ngth
)

1468  *
this
;

1470 i(
	`is8B
()) {

1471 i(
dC
 > 0xff)

1473  *
this
;

1475 i(
wC
 <= 0xff) {

1476 
LCh
* 
da
;

1477 
LCh
 
dCh
 = 
ic_
<LCh>(
dC
);

1478 
LCh
 
wCh
 = 
ic_
<LCh>(
wC
);

1480 aut
wIm
 = 
	`UnlizedIlNEmy
(
m_ngth
, 
da
);

1482 
i
 = 0; i !
m_ngth
; ++i) {

1483 
LCh
 
ch
 = 
m_da8
[
i
];

1484 i(
ch
 =
dCh
)

1485 
ch
 = 
wCh
;

1486 
da
[
i
] = 
ch
;

1488  
wIm
;

1493 
UCh
* 
da
;

1494 aut
wIm
 = 
	`UnlizedIlNEmy
(
m_ngth
, 
da
);

1496 
i
 = 0; i !
m_ngth
; ++i) {

1497 
UCh
 
ch
 = 
m_da8
[
i
];

1498 i(
ch
 =
dC
)

1499 
ch
 = 
wC
;

1500 
da
[
i
] = 
ch
;

1503  
wIm
;

1506 
UCh
* 
da
;

1507 aut
wIm
 = 
	`UnlizedIlNEmy
(
m_ngth
, 
da
);

1509 
i
 = 0; i !
m_ngth
; ++i) {

1510 
UCh
 
ch
 = 
m_da16
[
i
];

1511 i(
ch
 =
dC
)

1512 
ch
 = 
wC
;

1513 
da
[
i
] = 
ch
;

1515  
wIm
;

1516 
	}
}

1518 
	gPassRef
<
	gSgIm
> SgIm::
	$a
(
posi
, 
ngthToR
, 
SgIm
* 
r
)

1520 
posi
 = 
d
::
	`m
osi, 
	`ngth
());

1521 
ngthToR
 = 
d
::
	`m
֒gthToR, 
	`ngth
(- 
posi
);

1522 
ngthToIn
 = 
r
 ? s->
	`ngth
() : 0;

1523 i(!
ngthToR
 && !
ngthToIn
)

1524  *
this
;

1526 i((
	`ngth
(- 
ngthToR
>(
d
::
numic_lims
<>::
	`max
(- 
ngthToIn
))

1527 
	`CRASH
();

1529 i(
	`is8B
(&& (!
r
 || str->is8Bit())) {

1530 
LCh
* 
da
;

1531 aut
wIm
 = 
	`Unlized
(
	`ngth
(- 
ngthToR
 + 
ngthToIn
, 
da
);

1532 
	`memy
(
da
, 
m_da8
, 
posi
 * (
LCh
));

1533 i(
r
)

1534 
	`memy
(
da
 + 
posi
, 
r
->
m_da8
, 
ngthToIn
 * (
LCh
));

1535 
	`memy
(
da
 + 
posi
 + 
ngthToIn
, 
m_da8
 +osi + 
ngthToR
,

1536 (
	`ngth
(- 
posi
 - 
ngthToR
* (
LCh
));

1537  
wIm
;

1539 
UCh
* 
da
;

1540 aut
wIm
 = 
	`Unlized
(
	`ngth
(- 
ngthToR
 + 
ngthToIn
, 
da
);

1541 i(
	`is8B
())

1542 
i
 = 0; i < 
posi
; ++i)

1543 
da
[
i
] = 
m_da8
[i];

1545 
	`memy
(
da
, 
m_da16
, 
posi
 * (
UCh
));

1546 i(
r
) {

1547 i(
r
->
	`is8B
())

1548 
i
 = 0; i < 
ngthToIn
; ++i)

1549 
da
[
i
 + 
posi
] = 
r
->
m_da8
[i];

1551 
	`memy
(
da
 + 
posi
, 
r
->
m_da16
, 
ngthToIn
 * (
UCh
));

1553 i(
	`is8B
()) {

1554 
i
 = 0; i < 
	`ngth
(- 
posi
 - 
ngthToR
; ++i)

1555 
da
[
i
 + 
posi
 + 
ngthToIn
] = 
m_da8
[+osi + 
ngthToR
];

1557 
	`memy
(
da
 + 
posi
 + 
ngthToIn
, 
	`chas16
(+osi + 
ngthToR
,

1558 (
	`ngth
(- 
posi
 - 
ngthToR
* (
UCh
));

1560  
wIm
;

1561 
	}
}

1563 
	gPassRef
<
	gSgIm
> SgIm::
	$a
(
UCh
 
n
, 
SgIm
* 
amt
)

1565 i(!
amt
)

1566  *
this
;

1568 i(
amt
->
	`is8B
())

1569  
	`a
(
n
, 
amt
->
m_da8
,mt->
	`ngth
());

1571  
	`a
(
n
, 
amt
->
m_da16
,mt->
	`ngth
());

1572 
	}
}

1574 
	gPassRef
<
	gSgIm
> SgIm::
	$a
(
UCh
 
n
, cڡ 
LCh
* 
amt
, 
pSLgth
)

1576 
	`ASSERT
(
amt
);

1578 
size_t
 
cSegmtS
 = 0;

1579 
mchCou
 = 0;

1582 (
cSegmtS
 = 
	`fd
(
n
, srcSegmtS)!
nFound
) {

1583 ++
mchCou
;

1584 ++
cSegmtS
;

1588 i(!
mchCou
)

1589  *
this
;

1591 i(
pSLgth
 && 
mchCou
 > 
d
::
numic_lims
<>::
	`max
() /epStrLength)

1592 
	`CRASH
();

1594 
aSize
 = 
mchCou
 * 
pSLgth
;

1595 
wSize
 = 
m_ngth
 - 
mchCou
;

1596 i(
wSize
 >(
d
::
numic_lims
<>::
	`max
(- 
aSize
))

1597 
	`CRASH
();

1599 
wSize
 +
aSize
;

1602 
size_t
 
cSegmtEnd
;

1603 
cSegmtLgth
;

1604 
cSegmtS
 = 0;

1605 
dOfft
 = 0;

1607 i(
	`is8B
()) {

1608 
LCh
* 
da
;

1609 aut
wIm
 = 
	`Unlized
(
wSize
, 
da
);

1611 (
cSegmtEnd
 = 
	`fd
(
n
, 
cSegmtS
)!
nFound
) {

1612 
cSegmtLgth
 = 
cSegmtEnd
 - 
cSegmtS
;

1613 
	`memy
(
da
 + 
dOfft
, 
m_da8
 + 
cSegmtS
, 
cSegmtLgth
 * (
LCh
));

1614 
dOfft
 +
cSegmtLgth
;

1615 
	`memy
(
da
 + 
dOfft
, 
amt
, 
pSLgth
 * (
LCh
));

1616 
dOfft
 +
pSLgth
;

1617 
cSegmtS
 = 
cSegmtEnd
 + 1;

1620 
cSegmtLgth
 = 
m_ngth
 - 
cSegmtS
;

1621 
	`memy
(
da
 + 
dOfft
, 
m_da8
 + 
cSegmtS
, 
cSegmtLgth
 * (
LCh
));

1623 
	`ASSERT
(
dOfft
 + 
cSegmtLgth
 =
wIm
.
	`g
().
	`ngth
());

1625  
wIm
;

1628 
UCh
* 
da
;

1629 aut
wIm
 = 
	`Unlized
(
wSize
, 
da
);

1631 (
cSegmtEnd
 = 
	`fd
(
n
, 
cSegmtS
)!
nFound
) {

1632 
cSegmtLgth
 = 
cSegmtEnd
 - 
cSegmtS
;

1633 
	`memy
(
da
 + 
dOfft
, 
m_da16
 + 
cSegmtS
, 
cSegmtLgth
 * (
UCh
));

1635 
dOfft
 +
cSegmtLgth
;

1636 
i
 = 0; i < 
pSLgth
; ++i)

1637 
da
[
i
 + 
dOfft
] = 
amt
[i];

1639 
dOfft
 +
pSLgth
;

1640 
cSegmtS
 = 
cSegmtEnd
 + 1;

1643 
cSegmtLgth
 = 
m_ngth
 - 
cSegmtS
;

1644 
	`memy
(
da
 + 
dOfft
, 
m_da16
 + 
cSegmtS
, 
cSegmtLgth
 * (
UCh
));

1646 
	`ASSERT
(
dOfft
 + 
cSegmtLgth
 =
wIm
.
	`g
().
	`ngth
());

1648  
wIm
;

1649 
	}
}

1651 
	gPassRef
<
	gSgIm
> SgIm::
	$a
(
UCh
 
n
, cڡ UCh* 
amt
, 
pSLgth
)

1653 
	`ASSERT
(
amt
);

1655 
size_t
 
cSegmtS
 = 0;

1656 
mchCou
 = 0;

1659 (
cSegmtS
 = 
	`fd
(
n
, srcSegmtS)!
nFound
) {

1660 ++
mchCou
;

1661 ++
cSegmtS
;

1665 i(!
mchCou
)

1666  *
this
;

1668 i(
pSLgth
 && 
mchCou
 > 
d
::
numic_lims
<>::
	`max
() /epStrLength)

1669 
	`CRASH
();

1671 
aSize
 = 
mchCou
 * 
pSLgth
;

1672 
wSize
 = 
m_ngth
 - 
mchCou
;

1673 i(
wSize
 >(
d
::
numic_lims
<>::
	`max
(- 
aSize
))

1674 
	`CRASH
();

1676 
wSize
 +
aSize
;

1679 
size_t
 
cSegmtEnd
;

1680 
cSegmtLgth
;

1681 
cSegmtS
 = 0;

1682 
dOfft
 = 0;

1684 i(
	`is8B
()) {

1685 
UCh
* 
da
;

1686 aut
wIm
 = 
	`Unlized
(
wSize
, 
da
);

1688 (
cSegmtEnd
 = 
	`fd
(
n
, 
cSegmtS
)!
nFound
) {

1689 
cSegmtLgth
 = 
cSegmtEnd
 - 
cSegmtS
;

1690 
i
 = 0; i < 
cSegmtLgth
; ++i)

1691 
da
[
i
 + 
dOfft
] = 
m_da8
[+ 
cSegmtS
];

1693 
dOfft
 +
cSegmtLgth
;

1694 
	`memy
(
da
 + 
dOfft
, 
amt
, 
pSLgth
 * (
UCh
));

1696 
dOfft
 +
pSLgth
;

1697 
cSegmtS
 = 
cSegmtEnd
 + 1;

1700 
cSegmtLgth
 = 
m_ngth
 - 
cSegmtS
;

1701 
i
 = 0; i < 
cSegmtLgth
; ++i)

1702 
da
[
i
 + 
dOfft
] = 
m_da8
[+ 
cSegmtS
];

1704 
	`ASSERT
(
dOfft
 + 
cSegmtLgth
 =
wIm
.
	`g
().
	`ngth
());

1706  
wIm
;

1709 
UCh
* 
da
;

1710 aut
wIm
 = 
	`Unlized
(
wSize
, 
da
);

1712 (
cSegmtEnd
 = 
	`fd
(
n
, 
cSegmtS
)!
nFound
) {

1713 
cSegmtLgth
 = 
cSegmtEnd
 - 
cSegmtS
;

1714 
	`memy
(
da
 + 
dOfft
, 
m_da16
 + 
cSegmtS
, 
cSegmtLgth
 * (
UCh
));

1716 
dOfft
 +
cSegmtLgth
;

1717 
	`memy
(
da
 + 
dOfft
, 
amt
, 
pSLgth
 * (
UCh
));

1719 
dOfft
 +
pSLgth
;

1720 
cSegmtS
 = 
cSegmtEnd
 + 1;

1723 
cSegmtLgth
 = 
m_ngth
 - 
cSegmtS
;

1724 
	`memy
(
da
 + 
dOfft
, 
m_da16
 + 
cSegmtS
, 
cSegmtLgth
 * (
UCh
));

1726 
	`ASSERT
(
dOfft
 + 
cSegmtLgth
 =
wIm
.
	`g
().
	`ngth
());

1728  
wIm
;

1729 
	}
}

1731 
	gPassRef
<
	gSgIm
> SgIm::
	$a
(
SgIm
* 
n
, SgIm* 
amt
)

1733 i(!
n
 || !
amt
)

1734  *
this
;

1736 
nLgth
 = 
n
->
	`ngth
();

1737 i(!
nLgth
)

1738  *
this
;

1740 
pSLgth
 = 
amt
->
	`ngth
();

1741 
size_t
 
cSegmtS
 = 0;

1742 
mchCou
 = 0;

1745 (
cSegmtS
 = 
	`fd
(
n
, srcSegmtS)!
nFound
) {

1746 ++
mchCou
;

1747 
cSegmtS
 +
nLgth
;

1751 i(!
mchCou
)

1752  *
this
;

1754 
wSize
 = 
m_ngth
 - 
mchCou
 * 
nLgth
;

1755 i(
pSLgth
 && 
mchCou
 > 
d
::
numic_lims
<>::
	`max
() /epStrLength)

1756 
	`CRASH
();

1758 i(
wSize
 > (
d
::
numic_lims
<>::
	`max
(- 
mchCou
 * 
pSLgth
))

1759 
	`CRASH
();

1761 
wSize
 +
mchCou
 * 
pSLgth
;

1765 
size_t
 
cSegmtEnd
;

1766 
cSegmtLgth
;

1767 
cSegmtS
 = 0;

1768 
dOfft
 = 0;

1769 
bo
 
cIs8B
 = 
	`is8B
();

1770 
bo
 
amtIs8B
 = 
amt
->
	`is8B
();

1777 i(
cIs8B
 && 
amtIs8B
) {

1779 
LCh
* 
da
;

1780 aut
wIm
 = 
	`Unlized
(
wSize
, 
da
);

1781 (
cSegmtEnd
 = 
	`fd
(
n
, 
cSegmtS
)!
nFound
) {

1782 
cSegmtLgth
 = 
cSegmtEnd
 - 
cSegmtS
;

1783 
	`memy
(
da
 + 
dOfft
, 
m_da8
 + 
cSegmtS
, 
cSegmtLgth
 * (
LCh
));

1784 
dOfft
 +
cSegmtLgth
;

1785 
	`memy
(
da
 + 
dOfft
, 
amt
->
m_da8
, 
pSLgth
 * (
LCh
));

1786 
dOfft
 +
pSLgth
;

1787 
cSegmtS
 = 
cSegmtEnd
 + 
nLgth
;

1790 
cSegmtLgth
 = 
m_ngth
 - 
cSegmtS
;

1791 
	`memy
(
da
 + 
dOfft
, 
m_da8
 + 
cSegmtS
, 
cSegmtLgth
 * (
LCh
));

1793 
	`ASSERT
(
dOfft
 + 
cSegmtLgth
 =
wIm
.
	`g
().
	`ngth
());

1795  
wIm
;

1798 
UCh
* 
da
;

1799 aut
wIm
 = 
	`Unlized
(
wSize
, 
da
);

1800 (
cSegmtEnd
 = 
	`fd
(
n
, 
cSegmtS
)!
nFound
) {

1801 
cSegmtLgth
 = 
cSegmtEnd
 - 
cSegmtS
;

1802 i(
cIs8B
) {

1804 
i
 = 0; i < 
cSegmtLgth
; ++i)

1805 
da
[
i
 + 
dOfft
] = 
m_da8
[+ 
cSegmtS
];

1808 
	`memy
(
da
 + 
dOfft
, 
m_da16
 + 
cSegmtS
, 
cSegmtLgth
 * (
UCh
));

1810 
dOfft
 +
cSegmtLgth
;

1811 i(
amtIs8B
) {

1813 
i
 = 0; i < 
pSLgth
; ++i)

1814 
da
[
i
 + 
dOfft
] = 
amt
->
m_da8
[i];

1817 
	`memy
(
da
 + 
dOfft
, 
amt
->
m_da16
, 
pSLgth
 * (
UCh
));

1819 
dOfft
 +
pSLgth
;

1820 
cSegmtS
 = 
cSegmtEnd
 + 
nLgth
;

1823 
cSegmtLgth
 = 
m_ngth
 - 
cSegmtS
;

1824 i(
cIs8B
) {

1826 
i
 = 0; i < 
cSegmtLgth
; ++i)

1827 
da
[
i
 + 
dOfft
] = 
m_da8
[+ 
cSegmtS
];

1830 
	`memy
(
da
 + 
dOfft
, 
m_da16
 + 
cSegmtS
, 
cSegmtLgth
 * (
UCh
));

1833 
	`ASSERT
(
dOfft
 + 
cSegmtLgth
 =
wIm
.
	`g
().
	`ngth
());

1835  
wIm
;

1836 
	}
}

1838 
ALWAYS_INLINE
 
bo
 
	$rgImCڋEqu
(cڡ 
SgIm
& 
a
, cڡ SgIm& 
b
)

1840 
aLgth
 = 
a
.
	`ngth
();

1841 
bLgth
 = 
b
.
	`ngth
();

1842 i(
aLgth
 !
bLgth
)

1843  
l
;

1845 i(
a
.
	`is8B
()) {

1846 i(
b
.
	`is8B
())

1847  
	`equ
(
a
.
	`chas8
(), 
b
.chas8(), 
aLgth
);

1849  
	`equ
(
a
.
	`chas8
(), 
b
.
	`chas16
(), 
aLgth
);

1852 i(
b
.
	`is8B
())

1853  
	`equ
(
a
.
	`chas16
(), 
b
.
	`chas8
(), 
aLgth
);

1855  
	`equ
(
a
.
	`chas16
(), 
b
.chas16(), 
aLgth
);

1856 
	}
}

1858 
bo
 
	$equ
(cڡ 
SgIm
* 
a
, cڡ SgIm* 
b
)

1860 i(
a
 =
b
)

1861  
ue
;

1862 i(!
a
 || !
b
)

1863  
l
;

1865  
	`rgImCڋEqu
(*
a
, *
b
);

1866 
	}
}

1868 
	gme
 <
tyme
 
	gChTy
>

1869 
le
 
bo
 
	$equIl
(cڡ 
SgIm
* 
a
, cڡ 
ChTy
* 
b
, 
ngth
)

1871 i(!
a
)

1872  !
b
;

1873 i(!
b
)

1874  
l
;

1876 i(
a
->
	`ngth
(!
ngth
)

1877  
l
;

1878 i(
a
->
	`is8B
())

1879  
	`equ
(
a
->
	`chas8
(), 
b
, 
ngth
);

1880  
	`equ
(
a
->
	`chas16
(), 
b
, 
ngth
);

1881 
	}
}

1883 
bo
 
	$equ
(cڡ 
SgIm
* 
a
, cڡ 
LCh
* 
b
, 
ngth
)

1885  
	`equIl
(
a
, 
b
, 
ngth
);

1886 
	}
}

1888 
bo
 
	$equ
(cڡ 
SgIm
* 
a
, cڡ 
UCh
* 
b
, 
ngth
)

1890  
	`equIl
(
a
, 
b
, 
ngth
);

1891 
	}
}

1893 
bo
 
	$equ
(cڡ 
SgIm
* 
a
, cڡ 
LCh
* 
b
)

1895 i(!
a
)

1896  !
b
;

1897 i(!
b
)

1898  !
a
;

1900 
ngth
 = 
a
->
	`ngth
();

1902 i(
a
->
	`is8B
()) {

1903 cڡ 
LCh
* 
aP
 = 
a
->
	`chas8
();

1904 
i
 = 0; i !
ngth
; ++i) {

1905 
LCh
 
bc
 = 
b
[
i
];

1906 
LCh
 
ac
 = 
aP
[
i
];

1907 i(!
bc
)

1908  
l
;

1909 i(
ac
 !
bc
)

1910  
l
;

1913  !
b
[
ngth
];

1916 cڡ 
UCh
* 
aP
 = 
a
->
	`chas16
();

1917 
i
 = 0; i !
ngth
; ++i) {

1918 
LCh
 
bc
 = 
b
[
i
];

1919 i(!
bc
)

1920  
l
;

1921 i(
aP
[
i
] !
bc
)

1922  
l
;

1925  !
b
[
ngth
];

1926 
	}
}

1928 
bo
 
	$equ
(cڡ 
SgIm
& 
a
, cڡ SgIm& 
b
)

1930 i(&
a
 =&
b
)

1931  
ue
;

1933  
	`rgImCڋEqu
(
a
, 
b
);

1934 
	}
}

1936 
bo
 
	$equIgnܚgCa
(cڡ 
SgIm
* 
a
, cڡ SgIm* 
b
)

1938 i(
a
 =
b
)

1939  
ue
;

1940 i(!
a
 || !
b
)

1941  
l
;

1943  
CaFdgHash
::
	`equ
(
a
, 
b
);

1944 
	}
}

1946 
bo
 
	$equIgnܚgCa
(cڡ 
SgIm
* 
a
, cڡ 
LCh
* 
b
)

1948 i(!
a
)

1949  !
b
;

1950 i(!
b
)

1951  !
a
;

1953 
ngth
 = 
a
->
	`ngth
();

1956 
UCh
 
ed
 = 0;

1957 
bo
 
equ
 = 
ue
;

1958 i(
a
->
	`is8B
()) {

1959 cڡ 
LCh
* 
as
 = 
a
->
	`chas8
();

1960 
i
 = 0; i !
ngth
; ++i) {

1961 
LCh
 
bc
 = 
b
[
i
];

1962 i(!
bc
)

1963  
l
;

1964 
UCh
 
ac
 = 
as
[
i
];

1965 
ed
 |
ac
;

1966 
equ
 =qu && (
	`toASCIILow
(
ac
=toASCIILow(
bc
));

1970 i(
ed
 & ~0x7F) {

1971 
equ
 = 
ue
;

1972 
i
 = 0; i !
ngth
; ++i)

1973 
equ
 =qu && 
	`u_fdCa
(
as
[
i
], 
U_FOLD_CASE_DEFAULT
=u_fdCa(
b
[i], U_FOLD_CASE_DEFAULT);

1976  
equ
 && !
b
[
ngth
];

1979 cڡ 
UCh
* 
as
 = 
a
->
	`chas16
();

1980 
i
 = 0; i !
ngth
; ++i) {

1981 
LCh
 
bc
 = 
b
[
i
];

1982 i(!
bc
)

1983  
l
;

1984 
UCh
 
ac
 = 
as
[
i
];

1985 
ed
 |
ac
;

1986 
equ
 =qu && (
	`toASCIILow
(
ac
=toASCIILow(
bc
));

1990 i(
ed
 & ~0x7F) {

1991 
equ
 = 
ue
;

1992 
i
 = 0; i !
ngth
; ++i) {

1993 
equ
 =qu && 
	`u_fdCa
(
as
[
i
], 
U_FOLD_CASE_DEFAULT
=u_fdCa(
b
[i], U_FOLD_CASE_DEFAULT);

1997  
equ
 && !
b
[
ngth
];

1998 
	}
}

2000 
bo
 
	$equIgnܚgCaNNu
(cڡ 
SgIm
* 
a
, cڡ SgIm* 
b
)

2002 
	`ASSERT
(
a
 && 
b
);

2003 i(
a
 =
b
)

2004  
ue
;

2006 
ngth
 = 
a
->
	`ngth
();

2007 i(
ngth
 !
b
->
	`ngth
())

2008  
l
;

2010 i(
a
->
	`is8B
()) {

2011 i(
b
->
	`is8B
())

2012  
	`equIgnܚgCa
(
a
->
	`chas8
(), 
b
->chas8(), 
ngth
);

2014  
	`equIgnܚgCa
(
b
->
	`chas16
(), 
a
->
	`chas8
(), 
ngth
);

2017 i(
b
->
	`is8B
())

2018  
	`equIgnܚgCa
(
a
->
	`chas16
(), 
b
->
	`chas8
(), 
ngth
);

2020  
	`equIgnܚgCa
(
a
->
	`chas16
(), 
b
->chas16(), 
ngth
);

2021 
	}
}

2023 
bo
 
	$equIgnܚgNuΙy
(
SgIm
* 
a
, SgIm* 
b
)

2025 i(!
a
 && 
b
 && !b->
	`ngth
())

2026  
ue
;

2027 i(!
b
 && 
a
 && !a->
	`ngth
())

2028  
ue
;

2029  
	`equ
(
a
, 
b
);

2030 
	}
}

2032 
UChDei
 
	gSgIm
::
	$deuWrgDei
(
bo
* 
hasSgDeiڮy
)

2034 
i
 = 0; i < 
m_ngth
; ++i) {

2035 
UChDei
 
chDei
 = 
	`u_chDei
(
	`is8B
(? 
m_da8
[
i
] : 
m_da16
[i]);

2036 i(
chDei
 =
U_LEFT_TO_RIGHT
) {

2037 i(
hasSgDeiڮy
)

2038 *
hasSgDeiڮy
 = 
ue
;

2039  
U_LEFT_TO_RIGHT
;

2041 i(
chDei
 =
U_RIGHT_TO_LEFT
 || chDei =
U_RIGHT_TO_LEFT_ARABIC
) {

2042 i(
hasSgDeiڮy
)

2043 *
hasSgDeiڮy
 = 
ue
;

2044  
U_RIGHT_TO_LEFT
;

2047 i(
hasSgDeiڮy
)

2048 *
hasSgDeiڮy
 = 
l
;

2049  
U_LEFT_TO_RIGHT
;

2050 
	}
}

2052 
	gPassRef
<
	gSgIm
> SgIm::
adt
(
SgBufr
<
LCh
>& 
bufr
)

2054 
ngth
 = 
bufr
.length();

2055 i(!
	gngth
)

2056  *
emy
();

2057  
adtRef
(*
w
 
SgIm
(
bufr
.
a
(), 
ngth
));

2060 
	gPassRef
<
	gSgIm
> SgIm::
adt
(
SgBufr
<
UCh
>& 
bufr
)

2062 
ngth
 = 
bufr
.length();

2063 i(!
	gngth
)

2064  *
emy
();

2065  
adtRef
(*
w
 
SgIm
(
bufr
.
a
(), 
ngth
));

2068 
size_t
 
	gSgIm
::
	$sizeInBys
() const

2071 
size_t
 
size
 = 
	`ngth
();

2072 i(!
	`is8B
())

2073 
size
 *= 2;

2074  
size
 + (*
this
);

2075 
	}
}

2078 
le
 
	$putUTF8Tr
(*& 
bufr
, 
UCh
 
ch
)

2080 
	`ASSERT
(
ch
 >= 0x0800);

2081 *
bufr
++ = 
ic_
<>(((
ch
 >> 12) & 0x0F) | 0xE0);

2082 *
bufr
++ = 
ic_
<>(((
ch
 >> 6) & 0x3F) | 0x80);

2083 *
bufr
++ = 
ic_
<>((
ch
 & 0x3F) | 0x80);

2084 
	}
}

2086 
bo
 
	gSgIm
::
	$utf8Im
(cڡ 
UCh
* 
chas
, 
ngth
, *& 
bufr
, 
size_t
 
bufrSize
, 
CvsiMode
 
mode
)

2088 i(
mode
 =
SiCvsiRcgUaedSuogesWhFFFD
) {

2089 cڡ 
UCh
* 
chasEnd
 = 
chas
 + 
ngth
;

2090 * 
bufrEnd
 = 
bufr
 + 
bufrSize
;

2091 
chas
 < 
chasEnd
) {

2093 
CvsiResu
 
su
 = 
	`cvtUTF16ToUTF8
(&
chas
, 
chasEnd
, &
bufr
, 
bufrEnd
, 
ue
);

2094 
	`ASSERT
(
su
 !
rgExhaued
);

2097 i(
su
 !
cvsiOK
) {

2098 
	`ASSERT
((0xD800 <*
chas
 && *characters <= 0xDFFF));

2100 
	`ASSERT
((
bufr
 + 3<
bufrEnd
);

2101 
	`putUTF8Tr
(
bufr
, 
amtCha
);

2102 ++
chas
;

2106 
bo
 
ri
 = 
mode
 =
SiCvsi
;

2107 cڡ 
UCh
* 
igChas
 = 
chas
;

2108 
CvsiResu
 
su
 = 
	`cvtUTF16ToUTF8
(&
chas
, cha+ 
ngth
, &
bufr
, buf+ 
bufrSize
, 
ri
);

2109 
	`ASSERT
(
su
 !
rgExhaued
);

2112 i(
su
 =
sourIeg
) {

2113 
	`ASSERT
(
ri
);

2114  
l
;

2118 i(
su
 =
sourExhaued
) {

2119 i(
ri
)

2120  
l
;

2125 
	`ASSERT_UNUSED
(

2126 
igChas
, (
chas
 + 1=(igCha+ 
ngth
));

2127 
	`ASSERT
((*
chas
 >= 0xD800) && (*characters <= 0xDBFF));

2129 
	`ASSERT
((
bufr
 + 3<(buf+ 
bufrSize
));

2130 
	`putUTF8Tr
(
bufr
, *
chas
);

2134  
ue
;

2135 
	}
}

2137 
CSg
 
	gSgIm
::
	$utf8FChas
(cڡ 
UCh
* 
chas
, 
ngth
, 
CvsiMode
 
mode
)

2139 i(!
ngth
)

2140  
	`CSg
("", 0);

2141 i(
ngth
 > 
d
::
numic_lims
<>::
	`max
() / 3)

2142  
	`CSg
();

2143 
Ve
<, 1024> 
	`bufrVe
(
ngth
 * 3);

2144 * 
bufr
 = 
bufrVe
.
	`da
();

2145 i(!
	`utf8Im
(
chas
, 
ngth
, 
bufr
, 
bufrVe
.
	`size
(), 
mode
))

2146  
	`CSg
();

2147  
	`CSg
(
bufrVe
.
	`da
(), 
bufr
 - bufferVector.data());

2148 
	}
}

2150 
CSg
 
	gSgIm
::
	$utf8FRge
(
offt
, 
ngth
, 
CvsiMode
 
mode
) const

2152 
	`ASSERT
(
offt
 <
this
->
	`ngth
());

2153 
	`ASSERT
(
offt
 + 
ngth
 <
this
->
	`ngth
());

2155 i(!
ngth
)

2156  
	`CSg
("", 0);

2168 i(
ngth
 > 
d
::
numic_lims
<>::
	`max
() / 3)

2169  
	`CSg
();

2170 
Ve
<, 1024> 
	`bufrVe
(
ngth
 * 3);

2172 * 
bufr
 = 
bufrVe
.
	`da
();

2174 i(
	`is8B
()) {

2175 cڡ 
LCh
* 
chas
 = 
this
->
	`chas8
(+ 
offt
;

2177 
CvsiResu
 
su
 = 
	`cvtL1ToUTF8
(&
chas
, cha+ 
ngth
, &
bufr
, buf+ 
bufrVe
.
	`size
());

2178 
	`ASSERT_UNUSED
(
su
,esu !
rgExhaued
);

2180 i(!
	`utf8Im
(
this
->
	`chas16
(+ 
offt
, 
ngth
, 
bufr
, 
bufrVe
.
	`size
(), 
mode
))

2181  
	`CSg
();

2184  
	`CSg
(
bufrVe
.
	`da
(), 
bufr
 - bufferVector.data());

2185 
	}
}

2187 
CSg
 
	gSgIm
::
	$utf8
(
CvsiMode
 
mode
) const

2189  
	`utf8FRge
(0, 
	`ngth
(), 
mode
);

2190 
	}
}

2193 cڡ 
UCh
 
	gSgIm
::
t1CaFdTab
[256] = {

2212 
bo
 
	$equIgnܚgNuΙy
(cڡ 
UCh
* 
a
, 
size_t
 
aLgth
, 
SgIm
* 
b
)

2214 i(!
b
)

2215  !
aLgth
;

2216 i(
aLgth
 !
b
->
	`ngth
())

2217  
l
;

2218 i(
b
->
	`is8B
()) {

2219 cڡ 
LCh
* 
bChas
 = 
b
->
	`chas8
();

2220 
i
 = 0; i < 
aLgth
; ++i) {

2221 i(
a
[
i
] !
bChas
[i])

2222  
l
;

2224  
ue
;

2226  !
	`memcmp
(
a
, 
b
->
	`chas16
(), b->
	`ngth
(* (
UCh
));

2227 
	}
}

	@text/StringImpl.h

23 #ide
SgIm_h


24 
	#SgIm_h


	)

26 
	~<lims.h
>

27 
	~<unicode/uch.h
>

28 
	~<unicode/urg.h
>

29 
	~<wtf/ASCIICTy.h
>

30 
	~<wtf/Fwd.h
>

31 
	~<wtf/MhExas.h
>

32 
	~<wtf/StdLibExas.h
>

33 
	~<wtf/SgHash.h
>

34 
	~<wtf/Ve.h
>

35 
	~<wtf/xt/CvsiMode.h
>

43 #i
USE
(
CF
)

44 cڡ 
	t__CFSg
 * 
	tCFSgRef
;

47 #ifde
__OBJC__


48 @
ass
 
	gNSSg
;

51 
mea
 
	gJSC
 {

52 
mea
 
	gLLI
 { 
ass
 
	gDa
; }

53 
ass
 
	gLLIOfftsExa
;

56 
mea
 
	gWTF
 {

58 
	gCSgTn
;

59 
	gme
<
tyme
 
	gChaTy
> 
	gHashAndChasTn
;

60 
	gHashAndUTF8ChasTn
;

61 
	gLChBufrTn
;

62 
	gChBufrFromLDaTn
;

63 
	gSubrgTn
;

64 
	gUChBufrTn
;

65 
	gme
<
	gtyme
> 
ass
 
	gRaP
;

67 
	eTextCaSsivy
 {

68 
	gTextCaSsive
,

69 
	gTextCaInnsive


72 
bo
 (*
	tChaMchFuniP
)(
	tUCh
);

73 
bo
 (*
	tIsWheSFuniP
)(
	tUCh
);

76 #unde
STRING_STATS


78 #ifde
STRING_STATS


79 
	sSgSts
 {

80 
le
 
add8BSg
(
ngth
, 
bo
 
isSubSg
 = 
l
)

82 ++
m_tٮNumbSgs
;

83 ++
	gm_numb8BSgs
;

84 i(!
	gisSubSg
)

85 
	gm_tٮ8BDa
 +
ngth
;

88 
le
 
add16BSg
(
ngth
, 
bo
 
isSubSg
 = 
l
)

90 ++
m_tٮNumbSgs
;

91 ++
	gm_numb16BSgs
;

92 i(!
	gisSubSg
)

93 
	gm_tٮ16BDa
 +
ngth
;

96 
le
 
addUpcvdSg
(
ngth
)

98 ++
	gm_numbUpcvdSgs
;

99 
	gm_tٮUpcvdDa
 +
ngth
;

102 
moveSg
(
SgIm
*);

103 
tSts
();

105 cڡ 
	gs_tSgStsFqucy
 = 5000;

106 
	gs_rgRemovesTlPrtSts
;

108 
	gm_tٮNumbSgs
;

109 
	gm_numb8BSgs
;

110 
	gm_numb16BSgs
;

111 
	gm_numbUpcvdSgs
;

112 
	gm_tٮ8BDa
;

113 
	gm_tٮ16BDa
;

114 
	gm_tٮUpcvdDa
;

117 
	#STRING_STATS_ADD_8BIT_STRING
(
ngth

SgIm
::
	`rgSts
().
	`add8BSg
֒gth)

	)

118 
	#STRING_STATS_ADD_8BIT_STRING2
(
ngth
, 
isSubSg

SgIm
::
	`rgSts
().
	`add8BSg
֒gth, isSubSg)

	)

119 
	#STRING_STATS_ADD_16BIT_STRING
(
ngth

SgIm
::
	`rgSts
().
	`add16BSg
֒gth)

	)

120 
	#STRING_STATS_ADD_16BIT_STRING2
(
ngth
, 
isSubSg

SgIm
::
	`rgSts
().
	`add16BSg
֒gth, isSubSg)

	)

121 
	#STRING_STATS_ADD_UPCONVERTED_STRING
(
ngth

SgIm
::
	`rgSts
().
	`addUpcvdSg
֒gth)

	)

122 
	#STRING_STATS_REMOVE_STRING
(
rg

SgIm
::
	`rgSts
().
	`moveSg
(rg)

	)

124 
	#STRING_STATS_ADD_8BIT_STRING
(
ngth
(()0)

	)

125 
	#STRING_STATS_ADD_8BIT_STRING2
(
ngth
, 
isSubSg
(()0)

	)

126 
	#STRING_STATS_ADD_16BIT_STRING
(
ngth
(()0)

	)

127 
	#STRING_STATS_ADD_16BIT_STRING2
(
ngth
, 
isSubSg
(()0)

	)

128 
	#STRING_STATS_ADD_UPCONVERTED_STRING
(
ngth
(()0)

	)

129 
	#STRING_STATS_REMOVE_STRING
(
rg
(()0)

	)

132 as
	cSgIm
 {

133 
WTF_MAKE_NONCOPYABLE
(
SgIm
); 
	gWTF_MAKE_FAST_ALLOCATED
;

134 
nd
 
	gWTF
::
CSgTn
;

135 
	gme
<
tyme
 
	gChaTy
> 
nd
 
	gWTF
::
HashAndChasTn
;

136 
nd
 
	gWTF
::
HashAndUTF8ChasTn
;

137 
nd
 
	gWTF
::
ChBufrFromLDaTn
;

138 
nd
 
	gWTF
::
LChBufrTn
;

139 
nd
 
	gWTF
::
SubrgTn
;

140 
nd
 
	gWTF
::
UChBufrTn
;

141 
nd
 
ass
 
	gAtomicSgIm
;

142 
nd
 
ass
 
	gJSC
::
LLI
::
Da
;

143 
nd
 
ass
 
	gJSC
::
LLIOfftsExa
;

145 
	give
:

146 
	eBufrOwrsh
 {

147 
BufrIl
,

148 
	gBufrOwd
,

149 
	gBufrSubrg
,

155 
nd
 
ass
 
	gNevDeroyed
<
	gSgIm
>;

156 
	eCڡruEmySgTag
 { 
	gCڡruEmySg
 };

157 
SgIm
(
CڡruEmySgTag
)

158 : 
m_fCou
(
s_fCouFgIsSticSg
)

159 , 
m_ngth
(0)

160 , 
m_da8
(
t_
<cڡ 
LCh
*>(&
m_ngth
))

161 , 
m_hashAndFgs
(
s_hashFg8BBufr
 | 
s_hashFgIsAtomic
 | 
BufrOwd
)

166 
STRING_STATS_ADD_8BIT_STRING
(
m_ngth
);

168 
hash
();

172 
	eF8B
 { 
	gF8BCڡru
 };

174 
SgIm
(
ngth
, 
F8B
)

175 : 
m_fCou
(
s_fCouInemt
)

176 , 
m_ngth
(
ngth
)

177 , 
m_da8
(
Por
<
LCh
>())

178 , 
m_hashAndFgs
(
s_hashFg8BBufr
 | 
BufrIl
)

180 
ASSERT
(
m_da8
);

181 
ASSERT
(
m_ngth
);

183 
STRING_STATS_ADD_8BIT_STRING
(
m_ngth
);

187 
SgIm
(
ngth
)

188 : 
m_fCou
(
s_fCouInemt
)

189 , 
m_ngth
(
ngth
)

190 , 
m_da16
(
Por
<
UCh
>())

191 , 
m_hashAndFgs
(
BufrIl
)

193 
ASSERT
(
m_da16
);

194 
ASSERT
(
m_ngth
);

196 
STRING_STATS_ADD_16BIT_STRING
(
m_ngth
);

200 
SgIm
(
MlocP
<
LCh
> 
chas
, 
ngth
)

201 : 
m_fCou
(
s_fCouInemt
)

202 , 
m_ngth
(
ngth
)

203 , 
m_da8
(
chas
.
akP
())

204 , 
m_hashAndFgs
(
s_hashFg8BBufr
 | 
BufrOwd
)

206 
ASSERT
(
m_da8
);

207 
ASSERT
(
m_ngth
);

209 
STRING_STATS_ADD_8BIT_STRING
(
m_ngth
);

212 
	eCڡruWhoutCygTag
 { 
	gCڡruWhoutCyg
 };

213 
SgIm
(cڡ 
UCh
* 
chas
, 
ngth
, 
CڡruWhoutCygTag
)

214 : 
m_fCou
(
s_fCouInemt
)

215 , 
m_ngth
(
ngth
)

216 , 
m_da16
(
chas
)

217 , 
m_hashAndFgs
(
BufrIl
)

219 
ASSERT
(
m_da16
);

220 
ASSERT
(
m_ngth
);

222 
STRING_STATS_ADD_16BIT_STRING
(0);

225 
SgIm
(cڡ 
LCh
* 
chas
, 
ngth
, 
CڡruWhoutCygTag
)

226 : 
m_fCou
(
s_fCouInemt
)

227 , 
m_ngth
(
ngth
)

228 , 
m_da8
(
chas
)

229 , 
m_hashAndFgs
(
s_hashFg8BBufr
 | 
BufrIl
)

231 
ASSERT
(
m_da8
);

232 
ASSERT
(
m_ngth
);

234 
STRING_STATS_ADD_8BIT_STRING
(0);

238 
SgIm
(
MlocP
<
UCh
> 
chas
, 
ngth
)

239 : 
m_fCou
(
s_fCouInemt
)

240 , 
m_ngth
(
ngth
)

241 , 
m_da16
(
chas
.
akP
())

242 , 
m_hashAndFgs
(
BufrOwd
)

244 
ASSERT
(
m_da16
);

245 
ASSERT
(
m_ngth
);

247 
STRING_STATS_ADD_16BIT_STRING
(
m_ngth
);

251 
SgIm
(cڡ 
LCh
* 
chas
, 
ngth
, 
PassRefP
<SgIm> 
ba
)

252 : 
m_fCou
(
s_fCouInemt
)

253 , 
m_ngth
(
ngth
)

254 , 
m_da8
(
chas
)

255 , 
m_hashAndFgs
(
s_hashFg8BBufr
 | 
BufrSubrg
)

257 
ASSERT
(
is8B
());

258 
ASSERT
(
m_da8
);

259 
ASSERT
(
m_ngth
);

260 
ASSERT
(
ba
->
bufrOwrsh
(!
BufrSubrg
);

262 
subrgBufr
(
ba
.
akRef
();

264 
STRING_STATS_ADD_8BIT_STRING2
(
m_ngth
, 
ue
);

268 
SgIm
(cڡ 
UCh
* 
chas
, 
ngth
, 
PassRefP
<SgIm> 
ba
)

269 : 
m_fCou
(
s_fCouInemt
)

270 , 
m_ngth
(
ngth
)

271 , 
m_da16
(
chas
)

272 , 
m_hashAndFgs
(
BufrSubrg
)

274 
ASSERT
(!
is8B
());

275 
ASSERT
(
m_da16
);

276 
ASSERT
(
m_ngth
);

277 
ASSERT
(
ba
->
bufrOwrsh
(!
BufrSubrg
);

279 
subrgBufr
(
ba
.
akRef
();

281 
STRING_STATS_ADD_16BIT_STRING2
(
m_ngth
, 
ue
);

284 
	eCeEmyUniqueTag
 { 
	gCeEmyUnique
 };

285 
SgIm
(
CeEmyUniqueTag
)

286 : 
m_fCou
(
s_fCouInemt
)

287 , 
m_ngth
(0)

290 , 
m_da8
(
t_
<cڡ 
LCh
*>(&
m_ngth
))

291 , 
m_hashAndFgs
(
hashAndFgsFEmyUnique
())

293 
ASSERT
(
m_da8
);

295 
STRING_STATS_ADD_8BIT_STRING
(
m_ngth
);

298 ~
SgIm
();

300 
	gpublic
:

301 
WTF_EXPORT_STRING_API
 
deroy
(
SgIm
*);

303 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 

(cڡ 
UCh
*, 
ngth
);

304 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 

(cڡ 
LCh
*, 
ngth
);

305 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 
8BIfPossib
(cڡ 
UCh
*, 
ngth
);

306 
	gme
<
size_t
 
	gleCacy
>

307 
	gPassRef
<
	gSgIm
> 
8BIfPossib
(cڡ 
Ve
<
UCh
, 
leCacy
>& 
ve
)

309  
8BIfPossib
(
ve
.
da
(), ve.
size
());

311 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 
8BIfPossib
(cڡ 
UCh
*);

313 
ALWAYS_INLINE
 
	gPassRef
<
	gSgIm
> 

(cڡ * 
s
, 
ngth
{  ce(
t_
<cڡ 
LCh
*>(s),ength); }

314 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 

(cڡ 
LCh
*);

315 
ALWAYS_INLINE
 
	gPassRef
<
	gSgIm
> 

(cڡ * 
s
{  ce(
t_
<cڡ 
LCh
*>(s)); }

317 
ALWAYS_INLINE
 
	gPassRef
<
	gSgIm
> 
SubrgShgIm8
(
PassRefP
<
SgIm
> 
p
, 
offt
, 
ngth
)

319 
ASSERT
(
p
);

320 
ASSERT
(
ngth
 <
p
->length());

322 i(!
	gngth
)

323  *
emy
();

325 
ASSERT
(
p
->
is8B
());

326 
SgIm
* 
	gowrR
 = (
p
->
bufrOwrsh
(=
BufrSubrg
?->
subrgBufr
(:.
g
();

329 
SgIm
* 
	grgIm
 = 
ic_
<SgIm*>(
Mloc
(
lotiSize
<StringImpl*>(1)));

330  
adtRef
(*
w
 (
NNu
, 
rgIm

SgIm
(
p
->
m_da8
 + 
offt
, 
ngth
, 
owrR
));

333 
ALWAYS_INLINE
 
	gPassRef
<
	gSgIm
> 
SubrgShgIm
(
PassRefP
<
SgIm
> 
p
, 
offt
, 
ngth
)

335 
ASSERT
(
p
);

336 
ASSERT
(
ngth
 <
p
->length());

338 i(!
	gngth
)

339  *
emy
();

341 
SgIm
* 
	gowrR
 = (
p
->
bufrOwrsh
(=
BufrSubrg
?->
subrgBufr
(:.
g
();

344 
SgIm
* 
	grgIm
 = 
ic_
<SgIm*>(
Mloc
(
lotiSize
<StringImpl*>(1)));

345 i(
	gp
->
is8B
())

346  
adtRef
(*
w
 (
NNu
, 
rgIm

SgIm
(
p
->
m_da8
 + 
offt
, 
ngth
, 
owrR
));

347  
adtRef
(*
w
 (
NNu
, 
rgIm

SgIm
(
p
->
m_da16
 + 
offt
, 
ngth
, 
owrR
));

350 
	gme
<
	gchasCou
>

351 
ALWAYS_INLINE
 
	gPassRef
<
	gSgIm
> 
FromL
(cڡ (&
chas
)[
chasCou
])

353 
COMPILE_ASSERT
(
chasCou
 > 1, 
SgImFromLNEmy
);

354 
COMPILE_ASSERT
((
chasCou
 - 1 <(((~0- (
SgIm
)/ (
LCh
))), 
SgImFromLCnOvow
);

356  
WhoutCyg
(
t_
<cڡ 
LCh
*>(
chas
), 
chasCou
 - 1);

360 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 
FromL
(cڡ * 
chas
, 
ngth
);

361 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 
FromL
(cڡ * 
chas
);

363 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 
WhoutCyg
(cڡ 
UCh
* 
chas
, 
ngth
);

364 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 
WhoutCyg
(cڡ 
LCh
* 
chas
, 
ngth
);

366 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 
Unlized
(
ngth
, 
LCh
*& 
da
);

367 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 
Unlized
(
ngth
, 
UCh
*& 
da
);

368 
	gme
 <
tyme
 
	gT
> 
ALWAYS_INLINE
 
	gPassRefP
<
	gSgIm
> 
yCeUnlized
(
ngth
, 
T
*& 
ouut
)

370 i(!
	gngth
) {

371 
	gouut
 = 0;

372  
emy
();

375 i(
	gngth
 > ((
	gd
::
numic_lims
<>::
max
(- (
SgIm
)/ (
T
))) {

376 
ouut
 = 0;

379 
SgIm
* 
	gsuIm
;

380 i(!
yFaMloc
(
lotiSize
<
T
>(
ngth
)).
gVue
(
suIm
)) {

381 
	gouut
 = 0;

384 
	gouut
 = 
suIm
->
Por
<
T
>();

386  
	gcڡruIl
<
	gT
>(
	gsuIm
, 
	gngth
);

389 
	gPassRef
<
	gSgIm
> 
EmyUnique
()

391  
adtRef
(*
w
 
SgIm
(
CeEmyUnique
));

397 
	gPassRef
<
	gSgIm
> 
lo
(
PassRefP
<
SgIm
> 
igSg
, 
ngth
, 
LCh
*& 
da
);

398 
	gPassRef
<
	gSgIm
> 
lo
(
PassRefP
<
SgIm
> 
igSg
, 
ngth
, 
UCh
*& 
da
);

400 
agsOfft
({  
OBJECT_OFFSETOF
(
SgIm
, 
m_hashAndFgs
); }

401 
agIs8B
({  
	gs_hashFg8BBufr
; }

402 
agIsAtomic
({  
	gs_hashFgIsAtomic
; }

403 
daOfft
({  
OBJECT_OFFSETOF
(
SgIm
, 
m_da8
); }

405 
	gme
<
tyme
 
	gChTy
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

406 
	gPassRef
<
	gSgIm
> 
adt
(
Ve
<
ChTy
, 
leCacy
, 
OvowHdr
>& 
ve
)

408 i(
size_t
 
	gsize
 = 
ve
.
size
()) {

409 
ASSERT
(
ve
.
da
());

410 i(
	gsize
 > 
	gd
::
numic_lims
<>::
max
())

411 
CRASH
();

412  
adtRef
(*
w
 
SgIm
(
ve
.
aBufr
(), 
size
));

414  *
emy
();

417 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 
adt
(
SgBufr
<
UCh
>&);

418 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 
adt
(
SgBufr
<
LCh
>&);

420 
ngth
(cڡ {  
	gm_ngth
; }

421 
rdiff_t
 
ngthMemyOfft
({  
OBJECT_OFFSETOF
(
SgIm
, 
m_ngth
); }

422 
bo
 
is8B
(cڡ {  
	gm_hashAndFgs
 & 
	gs_hashFg8BBufr
; }

424 
ALWAYS_INLINE
 cڡ 
LCh
* 
chas8
(cڡ { 
ASSERT
(
is8B
());  
	gm_da8
; }

425 
ALWAYS_INLINE
 cڡ 
UCh
* 
chas16
(cڡ { 
ASSERT
(!
is8B
());  
	gm_da16
; }

427 
	gme
 <
tyme
 
	gChTy
>

428 
ALWAYS_INLINE
 cڡ 
ChTy
 *
chas
() const;

430 
size_t
 
co
() const

433 i(
bufrOwrsh
(=
BufrSubrg
)

434  
subrgBufr
()->
co
();

436 i(
	gm_hashAndFgs
 & 
	gs_hashFgDidRtCo
)

439 
	gm_hashAndFgs
 |
s_hashFgDidRtCo
;

440 
size_t
 
	gsu
 = 
m_ngth
;

441 i(!
is8B
())

442 
	gsu
 <<= 1;

443  
	gsu
;

446 
size_t
 
coDurgGC
()

448 i(
isStic
())

451 i(
bufrOwrsh
(=
BufrSubrg
)

452  
divideRoundedUp
(
subrgBufr
()->
coDurgGC
(), 
fCou
());

454 
size_t
 
	gsu
 = 
m_ngth
;

455 i(!
is8B
())

456 
	gsu
 <<= 1;

457  
divideRoundedUp
(
su
, 
fCou
());

460 
WTF_EXPORT_STRING_API
 
size_t
 
sizeInBys
() const;

462 
bo
 
isEmyUnique
() const

464  !
ngth
(&& !
isStic
();

467 
bo
 
isAtomic
(cڡ {  
	gm_hashAndFgs
 & 
	gs_hashFgIsAtomic
; }

468 
tIsAtomic
(
bo
 
isAtomic
)

470 
ASSERT
(!
isStic
());

471 
ASSERT
(!
isEmyUnique
());

472 i(
	gisAtomic
)

473 
	gm_hashAndFgs
 |
s_hashFgIsAtomic
;

475 
	gm_hashAndFgs
 &~
s_hashFgIsAtomic
;

478 #ifde
STRING_STATS


479 
bo
 
isSubSg
(cڡ {  
bufrOwrsh
(=
BufrSubrg
; }

482 
WTF_EXPORT_STRING_API
 
CSg
 
utf8FChas
(cڡ 
UCh
* 
chas
, 
ngth
, 
CvsiMode
 = 
LCvsi
);

483 
WTF_EXPORT_STRING_API
 
CSg
 
utf8FRge
(
offt
, 
ngth
, 
CvsiMode
 = 
LCvsi
) const;

484 
WTF_EXPORT_STRING_API
 
CSg
 
utf8
(
CvsiMode
 = 
LCvsi
) const;

486 
	give
:

487 
WTF_EXPORT_STRING_API
 
bo
 
utf8Im
(cڡ 
UCh
* 
chas
, 
ngth
, *& 
bufr
, 
size_t
 
bufrSize
, 
CvsiMode
);

492 
tHash
(
hash
) const

494 
ASSERT
(!
hasHash
());

496 
ASSERT
(
hash
 =(
is8B
(? 
SgHash
::
compuHashAndMaskT8Bs
(
m_da8
, 
m_ngth
: SgHash::compuHashAndMaskT8Bs(
m_da16
, m_length)));

497 
ASSERT
(!(
hash
 & (
s_agMask
 << (8 * (hash- 
s_agCou
))));

499 
	ghash
 <<
s_agCou
;

500 
ASSERT
(!(
hash
 & 
m_hashAndFgs
));

501 
ASSERT
(
hash
);

503 
	gm_hashAndFgs
 |
hash
;

506 
wHash
() const

508  
	gm_hashAndFgs
 >> 
	gs_agCou
;

511 
	gpublic
:

512 
bo
 
hasHash
() const

514  
wHash
() != 0;

517 
exigHash
() const

519 
ASSERT
(
hasHash
());

520  
wHash
();

523 
hash
() const

525 i(
hasHash
())

526  
exigHash
();

527  
hashSlowCa
();

530 
bo
 
isStic
(cڡ {  
	gm_fCou
 & 
	gs_fCouFgIsSticSg
; }

532 
le
 
size_t
 
fCou
() const

534  
	gm_fCou
 / 
	gs_fCouInemt
;

537 
le
 
bo
 
hasORef
() const

539  
	gm_fCou
 =
s_fCouInemt
;

543 
le
 
bo
 
hasAtLORef
() const

545  !!
	gm_fCou
;

548 
le
 
f
()

550 #i!
ENABLE
(
VMOLAB
)

551 
ASSERT
(!
isCompiThad
());

553 
	gm_fCou
 +
s_fCouInemt
;

556 
le
 
def
()

558 #i!
ENABLE
(
VMOLAB
)

559 
ASSERT
(!
isCompiThad
());

561 
	gmpRefCou
 = 
m_fCou
 - 
s_fCouInemt
;

562 i(!
	gmpRefCou
) {

563 
	gSgIm
::
deroy
(
this
);

566 
	gm_fCou
 = 
mpRefCou
;

569 
WTF_EXPORT_PRIVATE
 
SgIm
* 
emy
();

572 
	gme
 <
tyme
 
	gT
> 
cyChs
(
T
* 
dei
, cڡ T* 
sour
, 
numChas
)

574 i(
	gnumChas
 == 1) {

575 *
dei
 = *
sour
;

579 i(
	gnumChas
 <
s_cyChsIƚeCutOff
) {

580 
i
 = 0;

581 #i(
CPU
(
X86
|| CPU(
X86_64
))

582 cڡ 
	gchsPI
 = (
ut32_t
/ (
T
);

584 i(
	gnumChas
 > 
	gchsPI
) {

585 
	gCou
 = 
numChas
 & ~(
chsPI
 - 1);

587 cڡ 
ut32_t
* 
	gcChas
 = 
t_
<cڡ ut32_t*>(
sour
);

588 
ut32_t
* 
	gdeChas
 = 
t_
<ut32_t*>(
dei
);

589 
	gj
 = 0; 
	gi
 < 
	gCou
; i +
chsPI
, ++j)

590 
	gdeChas
[
j
] = 
cChas
[j];

593 ; 
	gi
 < 
	gnumChas
; ++i)

594 
	gdei
[
i
] = 
sour
[i];

596 
memy
(
dei
, 
sour
, 
numChas
 * (
T
));

599 
ALWAYS_INLINE
 
cyChs
(
UCh
* 
dei
, cڡ 
LCh
* 
sour
, 
numChas
)

601 
	gi
 = 0; i < 
	gnumChas
; ++i)

602 
	gdei
[
i
] = 
sour
[i];

608 
	gPassRef
<
	gSgIm
> 
isީedCy
() const;

610 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 
subrg
(
pos
, 
n
 = 
UINT_MAX
);

612 
UCh
 

(
i
) const

614 
ASSERT_WITH_SECURITY_IMPLICATION
(
i
 < 
m_ngth
);

615 i(
is8B
())

616  
	gm_da8
[
i
];

617  
	gm_da16
[
i
];

619 
UCh
 
	gݔ
[](
	gi
cڡ {  

(
i
); }

620 
WTF_EXPORT_STRING_API
 
UCh32
 
chaSgAt
();

622 
WTF_EXPORT_STRING_API
 
bo
 
cڏsOyWhea
();

624 
toISi
(
bo
* 
ok
 = 0, 
ba
 = 10);

625 
toUISi
(
bo
* 
ok
 = 0, 
ba
 = 10);

626 
t64_t
 
toI64Si
(
bo
* 
ok
 = 0, 
ba
 = 10);

627 
ut64_t
 
toUI64Si
(
bo
* 
ok
 = 0, 
ba
 = 10);

628 
_t
 
toIPSi
(
bo
* 
ok
 = 0, 
ba
 = 10);

630 
WTF_EXPORT_STRING_API
 
toI
(
bo
* 
ok
 = 0);

631 
toUI
(
bo
* 
ok
 = 0);

632 
t64_t
 
toI64
(
bo
* 
ok
 = 0);

633 
ut64_t
 
toUI64
(
bo
* 
ok
 = 0);

634 
_t
 
toIP
(
bo
* 
ok
 = 0);

639 
toDoub
(
bo
* 
ok
 = 0);

640 
toFlt
(
bo
* 
ok
 = 0);

642 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 
cvtToASCIILow
();

643 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 
low
();

644 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 
u
();

645 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 
low
(cڡ 
AtomicSg
& 
loIdtifr
);

646 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 
u
(cڡ 
AtomicSg
& 
loIdtifr
);

648 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 
fl
(
UCh
);

651 
	gPassRef
<
	gSgIm
> 
fdCa
();

653 
	gPassRef
<
	gSgIm
> 
rWheS
();

654 
	gPassRef
<
	gSgIm
> 
rWheS
(
IsWheSFuniP
);

655 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 
simifyWheS
();

656 
	gPassRef
<
	gSgIm
> 
simifyWheS
(
IsWheSFuniP
);

658 
	gPassRef
<
	gSgIm
> 
moveChas
(
ChaMchFuniP
);

659 
	gme
 <
tyme
 
	gChTy
>

660 
ALWAYS_INLINE
 
	gPassRef
<
	gSgIm
> 
moveChas
(cڡ 
ChTy
* 
chas
, 
ChaMchFuniP
);

662 
size_t
 
fd
(
LCh
 
cha
, 
t
 = 0);

663 
size_t
 
fd
(
cha
, 
t
 = 0);

664 
size_t
 
fd
(
UCh
 
cha
, 
t
 = 0);

665 
WTF_EXPORT_STRING_API
 
size_t
 
fd
(
ChaMchFuniP
, 
dex
 = 0);

666 
size_t
 
fd
(cڡ 
LCh
*, 
dex
 = 0);

667 
ALWAYS_INLINE
 
size_t
 
fd
(cڡ * 
s
, 
dex
 = 0{  fd(
t_
<cڡ 
LCh
*>(s), index); }

668 
WTF_EXPORT_STRING_API
 
size_t
 
fd
(
SgIm
*);

669 
WTF_EXPORT_STRING_API
 
size_t
 
fd
(
SgIm
*, 
dex
);

670 
size_t
 
fdIgnܚgCa
(cڡ 
LCh
*, 
dex
 = 0);

671 
ALWAYS_INLINE
 
size_t
 
fdIgnܚgCa
(cڡ * 
s
, 
dex
 = 0{  fdIgnܚgCa(
t_
<cڡ 
LCh
*>(s), index); }

672 
WTF_EXPORT_STRING_API
 
size_t
 
fdIgnܚgCa
(
SgIm
*, 
dex
 = 0);

674 
WTF_EXPORT_STRING_API
 
size_t
 
fdNextLeS
(
dex
 = 
UINT_MAX
);

676 
WTF_EXPORT_STRING_API
 
size_t
 
vFd
(
UCh
, 
dex
 = 
UINT_MAX
);

677 
WTF_EXPORT_STRING_API
 
size_t
 
vFd
(
SgIm
*, 
dex
 = 
UINT_MAX
);

678 
WTF_EXPORT_STRING_API
 
size_t
 
vFdIgnܚgCa
(
SgIm
*, 
dex
 = 
UINT_MAX
);

680 
WTF_EXPORT_STRING_API
 
bo
 
tsWh
(cڡ 
SgIm
*) const;

681 
bo
 
tsWh
(
SgIm
* 
r
, bo 
Ssive
{  
	gSsive
 ? ssWh(r: (
vFdIgnܚgCa
(str, 0) == 0); }

682 
WTF_EXPORT_STRING_API
 
bo
 
tsWh
(
UCh
) const;

683 
WTF_EXPORT_STRING_API
 
bo
 
tsWh
(cڡ *, 
mchLgth
, bo 
Ssive
) const;

684 
	gme
<
	gmchLgth
>

685 
bo
 
tsWh
(cڡ (&
efix
)[
mchLgth
], bo 
Ssive
 = 
ue
) const {  startsWith(prefix, matchLength - 1, caseSensitive); }

686 
WTF_EXPORT_STRING_API
 
bo
 
tsWh
(
SgIm
&, 
tOfft
, bo 
Ssive
) const;

688 
WTF_EXPORT_STRING_API
 
bo
 
dsWh
(
SgIm
*, bo 
Ssive
 = 
ue
);

689 
WTF_EXPORT_STRING_API
 
bo
 
dsWh
(
UCh
) const;

690 
WTF_EXPORT_STRING_API
 
bo
 
dsWh
(cڡ *, 
mchLgth
, bo 
Ssive
) const;

691 
	gme
<
	gmchLgth
>

692 
bo
 
dsWh
(cڡ (&
efix
)[
mchLgth
], bo 
Ssive
 = 
ue
) const { ndsWith(prefix, matchLength - 1, caseSensitive); }

693 
WTF_EXPORT_STRING_API
 
bo
 
dsWh
(
SgIm
&, 
dOfft
, bo 
Ssive
) const;

695 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 
a
(
UCh
, UChar);

696 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 
a
(
UCh
, 
SgIm
*);

697 
ALWAYS_INLINE
 
	gPassRef
<
	gSgIm
> 
a
(
UCh
 
n
, cڡ * 
amt
, 
amtLgth
{ թ, 
t_
<cڡ 
LCh
*>(replacement),eplacementLength); }

698 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 
a
(
UCh
, cڡ 
LCh
*, 
amtLgth
);

699 
	gPassRef
<
	gSgIm
> 
a
(
UCh
, cڡ UCh*, 
amtLgth
);

700 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 
a
(
SgIm
*, StringImpl*);

701 
WTF_EXPORT_STRING_API
 
	gPassRef
<
	gSgIm
> 
a
(
dex
, 
n
, 
SgIm
*);

703 
WTF_EXPORT_STRING_API
 
UChDei
 
deuWrgDei
(
bo
* 
hasSgDeiڮy
 = 
nuαr
);

705 #i
USE
(
CF
)

706 
	gRaP
<
	gCFSgRef
> 
CFSg
();

708 #ifde
__OBJC__


709 
WTF_EXPORT_STRING_API
 
ݔ
 
	gNSSg
*();

712 #ifde
STRING_STATS


713 
ALWAYS_INLINE
 
	gSgSts
& 
rgSts
({  
	gm_rgSts
; }

716 
WTF_EXPORT_STRING_API
 cڡ 
UCh
 
	gt1CaFdTab
[256];

718 
	give
:

719 
bo
 
quesCy
() const

721 i(
bufrOwrsh
(!
BufrIl
)

722  
ue
;

724 i(
is8B
())

725  
	gm_da8
 =
Por
<
LCh
>();

726  
	gm_da16
 =
Por
<
UCh
>();

729 
	gme
<
tyme
 
	gT
>

730 
size_t
 
lotiSize
(
EmtCou
)

732  
	gOfft
<
	gT
>(+ 
EmtCou
 * (T);

735 
	gme
<
tyme
 
	gT
>

736 
rdiff_t
 
Offt
()

738 #i
COMPILER
(
MSVC
)

740  
	groundUpToMuɝOf
<(
	gT
)>((
	gSgIm
));

742  
	groundUpToMuɝOf
<
ignof
(
T
)>(
offtof
(
SgIm
, 
m_hashAndFgs
+ (
	gSgIm
::m_hashAndFlags));

746 
	gme
<
tyme
 
	gT
>

747 cڡ 
T
* 
Por
() const

749  
	gt_
<cڡ 
	gT
*>et_<cڡ 
	gut8_t
*>(
	gthis
+ 
	gOfft
<T>());

752 
	gme
<
tyme
 
	gT
>

753 
T
* 
Por
()

755  
	gt_
<
	gT
*>et_<
	gut8_t
*>(
	gthis
+ 
	gOfft
<T>());

758 
SgIm
* cڡ& 
subrgBufr
() const

760 
ASSERT
(
bufrOwrsh
(=
BufrSubrg
);

762  *
	gPor
<
	gSgIm
*>();

765 
	gSgIm
*& 
subrgBufr
()

767 
ASSERT
(
bufrOwrsh
(=
BufrSubrg
);

769  *
	gPor
<
	gSgIm
*>();

773 cڡ 
	gs_cyChsIƚeCutOff
 = 20;

775 
BufrOwrsh
 
bufrOwrsh
(cڡ {  
	gic_
<
	gBufrOwrsh
>(
	gm_hashAndFgs
 & 
	gs_hashMaskBufrOwrsh
); }

776 
	gme
 <
ass
 
	gUChPdi
> 
	gPassRef
<
	gSgIm
> 
rMchedChas
(
UChPdi
);

777 
	gme
 <
tyme
 
	gChTy
, 
ass
 
	gUChPdi
> 
	gPassRef
<
	gSgIm
> 
simifyMchedChasToS
(
UChPdi
);

778 
	gme
 <
tyme
 
	gChTy
> 
	gPassRef
<
	gSgIm
> 
cڡruIl
(
SgIm
*, );

779 
	gme
 <
tyme
 
	gChTy
> 
	gPassRef
<
	gSgIm
> 
UnlizedIl
(, 
ChTy
*&);

780 
	gme
 <
tyme
 
	gChTy
> 
	gPassRef
<
	gSgIm
> 
UnlizedIlNEmy
(, 
ChTy
*&);

781 
	gme
 <
tyme
 
	gChTy
> 
	gPassRef
<
	gSgIm
> 
loIl
(
PassRefP
<
SgIm
>, , 
ChTy
*&);

782 
	gme
 <
tyme
 
	gChTy
> 
	gPassRef
<
	gSgIm
> 
Il
(cڡ 
ChTy
*, );

783 
WTF_EXPORT_PRIVATE
 
NEVER_INLINE
 
hashSlowCa
() const;

784 
WTF_EXPORT_PRIVATE
 
hashAndFgsFEmyUnique
();

787 cڡ 
	gs_fCouFgIsSticSg
 = 0x1;

788 cڡ 
	gs_fCouInemt
 = 0x2;

791 cڡ 
	gs_agCou
 = 6;

792 cڡ 
	gs_agMask
 = (1u << 
s_agCou
) - 1;

793 
COMPILE_ASSERT
(
s_agCou
 <
SgHash
::
agCou
, 
SgHash_rves_ough_bs_f_SgIm_ags
);

795 cڡ 
	gs_hashFg8BBufr
 = 1u << 5;

796 cڡ 
	gs_hashFgIsAtomic
 = 1u << 4;

797 cڡ 
	gs_hashFgDidRtCo
 = 1u << 3;

798 cڡ 
	gs_hashMaskBufrOwrsh
 = 1u | (1u << 1);

800 #ifde
STRING_STATS


801 
WTF_EXPORTDATA
 
SgSts
 
	gm_rgSts
;

804 
	gpublic
:

805 
	sSticASCIIL
 {

807 
m_fCou
;

808 
	gm_ngth
;

809 cڡ 
LCh
* 
	gm_da8
;

810 
	gm_hashAndFgs
;

813 cڡ 
	gs_lRefCou
 = 
s_fCouInemt
;

814 cڡ 
	gs_lFgs
 = 
s_hashFg8BBufr
 | 
BufrIl
;

815 cڡ 
	gs_hashShi
 = 
s_agCou
;

818 #ide
NDEBUG


819 
asHashIsCܻ
()

821 
ASSERT
(
hasHash
());

822 
ASSERT
(
exigHash
(=
SgHash
::
compuHashAndMaskT8Bs
(
chas8
(), 
ngth
()));

826 
	give
:

828 #i
ENABLE
(
VMOLAB
)

831 
m_fCou
;

832 
	gm_ngth
;

834 cڡ 
LCh
* 
	gm_da8
;

835 cڡ 
UCh
* 
	gm_da16
;

837 
mub
 
	gm_hashAndFgs
;

840 
ic_as
((
SgIm
=(SgIm::
SticASCIIL
), "");

842 #i!
ASSERT_DISABLED


848 
	gme
<> 

849 
	gVueCheck
<
	gSgIm
*> {

850 
checkCsicy
(cڡ 
SgIm
*) { }

854 
	gme
 <>

855 
ALWAYS_INLINE
 
	gPassRef
<
	gSgIm
> SgIm::
cڡruIl
<
LCh
>(
SgIm
* 
im
, 
	gngth
{  
adtRef
(*
w
 (
NNu
, imSgIm(
ngth
, 
F8BCڡru
)); }

856 
	gme
 <>

857 
ALWAYS_INLINE
 
	gPassRef
<
	gSgIm
> SgIm::
cڡruIl
<
UCh
>(
SgIm
* 
im
, 
	gngth
{  
adtRef
(*
w
 (
NNu
, imSgIm(
ngth
)); }

859 
	gme
 <>

860 
ALWAYS_INLINE
 cڡ 
LCh
* 
	gSgIm
::
chas
<LCh>(cڡ {  
chas8
(); }

862 
	gme
 <>

863 
ALWAYS_INLINE
 cڡ 
UCh
* 
	gSgIm
::
chas
<UCh>(cڡ {  
chas16
(); }

865 
WTF_EXPORT_STRING_API
 
bo
 
equ
(cڡ 
SgIm
*, const StringImpl*);

866 
WTF_EXPORT_STRING_API
 
bo
 
equ
(cڡ 
SgIm
*, cڡ 
LCh
*);

867 
le
 
bo
 
	$equ
(cڡ 
SgIm
* 
a
, cڡ * 
b
{  
	`equ
, 
t_
<cڡ 
LCh
*>(b)); 
	}
}

868 
WTF_EXPORT_STRING_API
 
bo
 
equ
(cڡ 
SgIm
*, cڡ 
LCh
*, );

869 
WTF_EXPORT_STRING_API
 
bo
 
equ
(cڡ 
SgIm
*, cڡ 
UCh
*, );

870 
le
 
bo
 
	$equ
(cڡ 
SgIm
* 
a
, cڡ * 
b
, 
ngth
{  
	`equ
, 
t_
<cڡ 
LCh
*>(b),gth); 
	}
}

871 
le
 
bo
 
	$equ
(cڡ 
LCh
* 
a
, 
SgIm
* 
b
{  
	`equ
(b,); 
	}
}

872 
le
 
bo
 
	$equ
(cڡ * 
a
, 
SgIm
* 
b
{  
	`equ
(b, 
t_
<cڡ 
LCh
*>)); 
	}
}

873 
WTF_EXPORT_STRING_API
 
bo
 
equ
(cڡ 
SgIm
& 
a
, cڡ SgIm& 
b
);

875 
	gme
<
tyme
 
	gT
>

876 
le
 
T
 
	$ldUligd
(cڡ * 
s
)

878 #i
	`COMPILER
(
CLANG
)

879 
T
 
tmp
;

880 
	`memy
(&
tmp
, 
s
, (
T
));

881  
tmp
;

884  *
t_
<cڡ 
T
*>(
s
);

886 
	}
}

889 #i
CPU
(
X86_64
|| 
	$CPU
(
ARM64
)

890 
ALWAYS_INLINE
 
bo
 
	$equ
(cڡ 
LCh
* 
aLCh
, cڡ LCh* 
bLCh
, 
ngth
)

892 
dwdLgth
 = 
ngth
 >> 3;

894 cڡ * 
a
 = 
t_
<cڡ *>(
aLCh
);

895 cڡ * 
b
 = 
t_
<cڡ *>(
bLCh
);

897 i(
dwdLgth
) {

898 
i
 = 0; i !
dwdLgth
; ++i) {

899 i(
ldUligd
<
ut64_t
>(
a
!ldUligd<ut64_t>(
b
))

900  
l
;

902 
a
 +(
ut64_t
);

903 
b
 +(
ut64_t
);

907 i(
ngth
 & 4) {

908 i(
ldUligd
<
ut32_t
>(
a
!ldUligd<ut32_t>(
b
))

909  
l
;

911 
a
 +(
ut32_t
);

912 
b
 +(
ut32_t
);

915 i(
ngth
 & 2) {

916 i(
ldUligd
<
ut16_t
>(
a
!ldUligd<ut16_t>(
b
))

917  
l
;

919 
a
 +(
ut16_t
);

920 
b
 +(
ut16_t
);

923 i(
ngth
 & 1 && (*
t_
<cڡ 
LCh
*>(
a
!*t_<cڡ LCh*>(
b
)))

924  
l
;

926  
ue
;

927 
	}
}

929 
ALWAYS_INLINE
 
bo
 
	$equ
(cڡ 
UCh
* 
aUCh
, cڡ UCh* 
bUCh
, 
ngth
)

931 
dwdLgth
 = 
ngth
 >> 2;

933 cڡ * 
a
 = 
t_
<cڡ *>(
aUCh
);

934 cڡ * 
b
 = 
t_
<cڡ *>(
bUCh
);

936 i(
dwdLgth
) {

937 
i
 = 0; i !
dwdLgth
; ++i) {

938 i(
ldUligd
<
ut64_t
>(
a
!ldUligd<ut64_t>(
b
))

939  
l
;

941 
a
 +(
ut64_t
);

942 
b
 +(
ut64_t
);

946 i(
ngth
 & 2) {

947 i(
ldUligd
<
ut32_t
>(
a
!ldUligd<ut32_t>(
b
))

948  
l
;

950 
a
 +(
ut32_t
);

951 
b
 +(
ut32_t
);

954 i(
ngth
 & 1 && (*
t_
<cڡ 
UCh
*>(
a
!*t_<cڡ UCh*>(
b
)))

955  
l
;

957  
ue
;

958 
	}
}

959 #i
	$CPU
(
X86
)

960 
ALWAYS_INLINE
 
bo
 
	$equ
(cڡ 
LCh
* 
aLCh
, cڡ LCh* 
bLCh
, 
ngth
)

962 cڡ * 
a
 = 
t_
<cڡ *>(
aLCh
);

963 cڡ * 
b
 = 
t_
<cڡ *>(
bLCh
);

965 
wdLgth
 = 
ngth
 >> 2;

966 
i
 = 0; i !
wdLgth
; ++i) {

967 i(
ldUligd
<
ut32_t
>(
a
!ldUligd<ut32_t>(
b
))

968  
l
;

969 
a
 +(
ut32_t
);

970 
b
 +(
ut32_t
);

973 
ngth
 &= 3;

975 i(
ngth
) {

976 cڡ 
LCh
* 
aRemad
 = 
t_
<cڡ LCh*>(
a
);

977 cڡ 
LCh
* 
bRemad
 = 
t_
<cڡ LCh*>(
b
);

979 
i
 = 0; i < 
ngth
; ++i) {

980 i(
aRemad
[
i
] !
bRemad
[i])

981  
l
;

985  
ue
;

986 
	}
}

988 
ALWAYS_INLINE
 
bo
 
	$equ
(cڡ 
UCh
* 
aUCh
, cڡ UCh* 
bUCh
, 
ngth
)

990 cڡ * 
a
 = 
t_
<cڡ *>(
aUCh
);

991 cڡ * 
b
 = 
t_
<cڡ *>(
bUCh
);

993 
wdLgth
 = 
ngth
 >> 1;

994 
i
 = 0; i !
wdLgth
; ++i) {

995 i(
ldUligd
<
ut32_t
>(
a
!ldUligd<ut32_t>(
b
))

996  
l
;

997 
a
 +(
ut32_t
);

998 
b
 +(
ut32_t
);

1001 i(
ngth
 & 1 && *
t_
<cڡ 
UCh
*>(
a
!*t_<cڡ UCh*>(
b
))

1002  
l
;

1004  
ue
;

1005 
	}
}

1006 #i
PLATFORM
(
IOS
&& 
	$WTF_ARM_ARCH_AT_LEAST
(7)

1007 
ALWAYS_INLINE
 
bo
 
	$equ
(cڡ 
LCh
* 
a
, cڡ LCh* 
b
, 
ngth
)

1009 
bo
 
isEqu
 = 
l
;

1010 
ut32_t
 
aVue
;

1011 
ut32_t
 
bVue
;

1012 
	`asm
("subs %[length], #4\n"

1049 : [
ngth
]"+r"֒gth), [
isEqu
]"+r"(isEqu), [
a
]"+r"), [
b
]"+r"(b), [
aVue
]"+r"Vue), [
bVue
]"+r"(bValue)

1053  
isEqu
;

1054 
	}
}

1056 
ALWAYS_INLINE
 
bo
 
	$equ
(cڡ 
UCh
* 
a
, cڡ UCh* 
b
, 
ngth
)

1058 
bo
 
isEqu
 = 
l
;

1059 
ut32_t
 
aVue
;

1060 
ut32_t
 
bVue
;

1061 
	`asm
("subs %[length], #2\n"

1088 : [
ngth
]"+r"֒gth), [
isEqu
]"+r"(isEqu), [
a
]"+r"), [
b
]"+r"(b), [
aVue
]"+r"Vue), [
bVue
]"+r"(bValue)

1092  
isEqu
;

1093 
	}
}

1095 
ALWAYS_INLINE
 
bo
 
	$equ
(cڡ 
LCh
* 
a
, cڡ LCh* 
b
, 
ngth
{  !
	`memcmp
, b,gth); 
	}
}

1096 
ALWAYS_INLINE
 
bo
 
	$equ
(cڡ 
UCh
* 
a
, cڡ UCh* 
b
, 
ngth
{  !
	`memcmp
, b,gth * (UCh)); 
	}
}

1099 
ALWAYS_INLINE
 
bo
 
	$equ
(cڡ 
LCh
* 
a
, cڡ 
UCh
* 
b
, 
ngth
)

1101 
i
 = 0; i < 
ngth
; ++i) {

1102 i(
a
[
i
] !
b
[i])

1103  
l
;

1105  
ue
;

1106 
	}
}

1108 
ALWAYS_INLINE
 
bo
 
	$equ
(cڡ 
UCh
* 
a
, cڡ 
LCh
* 
b
, 
ngth
{  
	`equ
(b,,gth); 
	}
}

1110 
WTF_EXPORT_STRING_API
 
bo
 
equIgnܚgCa
(cڡ 
SgIm
*, const StringImpl*);

1111 
WTF_EXPORT_STRING_API
 
bo
 
equIgnܚgCa
(cڡ 
SgIm
*, cڡ 
LCh
*);

1112 
le
 
bo
 
	$equIgnܚgCa
(cڡ 
LCh
* 
a
, cڡ 
SgIm
* 
b
{  
	`equIgnܚgCa
(b,); 
	}
}

1113 
WTF_EXPORT_STRING_API
 
bo
 
equIgnܚgCa
(cڡ 
LCh
*, const LChar*, );

1114 
WTF_EXPORT_STRING_API
 
bo
 
equIgnܚgCa
(cڡ 
UCh
*, cڡ 
LCh
*, );

1115 
le
 
bo
 
	$equIgnܚgCa
(cڡ 
UCh
* 
a
, cڡ * 
b
, 
ngth
{  
	`equIgnܚgCa
, 
t_
<cڡ 
LCh
*>(b),gth); 
	}
}

1116 
le
 
bo
 
	$equIgnܚgCa
(cڡ 
LCh
* 
a
, cڡ 
UCh
* 
b
, 
ngth
{  
	`equIgnܚgCa
(b,,gth); 
	}
}

1117 
le
 
bo
 
	$equIgnܚgCa
(cڡ * 
a
, cڡ 
UCh
* 
b
, 
ngth
{  
	`equIgnܚgCa
(b, 
t_
<cڡ 
LCh
*>),gth); 
	}
}

1118 
le
 
bo
 
	$equIgnܚgCa
(cڡ * 
a
, cڡ 
LCh
* 
b
, 
ngth
{  
	`equIgnܚgCa
(b, 
t_
<cڡ LCh*>),gth); 
	}
}

1119 
le
 
bo
 
	$equIgnܚgCa
(cڡ 
UCh
* 
a
, cڡ UCh* 
b
, 
ngth
)

1121 
	`ASSERT
(
ngth
 >= 0);

1122  !
	`u_memcmp
(
a
, 
b
, 
ngth
, 
U_FOLD_CASE_DEFAULT
);

1123 
	}
}

1124 
WTF_EXPORT_STRING_API
 
bo
 
equIgnܚgCaNNu
(cڡ 
SgIm
*, const StringImpl*);

1126 
WTF_EXPORT_STRING_API
 
bo
 
equIgnܚgNuΙy
(
SgIm
*, StringImpl*);

1127 
WTF_EXPORT_STRING_API
 
bo
 
equIgnܚgNuΙy
(cڡ 
UCh
*, 
size_t
 
ngth
, 
SgIm
*);

1129 
	gme
<
tyme
 
	gChaTy
>

1130 
le
 
size_t
 
	$fd
(cڡ 
ChaTy
* 
chas
, 
ngth
, ChaTy 
mchCha
, 
dex
 = 0)

1132 
dex
 < 
ngth
) {

1133 i(
chas
[
dex
] =
mchCha
)

1134  
dex
;

1135 ++
dex
;

1137  
nFound
;

1138 
	}
}

1140 
ALWAYS_INLINE
 
size_t
 
	$fd
(cڡ 
UCh
* 
chas
, 
ngth
, 
LCh
 
mchCha
, 
dex
 = 0)

1142  
	`fd
(
chas
, 
ngth
, 
ic_
<
UCh
>(
mchCha
), 
dex
);

1143 
	}
}

1145 
le
 
size_t
 
	$fd
(cڡ 
LCh
* 
chas
, 
ngth
, 
UCh
 
mchCha
, 
dex
 = 0)

1147 i(
mchCha
 & ~0xFF)

1148  
nFound
;

1149  
	`fd
(
chas
, 
ngth
, 
ic_
<
LCh
>(
mchCha
), 
dex
);

1150 
	}
}

1152 
le
 
size_t
 
	$fd
(cڡ 
LCh
* 
chas
, 
ngth
, 
ChaMchFuniP
 
mchFuni
, 
dex
 = 0)

1154 
dex
 < 
ngth
) {

1155 i(
	`mchFuni
(
chas
[
dex
]))

1156  
dex
;

1157 ++
dex
;

1159  
nFound
;

1160 
	}
}

1162 
le
 
size_t
 
	$fd
(cڡ 
UCh
* 
chas
, 
ngth
, 
ChaMchFuniP
 
mchFuni
, 
dex
 = 0)

1164 
dex
 < 
ngth
) {

1165 i(
	`mchFuni
(
chas
[
dex
]))

1166  
dex
;

1167 ++
dex
;

1169  
nFound
;

1170 
	}
}

1172 
	gme
<
tyme
 
	gChaTy
>

1173 
le
 
size_t
 
	$fdNextLeS
(cڡ 
ChaTy
* 
chas
, 
ngth
, 
dex
 = 0)

1175 
dex
 < 
ngth
) {

1176 
ChaTy
 
c
 = 
chas
[
dex
++];

1177 i((
c
 != '\n') && (c != '\r'))

1182 i(
dex
 < 
ngth
) {

1186 i(
c
 == '\n')

1187  
dex
;

1189 
ChaTy
 
c2
 = 
chas
[
dex
];

1190 i(
c2
 != '\n')

1191  
dex
;

1196 i(++
dex
 < 
ngth
)

1197  
dex
;

1200  
nFound
;

1201 
	}
}

1203 
	gme
<
tyme
 
	gChaTy
>

1204 
le
 
size_t
 
	$vFdLeTm
(cڡ 
ChaTy
* 
chas
, 
ngth
, 
dex
 = 
UINT_MAX
)

1206 i(!
ngth
)

1207  
nFound
;

1208 i(
dex
 >
ngth
)

1209 
dex
 = 
ngth
 - 1;

1210 
ChaTy
 
c
 = 
chas
[
dex
];

1211 (
c
 != '\n') && (c != '\r')) {

1212 i(!
dex
--)

1213  
nFound
;

1214 
c
 = 
chas
[
dex
];

1216  
dex
;

1217 
	}
}

1219 
	gme
<
tyme
 
	gChaTy
>

1220 
le
 
size_t
 
	$vFd
(cڡ 
ChaTy
* 
chas
, 
ngth
, ChaTy 
mchCha
, 
dex
 = 
UINT_MAX
)

1222 i(!
ngth
)

1223  
nFound
;

1224 i(
dex
 >
ngth
)

1225 
dex
 = 
ngth
 - 1;

1226 
chas
[
dex
] !
mchCha
) {

1227 i(!
dex
--)

1228  
nFound
;

1230  
dex
;

1231 
	}
}

1233 
ALWAYS_INLINE
 
size_t
 
	$vFd
(cڡ 
UCh
* 
chas
, 
ngth
, 
LCh
 
mchCha
, 
dex
 = 
UINT_MAX
)

1235  
	`vFd
(
chas
, 
ngth
, 
ic_
<
UCh
>(
mchCha
), 
dex
);

1236 
	}
}

1238 
le
 
size_t
 
	$vFd
(cڡ 
LCh
* 
chas
, 
ngth
, 
UCh
 
mchCha
, 
dex
 = 
UINT_MAX
)

1240 i(
mchCha
 & ~0xFF)

1241  
nFound
;

1242  
	`vFd
(
chas
, 
ngth
, 
ic_
<
LCh
>(
mchCha
), 
dex
);

1243 
	}
}

1245 
le
 
size_t
 
	gSgIm
::
	$fd
(
LCh
 
cha
, 
t
)

1247 i(
	`is8B
())

1248  
WTF
::
	`fd
(
	`chas8
(), 
m_ngth
, 
cha
, 
t
);

1249  
WTF
::
	`fd
(
	`chas16
(), 
m_ngth
, 
cha
, 
t
);

1250 
	}
}

1252 
ALWAYS_INLINE
 
size_t
 
	gSgIm
::
	$fd
(
cha
, 
t
)

1254  
	`fd
(
ic_
<
LCh
>(
cha
), 
t
);

1255 
	}
}

1257 
le
 
size_t
 
	gSgIm
::
	$fd
(
UCh
 
cha
, 
t
)

1259 i(
	`is8B
())

1260  
WTF
::
	`fd
(
	`chas8
(), 
m_ngth
, 
cha
, 
t
);

1261  
WTF
::
	`fd
(
	`chas16
(), 
m_ngth
, 
cha
, 
t
);

1262 
	}
}

1264 
	gme
<
size_t
 
	gleCacy
> 
le
 
bo
 
equIgnܚgNuΙy
(cڡ 
Ve
<
UCh
, 
leCacy
>& 
a
, 
SgIm
* 
b
)

1266  
equIgnܚgNuΙy
(
a
.
da
(),.
size
(), 
b
);

1269 
	gme
<
tyme
 
	gChaTy1
,ym
	gChaTy2
>

1270 
le
 
	$codePotCom
(
l1
, 
l2
, cڡ 
ChaTy1
* 
c1
, cڡ 
ChaTy2
* 
c2
)

1272 cڡ 
lm
 = 
l1
 < 
l2
 ?1 :2;

1273 
pos
 = 0;

1274 
pos
 < 
lm
 && *
c1
 =*
c2
) {

1275 ++
c1
;

1276 ++
c2
;

1277 ++
pos
;

1280 i(
pos
 < 
lm
)

1281  (
c1
[0] > 
c2
[0]) ? 1 : -1;

1283 i(
l1
 =
l2
)

1286  (
l1
 > 
l2
) ? 1 : -1;

1287 
	}
}

1289 
le
 
	$codePotCom8
(cڡ 
SgIm
* 
rg1
, cڡ SgIm* 
rg2
)

1291  
	`codePotCom
(
rg1
->
	`ngth
(), 
rg2
->ngth(), sg1->
	`chas8
(), string2->characters8());

1292 
	}
}

1294 
le
 
	$codePotCom16
(cڡ 
SgIm
* 
rg1
, cڡ SgIm* 
rg2
)

1296  
	`codePotCom
(
rg1
->
	`ngth
(), 
rg2
->ngth(), sg1->
	`chas16
(), string2->characters16());

1297 
	}
}

1299 
le
 
	$codePotCom8To16
(cڡ 
SgIm
* 
rg1
, cڡ SgIm* 
rg2
)

1301  
	`codePotCom
(
rg1
->
	`ngth
(), 
rg2
->ngth(), sg1->
	`chas8
(), sg2->
	`chas16
());

1302 
	}
}

1304 
le
 
	$codePotCom
(cڡ 
SgIm
* 
rg1
, cڡ SgIm* 
rg2
)

1306 i(!
rg1
)

1307  (
rg2
 && sg2->
	`ngth
()) ? -1 : 0;

1309 i(!
rg2
)

1310  
rg1
->
	`ngth
() ? 1 : 0;

1312 
bo
 
rg1Is8B
 = 
rg1
->
	`is8B
();

1313 
bo
 
rg2Is8B
 = 
rg2
->
	`is8B
();

1314 i(
rg1Is8B
) {

1315 i(
rg2Is8B
)

1316  
	`codePotCom8
(
rg1
, 
rg2
);

1317  
	`codePotCom8To16
(
rg1
, 
rg2
);

1319 i(
rg2Is8B
)

1320  -
	`codePotCom8To16
(
rg2
, 
rg1
);

1321  
	`codePotCom16
(
rg1
, 
rg2
);

1322 
	}
}

1324 
le
 
bo
 
	$isSOrNewle
(
UCh
 
c
)

1328  
c
 <0x7F ? 
	`isASCIIS
(c: 
	`u_chDei
(c=
U_WHITE_SPACE_NEUTRAL
;

1329 
	}
}

1331 
	gme
<
tyme
 
	gChaTy
>

1332 
le
 
	$ngthOfNuTmedSg
(cڡ 
ChaTy
* 
rg
)

1334 
	`ASSERT
(
rg
);

1335 
size_t
 
ngth
 = 0;

1336 
rg
[
ngth
])

1337 ++
ngth
;

1339 
	`RELEASE_ASSERT
(
ngth
 < 
d
::
numic_lims
<>::
	`max
());

1340  
ic_
<>(
ngth
);

1341 
	}
}

1343 
le
 
	gPassRef
<
	gSgIm
> SgIm::
	$isީedCy
() const

1345 i(!
	`quesCy
()) {

1346 i(
	`is8B
())

1347  
SgIm
::
	`WhoutCyg
(
m_da8
, 
m_ngth
);

1348  
SgIm
::
	`WhoutCyg
(
m_da16
, 
m_ngth
);

1351 i(
	`is8B
())

1352  
	`
(
m_da8
, 
m_ngth
);

1353  
	`
(
m_da16
, 
m_ngth
);

1354 
	}
}

1356 
	gSgHash
;

1359 
	gme
<
tyme
 
	gT
> 
	gDeuHash
;

1360 
	gme
<> 
	gDeuHash
<
	gSgIm
*> {

1361 
SgHash
 
	tHash
;

1363 
	gme
<> 
	gDeuHash
<
	gRefP
<
	gSgIm
>> {

1364 
SgHash
 
	tHash
;

1369 
usg
 
	gWTF
::
SgIm
;

1370 
usg
 
	gWTF
::
equ
;

1371 
usg
 
	gWTF
::
TextCaSsivy
;

1372 
usg
 
	gWTF
::
TextCaSsive
;

1373 
usg
 
	gWTF
::
TextCaInnsive
;

	@text/StringOperators.h

22 #ide
SgOts_h


23 
	#SgOts_h


	)

25 
mea
 
	gWTF
 {

27 
	gme
<
tyme
 
	gSgTy1
,ym
	gSgTy2
>

28 as
	cSgAd
 {

29 
	gpublic
:

30 
SgAd
(
SgTy1
 
rg1
, 
SgTy2
 
rg2
)

31 : 
m_rg1
(
rg1
)

32 , 
m_rg2
(
rg2
)

36 
ݔ
 
Sg
() const

38 
	gRefP
<
	gSgIm
> 
	gsuIm
 = 
yMakeSg
(
m_rg1
, 
m_rg2
);

39 i(!
	gsuIm
)

40 
CRASH
();

41  
	gsuIm
.
a
();

44 
ݔ
 
AtomicSg
() const

46  
ݔ
 
Sg
();

49 
bo
 
is8B
()

51 
	gSgTyAdr
<
	gSgTy1
> 
adr1
(
m_rg1
);

52 
	gSgTyAdr
<
	gSgTy2
> 
adr2
(
m_rg2
);

53  
	gadr1
.
is8B
(&& 
	gadr2
.is8Bit();

56 
wreTo
(
LCh
* 
dei
)

58 
ASSERT
(
is8B
());

59 
	gSgTyAdr
<
	gSgTy1
> 
adr1
(
m_rg1
);

60 
	gSgTyAdr
<
	gSgTy2
> 
adr2
(
m_rg2
);

61 
	gadr1
.
wreTo
(
dei
);

62 
	gadr2
.
wreTo
(
dei
 + 
adr1
.
ngth
());

65 
wreTo
(
UCh
* 
dei
)

67 
	gSgTyAdr
<
	gSgTy1
> 
adr1
(
m_rg1
);

68 
	gSgTyAdr
<
	gSgTy2
> 
adr2
(
m_rg2
);

69 
	gadr1
.
wreTo
(
dei
);

70 
	gadr2
.
wreTo
(
dei
 + 
adr1
.
ngth
());

73 
ngth
()

75 
	gSgTyAdr
<
	gSgTy1
> 
adr1
(
m_rg1
);

76 
	gSgTyAdr
<
	gSgTy2
> 
adr2
(
m_rg2
);

77  
	gadr1
.
ngth
(+ 
	gadr2
.length();

80 
	give
:

81 
SgTy1
 
m_rg1
;

82 
SgTy2
 
	gm_rg2
;

85 
	gme
<
tyme
 
	gSgTy1
,ym
	gSgTy2
>

86 
ass
 
	gSgTyAdr
<
	gSgAd
<
	gSgTy1
, 
	gSgTy2
>> {

87 
	gpublic
:

88 
SgTyAdr
<
SgAd
<
SgTy1
, 
	gSgTy2
>>(
	gSgAd
<
	gSgTy1
, SgTy2>& 
	gbufr
)

89 : 
m_bufr
(
bufr
)

93 
ngth
({  
m_bufr
.length(); }

95 
bo
 
is8B
({  
	gm_bufr
.is8Bit(); }

97 
wreTo
(
LCh
* 
dei
{ 
	gm_bufr
.writeTo(destination); }

98 
wreTo
(
UCh
* 
dei
{ 
	gm_bufr
.writeTo(destination); }

100 
	give
:

101 
SgAd
<
SgTy1
, 
	gSgTy2
>& 
	gm_bufr
;

104 
le
 
	gSgAd
<cڡ *, 
	gSg
> 
	gݔ
+(cڡ * 
	grg1
, cڡ Sg& 
	grg2
)

106  
	gSgAd
<cڡ *, 
	gSg
>(
	grg1
, 
	grg2
);

109 
le
 
	gSgAd
<cڡ *, 
	gAtomicSg
> 
	gݔ
+(cڡ * 
	grg1
, cڡ AtomicSg& 
	grg2
)

111  
	gSgAd
<cڡ *, 
	gAtomicSg
>(
	grg1
, 
	grg2
);

114 
	gme
<
tyme
 
	gU
,ym
	gV
>

115 
le
 
	gSgAd
<cڡ *, SgAd<
	gU
, 
	gV
>> 
	gݔ
+(cڡ * 
	grg1
, cڡ SgAd<U, V>& 
	grg2
)

117  
	gSgAd
<cڡ *, SgAd<
	gU
, 
	gV
>>(
	grg1
, 
	grg2
);

120 
le
 
	gSgAd
<cڡ 
	gUCh
*, 
	gSg
> 
	gݔ
+(cڡ 
UCh
* 
	grg1
, cڡ Sg& 
	grg2
)

122  
	gSgAd
<cڡ 
	gUCh
*, 
	gSg
>(
	grg1
, 
	grg2
);

125 
le
 
	gSgAd
<cڡ 
	gUCh
*, 
	gAtomicSg
> 
	gݔ
+(cڡ 
UCh
* 
	grg1
, cڡ AtomicSg& 
	grg2
)

127  
	gSgAd
<cڡ 
	gUCh
*, 
	gAtomicSg
>(
	grg1
, 
	grg2
);

130 
	gme
<
tyme
 
	gU
,ym
	gV
>

131 
le
 
	gSgAd
<cڡ 
	gUCh
*, SgAd<
	gU
, 
	gV
>> 
	gݔ
+(cڡ 
UCh
* 
	grg1
, cڡ SgAd<U, V>& 
	grg2
)

133  
	gSgAd
<cڡ 
	gUCh
*, SgAd<
	gU
, 
	gV
>>(
	grg1
, 
	grg2
);

136 
le
 
	gSgAd
<
	gASCIIL
, 
	gSg
> 
	gݔ
+(cڡ ASCIIL& 
	grg1
, cڡ Sg& 
	grg2
)

138  
	gSgAd
<
	gASCIIL
, 
	gSg
>(
	grg1
, 
	grg2
);

141 
le
 
	gSgAd
<
	gASCIIL
, 
	gAtomicSg
> 
	gݔ
+(cڡ ASCIIL& 
	grg1
, cڡ AtomicSg& 
	grg2
)

143  
	gSgAd
<
	gASCIIL
, 
	gAtomicSg
>(
	grg1
, 
	grg2
);

146 
	gme
<
tyme
 
	gU
,ym
	gV
>

147 
le
 
	gSgAd
<
	gASCIIL
, SgAd<
	gU
, 
	gV
>> 
	gݔ
+(cڡ ASCIIL& 
	grg1
, cڡ SgAd<U, V>& 
	grg2
)

149  
	gSgAd
<
	gASCIIL
, SgAd<
	gU
, 
	gV
>>(
	grg1
, 
	grg2
);

152 
	gme
<
tyme
 
	gT
>

153 
	gSgAd
<
	gSg
, 
	gT
> 
	gݔ
+(cڡ Sg& 
	grg1
, 
T
 
	grg2
)

155  
	gSgAd
<
	gSg
, 
	gT
>(
	grg1
, 
	grg2
);

158 
	gme
<
tyme
 
	gU
,ym
	gV
,ym
	gW
>

159 
	gSgAd
<SgAd<
	gU
, 
	gV
>, 
	gW
> 
	gݔ
+(cڡ SgAd<U, V>& 
	grg1
, 
W
 
	grg2
)

161  
	gSgAd
<SgAd<
	gU
, 
	gV
>, 
	gW
>(
	grg1
, 
	grg2
);

	@text/StringStatics.cpp

26 
	~"cfig.h
"

28 #ifde
SKIP_STATIC_CONSTRUCTORS_ON_GCC


29 
	#ATOMICSTRING_HIDE_GLOBALS
 1

	)

32 
	~"AtomicSg.h
"

33 
	~"MaThad.h
"

34 
	~"NevDeroyed.h
"

35 
	~"SticCڡrus.h
"

36 
	~"SgIm.h
"

38 #i
USE
(
WEB_THREAD
)

39 
	~<had.h
>

42 
mea
 
	gWTF
 {

44 
SgIm
* 
	gSgIm
::
emy
()

46 
NevDeroyed
<
SgIm
> 
emySg
(
CڡruEmySg
);

47  &
	gemySg
.
g
();

55 
	gSgIm
::
hashAndFgsFEmyUnique
()

57 
s_xtHashAndFgsFEmyUnique
 = 
BufrIl
 | 
s_hashFg8BBufr
 | 
s_hashFgIsAtomic
;

58 
	gs_xtHashAndFgsFEmyUnique
 +1 << 
s_agCou
;

59 
	gs_xtHashAndFgsFEmyUnique
 |= 1 << 31;

60  
	gs_xtHashAndFgsFEmyUnique
;

63 
WTF_EXPORTDATA
 
DEFINE_GLOBAL
(
AtomicSg
, 
nuAtom
)

64 
WTF_EXPORTDATA
 
DEFINE_GLOBAL
(
AtomicSg
, 
emyAtom
)

65 
WTF_EXPORTDATA
 
DEFINE_GLOBAL
(
AtomicSg
, 
xtAtom
)

66 
WTF_EXPORTDATA
 
DEFINE_GLOBAL
(
AtomicSg
, 
commtAtom
)

67 
WTF_EXPORTDATA
 
DEFINE_GLOBAL
(
AtomicSg
, 
Atom
)

68 
WTF_EXPORTDATA
 
DEFINE_GLOBAL
(
AtomicSg
, 
xmlAtom
)

69 
WTF_EXPORTDATA
 
DEFINE_GLOBAL
(
AtomicSg
, 
xmsAtom
)

70 
WTF_EXPORTDATA
 
DEFINE_GLOBAL
(
AtomicSg
, 
xlkAtom
)

72 
NEVER_INLINE
 
	gSgIm
::
hashSlowCa
() const

74 i(
is8B
())

75 
tHash
(
SgHash
::
compuHashAndMaskT8Bs
(
m_da8
, 
m_ngth
));

77 
tHash
(
SgHash
::
compuHashAndMaskT8Bs
(
m_da16
, 
m_ngth
));

78  
exigHash
();

81 
	gAtomicSg
::

()

83 
bo
 
lized
;

84 i(!
	glized
) {

86 
ASSERT
(
isUIThad
());

89 
w
 (
NNu
, (*)&
nuAtom

	gAtomicSg
;

90 
w
 (
NNu
, (*)&
emyAtom

AtomicSg
("");

91 
w
 (
NNu
, (*)&
xtAtom

AtomicSg
("#xt", AtomicSg::
CڡruFromL
);

92 
w
 (
NNu
, (*)&
commtAtom

AtomicSg
("#commt", AtomicSg::
CڡruFromL
);

93 
w
 (
NNu
, (*)&
Atom

AtomicSg
("*", AtomicSg::
CڡruFromL
);

94 
w
 (
NNu
, (*)&
xmlAtom

AtomicSg
("xml", AtomicSg::
CڡruFromL
);

95 
w
 (
NNu
, (*)&
xmsAtom

AtomicSg
("xms", AtomicSg::
CڡruFromL
);

96 
w
 (
NNu
, (*)&
xlkAtom

AtomicSg
("xlk", AtomicSg::
CڡruFromL
);

98 
	glized
 = 
ue
;

	@text/StringView.h

26 #ide
SgVw_h


27 
	#SgVw_h


	)

29 
	~<wtf/xt/SgCǋ.h
>

31 
mea
 
	gWTF
 {

38 as
	cSgVw
 {

39 
	gpublic
:

40 
SgVw
()

41 : 
m_chas
(
nuαr
)

42 , 
m_ngth
(0)

46 
SgVw
(cڡ 
LCh
* 
chas
, 
ngth
)

48 
lize
(
chas
, 
ngth
);

51 
SgVw
(cڡ 
UCh
* 
chas
, 
ngth
)

53 
lize
(
chas
, 
ngth
);

56 
SgVw
(cڡ 
SgIm
& 
rg
)

58 i(
	grg
.
is8B
())

59 
lize
(
rg
.
chas8
(), sg.
ngth
());

61 
lize
(
rg
.
chas16
(), sg.
ngth
());

64 
SgVw
(cڡ 
Sg
& 
rg
)

66 i(!
	grg
.
im
()) {

67 
	gm_chas
 = 
nuαr
;

68 
	gm_ngth
 = 0;

71 i(
	grg
.
is8B
()) {

72 
lize
(
rg
.
chas8
(), sg.
ngth
());

75 
lize
(
rg
.
chas16
(), sg.
ngth
());

78 
SgVw
 
emy
()

80  
SgVw
(
t_
<cڡ 
LCh
*>(""), 0);

83 cڡ 
LCh
* 
chas8
() const

85 
ASSERT
(
is8B
());

87  
	gic_
<cڡ 
	gLCh
*>(
	gm_chas
);

90 cڡ 
UCh
* 
chas16
() const

92 
ASSERT
(!
is8B
());

94  
	gic_
<cڡ 
	gUCh
*>(
	gm_chas
);

97 
gChasWhUpcvt
(
LCh
*) const;

98 
gChasWhUpcvt
(
UCh
*) const;

100 as
	cUpcvdChas
 {

101 
	gpublic
:

102 
exic
 
UpcvdChas
(cڡ 
SgVw
&);

103 
ݔ
 cڡ 
	gUCh
*(cڡ {  
	gm_chas
; }

104 cڡ 
UCh
* 
g
(cڡ {  
	gm_chas
; }

105 
	give
:

106 
Ve
<
UCh
, 32> 
	gm_upcvdChas
;

107 cڡ 
UCh
* 
	gm_chas
;

109 
UpcvdChas
 
upcvdChas
(cڡ {  UpcvdChas(*
this
); }

111 
bo
 
isNu
(cڡ {  !
	gm_chas
; }

112 
bo
 
isEmy
(cڡ {  !
ngth
(); }

113 
ngth
(cڡ {  
	gm_ngth
 & ~
	gis16BSgFg
; }

115 
exic
 
ݔ
 
bo
(cڡ {  !
isNu
(); }

117 
bo
 
is8B
(cڡ {  !(
	gm_ngth
 & 
	gis16BSgFg
); }

119 
SgVw
 
subrg
(
t
, 
ngth
 = 
d
::
numic_lims
<>::
max
()) const

121 i(
t
 >
this
->
ngth
())

122  
emy
();

123 
	gmaxLgth
 = 
this
->
ngth
(- 
t
;

125 i(
	gngth
 >
maxLgth
) {

126 i(!
t
)

127  *
this
;

128 
	gngth
 = 
maxLgth
;

131 i(
is8B
())

132  
SgVw
(
chas8
(+ 
t
, 
ngth
);

134  
SgVw
(
chas16
(+ 
t
, 
ngth
);

137 
Sg
 
toSg
() const

139 i(
is8B
())

140  
Sg
(
chas8
(), 
ngth
());

142  
Sg
(
chas16
(), 
ngth
());

145 
toFlt
(
bo
& 
isVid
)

147 i(
is8B
())

148  
chasToFlt
(
chas8
(), 
ngth
(), &
isVid
);

149  
chasToFlt
(
chas16
(), 
ngth
(), &
isVid
);

152 
toI
(
bo
& 
isVid
)

154 i(
is8B
())

155  
chasToI
(
chas8
(), 
ngth
(), &
isVid
);

156  
chasToI
(
chas16
(), 
ngth
(), &
isVid
);

159 
Sg
 
toSgWhoutCyg
() const

161 i(
is8B
())

162  
	gSgIm
::
WhoutCyg
(
chas8
(), 
ngth
());

164  
	gSgIm
::
WhoutCyg
(
chas16
(), 
ngth
());

167 
UCh
 
	gݔ
[](
	gdex
) const

169 
ASSERT
(
dex
 < 
ngth
());

170 i(
is8B
())

171  
chas8
()[
dex
];

172  
chas16
()[
dex
];

175 
size_t
 
fd
(
UCh
 
cha
, 
t
 = 0) const

177 i(
is8B
())

178  
WTF
::
fd
(
chas8
(), 
ngth
(), 
cha
, 
t
);

179  
	gWTF
::
fd
(
chas16
(), 
ngth
(), 
cha
, 
t
);

182 
bo
 
cڏs
(
UCh
 
c
cڡ {  
fd
(c!
nFound
; }

184 #i
USE
(
CF
)

186 
WTF_EXPORT_STRING_API
 
	gRaP
<
	gCFSgRef
> 
CFSgWhoutCyg
() const;

189 #ifde
__OBJC__


191 
WTF_EXPORT_STRING_API
 
	gRaP
<
	gNSSg
> 
NSSg
() const;

192 
WTF_EXPORT_STRING_API
 
	gRaP
<
	gNSSg
> 
NSSgWhoutCyg
() const;

195 
	give
:

196 
lize
(cڡ 
LCh
* 
chas
, 
ngth
)

198 
ASSERT
(!(
ngth
 & 
is16BSgFg
));

200 
	gm_chas
 = 
chas
;

201 
	gm_ngth
 = 
ngth
;

204 
lize
(cڡ 
UCh
* 
chas
, 
ngth
)

206 
ASSERT
(!(
ngth
 & 
is16BSgFg
));

208 
	gm_chas
 = 
chas
;

209 
	gm_ngth
 = 
is16BSgFg
 | 
ngth
;

212 cڡ 
	gis16BSgFg
 = 1u << 31;

214 cڡ * 
	gm_chas
;

215 
	gm_ngth
;

218 
le
 
	gSgVw
::
	$gChasWhUpcvt
(
LCh
* 
dei
) const

220 
	`ASSERT
(
	`is8B
());

221 
	`memy
(
dei
, 
	`chas8
(), 
	`ngth
());

222 
	}
}

224 
le
 
	gSgVw
::
	$gChasWhUpcvt
(
UCh
* 
dei
) const

226 i(
	`is8B
()) {

227 cڡ 
LCh
* 
chas8
 = 
this
->
	`chas8
();

228 
ngth
 = 
this
->
	`ngth
();

229 
i
 = 0; i < 
ngth
; ++i)

230 
dei
[
i
] = 
chas8
[i];

233 
	`memy
(
dei
, 
	`chas16
(), 
	`ngth
(* (
UCh
));

234 
	}
}

236 
le
 
	gSgVw
::
UpcvdChas
::
	$UpcvdChas
(cڡ 
SgVw
& 
rg
)

238 i(!
rg
.
	`is8B
()) {

239 
m_chas
 = 
rg
.
	`chas16
();

242 cڡ 
LCh
* 
chas8
 = 
rg
.
	`chas8
();

243 
ngth
 = 
rg
.
	`ngth
();

244 
m_upcvdChas
.
	`rveInlCacy
(
ngth
);

245 
i
 = 0; i < 
ngth
; ++i)

246 
m_upcvdChas
.
	`uncheckedAd
(
chas8
[
i
]);

247 
m_chas
 = 
m_upcvdChas
.
	`da
();

248 
	}
}

250 
	gme
<> 
ass
 
	gSgTyAdr
<
	gSgVw
> {

251 
	gpublic
:

252 
SgTyAdr
<
SgVw
>(SgVw 
rg
)

253 : 
m_rg
(
rg
)

257 
ngth
({  
m_rg
.length(); }

258 
bo
 
is8B
({  
	gm_rg
.is8Bit(); }

259 
wreTo
(
LCh
* 
dei
{ 
	gm_rg
.
gChasWhUpcvt
(destination); }

260 
wreTo
(
UCh
* 
dei
{ 
	gm_rg
.
gChasWhUpcvt
(destination); }

262 
	give
:

263 
SgVw
 
m_rg
;

266 
	gme
<
tyme
 
	gChaTy
, 
size_t
 
	gleCacy
> 
nd
(
Ve
<
ChaTy
, 
leCacy
>& 
bufr
, 
SgVw
 
rg
)

268 
	gdSize
 = 
bufr
.
size
();

269 
	gbufr
.
grow
(
dSize
 + 
rg
.
ngth
());

270 
	grg
.
gChasWhUpcvt
(
bufr
.
da
(+ 
dSize
);

275 
usg
 
	gWTF
::
nd
;

276 
usg
 
	gWTF
::
SgVw
;

	@text/TextPosition.h

25 #ide
TextPosi_h


26 
	#TextPosi_h


	)

28 
	~<wtf/Asis.h
>

30 
mea
 
	gWTF
 {

35 as
	cOrdNumb
 {

36 
	gpublic
:

37 
OrdNumb
 
omZoBadI
(
zoBadI
) {  OrdinalNumber(zeroBasedInt); }

38 
OrdNumb
 
omOBadI
(
eBadI
) {  OrdinalNumber(oneBasedInt - 1); }

39 
OrdNumb
(: 
m_zoBadVue
(0) { }

41 
zoBadI
(cڡ {  
m_zoBadVue
; }

42 
eBadI
(cڡ {  
	gm_zoBadVue
 + 1; }

44 
bo
 
	gݔ
==(
OrdNumb
 
h
{  
m_zoBadVue
 == other.m_zeroBasedValue; }

45 
bo
 
	gݔ
!=(
OrdNumb
 
h
{  !((*
this
) == other); }

47 
OrdNumb
 
f
() {  OrdinalNumber(0); }

48 
OrdNumb
 
befeF
() {  OrdinalNumber(-1); }

50 
	give
:

51 
OrdNumb
(
zoBadI
: 
m_zoBadVue
(zeroBasedInt) { }

52 
m_zoBadVue
;

58 as
	cTextPosi
 {

59 
	gpublic
:

60 
TextPosi
(
OrdNumb
 
le
, OrdNumb 
cumn
)

61 : 
m_le
(
le
)

62 , 
m_cumn
(
cumn
)

65 
TextPosi
() { }

66 
bo
 
	gݔ
==(cڡ 
TextPosi
& 
h
{  
m_le
 =h.m_l&& 
m_cumn
 == other.m_column; }

67 
bo
 
	gݔ
!=(cڡ 
TextPosi
& 
h
{  !((*
this
) == other); }

70 
TextPosi
 
mimumPosi
({  TextPosi(
OrdNumb
::
f
(), OrdinalNumber::first()); }

73 
TextPosi
 
bowRgePosi
({  TextPosi(
OrdNumb
::
befeF
(), OrdinalNumber::beforeFirst()); }

75 
OrdNumb
 
	gm_le
;

76 
OrdNumb
 
	gm_cumn
;

81 
usg
 
	gWTF
::
OrdNumb
;

83 
usg
 
	gWTF
::
TextPosi
;

	@text/WTFString.cpp

22 
	~"cfig.h
"

23 
	~"WTFSg.h
"

25 
	~"IegToSgCvsi.h
"

26 
	~<dg.h
>

27 
	~<wtf/ASCIICTy.h
>

28 
	~<wtf/DaLog.h
>

29 
	~<wtf/HexNumb.h
>

30 
	~<wtf/MhExas.h
>

31 
	~<wtf/NevDeroyed.h
>

32 
	~<wtf/xt/CSg.h
>

33 
	~<wtf/SgExas.h
>

34 
	~<wtf/Ve.h
>

35 
	~<wtf/dt.h
>

36 
	~<wtf/unicode/ChaNames.h
>

37 
	~<wtf/unicode/UTF8.h
>

39 
mea
 
	gWTF
 {

41 
usg
 
mea
 
	gUnicode
;

44 
	gSg
::
Sg
(cڡ 
UCh
* 
chas
, 
ngth
)

46 i(
	gchas
)

47 
	gm_im
 = 
SgIm
::

(
chas
, 
ngth
);

51 
	gSg
::
Sg
(cڡ 
UCh
* 
r
)

53 i(!
r
)

56 
	gm_im
 = 
SgIm
::

(
r
, 
ngthOfNuTmedSg
(str));

60 
	gSg
::
Sg
(cڡ 
LCh
* 
chas
, 
ngth
)

62 i(
	gchas
)

63 
	gm_im
 = 
SgIm
::

(
chas
, 
ngth
);

66 
	gSg
::
Sg
(cڡ * 
chas
, 
ngth
)

68 i(
	gchas
)

69 
	gm_im
 = 
SgIm
::

(
t_
<cڡ 
LCh
*>(
chas
), 
ngth
);

73 
	gSg
::
Sg
(cڡ 
LCh
* 
chas
)

75 i(
chas
)

76 
m_im
 = 
SgIm
::

(
chas
);

79 
	gSg
::
Sg
(cڡ * 
chas
)

81 i(
chas
)

82 
m_im
 = 
SgIm
::

(
t_
<cڡ 
LCh
*>(
chas
));

85 
	gSg
::
Sg
(
ASCIIL
 
chas
)

86 : 
m_im
(
SgIm
::
FromL
(
chas
))

90 
Sg
::
nd
(cڡ Sg& 
r
)

94 i(
r
.
isEmy
())

97 i(
	gr
.
	gm_im
) {

98 i(
	gm_im
) {

99 i(
	gm_im
->
is8B
(&& 
	gr
.m_impl->is8Bit()) {

100 
LCh
* 
	gda
;

101 i(
	gr
.
ngth
(> 
	gd
::
numic_lims
<>::
max
(- 
m_im
->length())

102 
CRASH
();

103 
	gRefP
<
	gSgIm
> 
	gwIm
 = 
SgIm
::
Unlized
(
m_im
->
ngth
(+ 
r
.ngth(), 
da
);

104 
memy
(
da
, 
m_im
->
chas8
(), m_im->
ngth
(* (
LCh
));

105 
memy
(
da
 + 
m_im
->
ngth
(), 
r
.
chas8
(), s.ngth(* (
LCh
));

106 
	gm_im
 = 
wIm
.
a
();

109 
UCh
* 
	gda
;

110 i(
	gr
.
ngth
(> 
	gd
::
numic_lims
<>::
max
(- 
m_im
->length())

111 
CRASH
();

112 
	gRefP
<
	gSgIm
> 
	gwIm
 = 
SgIm
::
Unlized
(
m_im
->
ngth
(+ 
r
.ngth(), 
da
);

113 
SgVw
(*
m_im
).
gChasWhUpcvt
(
da
);

114 
SgVw
(
r
).
gChasWhUpcvt
(
da
 + 
m_im
->
ngth
());

115 
	gm_im
 = 
wIm
.
a
();

117 
	gm_im
 = 
r
.
m_im
;

121 
	gSg
::
nd
(
LCh
 
cha
)

125 i(!
m_im
) {

126 
m_im
 = 
SgIm
::

(&
cha
, 1);

129 i(!
is8B
()) {

130 
nd
(
ic_
<
UCh
>(
cha
));

133 i(
	gm_im
->
ngth
(>
d
::
numic_lims
<>::
max
())

134 
CRASH
();

135 
LCh
* 
	gda
;

136 
	gRefP
<
	gSgIm
> 
	gwIm
 = 
SgIm
::
Unlized
(
m_im
->
ngth
(+ 1, 
da
);

137 
memy
(
da
, 
m_im
->
chas8
(), m_im->
ngth
());

138 
	gda
[
m_im
->
ngth
()] = 
cha
;

139 
	gm_im
 = 
wIm
.
a
();

142 
	gSg
::
nd
(
UCh
 
cha
)

146 i(!
m_im
) {

147 
m_im
 = 
SgIm
::

(&
cha
, 1);

150 i(
	gcha
 <0xFF && 
is8B
()) {

151 
nd
(
ic_
<
LCh
>(
cha
));

154 i(
	gm_im
->
ngth
(>
d
::
numic_lims
<>::
max
())

155 
CRASH
();

156 
UCh
* 
	gda
;

157 
	gRefP
<
	gSgIm
> 
	gwIm
 = 
SgIm
::
Unlized
(
m_im
->
ngth
(+ 1, 
da
);

158 
SgVw
(*
m_im
).
gChasWhUpcvt
(
da
);

159 
	gda
[
m_im
->
ngth
()] = 
cha
;

160 
	gm_im
 = 
wIm
.
a
();

163 
codePotCom
(cڡ 
Sg
& 
a
, cڡ Sg& 
b
)

165  
codePotCom
(
a
.
im
(), 
b
.impl());

168 
	gSg
::

(cڡ 
Sg
& 
rg
, 
posi
)

172 
	gngthToIn
 = 
rg
.
ngth
();

174 i(!
	gngthToIn
) {

175 i(
	grg
.
isNu
())

177 i(
isNu
())

178 
	gm_im
 = 
rg
.
im
();

182 i(
	gposi
 >
ngth
()) {

183 
nd
(
rg
);

187 i(
	gngthToIn
 > 
	gd
::
numic_lims
<>::
max
(- 
ngth
())

188 
CRASH
();

190 
	gRefP
<
	gSgIm
> 
	gwSg
;

191 i(
is8B
(&& 
	grg
.is8Bit()) {

192 
LCh
* 
	gda
;

193 
	gwSg
 = 
SgIm
::
Unlized
(
ngth
(+ 
ngthToIn
, 
da
);

194 
SgVw
(*
m_im
).
subrg
(0, 
posi
).
gChasWhUpcvt
(
da
);

195 
SgVw
(
rg
).
gChasWhUpcvt
(
da
 + 
posi
);

196 
SgVw
(*
m_im
).
subrg
(
posi
).
gChasWhUpcvt
(
da
 +osi + 
ngthToIn
);

198 
UCh
* 
	gda
;

199 
	gwSg
 = 
SgIm
::
Unlized
(
ngth
(+ 
ngthToIn
, 
da
);

200 
SgVw
(*
m_im
).
subrg
(0, 
posi
).
gChasWhUpcvt
(
da
);

201 
SgVw
(
rg
).
gChasWhUpcvt
(
da
 + 
posi
);

202 
SgVw
(*
m_im
).
subrg
(
posi
).
gChasWhUpcvt
(
da
 +osi + 
ngthToIn
);

204 
	gm_im
 = 
wSg
.
a
();

207 
	gSg
::
nd
(cڡ 
LCh
* 
chasToAd
, 
ngthToAd
)

211 i(!
	gm_im
) {

212 i(!
	gchasToAd
)

214 
	gm_im
 = 
SgIm
::

(
chasToAd
, 
ngthToAd
);

218 i(!
	gngthToAd
)

221 
ASSERT
(
chasToAd
);

223 
	grLgth
 = 
m_im
->
ngth
();

225 i(
	gm_im
->
is8B
()) {

226 i(
	gngthToAd
 > 
	gd
::
numic_lims
<>::
max
(- 
rLgth
)

227 
CRASH
();

228 
LCh
* 
	gda
;

229 
	gRefP
<
	gSgIm
> 
	gwIm
 = 
SgIm
::
Unlized
(
rLgth
 + 
ngthToAd
, 
da
);

230 
	gSgIm
::
cyChs
(
da
, 
m_im
->
chas8
(), 
rLgth
);

231 
	gSgIm
::
cyChs
(
da
 + 
rLgth
, 
chasToAd
, 
ngthToAd
);

232 
	gm_im
 = 
wIm
.
a
();

236 i(
	gngthToAd
 > 
	gd
::
numic_lims
<>::
max
(- 
rLgth
)

237 
CRASH
();

238 
UCh
* 
	gda
;

239 
	gRefP
<
	gSgIm
> 
	gwIm
 = 
SgIm
::
Unlized
(
ngth
(+ 
ngthToAd
, 
da
);

240 
	gSgIm
::
cyChs
(
da
, 
m_im
->
chas16
(), 
rLgth
);

241 
	gSgIm
::
cyChs
(
da
 + 
rLgth
, 
chasToAd
, 
ngthToAd
);

242 
	gm_im
 = 
wIm
.
a
();

245 
	gSg
::
nd
(cڡ 
UCh
* 
chasToAd
, 
ngthToAd
)

249 i(!
	gm_im
) {

250 i(!
	gchasToAd
)

252 
	gm_im
 = 
SgIm
::

(
chasToAd
, 
ngthToAd
);

256 i(!
	gngthToAd
)

259 
	grLgth
 = 
m_im
->
ngth
();

261 
ASSERT
(
chasToAd
);

262 i(
	gngthToAd
 > 
	gd
::
numic_lims
<>::
max
(- 
rLgth
)

263 
CRASH
();

264 
UCh
* 
	gda
;

265 
	gRefP
<
	gSgIm
> 
	gwIm
 = 
SgIm
::
Unlized
(
rLgth
 + 
ngthToAd
, 
da
);

266 i(
	gm_im
->
is8B
())

267 
	gSgIm
::
cyChs
(
da
, 
chas8
(), 
rLgth
);

269 
	gSgIm
::
cyChs
(
da
, 
chas16
(), 
rLgth
);

270 
	gSgIm
::
cyChs
(
da
 + 
rLgth
, 
chasToAd
, 
ngthToAd
);

271 
	gm_im
 = 
wIm
.
a
();

275 
UCh32
 
	gSg
::
chaSgAt
(
i
) const

277 i(!
m_im
 || 
i
 >m_im->
ngth
())

279  
	gm_im
->
chaSgAt
(
i
);

282 
	gSg
::
un
(
posi
)

284 i(
m_im
)

285 
m_im
 = m_im->
subrg
(0, 
posi
);

288 
	gme
 <
tyme
 
	gChaTy
>

289 
le
 
	gSg
::
moveIl
(cڡ 
ChaTy
* 
chas
, 
posi
, 
ngthToRemove
)

291 
ChaTy
* 
	gda
;

292 
	gRefP
<
	gSgIm
> 
	gwIm
 = 
SgIm
::
Unlized
(
ngth
(- 
ngthToRemove
, 
da
);

293 
memy
(
da
, 
chas
, 
posi
 * (
ChaTy
));

294 
memy
(
da
 + 
posi
, 
chas
 +osi + 
ngthToRemove
,

295 (
ngth
(- 
ngthToRemove
 - 
posi
* (
ChaTy
));

297 
	gm_im
 = 
wIm
.
a
();

300 
	gSg
::
move
(
posi
, 
ngthToRemove
)

302 i(
	gngthToRemove
 <= 0)

304 i(
	gposi
 >
ngth
())

306 i(
	gic_
<>(
	gngthToRemove
> 
ngth
(- 
	gposi
)

307 
	gngthToRemove
 = 
ngth
(- 
posi
;

309 i(
is8B
()) {

310 
moveIl
(
chas8
(), 
posi
, 
ngthToRemove
);

315 
moveIl
(
chas16
(), 
posi
, 
ngthToRemove
);

318 
Sg
 
	gSg
::
subrg
(
pos
, 
n
) const

320 i(!
	gm_im
)

321  
Sg
();

322  
	gm_im
->
subrg
(
pos
, 
n
);

325 
Sg
 
	gSg
::
subrgShgIm
(
offt
, 
ngth
) const

329 
	grgLgth
 = 
this
->
ngth
();

330 
	gofft
 = 
d
::
m
(
offt
, 
rgLgth
);

331 
	gngth
 = 
d
::
m
(
ngth
, 
rgLgth
 - 
offt
);

333 i(!
	gofft
 && 
	gngth
 =
rgLgth
)

334  *
this
;

335  
Sg
(
SgIm
::
SubrgShgIm
(
m_im
, 
offt
, 
ngth
));

338 
Sg
 
	gSg
::
cvtToASCIILow
() const

341 i(!
m_im
)

342  
Sg
();

343  
	gm_im
->
cvtToASCIILow
();

346 
Sg
 
	gSg
::
low
() const

348 i(!
m_im
)

349  
Sg
();

350  
	gm_im
->
low
();

353 
Sg
 
	gSg
::
u
() const

355 i(!
m_im
)

356  
Sg
();

357  
	gm_im
->
u
();

360 
Sg
 
	gSg
::
low
(cڡ 
AtomicSg
& 
loIdtifr
) const

362 i(!
m_im
)

363  
Sg
();

364  
	gm_im
->
low
(
loIdtifr
);

367 
Sg
 
	gSg
::
u
(cڡ 
AtomicSg
& 
loIdtifr
) const

369 i(!
m_im
)

370  
Sg
();

371  
	gm_im
->
u
(
loIdtifr
);

374 
Sg
 
	gSg
::
rWheS
() const

376 i(!
m_im
)

377  
Sg
();

378  
	gm_im
->
rWheS
();

381 
Sg
 
	gSg
::
rWheS
(
IsWheSFuniP
 
isWheS
) const

383 i(!
m_im
)

384  
Sg
();

385  
	gm_im
->
rWheS
(
isWheS
);

388 
Sg
 
	gSg
::
simifyWheS
() const

390 i(!
m_im
)

391  
Sg
();

392  
	gm_im
->
simifyWheS
();

395 
Sg
 
	gSg
::
simifyWheS
(
IsWheSFuniP
 
isWheS
) const

397 i(!
m_im
)

398  
Sg
();

399  
	gm_im
->
simifyWheS
(
isWheS
);

402 
Sg
 
	gSg
::
moveChas
(
ChaMchFuniP
 
fdMch
) const

404 i(!
m_im
)

405  
Sg
();

406  
	gm_im
->
moveChas
(
fdMch
);

409 
Sg
 
	gSg
::
fdCa
() const

411 i(!
m_im
)

412  
Sg
();

413  
	gm_im
->
fdCa
();

416 
bo
 
	gSg
::
rage
(& 
su
) const

418 i(!
m_im
 || !m_im->
ngth
())

419  
l
;

421 i((*
	gm_im
)[
m_im
->
ngth
() - 1] != '%')

422  
l
;

424 i(
	gm_im
->
is8B
())

425 
	gsu
 = 
chasToISi
(
m_im
->
chas8
(), m_im->
ngth
() - 1);

427 
	gsu
 = 
chasToISi
(
m_im
->
chas16
(), m_im->
ngth
() - 1);

428  
	gue
;

431 
	gVe
<
	gUCh
> 
	gSg
::
chasWhNuTmi
() const

433 
Ve
<
UCh
> 
su
;

435 i(
	gm_im
) {

436 
	gsu
.
rveInlCacy
(
ngth
() + 1);

438 i(
is8B
()) {

439 cڡ 
LCh
* 
	gchas8
 = 
m_im
->
chas8
();

440 
size_t
 
	gi
 = 0; i < 
ngth
(); ++i)

441 
	gsu
.
uncheckedAd
(
chas8
[
i
]);

443 cڡ 
UCh
* 
	gchas16
 = 
m_im
->
chas16
();

444 
	gsu
.
nd
(
chas16
, 
m_im
->
ngth
());

447 
	gsu
.
nd
(0);

450  
	gsu
;

453 
Sg
 
	gSg
::
fm
(const *format, ...)

455 
va_li
 
	ggs
;

456 
va_t
(
gs
, 
fm
);

458 
	gVe
<, 256> 
	gbufr
;

461 #i
COMPILER
(
MSVC
)

462 
	gsu
 = 
_vsrtf
(
fm
, 
gs
);

464 
	gch
;

465 
	gsu
 = 
vtf
(&
ch
, 1, 
fm
, 
gs
);

472 
va_d
(
gs
);

473 
va_t
(
gs
, 
fm
);

476 i(
	gsu
 == 0)

477  
Sg
("");

478 i(
	gsu
 < 0)

479  
Sg
();

480 
	gn
 = 
su
;

481 
	gbufr
.
grow
(
n
 + 1);

484 
vtf
(
bufr
.
da
(), bufr.
size
(), 
fm
, 
gs
);

486 
va_d
(
gs
);

488  
	gSgIm
::

(
t_
<cڡ 
LCh
*>(
bufr
.
da
()), 
n
);

491 
Sg
 
	gSg
::
numb
(number)

493  
numbToSgSigd
<
Sg
>(
numb
);

496 
Sg
 
	gSg
::
numb
(number)

498  
numbToSgUnsigd
<
Sg
>(
numb
);

501 
Sg
 
	gSg
::
numb
(number)

503  
numbToSgSigd
<
Sg
>(
numb
);

506 
Sg
 
	gSg
::
numb
(number)

508  
numbToSgUnsigd
<
Sg
>(
numb
);

511 
Sg
 
	gSg
::
numb
(number)

513  
numbToSgSigd
<
Sg
>(
numb
);

516 
Sg
 
	gSg
::
numb
(number)

518  
numbToSgUnsigd
<
Sg
>(
numb
);

521 
Sg
 
	gSg
::
numb
(numb, 
ecisi
, 
TgZosTruntgPicy
 
agZosTruntgPicy
)

523 
NumbToSgBufr
 
	gbufr
;

524  
Sg
(
numbToFixedPcisiSg
(
numb
, 
ecisi
, 
bufr
, 
agZosTruntgPicy
 =
TrunTgZos
));

527 
Sg
 
	gSg
::
numbToSgECMASt
(
numb
)

529 
NumbToSgBufr
 
bufr
;

530  
Sg
(
numbToSg
(
numb
, 
bufr
));

533 
Sg
 
	gSg
::
numbToSgFixedWidth
(
numb
, 
decimPs
)

535 
NumbToSgBufr
 
	gbufr
;

536  
Sg
(
numbToFixedWidthSg
(
numb
, 
decimPs
, 
bufr
));

539 
	gSg
::
toISi
(
bo
* 
ok
, 
ba
) const

541 i(!
	gm_im
) {

542 i(
	gok
)

543 *
	gok
 = 
l
;

546  
	gm_im
->
toISi
(
ok
, 
ba
);

549 
	gSg
::
toUISi
(
bo
* 
ok
, 
ba
) const

551 i(!
	gm_im
) {

552 i(
	gok
)

553 *
	gok
 = 
l
;

556  
	gm_im
->
toUISi
(
ok
, 
ba
);

559 
t64_t
 
	gSg
::
toI64Si
(
bo
* 
ok
, 
ba
) const

561 i(!
	gm_im
) {

562 i(
	gok
)

563 *
	gok
 = 
l
;

566  
	gm_im
->
toI64Si
(
ok
, 
ba
);

569 
ut64_t
 
	gSg
::
toUI64Si
(
bo
* 
ok
, 
ba
) const

571 i(!
	gm_im
) {

572 i(
	gok
)

573 *
	gok
 = 
l
;

576  
	gm_im
->
toUI64Si
(
ok
, 
ba
);

579 
_t
 
	gSg
::
toIPSi
(
bo
* 
ok
, 
ba
) const

581 i(!
	gm_im
) {

582 i(
	gok
)

583 *
	gok
 = 
l
;

586  
	gm_im
->
toIPSi
(
ok
, 
ba
);

589 
	gSg
::
toI
(
bo
* 
ok
) const

591 i(!
m_im
) {

592 i(
ok
)

593 *
ok
 = 
l
;

596  
	gm_im
->
toI
(
ok
);

599 
	gSg
::
toUI
(
bo
* 
ok
) const

601 i(!
m_im
) {

602 i(
ok
)

603 *
ok
 = 
l
;

606  
	gm_im
->
toUI
(
ok
);

609 
t64_t
 
	gSg
::
toI64
(
bo
* 
ok
) const

611 i(!
m_im
) {

612 i(
ok
)

613 *
ok
 = 
l
;

616  
	gm_im
->
toI64
(
ok
);

619 
ut64_t
 
	gSg
::
toUI64
(
bo
* 
ok
) const

621 i(!
m_im
) {

622 i(
ok
)

623 *
ok
 = 
l
;

626  
	gm_im
->
toUI64
(
ok
);

629 
_t
 
	gSg
::
toIP
(
bo
* 
ok
) const

631 i(!
m_im
) {

632 i(
ok
)

633 *
ok
 = 
l
;

636  
	gm_im
->
toIP
(
ok
);

639 
	gSg
::
toDoub
(
bo
* 
ok
) const

641 i(!
m_im
) {

642 i(
ok
)

643 *
ok
 = 
l
;

646  
	gm_im
->
toDoub
(
ok
);

649 
	gSg
::
toFlt
(
bo
* 
ok
) const

651 i(!
m_im
) {

652 i(
ok
)

653 *
ok
 = 
l
;

656  
	gm_im
->
toFlt
(
ok
);

659 #i
COMPILER_SUPPORTS
(
CXX_REFERENCE_QUALIFIED_FUNCTIONS
)

660 
Sg
 
	gSg
::
isީedCy
() const &

662 i(!
m_im
)

663  
Sg
();

664  
	gm_im
->
isީedCy
();

667 
Sg
 
	gSg
::
isީedCy
() &&

669 i(
isSaToSdToAnhThad
()) {

672  
Sg
(
WTF
::
move
(*
this
));

675 i(!
	gm_im
)

676  
Sg
();

678  
	gm_im
->
isީedCy
();

681 
Sg
 
	gSg
::
isީedCy
() const

683 i(!
m_im
)

684  
Sg
();

685  
	gm_im
->
isީedCy
();

689 
bo
 
	gSg
::
isSaToSdToAnhThad
() const

691 i(!
im
())

692  
ue
;

695 i(
im
()->
isAtomic
())

696  
	gl
;

697 i(
im
()->
hasORef
())

698  
	gue
;

699 i(
isEmy
())

700  
	gue
;

701  
	gl
;

704 
	gSg
::
l
(cڡ 
Sg
& 
t
, 
bo
 
lowEmyErs
, 
Ve
<Sg>& 
su
) const

706 
	gsu
.
r
();

708 
	gtPos
 = 0;

709 
size_t
 
	gdPos
;

710 (
	gdPos
 = 
fd
(
t
, 
tPos
)!
nFound
) {

711 i(
lowEmyErs
 || 
tPos
 !
dPos
)

712 
su
.
nd
(
subrg
(
tPos
, 
dPos
 - startPos));

713 
	gtPos
 = 
dPos
 + 
t
.
ngth
();

715 i(
	glowEmyErs
 || 
	gtPos
 !
ngth
())

716 
su
.
nd
(
subrg
(
tPos
));

719 
	gSg
::
l
(
UCh
 
t
, 
bo
 
lowEmyErs
, 
Ve
<
Sg
>& 
su
) const

721 
	gsu
.
r
();

723 
	gtPos
 = 0;

724 
size_t
 
	gdPos
;

725 (
	gdPos
 = 
fd
(
t
, 
tPos
)!
nFound
) {

726 i(
lowEmyErs
 || 
tPos
 !
dPos
)

727 
su
.
nd
(
subrg
(
tPos
, 
dPos
 - startPos));

728 
	gtPos
 = 
dPos
 + 1;

730 i(
	glowEmyErs
 || 
	gtPos
 !
ngth
())

731 
su
.
nd
(
subrg
(
tPos
));

734 
CSg
 
	gSg
::
ascii
() const

739 
ngth
 = 
this
->length();

740 i(!
	gngth
) {

741 * 
	gchaBufr
;

742  
	gCSg
::
wUnlized
(
ngth
, 
chaBufr
);

745 i(
	gthis
->
is8B
()) {

746 cڡ 
LCh
* 
	gchas
 = 
this
->
chas8
();

748 * 
	gchaBufr
;

749 
CSg
 
	gsu
 = CSg::
wUnlized
(
ngth
, 
chaBufr
);

751 
	gi
 = 0; i < 
	gngth
; ++i) {

752 
LCh
 
	gch
 = 
chas
[
i
];

753 
	gchaBufr
[
i
] = 
ch
 && (ch < 0x20 || ch > 0x7f) ? '?' : ch;

756  
	gsu
;

759 cڡ 
UCh
* 
	gchas
 = 
this
->
chas16
();

761 * 
	gchaBufr
;

762 
CSg
 
	gsu
 = CSg::
wUnlized
(
ngth
, 
chaBufr
);

764 
	gi
 = 0; i < 
	gngth
; ++i) {

765 
UCh
 
	gch
 = 
chas
[
i
];

766 
	gchaBufr
[
i
] = 
ch
 && (ch < 0x20 || ch > 0x7f) ? '?' : ch;

769  
	gsu
;

772 
CSg
 
	gSg
::
t1
() const

777 
ngth
 = 
this
->length();

779 i(!
	gngth
)

780  
CSg
("", 0);

782 i(
is8B
())

783  
CSg
(
t_
<cڡ *>(
this
->
chas8
()), 
ngth
);

785 cڡ 
UCh
* 
	gchas
 = 
this
->
chas16
();

787 * 
	gchaBufr
;

788 
CSg
 
	gsu
 = CSg::
wUnlized
(
ngth
, 
chaBufr
);

790 
	gi
 = 0; i < 
	gngth
; ++i) {

791 
UCh
 
	gch
 = 
chas
[
i
];

792 
	gchaBufr
[
i
] = 
ch
 > 0xff ? '?' : ch;

795  
	gsu
;

798 
CSg
 
	gSg
::
utf8
(
CvsiMode
 
mode
) const

800 i(!
m_im
)

801  
CSg
("", 0);

803  
	gm_im
->
utf8
(
mode
);

806 
Sg
 
	gSg
::
make8BFrom16BSour
(cڡ 
UCh
* 
sour
, 
size_t
 
ngth
)

808 i(!
	gngth
)

809  
Sg
();

811 
LCh
* 
	gdei
;

812 
Sg
 
	gsu
 = Sg::
Unlized
(
ngth
, 
dei
);

814 
cyLChsFromUChSour
(
dei
, 
sour
, 
ngth
);

816  
	gsu
;

819 
Sg
 
	gSg
::
make16BFrom8BSour
(cڡ 
LCh
* 
sour
, 
size_t
 
ngth
)

821 i(!
	gngth
)

822  
Sg
();

824 
UCh
* 
	gdei
;

825 
Sg
 
	gsu
 = Sg::
Unlized
(
ngth
, 
dei
);

827 
	gSgIm
::
cyChs
(
dei
, 
sour
, 
ngth
);

829  
	gsu
;

832 
Sg
 
	gSg
::
omUTF8
(cڡ 
LCh
* 
rgS
, 
size_t
 
ngth
)

834 i(
	gngth
 > 
	gd
::
numic_lims
<>::
max
())

835 
CRASH
();

837 i(!
	grgS
)

838  
Sg
();

840 i(!
	gngth
)

841  
emySg
();

843 i(
chasAAASCII
(
rgS
, 
ngth
))

844  
	gSgIm
::

(
rgS
, 
ngth
);

846 
	gVe
<
	gUCh
, 1024> 
bufr
(
ngth
);

847 
UCh
* 
	gbufrS
 = 
bufr
.
da
();

849 
UCh
* 
	gbufrCut
 = 
bufrS
;

850 cڡ * 
	grgCut
 = 
t_
<cڡ *>(
rgS
);

851 i(
cvtUTF8ToUTF16
(&
rgCut
, 
t_
<cڡ *>(
rgS
 + 
ngth
), &
bufrCut
, bufrCu+ 
bufr
.
size
()!
cvsiOK
)

852  
Sg
();

854 
	gutf16Lgth
 = 
bufrCut
 - 
bufrS
;

855 
ASSERT_WITH_SECURITY_IMPLICATION
(
utf16Lgth
 < 
ngth
);

856  
	gSgIm
::

(
bufrS
, 
utf16Lgth
);

859 
Sg
 
	gSg
::
omUTF8
(cڡ 
LCh
* 
rg
)

861 i(!
rg
)

862  
Sg
();

863  
omUTF8
(
rg
, 

(
t_
<const *>(string)));

866 
Sg
 
	gSg
::
omUTF8
(cڡ 
CSg
& 
s
)

868  
omUTF8
(
s
.
da
());

871 
Sg
 
	gSg
::
omUTF8WhL1Flback
(cڡ 
LCh
* 
rg
, 
size_t
 
size
)

873 
Sg
 
	gutf8
 = 
omUTF8
(
rg
, 
size
);

874 i(!
	gutf8
)

875  
Sg
(
rg
, 
size
);

876  
	gutf8
;

881 
bo
 
isChaAowedInBa
(
UCh
 
c
, 
ba
)

883 i(
	gc
 > 0x7F)

884  
	gl
;

885 i(
isASCIIDig
(
c
))

886  
	gc
 - '0' < 
	gba
;

887 i(
isASCIIAha
(
c
)) {

888 i(
	gba
 > 36)

889 
	gba
 = 36;

890  (
	gc
 >'a' && 
c
 < 'a' + 
ba
 - 10)

891 || (
c
 >'A' && c < 'A' + 
ba
 - 10);

893  
	gl
;

896 
	gme
 <
tyme
 
	gIeglTy
,ym
	gChTy
>

897 
le
 
IeglTy
 
toIeglTy
(cڡ 
ChTy
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
, 
ba
)

899 cڡ 
IeglTy
 
	gglMax
 = 
d
::
numic_lims
<IeglTy>::
max
();

900 cڡ 
bo
 
	gisSigd
 = 
d
::
numic_lims
<
IeglTy
>::
is_sigd
;

901 cڡ 
IeglTy
 
	gmaxMuɝlr
 = 
glMax
 / 
ba
;

903 
IeglTy
 
	gvue
 = 0;

904 
bo
 
	gisOk
 = 
l
;

905 
bo
 
	gisNegive
 = 
l
;

907 i(!
	gda
)

908 
	gbye
;

911 
	gngth
 && 
isSOrNewle
(*
da
)) {

912 --
	gngth
;

913 ++
	gda
;

916 i(
	gisSigd
 && 
	gngth
 && *
	gda
 == '-') {

917 --
ngth
;

918 ++
	gda
;

919 
	gisNegive
 = 
ue
;

920 } i(
	gngth
 && *
	gda
 == '+') {

921 --
ngth
;

922 ++
	gda
;

925 i(!
	gngth
 || !
isChaAowedInBa
(*
da
, 
ba
))

926 
	gbye
;

928 
	gngth
 && 
isChaAowedInBa
(*
da
, 
ba
)) {

929 --
	gngth
;

930 
IeglTy
 
	gdigVue
;

931 
ChTy
 
	gc
 = *
da
;

932 i(
isASCIIDig
(
c
))

933 
	gdigVue
 = 
c
 - '0';

934 i(
	gc
 >= 'a')

935 
digVue
 = 
c
 - 'a' + 10;

937 
	gdigVue
 = 
c
 - 'A' + 10;

939 i(
	gvue
 > 
	gmaxMuɝlr
 || (vu=
maxMuɝlr
 && 
digVue
 > (
glMax
 % 
ba
+ 
isNegive
))

940 
bye
;

942 
	gvue
 = 
ba
 * 
vue
 + 
digVue
;

943 ++
	gda
;

946 #i
COMPILER
(
MSVC
)

947 #agm
wng
(
push
, 0)

948 #agm
wng
(
dib
:4146)

951 i(
	gisNegive
)

952 
	gvue
 = -
vue
;

954 #i
COMPILER
(
MSVC
)

955 #agm
wng
(
p
)

959 
	gngth
 && 
isSOrNewle
(*
da
)) {

960 --
	gngth
;

961 ++
	gda
;

964 i(!
	gngth
)

965 
	gisOk
 = 
ue
;

966 
	gbye
:

967 i(
ok
)

968 *
ok
 = 
isOk
;

969  
	gisOk
 ? 
	gvue
 : 0;

972 
	gme
 <
tyme
 
	gChTy
>

973 
ngthOfChasAsIeg
(cڡ 
ChTy
* 
da
, 
size_t
 
ngth
)

975 
size_t
 
	gi
 = 0;

978 ; 
	gi
 !
ngth
; ++i) {

979 i(!
isSOrNewle
(
da
[
i
]))

984 i(
	gi
 !
ngth
 && (
da
[
i
] == '+' || data[i] == '-'))

985 ++
i
;

988 ; 
	gi
 !
ngth
; ++i) {

989 i(!
isASCIIDig
(
da
[
i
]))

993  
	gi
;

996 
chasToISi
(cڡ 
LCh
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
, 
ba
)

998  
	gtoIeglTy
<, 
	gLCh
>(
	gda
, 
	gngth
, 
	gok
, 
	gba
);

1001 
chasToISi
(cڡ 
UCh
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
, 
ba
)

1003  
	gtoIeglTy
<, 
	gUCh
>(
	gda
, 
	gngth
, 
	gok
, 
	gba
);

1006 
chasToUISi
(cڡ 
LCh
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
, 
ba
)

1008  
	gtoIeglTy
<, 
	gLCh
>(
	gda
, 
	gngth
, 
	gok
, 
	gba
);

1011 
chasToUISi
(cڡ 
UCh
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
, 
ba
)

1013  
	gtoIeglTy
<, 
	gUCh
>(
	gda
, 
	gngth
, 
	gok
, 
	gba
);

1016 
t64_t
 
chasToI64Si
(cڡ 
LCh
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
, 
ba
)

1018  
	gtoIeglTy
<
	gt64_t
, 
	gLCh
>(
	gda
, 
	gngth
, 
	gok
, 
	gba
);

1021 
t64_t
 
chasToI64Si
(cڡ 
UCh
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
, 
ba
)

1023  
	gtoIeglTy
<
	gt64_t
, 
	gUCh
>(
	gda
, 
	gngth
, 
	gok
, 
	gba
);

1026 
ut64_t
 
chasToUI64Si
(cڡ 
LCh
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
, 
ba
)

1028  
	gtoIeglTy
<
	gut64_t
, 
	gLCh
>(
	gda
, 
	gngth
, 
	gok
, 
	gba
);

1031 
ut64_t
 
chasToUI64Si
(cڡ 
UCh
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
, 
ba
)

1033  
	gtoIeglTy
<
	gut64_t
, 
	gUCh
>(
	gda
, 
	gngth
, 
	gok
, 
	gba
);

1036 
_t
 
chasToIPSi
(cڡ 
LCh
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
, 
ba
)

1038  
	gtoIeglTy
<
	g_t
, 
	gLCh
>(
	gda
, 
	gngth
, 
	gok
, 
	gba
);

1041 
_t
 
chasToIPSi
(cڡ 
UCh
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
, 
ba
)

1043  
	gtoIeglTy
<
	g_t
, 
	gUCh
>(
	gda
, 
	gngth
, 
	gok
, 
	gba
);

1046 
chasToI
(cڡ 
LCh
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
)

1048  
	gtoIeglTy
<, 
	gLCh
>(
	gda
, 
	gngthOfChasAsIeg
<LCh>(da, 
	gngth
), 
	gok
, 10);

1051 
chasToI
(cڡ 
UCh
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
)

1053  
	gtoIeglTy
<, 
	gUCh
>(
	gda
, 
ngthOfChasAsIeg
(
da
, 
ngth
), 
	gok
, 10);

1056 
chasToUI
(cڡ 
LCh
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
)

1058  
	gtoIeglTy
<, 
	gLCh
>(
	gda
, 
	gngthOfChasAsIeg
<LCh>(da, 
	gngth
), 
	gok
, 10);

1061 
chasToUI
(cڡ 
UCh
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
)

1063  
	gtoIeglTy
<, 
	gUCh
>(
	gda
, 
	gngthOfChasAsIeg
<UCh>(da, 
	gngth
), 
	gok
, 10);

1066 
t64_t
 
chasToI64
(cڡ 
LCh
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
)

1068  
	gtoIeglTy
<
	gt64_t
, 
	gLCh
>(
	gda
, 
	gngthOfChasAsIeg
<LCh>(da, 
	gngth
), 
	gok
, 10);

1071 
t64_t
 
chasToI64
(cڡ 
UCh
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
)

1073  
	gtoIeglTy
<
	gt64_t
, 
	gUCh
>(
	gda
, 
	gngthOfChasAsIeg
<UCh>(da, 
	gngth
), 
	gok
, 10);

1076 
ut64_t
 
chasToUI64
(cڡ 
LCh
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
)

1078  
	gtoIeglTy
<
	gut64_t
, 
	gLCh
>(
	gda
, 
	gngthOfChasAsIeg
<LCh>(da, 
	gngth
), 
	gok
, 10);

1081 
ut64_t
 
chasToUI64
(cڡ 
UCh
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
)

1083  
	gtoIeglTy
<
	gut64_t
, 
	gUCh
>(
	gda
, 
	gngthOfChasAsIeg
<UCh>(da, 
	gngth
), 
	gok
, 10);

1086 
_t
 
chasToIP
(cڡ 
LCh
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
)

1088  
	gtoIeglTy
<
	g_t
, 
	gLCh
>(
	gda
, 
	gngthOfChasAsIeg
<LCh>(da, 
	gngth
), 
	gok
, 10);

1091 
_t
 
chasToIP
(cڡ 
UCh
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
)

1093  
	gtoIeglTy
<
	g_t
, 
	gUCh
>(
	gda
, 
	gngthOfChasAsIeg
<UCh>(da, 
	gngth
), 
	gok
, 10);

1096 
	eTgJunkPicy
 { 
	gDiowTgJunk
, 
	gAowTgJunk
 };

1098 
	gme
 <
tyme
 
	gChTy
, 
TgJunkPicy
 
	gpicy
>

1099 
le
 
toDoubTy
(cڡ 
ChTy
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
, size_t& 
rdLgth
)

1101 
size_t
 
	gadgSsLgth
 = 0;

1102 
	gadgSsLgth
 < 
	gngth
 && 
isASCIIS
(
da
[
adgSsLgth
]))

1103 ++
	gadgSsLgth
;

1105 
	gnumb
 = 
rDoub
(
da
 + 
adgSsLgth
, 
ngth
 -dgSsLgth, 
rdLgth
);

1106 i(!
	grdLgth
) {

1107 i(
	gok
)

1108 *
	gok
 = 
l
;

1112 
	grdLgth
 +
adgSsLgth
;

1113 i(
	gok
)

1114 *
	gok
 = 
picy
 =
AowTgJunk
 || 
rdLgth
 =
ngth
;

1115  
	gnumb
;

1118 
chasToDoub
(cڡ 
LCh
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
)

1120 
size_t
 
	grdLgth
;

1121  
	gtoDoubTy
<
	gLCh
, 
	gDiowTgJunk
>(
	gda
, 
	gngth
, 
	gok
, 
	grdLgth
);

1124 
chasToDoub
(cڡ 
UCh
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
)

1126 
size_t
 
	grdLgth
;

1127  
	gtoDoubTy
<
	gUCh
, 
	gDiowTgJunk
>(
	gda
, 
	gngth
, 
	gok
, 
	grdLgth
);

1130 
chasToFlt
(cڡ 
LCh
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
)

1133 
size_t
 
	grdLgth
;

1134  
	gic_
<>(
	gtoDoubTy
<
	gLCh
, 
	gDiowTgJunk
>(
	gda
, 
	gngth
, 
	gok
, 
	grdLgth
));

1137 
chasToFlt
(cڡ 
UCh
* 
da
, 
size_t
 
ngth
, 
bo
* 
ok
)

1140 
size_t
 
	grdLgth
;

1141  
	gic_
<>(
	gtoDoubTy
<
	gUCh
, 
	gDiowTgJunk
>(
	gda
, 
	gngth
, 
	gok
, 
	grdLgth
));

1144 
chasToFlt
(cڡ 
LCh
* 
da
, 
size_t
 
ngth
, size_t& 
rdLgth
)

1147  
	gic_
<>(
	gtoDoubTy
<
	gLCh
, 
	gAowTgJunk
>(
	gda
, 
	gngth
, 0, 
	grdLgth
));

1150 
chasToFlt
(cڡ 
UCh
* 
da
, 
size_t
 
ngth
, size_t& 
rdLgth
)

1153  
	gic_
<>(
	gtoDoubTy
<
	gUCh
, 
	gAowTgJunk
>(
	gda
, 
	gngth
, 0, 
	grdLgth
));

1156 cڡ 
	gSg
& 
emySg
()

1158 
	gNevDeroyed
<
	gSg
> 
emySg
(
SgIm
::
emy
());

1160  
	gemySg
;

1165 #ide
NDEBUG


1167 
Sg
* 
rg
(const *);

1168 
	gVe
<> 
asciiDebug
(
SgIm
* 
im
);

1169 
	gVe
<> 
asciiDebug
(
Sg
& 
rg
);

1171 
	gSg
::
	$show
() const

1173 
	`daLogF
("%s\n", 
	`asciiDebug
(
	`im
()).
	`da
());

1174 
	}
}

1176 
Sg
* 
	$rg
(cڡ * 
s
)

1179  
w
 
	`Sg
(
s
);

1180 
	}
}

1182 
	gVe
<> 
	$asciiDebug
(
SgIm
* 
im
)

1184 i(!
im
)

1185  
	`asciiDebug
(
	`Sg
(
	`ASCIIL
("[nu]")).
	`im
());

1187 
Ve
<> 
bufr
;

1188 
i
 = 0; i < 
im
->
	`ngth
(); ++i) {

1189 
UCh
 
ch
 = (*
im
)[
i
];

1190 i(
	`isASCIIPrb
(
ch
)) {

1191 i(
ch
 == '\\')

1192 
bufr
.
	`nd
(
ch
);

1193 
bufr
.
	`nd
(
ch
);

1195 
bufr
.
	`nd
('\\');

1196 
bufr
.
	`nd
('u');

1197 
	`ndUnsigdAsHexFixedSize
(
ch
, 
bufr
, 4);

1200 
bufr
.
	`nd
('\0');

1201  
bufr
;

1202 
	}
}

1204 
	gVe
<> 
	$asciiDebug
(
Sg
& 
rg
)

1206  
	`asciiDebug
(
rg
.
	`im
());

1207 
	}
}

	@text/WTFString.h

22 #ide
WTFSg_h


23 
	#WTFSg_h


	)

28 
	~<wtf/xt/ASCIIFaPh.h
>

29 
	~<wtf/xt/SgIm.h
>

31 #ifde
__OBJC__


32 
	~<objc/objc.h
>

35 
mea
 
	gWTF
 {

37 
ass
 
	gCSg
;

38 
	gSgHash
;

42 
WTF_EXPORT_STRING_API
 
chasToISi
(cڡ 
LCh
*, 
size_t
, 
bo
* 
ok
 = 0, 
ba
 = 10);

43 
WTF_EXPORT_STRING_API
 
chasToISi
(cڡ 
UCh
*, 
size_t
, 
bo
* 
ok
 = 0, 
ba
 = 10);

44 
WTF_EXPORT_STRING_API
 
chasToUISi
(cڡ 
LCh
*, 
size_t
, 
bo
* 
ok
 = 0, 
ba
 = 10);

45 
WTF_EXPORT_STRING_API
 
chasToUISi
(cڡ 
UCh
*, 
size_t
, 
bo
* 
ok
 = 0, 
ba
 = 10);

46 
t64_t
 
chasToI64Si
(cڡ 
LCh
*, 
size_t
, 
bo
* 
ok
 = 0, 
ba
 = 10);

47 
t64_t
 
chasToI64Si
(cڡ 
UCh
*, 
size_t
, 
bo
* 
ok
 = 0, 
ba
 = 10);

48 
ut64_t
 
chasToUI64Si
(cڡ 
LCh
*, 
size_t
, 
bo
* 
ok
 = 0, 
ba
 = 10);

49 
ut64_t
 
chasToUI64Si
(cڡ 
UCh
*, 
size_t
, 
bo
* 
ok
 = 0, 
ba
 = 10);

50 
_t
 
chasToIPSi
(cڡ 
LCh
*, 
size_t
, 
bo
* 
ok
 = 0, 
ba
 = 10);

51 
_t
 
chasToIPSi
(cڡ 
UCh
*, 
size_t
, 
bo
* 
ok
 = 0, 
ba
 = 10);

53 
WTF_EXPORT_STRING_API
 
chasToI
(cڡ 
LCh
*, 
size_t
, 
bo
* 
ok
 = 0);

54 
WTF_EXPORT_STRING_API
 
chasToI
(cڡ 
UCh
*, 
size_t
, 
bo
* 
ok
 = 0);

55 
chasToUI
(cڡ 
LCh
*, 
size_t
, 
bo
* 
ok
 = 0);

56 
chasToUI
(cڡ 
UCh
*, 
size_t
, 
bo
* 
ok
 = 0);

57 
t64_t
 
chasToI64
(cڡ 
LCh
*, 
size_t
, 
bo
* 
ok
 = 0);

58 
t64_t
 
chasToI64
(cڡ 
UCh
*, 
size_t
, 
bo
* 
ok
 = 0);

59 
ut64_t
 
chasToUI64
(cڡ 
LCh
*, 
size_t
, 
bo
* 
ok
 = 0);

60 
ut64_t
 
chasToUI64
(cڡ 
UCh
*, 
size_t
, 
bo
* 
ok
 = 0);

61 
_t
 
chasToIP
(cڡ 
LCh
*, 
size_t
, 
bo
* 
ok
 = 0);

62 
_t
 
chasToIP
(cڡ 
UCh
*, 
size_t
, 
bo
* 
ok
 = 0);

67 
WTF_EXPORT_STRING_API
 
chasToDoub
(cڡ 
LCh
*, 
size_t
, 
bo
* 
ok
 = 0);

68 
WTF_EXPORT_STRING_API
 
chasToDoub
(cڡ 
UCh
*, 
size_t
, 
bo
* 
ok
 = 0);

69 
WTF_EXPORT_STRING_API
 
chasToFlt
(cڡ 
LCh
*, 
size_t
, 
bo
* 
ok
 = 0);

70 
WTF_EXPORT_STRING_API
 
chasToFlt
(cڡ 
UCh
*, 
size_t
, 
bo
* 
ok
 = 0);

71 
WTF_EXPORT_STRING_API
 
chasToFlt
(cڡ 
LCh
*, 
size_t
, size_t& 
rdLgth
);

72 
WTF_EXPORT_STRING_API
 
chasToFlt
(cڡ 
UCh
*, 
size_t
, size_t& 
rdLgth
);

74 
ass
 
	gASCIIL
;

76 
	eTgZosTruntgPicy
 {

77 
	gKpTgZos
,

78 
	gTrunTgZos


81 
	gme
<
bo
 
isSclCha
(
UCh
), 
tyme
 
	gChaTy
>

82 
bo
 
isASclChas
(cڡ 
ChaTy
*, 
size_t
);

84 as
	cSg
 {

85 
	gpublic
:

87 
Sg
() { }

90 
WTF_EXPORT_STRING_API
 
Sg
(cڡ 
UCh
* 
chas
, 
ngth
);

100 
	gme
<
size_t
 
	gleCacy
, 
tyme
 
	gOvowHdr
>

101 
exic
 
Sg
(cڡ 
Ve
<
UCh
, 
leCacy
, 
OvowHdr
>&);

104 
WTF_EXPORT_STRING_API
 
Sg
(cڡ 
UCh
*);

107 
WTF_EXPORT_STRING_API
 
Sg
(cڡ 
LCh
* 
chas
, 
ngth
);

108 
WTF_EXPORT_STRING_API
 
Sg
(cڡ * 
chas
, 
ngth
);

111 
WTF_EXPORT_STRING_API
 
Sg
(cڡ 
LCh
* 
chas
);

112 
WTF_EXPORT_STRING_API
 
Sg
(cڡ * 
chas
);

115 
Sg
(
SgIm
& 
im
: 
m_im
(&impl) { }

116 
Sg
(
SgIm
* 
im
: 
m_im
(impl) { }

117 
Sg
(
PassRefP
<
SgIm
> 
im
: 
m_im
(impl) { }

118 
Sg
(
PassRef
<
SgIm
>&& 
im
: 
m_im
(
d
::
fwd
<PassRef<StringImpl>>(impl)) { }

119 
Sg
(
RefP
<
SgIm
>&& 
im
: 
m_im
(impl) { }

122 
WTF_EXPORT_STRING_API
 
Sg
(
ASCIIL
 
chas
);

126 
	eCڡruFromLTag
 { 
	gCڡruFromL
 };

127 
	gme
<
	gchasCou
>

128 
Sg
(cڡ (&
chas
)[
chasCou
], 
CڡruFromLTag
: 
m_im
(
SgIm
::
FromL
<charactersCount>(characters)) { }

132 
Sg
(cڡ Sg& 
h
: 
m_im
(other.m_impl) { }

133 
Sg
(Sg&& 
h
: 
m_im
(h.m_im.
a
()) { }

134 
Sg
& 
ݔ
=(cڡ Sg& 
h
{ 
m_im
 = oth.m_im;  *
	gthis
; }

135 
	gSg
& 
	gݔ
=(
Sg
&& 
h
{ 
m_im
 = oth.m_im.
a
();  *
	gthis
; }

138 
	gALWAYS_INLINE
 ~
Sg
() { }

140 
sw
(
Sg
& 
o
{ 
	gm_im
.sw(o.
m_im
); }

142 
Sg
 
adt
(
SgBufr
<
LCh
>& 
bufr
{  
	gSgIm
::adopt(buffer); }

143 
Sg
 
adt
(
SgBufr
<
UCh
>& 
bufr
{  
	gSgIm
::adopt(buffer); }

144 
	gme
<
tyme
 
	gChaTy
, 
size_t
 
	gleCacy
,ym
	gOvowHdr
>

145 
Sg
 
adt
(
Ve
<
ChaTy
, 
leCacy
, 
OvowHdr
>& 
ve
{  
	gSgIm
::adopt(vector); }

147 
bo
 
isNu
(cڡ {  !
	gm_im
; }

148 
bo
 
isEmy
(cڡ {  !
	gm_im
 || !m_im->
ngth
(); }

150 
SgIm
* 
im
(cڡ {  
	gm_im
.
g
(); }

151 
	gPassRefP
<
	gSgIm
> 
aIm
({  
	gm_im
.
a
(); }

153 
ngth
() const

155 i(!
	gm_im
)

157  
	gm_im
->
ngth
();

160 cڡ 
LCh
* 
chas8
() const

162 i(!
	gm_im
)

164 
ASSERT
(
m_im
->
is8B
());

165  
	gm_im
->
chas8
();

168 cڡ 
UCh
* 
chas16
() const

170 i(!
	gm_im
)

172 
ASSERT
(!
m_im
->
is8B
());

173  
	gm_im
->
chas16
();

177 
	gme
 <
tyme
 
	gChaTy
>

178 
le
 cڡ 
ChaTy
* 
chas
() const;

180 
bo
 
is8B
(cڡ {  
	gm_im
->is8Bit(); }

182 
sizeInBys
() const

184 i(!
	gm_im
)

186  
	gm_im
->
ngth
(* (
is8B
(? (
	gLCh
: (
UCh
));

189 
WTF_EXPORT_STRING_API
 
CSg
 
ascii
() const;

190 
WTF_EXPORT_STRING_API
 
CSg
 
t1
() const;

192 
WTF_EXPORT_STRING_API
 
CSg
 
utf8
(
CvsiMode
 = 
LCvsi
) const;

194 
UCh
 

(
dex
) const

196 i(!
	gm_im
 || 
	gdex
 >
m_im
->
ngth
())

198  (*
	gm_im
)[
dex
];

200 
UCh
 
	gݔ
[](
	gdex
cڡ {  

(
dex
); }

202 
WTF_EXPORT_STRING_API
 
Sg
 
numb
();

203 
WTF_EXPORT_STRING_API
 
Sg
 
numb
();

204 
WTF_EXPORT_STRING_API
 
Sg
 
numb
();

205 
WTF_EXPORT_STRING_API
 
Sg
 
numb
();

206 
WTF_EXPORT_STRING_API
 
Sg
 
numb
();

207 
WTF_EXPORT_STRING_API
 
Sg
 
numb
();

209 
WTF_EXPORT_STRING_API
 
Sg
 
numb
(, 
ecisi
 = 6, 
TgZosTruntgPicy
 = 
TrunTgZos
);

212 
WTF_EXPORT_STRING_API
 
Sg
 
numbToSgECMASt
();

213 
WTF_EXPORT_STRING_API
 
Sg
 
numbToSgFixedWidth
(, 
decimPs
);

216 
size_t
 
fd
(
UCh
 
c
, 
t
 = 0) const

217 {  
m_im
 ? m_im->
fd
(
c
, 
t
: 
nFound
; }

219 
size_t
 
fd
(cڡ 
Sg
& 
r
) const

220 {  
	gm_im
 ? m_im->
fd
(
r
.
im
(): 
nFound
; }

221 
size_t
 
fd
(cڡ 
Sg
& 
r
, 
t
) const

222 {  
	gm_im
 ? m_im->
fd
(
r
.
im
(), 
t
: 
nFound
; }

224 
size_t
 
fd
(
ChaMchFuniP
 
mchFuni
, 
t
 = 0) const

225 {  
m_im
 ? m_im->
fd
(
mchFuni
, 
t
: 
nFound
; }

226 
size_t
 
fd
(cڡ 
LCh
* 
r
, 
t
 = 0) const

227 {  
m_im
 ? m_im->
fd
(
r
, 
t
: 
nFound
; }

229 
size_t
 
fdNextLeS
(
t
 = 0) const

230 {  
m_im
 ? m_im->
fdNextLeS
(
t
: 
nFound
; }

233 
size_t
 
vFd
(
UCh
 
c
, 
t
 = 
UINT_MAX
) const

234 {  
m_im
 ? m_im->
vFd
(
c
, 
t
: 
nFound
; }

235 
size_t
 
vFd
(cڡ 
Sg
& 
r
, 
t
 = 
UINT_MAX
) const

236 {  
m_im
 ? m_im->
vFd
(
r
.
im
(), 
t
: 
nFound
; }

239 
size_t
 
fdIgnܚgCa
(cڡ 
LCh
* 
r
, 
t
 = 0) const

240 {  
m_im
 ? m_im->
fdIgnܚgCa
(
r
, 
t
: 
nFound
; }

241 
size_t
 
fdIgnܚgCa
(cڡ 
Sg
& 
r
, 
t
 = 0) const

242 {  
m_im
 ? m_im->
fdIgnܚgCa
(
r
.
im
(), 
t
: 
nFound
; }

243 
size_t
 
vFdIgnܚgCa
(cڡ 
Sg
& 
r
, 
t
 = 
UINT_MAX
) const

244 {  
m_im
 ? m_im->
vFdIgnܚgCa
(
r
.
im
(), 
t
: 
nFound
; }

247 
size_t
 
fd
(cڡ 
LCh
* 
r
, 
t
, 
bo
 
Ssive
) const

248 {  
	gSsive
 ? 
fd
(
r
, 
t
: 
fdIgnܚgCa
(str, start); }

249 
size_t
 
fd
(cڡ 
Sg
& 
r
, 
t
, 
bo
 
Ssive
) const

250 {  
	gSsive
 ? 
fd
(
r
, 
t
: 
fdIgnܚgCa
(str, start); }

251 
size_t
 
vFd
(cڡ 
Sg
& 
r
, 
t
, 
bo
 
Ssive
) const

252 {  
	gSsive
 ? 
vFd
(
r
, 
t
: 
vFdIgnܚgCa
(str, start); }

254 
WTF_EXPORT_STRING_API
 
	gVe
<
	gUCh
> 
chasWhNuTmi
() const;

256 
WTF_EXPORT_STRING_API
 
UCh32
 
chaSgAt
() const;

258 
bo
 
cڏs
(
UCh
 
c
cڡ {  
fd
(c!
nFound
; }

259 
bo
 
cڏs
(cڡ 
LCh
* 
r
, bo 
Ssive
 = 
ue
, 
tOfft
 = 0) const

260 {  
fd
(
r
, 
tOfft
, 
Ssive
!
nFound
; }

261 
bo
 
cڏs
(cڡ 
Sg
& 
r
, bo 
Ssive
 = 
ue
, 
tOfft
 = 0) const

262 {  
fd
(
r
, 
tOfft
, 
Ssive
!
nFound
; }

264 
bo
 
tsWh
(cڡ 
Sg
& 
s
) const

265 {  
	gm_im
 ? m_im->
tsWh
(
s
.
im
(): s.
isEmy
(); }

266 
bo
 
tsWh
(cڡ 
Sg
& 
s
, bo 
Ssive
) const

267 {  
	gm_im
 ? m_im->
tsWh
(
s
.
im
(), 
Ssive
: s.
isEmy
(); }

268 
bo
 
tsWh
(
UCh
 
cha
) const

269 {  
	gm_im
 ? m_im->
tsWh
(
cha
: 
l
; }

270 
	gme
<
	gmchLgth
>

271 
bo
 
tsWh
(cڡ (&
efix
)[
mchLgth
], bo 
Ssive
 = 
ue
) const

272 {  
m_im
 ? m_im->
tsWh
<
mchLgth
>(
efix
, 
Ssive
) : !matchLength; }

273 
bo
 
tsWh
(
Sg
& 
efix
, 
tOfft
, bo 
Ssive
) const

274 {  
	gm_im
 && 
	gefix
.
im
(? m_im->
tsWh
(*
efix
.im(), 
tOfft
, 
Ssive
: 
l
; }

276 
bo
 
dsWh
(cڡ 
Sg
& 
s
, bo 
Ssive
 = 
ue
) const

277 {  
m_im
 ? m_im->
dsWh
(
s
.
im
(), 
Ssive
: s.
isEmy
(); }

278 
bo
 
dsWh
(
UCh
 
cha
) const

279 {  
	gm_im
 ? m_im->
dsWh
(
cha
: 
l
; }

280 
bo
 
dsWh
(
cha
cڡ { ndsWh(
ic_
<
UCh
>(character)); }

281 
	gme
<
	gmchLgth
>

282 
bo
 
dsWh
(cڡ (&
efix
)[
mchLgth
], bo 
Ssive
 = 
ue
) const

283 {  
m_im
 ? m_im->
dsWh
<
mchLgth
>(
efix
, 
Ssive
) : !matchLength; }

284 
bo
 
dsWh
(
Sg
& 
suffix
, 
dOfft
, bo 
Ssive
) const

285 {  
	gm_im
 && 
	gsuffix
.
im
(? m_im->
dsWh
(*
suffix
.im(), 
dOfft
, 
Ssive
: 
l
; }

287 
WTF_EXPORT_STRING_API
 
nd
(cڡ 
Sg
&);

288 
WTF_EXPORT_STRING_API
 
nd
(
LCh
);

289 
nd
(
c
{d(
ic_
<
LCh
>(c)); };

290 
WTF_EXPORT_STRING_API
 
nd
(
UCh
);

291 
WTF_EXPORT_STRING_API
 
nd
(cڡ 
LCh
*, 
ngth
);

292 
WTF_EXPORT_STRING_API
 
nd
(cڡ 
UCh
*, 
ngth
);

293 
WTF_EXPORT_STRING_API
 

(cڡ 
Sg
&, 
pos
);

295 
	gSg
& 
a
(
UCh
 
a
, UCh 
b
{ i(
	gm_im
m_im = 
m_im
->a, b);  *
	gthis
; }

296 
	gSg
& 
a
(
UCh
 
a
, cڡ 
Sg
& 
b
{ i(
	gm_im
m_im = 
m_im
->a, b.
im
());  *
	gthis
; }

297 
	gSg
& 
a
(cڡ 
Sg
& 
a
, cڡ Sg& 
b
{ i(
	gm_im
m_im = 
m_im
->a.
im
(), b.im());  *
	gthis
; }

298 
	gSg
& 
a
(
dex
, 
n
, cڡ 
Sg
& 
b
{ i(
	gm_im
m_im = 
m_im
->a(dex,, b.
im
());  *
	gthis
; }

300 
	gme
<
	gchasCou
>

301 
ALWAYS_INLINE
 
	gSg
& 
aWhL
(
UCh
 
a
, cڡ (&
chas
)[
chasCou
])

303 i(
	gm_im
)

304 
	gm_im
 = 
m_im
->
a
(
a
, 
chas
, 
chasCou
 - 1);

306  *
	gthis
;

309 
fl
(
UCh
 
c
{ i(
	gm_im
m_im = 
m_im
->fill(c); }

311 
WTF_EXPORT_STRING_API
 
un
(
n
);

312 
WTF_EXPORT_STRING_API
 
move
(
pos
, 
n
 = 1);

314 
WTF_EXPORT_STRING_API
 
Sg
 
subrg
(
pos
, 
n
 = 
UINT_MAX
) const;

315 
WTF_EXPORT_STRING_API
 
Sg
 
subrgShgIm
(
pos
, 
n
 = 
UINT_MAX
) const;

316 
Sg
 

(
n
cڡ {  
subrg
(0,en); }

317 
Sg
 
right
(
n
cڡ {  
subrg
(
ngth
() -en,en); }

322 
WTF_EXPORT_STRING_API
 
Sg
 
cvtToASCIILow
() const;

323 
WTF_EXPORT_STRING_API
 
Sg
 
low
() const;

324 
WTF_EXPORT_STRING_API
 
Sg
 
u
() const;

326 
WTF_EXPORT_STRING_API
 
Sg
 
low
(cڡ 
AtomicSg
& 
loIdtifr
) const;

327 
WTF_EXPORT_STRING_API
 
Sg
 
u
(cڡ 
AtomicSg
& 
loIdtifr
) const;

329 
WTF_EXPORT_STRING_API
 
Sg
 
rWheS
() const;

330 
WTF_EXPORT_STRING_API
 
Sg
 
rWheS
(
IsWheSFuniP
) const;

331 
WTF_EXPORT_STRING_API
 
Sg
 
simifyWheS
() const;

332 
WTF_EXPORT_STRING_API
 
Sg
 
simifyWheS
(
IsWheSFuniP
) const;

334 
WTF_EXPORT_STRING_API
 
Sg
 
moveChas
(
ChaMchFuniP
) const;

335 
	gme
<
bo
 
isSclCha
(
UCh
)> bo 
isASclChas
() const;

339 
WTF_EXPORT_STRING_API
 
Sg
 
fdCa
() const;

341 
WTF_EXPORT_STRING_API
 
Sg
 
fm
(cڡ *, ...
WTF_ATTRIBUTE_PRINTF
(1, 2);

346 
Sg
 
Unlized
(
ngth
, 
UCh
*& 
da
{  
	gSgIm
::createUninitialized(length, data); }

347 
Sg
 
Unlized
(
ngth
, 
LCh
*& 
da
{  
	gSgIm
::createUninitialized(length, data); }

349 
WTF_EXPORT_STRING_API
 
l
(cڡ 
Sg
& 
t
, 
bo
 
lowEmyErs
, 
Ve
<Sg>& 
su
) const;

350 
l
(cڡ 
Sg
& 
t
, 
Ve
<Sg>& 
su
) const

352 
l
(
t
, 
l
, 
su
);

354 
WTF_EXPORT_STRING_API
 
l
(
UCh
 
t
, 
bo
 
lowEmyErs
, 
Ve
<
Sg
>& 
su
) const;

355 
l
(
UCh
 
t
, 
Ve
<
Sg
>& 
su
) const

357 
l
(
t
, 
l
, 
su
);

360 
WTF_EXPORT_STRING_API
 
toISi
(
bo
* 
ok
 = 0, 
ba
 = 10) const;

361 
WTF_EXPORT_STRING_API
 
toUISi
(
bo
* 
ok
 = 0, 
ba
 = 10) const;

362 
WTF_EXPORT_STRING_API
 
t64_t
 
toI64Si
(
bo
* 
ok
 = 0, 
ba
 = 10) const;

363 
WTF_EXPORT_STRING_API
 
ut64_t
 
toUI64Si
(
bo
* 
ok
 = 0, 
ba
 = 10) const;

364 
WTF_EXPORT_STRING_API
 
_t
 
toIPSi
(
bo
* 
ok
 = 0, 
ba
 = 10) const;

366 
WTF_EXPORT_STRING_API
 
toI
(
bo
* 
ok
 = 0) const;

367 
WTF_EXPORT_STRING_API
 
toUI
(
bo
* 
ok
 = 0) const;

368 
WTF_EXPORT_STRING_API
 
t64_t
 
toI64
(
bo
* 
ok
 = 0) const;

369 
WTF_EXPORT_STRING_API
 
ut64_t
 
toUI64
(
bo
* 
ok
 = 0) const;

370 
WTF_EXPORT_STRING_API
 
_t
 
toIP
(
bo
* 
ok
 = 0) const;

375 
WTF_EXPORT_STRING_API
 
toDoub
(
bo
* 
ok
 = 0) const;

376 
WTF_EXPORT_STRING_API
 
toFlt
(
bo
* 
ok
 = 0) const;

378 
bo
 
rage
(&ercentage) const;

380 #i
COMPILER_SUPPORTS
(
CXX_REFERENCE_QUALIFIED_FUNCTIONS
)

381 
WTF_EXPORT_STRING_API
 
Sg
 
isީedCy
() const &;

382 
WTF_EXPORT_STRING_API
 
Sg
 
isީedCy
() &&;

384 
WTF_EXPORT_STRING_API
 
Sg
 
isީedCy
() const;

387 
WTF_EXPORT_STRING_API
 
bo
 
isSaToSdToAnhThad
() const;

391 
	gImicCvsiFromWTFSgToBoDiowedA
* (
	tSg
::*
	tUnecifdBoTyA
);

392 
	gImicCvsiFromWTFSgToBoDiowedB
* (
	tSg
::*
	tUnecifdBoTyB
);

393 
ݔ
 
UnecifdBoTyA
() const;

394 
ݔ
 
UnecifdBoTyB
() const;

396 #i
USE
(
CF
)

397 
WTF_EXPORT_STRING_API
 
Sg
(
CFSgRef
);

398 
WTF_EXPORT_STRING_API
 
	gRaP
<
	gCFSgRef
> 
CFSg
() const;

401 #ifde
__OBJC__


402 
WTF_EXPORT_STRING_API
 
Sg
(
NSSg
*);

406 
ݔ
 
	gNSSg
*(cڡ { i(!
	gm_im
)  @"";  *m_impl; }

409 
WTF_EXPORT_STRING_API
 
Sg
 
make8BFrom16BSour
(cڡ 
UCh
*, 
size_t
);

410 
	gme
<
size_t
 
	gleCacy
>

411 
Sg
 
make8BFrom16BSour
(cڡ 
Ve
<
UCh
, 
leCacy
>& 
bufr
)

413  
make8BFrom16BSour
(
bufr
.
da
(), bufr.
size
());

416 
WTF_EXPORT_STRING_API
 
Sg
 
make16BFrom8BSour
(cڡ 
LCh
*, 
size_t
);

420 
WTF_EXPORT_STRING_API
 
Sg
 
omUTF8
(cڡ 
LCh
*, 
size_t
);

421 
WTF_EXPORT_STRING_API
 
Sg
 
omUTF8
(cڡ 
LCh
*);

422 
Sg
 
omUTF8
(cڡ * 
s
, 
size_t
 
ngth
{  fromUTF8(
t_
<cڡ 
LCh
*>(s),ength); };

423 
Sg
 
omUTF8
(cڡ * 
s
{  fromUTF8(
t_
<cڡ 
LCh
*>(s)); };

424 
WTF_EXPORT_STRING_API
 
Sg
 
omUTF8
(cڡ 
CSg
&);

427 
WTF_EXPORT_STRING_API
 
Sg
 
omUTF8WhL1Flback
(cڡ 
LCh
*, 
size_t
);

428 
Sg
 
omUTF8WhL1Flback
(cڡ * 
s
, 
size_t
 
ngth
{  fromUTF8WhL1Flback(
t_
<cڡ 
LCh
*>(s),ength); };

431 
UChDei
 
deuWrgDei
(
bo
* 
hasSgDeiڮy
 = 
nuαr
) const

433 i(
m_im
)

434  
m_im
->
deuWrgDei
(
hasSgDeiڮy
);

435 i(
	ghasSgDeiڮy
)

436 *
	ghasSgDeiڮy
 = 
l
;

437  
	gU_LEFT_TO_RIGHT
;

440 
bo
 
cڏsOyASCII
() const;

441 
bo
 
cڏsOyL1
() const;

442 
bo
 
cڏsOyWhea
(cڡ {  !
	gm_im
 || m_impl->containsOnlyWhitespace(); }

445 
Sg
(
WTF
::
HashTabDedVueTy
: 
m_im
(WTF::
HashTabDedVue
) { }

446 
bo
 
isHashTabDedVue
(cڡ {  
m_im
.isHashTableDeletedValue(); }

448 #ide
NDEBUG


449 
WTF_EXPORT_STRING_API
 
show
() const;

453 
UCh
 
chaAt
(
dex
) const

455 i(!
	gm_im
 || 
	gdex
 >
m_im
->
ngth
())

457  (*
	gm_im
)[
dex
];

460 
	give
:

461 
me
 <
tyme
 
ChaTy
>

462 
moveIl
(cڡ 
ChaTy
*, , );

464 
	gme
 <
tyme
 
	gChaTy
>

465 
ndIl
(
ChaTy
);

467 
	gRefP
<
	gSgIm
> 
	gm_im
;

470 
le
 
bo
 
	gݔ
==(cڡ 
Sg
& 
a
, cڡ 
	gSg
& 
	gb
{  
equ
.
im
(), 
b
.impl()); }

471 
le
 
bo
 
	gݔ
==(cڡ 
Sg
& 
a
, cڡ 
LCh
* 
	gb
{  
equ
.
im
(), 
b
); }

472 
le
 
bo
 
	gݔ
==(cڡ 
Sg
& 
a
, cڡ * 
	gb
{  
equ
.
im
(), 
t_
<cڡ 
LCh
*>(
b
)); }

473 
le
 
bo
 
	gݔ
==(cڡ 
LCh
* 
a
, cڡ 
	gSg
& 
	gb
{  
equ
, 
b
.
im
()); }

474 
le
 
bo
 
	gݔ
==(cڡ * 
a
, cڡ 
	gSg
& 
	gb
{  
equ
(
t_
<cڡ 
LCh
*>), 
b
.
im
()); }

475 
	gme
<
size_t
 
	gleCacy
>

476 
le
 
bo
 
	gݔ
==(cڡ 
Ve
<, 
	gleCacy
>& 
	ga
, cڡ 
	gSg
& 
	gb
{  
equ
(
b
.
im
(), 
a
.
da
(),.
size
()); }

477 
	gme
<
size_t
 
	gleCacy
>

478 
le
 
bo
 
	gݔ
==(cڡ 
Sg
& 
a
, cڡ 
	gVe
<, 
	gleCacy
>& 
	gb
) {  b ==; }

481 
le
 
bo
 
	gݔ
!=(cڡ 
Sg
& 
a
, cڡ 
	gSg
& 
	gb
{  !
equ
.
im
(), 
b
.impl()); }

482 
le
 
bo
 
	gݔ
!=(cڡ 
Sg
& 
a
, cڡ 
LCh
* 
	gb
{  !
equ
.
im
(), 
b
); }

483 
le
 
bo
 
	gݔ
!=(cڡ 
Sg
& 
a
, cڡ * 
	gb
{  !
equ
.
im
(), 
t_
<cڡ 
LCh
*>(
b
)); }

484 
le
 
bo
 
	gݔ
!=(cڡ 
LCh
* 
a
, cڡ 
	gSg
& 
	gb
{  !
equ
, 
b
.
im
()); }

485 
le
 
bo
 
	gݔ
!=(cڡ * 
a
, cڡ 
	gSg
& 
	gb
{  !
equ
(
t_
<cڡ 
LCh
*>), 
b
.
im
()); }

486 
	gme
<
size_t
 
	gleCacy
>

487 
le
 
bo
 
	gݔ
!=(cڡ 
Ve
<, 
	gleCacy
>& 
	ga
, cڡ 
	gSg
& 
	gb
{  ! =
b
); }

488 
	gme
<
size_t
 
	gleCacy
>

489 
le
 
bo
 
	gݔ
!=(cڡ 
Sg
& 
a
, cڡ 
	gVe
<, 
	gleCacy
>& 
	gb
) {  b !=; }

491 
le
 
bo
 
	$equIgnܚgCa
(cڡ 
Sg
& 
a
, cڡ Sg& 
b
{  
	`equIgnܚgCa
.
	`im
(), b.im()); 
	}
}

492 
le
 
bo
 
	$equIgnܚgCa
(cڡ 
Sg
& 
a
, cڡ 
LCh
* 
b
{  
	`equIgnܚgCa
.
	`im
(), b); 
	}
}

493 
le
 
bo
 
	$equIgnܚgCa
(cڡ 
Sg
& 
a
, cڡ * 
b
{  
	`equIgnܚgCa
.
	`im
(), 
t_
<cڡ 
LCh
*>(b)); 
	}
}

494 
le
 
bo
 
	$equIgnܚgCa
(cڡ 
LCh
* 
a
, cڡ 
Sg
& 
b
{  
	`equIgnܚgCa
, b.
	`im
()); 
	}
}

495 
le
 
bo
 
	$equIgnܚgCa
(cڡ * 
a
, cڡ 
Sg
& 
b
{  
	`equIgnܚgCa
(
t_
<cڡ 
LCh
*>), b.
	`im
()); 
	}
}

497 
le
 
bo
 
	$equPossiblyIgnܚgCa
(cڡ 
Sg
& 
a
, cڡ Sg& 
b
, 
bo
 
igneCa
)

499  
igneCa
 ? 
	`equIgnܚgCa
(
a
, 
b
) : (a == b);

500 
	}
}

502 
le
 
bo
 
	$equIgnܚgNuΙy
(cڡ 
Sg
& 
a
, cڡ Sg& 
b
{  
	`equIgnܚgNuΙy
.
	`im
(), b.im()); 
	}
}

504 
	gme
<
size_t
 
	gleCacy
>

505 
le
 
bo
 
equIgnܚgNuΙy
(cڡ 
Ve
<
UCh
, 
leCacy
>& 
a
, cڡ 
Sg
& 
b
{ quIgnܚgNuΙy, b.
im
()); }

507 
le
 
bo
 
	gݔ
!(cڡ 
	gSg
& 
	gr
{  s.
isNu
(); }

509 
le
 
	$sw
(
Sg
& 
a
, Sg& 
b
{.
	`sw
(b); 
	}
}

513 
	gme
<
size_t
 
	gleCacy
, 
tyme
 
	gOvowHdr
>

514 
	gSg
::
Sg
(cڡ 
Ve
<
UCh
, 
leCacy
, 
OvowHdr
>& 
ve
)

515 : 
m_im
(
ve
.
size
(? 
SgIm
::

(ve.
da
(), ve.
	$size
(): *
SgIm
::
	$emy
())

517 
	}
}

519 
me
<>

520 
le
 cڡ 
LCh
* 
Sg
::
chas
<LChar>() const

522 
ASSERT
(
is8B
());

523  
chas8
();

526 
	gme
<>

527 
le
 cڡ 
UCh
* 
	gSg
::
chas
<UChar>() const

529 
ASSERT
(!
is8B
());

530  
chas16
();

533 
le
 
bo
 
	gSg
::
	$cڏsOyL1
() const

535 i(
	`isEmy
())

536  
ue
;

538 i(
	`is8B
())

539  
ue
;

541 cڡ 
UCh
* 
chas
 = 
	`chas16
();

542 
UCh
 
ed
 = 0;

543 
size_t
 
i
 = 0; i < 
m_im
->
	`ngth
(); ++i)

544 
ed
 |
chas
[
i
];

545  !(
ed
 & 0xFF00);

546 
	}
}

549 #ifde
__OBJC__


553 
le
 
NSSg
* 
	$nsSgNIfEmy
(cڡ 
Sg
& 
r
{  s.
	`isEmy
(? 
n
 : (
NSSg
*)r; 
	}
}

556 
le
 
bo
 
	gSg
::
	$cڏsOyASCII
() const

558 i(
	`isEmy
())

559  
ue
;

561 i(
	`is8B
())

562  
	`chasAAASCII
(
	`chas8
(), 
m_im
->
	`ngth
());

564  
	`chasAAASCII
(
	`chas16
(), 
m_im
->
	`ngth
());

565 
	}
}

567 
WTF_EXPORT_STRING_API
 
codePotCom
(cڡ 
Sg
&, const String&);

569 
le
 
bo
 
	$codePotComLessTh
(cڡ 
Sg
& 
a
, cڡ Sg& 
b
)

571  
	`codePotCom
(
a
.
	`im
(), 
b
.impl()) < 0;

572 
	}
}

574 
	gme
<
tyme
 
	gChaTy
>

575 
le
 
ndNumb
(
Ve
<
ChaTy
>& 
ve
, 
numb
)

577 
	gnumbLgth
 = 
numb
 > 99 ? 3 : (number > 9 ? 2 : 1);

578 
size_t
 
	gveSize
 = 
ve
.
size
();

579 
	gve
.
grow
(
veSize
 + 
numbLgth
);

581 
	gnumbLgth
) {

583 
ve
[
veSize
 + 2] = 
numb
 % 10 + '0';

584 
	gnumb
 /= 10;

585 
	gFALLTHROUGH
;

588 
ve
[
veSize
 + 1] = 
numb
 % 10 + '0';

589 
	gnumb
 /= 10;

590 
	gFALLTHROUGH
;

593 
ve
[
veSize
] = 
numb
 % 10 + '0';

597 
	gme
<
bo
 
isSclCha
(
UCh
), 
tyme
 
	gChaTy
>

598 
le
 
bo
 
	$isASclChas
(cڡ 
ChaTy
* 
chas
, 
size_t
 
ngth
)

600 
size_t
 
i
 = 0; i < 
ngth
; ++i) {

601 i(!
	`isSclCha
(
chas
[
i
]))

602  
l
;

604  
ue
;

605 
	}
}

607 
	gme
<
bo
 
isSclCha
(
UCh
)>

608 
le
 
bo
 
	gSg
::
	$isASclChas
() const

610 
size_t
 
n
 = 
	`ngth
();

612 i(!
n
)

613  
ue
;

615 i(
	`is8B
())

616  
WTF
::
isASclChas
<
isSclCha
, 
LCh
>(
	`chas8
(), 
n
);

617  
WTF
::
isASclChas
<
isSclCha
, 
UCh
>(
	`chas16
(), 
n
);

618 
	}
}

621 
	gme
<
tyme
 
	gT
> 
	gDeuHash
;

622 
	gme
<> 
	gDeuHash
<
	gSg
> {

623 
SgHash
 
	tHash
;

626 
	gme
 <> 
	gVeTs
<
	gSg
> : 
SimeCssVeTs
 { };

628 as
	cASCIIL
 {

629 
	gpublic
:

630 
exic
 
ASCIIL
(cڡ * 
chas
: 
m_chas
(characters) { }

631 
ݔ
 cڡ *({  
m_chas
; }

633 
	give
:

634 cڡ * 
m_chas
;

638 
WTF_EXPORT_STRING_API
 cڡ 
	gSg
& 
emySg
();

642 
usg
 
	gWTF
::
CSg
;

643 
usg
 
	gWTF
::
KpTgZos
;

644 
usg
 
	gWTF
::
Sg
;

645 
usg
 
	gWTF
::
emySg
;

646 
usg
 
	gWTF
::
ndNumb
;

647 
usg
 
	gWTF
::
chasAAASCII
;

648 
usg
 
	gWTF
::
chasToISi
;

649 
usg
 
	gWTF
::
chasToUISi
;

650 
usg
 
	gWTF
::
chasToI64Si
;

651 
usg
 
	gWTF
::
chasToUI64Si
;

652 
usg
 
	gWTF
::
chasToIPSi
;

653 
usg
 
	gWTF
::
chasToI
;

654 
usg
 
	gWTF
::
chasToUI
;

655 
usg
 
	gWTF
::
chasToI64
;

656 
usg
 
	gWTF
::
chasToUI64
;

657 
usg
 
	gWTF
::
chasToIP
;

658 
usg
 
	gWTF
::
chasToDoub
;

659 
usg
 
	gWTF
::
chasToFlt
;

660 
usg
 
	gWTF
::
equ
;

661 
usg
 
	gWTF
::
equIgnܚgCa
;

662 
usg
 
	gWTF
::
fd
;

663 
usg
 
	gWTF
::
isASclChas
;

664 
usg
 
	gWTF
::
isSOrNewle
;

665 
usg
 
	gWTF
::
vFd
;

666 
usg
 
	gWTF
::
ASCIIL
;

668 
	~<wtf/xt/AtomicSg.h
>

	@text/cf/AtomicStringCF.cpp

26 
	~"cfig.h
"

27 
	~<wtf/xt/AtomicSg.h
>

29 #i
USE
(
CF
)

31 
	~<CeFoundi/CeFoundi.h
>

32 
	~<wtf/xt/CSg.h
>

34 
mea
 
	gWTF
 {

36 
	gPassRefP
<
	gSgIm
> 
	gAtomicSg
::
add
(
CFSgRef
 
rg
)

38 i(!
rg
)

41 
CFIndex
 
	gngth
 = 
CFSgGLgth
(
rg
);

43 i(cڡ 
LCh
* 
	gr
 = 
t_
<cڡ LCh*>(
CFSgGCSgP
(
rg
, 
kCFSgEncodgISOL1
)))

44  
add
(
r
, 
ngth
);

46 i(cڡ 
UniCh
* 
	gr
 = 
CFSgGChasP
(
rg
))

47  
add
(
t_
<cڡ 
UCh
*>(
r
), 
ngth
);

49 
	gVe
<
	gUniCh
, 1024> 
uchBufr
(
ngth
);

50 
CFSgGChas
(
rg
, 
CFRgeMake
(0, 
ngth
), 
uchBufr
.
da
());

51  
add
(
t_
<cڡ 
UCh
*>(
uchBufr
.
da
()), 
ngth
);

	@text/cf/StringCF.cpp

21 
	~"cfig.h
"

22 
	~<wtf/xt/WTFSg.h
>

24 #i
USE
(
CF
)

26 
	~<CeFoundi/CeFoundi.h
>

27 
	~<wtf/RaP.h
>

29 
mea
 
	gWTF
 {

31 
	gSg
::
Sg
(
CFSgRef
 
r
)

33 i(!
r
)

36 
CFIndex
 
	gsize
 = 
CFSgGLgth
(
r
);

37 i(
	gsize
 == 0)

38 
m_im
 = 
SgIm
::
emy
();

40 
	gVe
<
	gLCh
, 1024> 
lchBufr
(
size
);

41 
CFIndex
 
	gudBufL
;

42 
CFIndex
 
	gcvdsize
 = 
CFSgGBys
(
r
, 
CFRgeMake
(0, 
size
), 
kCFSgEncodgISOL1
, 0, 
l
, 
lchBufr
.
da
(), size, &
udBufL
);

43 i((
	gcvdsize
 =
size
&& (
udBufL
 == size)) {

44 
m_im
 = 
SgIm
::

(
lchBufr
.
da
(), 
size
);

48 
	gVe
<
	gUCh
, 1024> 
bufr
(
size
);

49 
CFSgGChas
(
r
, 
CFRgeMake
(0, 
size
), (
UniCh
*)
bufr
.
da
());

50 
	gm_im
 = 
SgIm
::

(
bufr
.
da
(), 
size
);

54 
	gRaP
<
	gCFSgRef
> 
	gSg
::
CFSg
() const

56 i(!
m_im
)

57  
CFSTR
("");

59  
	gm_im
->
CFSg
();

	@text/cf/StringImplCF.cpp

21 
	~"cfig.h
"

22 
	~<wtf/xt/SgIm.h
>

24 #i
USE
(
CF
)

26 
	~<CeFoundi/CeFoundi.h
>

27 
	~<wtf/MaThad.h
>

28 
	~<wtf/PassRefP.h
>

29 
	~<wtf/RaP.h
>

30 
	~<wtf/Thadg.h
>

32 #i
PLATFORM
(
MAC
)

33 
	~<objc/objc-auto.h
>

36 
le
 
bo
 
	$gbageCiEbd
()

38 #i
	`PLATFORM
(
MAC
)

39  
	`objc_cgEbd
();

41  
l
;

43 
	}
}

45 
mea
 
	gWTF
 {

47 
mea
 
	gSgWCFAot
 {

49 
SgIm
* 
	gcutSg
;

51 cڡ * 

(cڡ * 
fo
)

53  
	gfo
;

56 
NO_RETURN_DUE_TO_ASSERT


57 
a
(const *)

59 
ASSERT_NOT_REACHED
();

62 
CFSgRef
 
cyDesti
(const *)

64  
CFSTR
("WTF::String-basedllocator");

67 * 
lo
(
CFIndex
 
size
, 
CFOiFgs
, *)

69 
SgIm
* 
	gundlygSg
 = 0;

70 i(
isMaThad
()) {

71 
	gundlygSg
 = 
cutSg
;

72 i(
	gundlygSg
) {

73 
	gcutSg
 = 0;

74 
	gundlygSg
->
f
();

77 
SgIm
** 
	ghd
 = 
ic_
<SgIm**>(
Mloc
((SgIm*+ 
size
));

78 *
	ghd
 = 
undlygSg
;

79  
	ghd
 + 1;

82 * 
lo
(* 
por
, 
CFIndex
 
wSize
, 
CFOiFgs
, *)

84 
size_t
 
	gwAotiSize
 = (
SgIm
*+ 
wSize
;

85 
SgIm
** 
	ghd
 = 
ic_
<SgIm**>(
por
) - 1;

86 
ASSERT
(!*
hd
);

87 
	ghd
 = 
ic_
<
SgIm
**>(
Roc
(
hd
, 
wAotiSize
));

88  
	ghd
 + 1;

91 
doOnMaThad
(* 
hdPor
)

93 
SgIm
** 
	ghd
 = 
ic_
<SgIm**>(
hdPor
);

94 
SgIm
* 
	gundlygSg
 = *
hd
;

95 
ASSERT
(
undlygSg
);

96 
	gundlygSg
->
def
();

97 
Fe
(
hd
);

100 
do
(* 
por
, *)

102 
SgIm
** 
	ghd
 = 
ic_
<SgIm**>(
por
) - 1;

103 
SgIm
* 
	gundlygSg
 = *
hd
;

104 i(!
	gundlygSg
)

105 
Fe
(
hd
);

107 i(!
isMaThad
())

108 
OnMaThad
(
doOnMaThad
, 
hd
);

110 
	gundlygSg
->
def
();

111 
Fe
(
hd
);

116 
CFIndex
 
eedSize
(CFIndex 
size
, 
CFOiFgs
, *)

123  
	gsize
;

126 
CFAotRef
 

()

128 
ASSERT
(!
gbageCiEbd
());

129 
CFAotCڋxt
 
	gcڋxt
 = { 0, 0, 

, 
a
, 
cyDesti
, 
lo
, 
lo
, 
do
, 
eedSize
 };

130  
CFAotCe
(0, &
cڋxt
);

133 
CFAotRef
 
lot
()

135 
CFAotRef
 
	glot
 = 

();

136  
	glot
;

141 
	gRaP
<
	gCFSgRef
> 
	gSgIm
::
CFSg
()

145 i(!
m_ngth
 || !
isMaThad
(|| 
gbageCiEbd
()) {

146 i(
is8B
())

147  
adtCF
(
CFSgCeWhBys
(0, 
t_
<cڡ 
UI8
*>(
chas8
()), 
m_ngth
, 
kCFSgEncodgISOL1
, 
l
));

148  
adtCF
(
CFSgCeWhChas
(0, 
t_
<cڡ 
UniCh
*>(
chas16
()), 
m_ngth
));

150 
CFAotRef
 
	glot
 = 
SgWCFAot
::
lot
();

153 
ASSERT
(!
SgWCFAot
::
cutSg
);

154 
	gSgWCFAot
::
cutSg
 = 
this
;

156 
CFSgRef
 
	grg
;

157 i(
is8B
())

158 
	grg
 = 
CFSgCeWhBysNoCy
(
lot
, 
t_
<cڡ 
UI8
*>(
chas8
()), 
m_ngth
, 
kCFSgEncodgISOL1
, 
l
, 
kCFAotNu
);

160 
	grg
 = 
CFSgCeWhChasNoCy
(
lot
, 
t_
<cڡ 
UniCh
*>(
chas16
()), 
m_ngth
, 
kCFAotNu
);

162 
	gSgWCFAot
::
cutSg
 = 0;

164  
adtCF
(
rg
);

	@text/cf/StringViewCF.cpp

26 
	~"cfig.h
"

27 
	~<wtf/xt/SgVw.h
>

29 #i
USE
(
CF
)

31 
	~<CeFoundi/CeFoundi.h
>

32 
	~<wtf/RaP.h
>

34 
mea
 
	gWTF
 {

36 
	gRaP
<
	gCFSgRef
> 
	gSgVw
::
CFSgWhoutCyg
() const

38 i(
is8B
())

39  
adtCF
(
CFSgCeWhBysNoCy
(
kCFAotDeu
, 
chas8
(), 
ngth
(), 
kCFSgEncodgISOL1
, 
l
, 
kCFAotNu
));

41  
adtCF
(
CFSgCeWhChasNoCy
(
kCFAotDeu
, 
t_
<cڡ 
UniCh
*>(
chas16
()), 
ngth
(), 
kCFAotNu
));

	@threads/BinarySemaphore.cpp

26 
	~"cfig.h
"

27 
	~"BySemhe.h
"

29 #i!
PLATFORM
(
WIN
)

31 
mea
 
	gWTF
 {

33 
	gBySemhe
::
BySemhe
()

34 : 
m_isS
(
l
)

38 
BySemhe
::~BinarySemaphore()

42 
BySemhe
::
sigl
()

44 
MuxLock
 
lock
(
m_mux
);

46 
	gm_isS
 = 
ue
;

47 
	gm_cdi
.
sigl
();

50 
bo
 
	gBySemhe
::
wa
(
absuTime
)

52 
MuxLock
 
lock
(
m_mux
);

54 
bo
 
	gtimedOut
 = 
l
;

55 !
	gm_isS
) {

56 
	gtimedOut
 = !
m_cdi
.
timedWa
(
m_mux
, 
absuTime
);

57 i(
	gtimedOut
)

58  
	gl
;

62 
	gm_isS
 = 
l
;

63  
	gue
;

	@threads/BinarySemaphore.h

26 #ide
BySemhe_h


27 
	#BySemhe_h


	)

29 
	~<wtf/Ncyab.h
>

30 
	~<wtf/ThadgPrimives.h
>

32 
mea
 
	gWTF
 {

34 as
	cBySemhe
 {

35 
WTF_MAKE_NONCOPYABLE
(
BySemhe
);

37 
	gpublic
:

38 
WTF_EXPORT_PRIVATE
 
BySemhe
();

39 
	gWTF_EXPORT_PRIVATE
 ~
BySemhe
();

41 
WTF_EXPORT_PRIVATE
 
sigl
();

42 
WTF_EXPORT_PRIVATE
 
bo
 
wa
(
absuTime
);

44 #i
OS
(
WINDOWS
)

45 
HANDLE
 
evt
(cڡ {  
	gm_evt
; }

48 
	give
:

49 #i
OS
(
WINDOWS
)

50 
HANDLE
 
m_evt
;

52 
bo
 
	gm_isS
;

54 
Mux
 
	gm_mux
;

55 
ThadCdi
 
	gm_cdi
;

61 
usg
 
	gWTF
::
BySemhe
;

	@threads/win/BinarySemaphoreWin.cpp

26 
	~"cfig.h
"

27 
	~"BySemhe.h
"

29 
mea
 
	gWTF
 {

31 
	gBySemhe
::
BySemhe
()

32 : 
m_evt
(::
CeEvtW
(0, 
FALSE
, FALSE, 0))

36 
	gBySemhe
::~
BySemhe
()

38 ::
CloHd
(
m_evt
);

41 
	gBySemhe
::
sigl
()

43 ::
SEvt
(
m_evt
);

46 
bo
 
	gBySemhe
::
wa
(
absuTime
)

48 
DWORD
 
rv
 = 
absuTimeToWaTimeoutIv
(
absuTime
);

49 i(!
	grv
) {

52  
	gl
;

55 
DWORD
 
	gsu
 = ::
WaFSgObje
(
m_evt
, 
rv
);

56 
	gsu
) {

57 
	gWAIT_OBJECT_0
:

59  
ue
;

61 
	gWAIT_TIMEOUT
:

63  
l
;

65 
	gWAIT_FAILED
:

66 
ASSERT_WITH_MESSAGE
(
l
, "::WaFSgObje faed wh %lu", ::
GLaE
());

67  
	gl
;

70 
ASSERT_WITH_MESSAGE
(
l
, "::WaFSgObjeued uxedesu %lu", 
su
);

71  
	gl
;

	@unicode/CharacterNames.h

26 #ide
ChaNames_h


27 
	#ChaNames_h


	)

29 
	~<unicode/utys.h
>

31 
mea
 
	gWTF
 {

32 
mea
 
	gUnicode
 {

39 cڡ 
UCh
 
	gALogo
 = 0xF8FF;

40 cڡ 
UCh32
 
	ggnWdSLe
 = 0x10100;

41 cڡ 
UCh32
 
	ggnWdSD
 = 0x10101;

42 cڡ 
UCh
 
	gorhe
 = 0x0027;

43 cڡ 
UCh
 
	gbckCe
 = 0x25CF;

44 cڡ 
UCh
 
	gbckSque
 = 0x25A0;

45 cڡ 
UCh
 
	gbckUpPotgTrng
 = 0x25B2;

46 cڡ 
UCh
 
	gbuΑ
 = 0x2022;

47 cڡ 
UCh
 
	gbuΣye
 = 0x25CE;

48 cڡ 
UCh
 
	ggeRu
 = 0x000D;

49 cڡ 
UCh
 
	ghiicPC
 = 0x1366;

50 cڡ 
UCh
 
	ghiicWda
 = 0x1361;

51 cڡ 
UCh
 
	gfisheye
 = 0x25C9;

52 cڡ 
UCh
 
	gqu٩iMk
 = 0x0022;

53 cڡ 
UCh
 
	ghebwPunuiGesh
 = 0x05F3;

54 cڡ 
UCh
 
	ghebwPunuiGshayim
 = 0x05F4;

55 cڡ 
UCh
 
	gHagaLrSmlA
 = 0x3041;

56 cڡ 
UCh
 
	ghizڏlEΝsis
 = 0x2026;

57 cڡ 
UCh
 
	ghyph
 = 0x2010;

58 cڡ 
UCh
 
	ghyphMus
 = 0x002D;

59 cڡ 
UCh
 
	gideogphicComma
 = 0x3001;

60 cڡ 
UCh
 
	gideogphicFuSt
 = 0x3002;

61 cڡ 
UCh
 
	gideogphicS
 = 0x3000;

62 cڡ 
UCh
 
	gDoubQu٩iMk
 = 0x201C;

63 cڡ 
UCh
 
	gSgQu٩iMk
 = 0x2018;

64 cڡ 
UCh
 
	gToRightEmbed
 = 0x202A;

65 cڡ 
UCh
 
	gToRightMk
 = 0x200E;

66 cڡ 
UCh
 
	gToRightOvride
 = 0x202D;

67 cڡ 
UCh
 
	gmusSign
 = 0x2212;

68 cڡ 
UCh
 
	gwleCha
 = 0x000A;

69 cڡ 
UCh
 
	gnoBakS
 = 0x00A0;

70 cڡ 
UCh
 
	gobjeRmtCha
 = 0xFFFC;

71 cڡ 
UCh
 
	gpDeiڮFmtg
 = 0x202C;

72 cڡ 
UCh
 
	gamtCha
 = 0xFFFD;

73 cڡ 
UCh
 
	grightDoubQu٩iMk
 = 0x201D;

74 cڡ 
UCh
 
	grightSgQu٩iMk
 = 0x2019;

75 cڡ 
UCh
 
	grightToLeEmbed
 = 0x202B;

76 cڡ 
UCh
 
	grightToLeMk
 = 0x200F;

77 cڡ 
UCh
 
	grightToLeOvride
 = 0x202E;

78 cڡ 
UCh
 
	gmeD
 = 0xFE45;

79 cڡ 
UCh
 
	gsmlLrShpS
 = 0x00DF;

80 cڡ 
UCh
 
	gsoHyph
 = 0x00AD;

81 cڡ 
UCh
 
	ga
 = 0x0020;

82 cڡ 
UCh
 
	gtibMkIsyabicTsheg
 = 0x0F0B;

83 cڡ 
UCh
 
	gtibMkDimTshegB
 = 0x0F0C;

84 cڡ 
UCh32
 
	gugicWdDivid
 = 0x1039F;

85 cڡ 
UCh
 
	gwheBuΑ
 = 0x25E6;

86 cڡ 
UCh
 
	gwheCe
 = 0x25CB;

87 cڡ 
UCh
 
	gwheSemeD
 = 0xFE46;

88 cڡ 
UCh
 
	gwheUpPotgTrng
 = 0x25B3;

89 cڡ 
UCh
 
	gySign
 = 0x00A5;

90 cڡ 
UCh
 
	gzoWidthJo
 = 0x200D;

91 cڡ 
UCh
 
	gzoWidthNJo
 = 0x200C;

92 cڡ 
UCh
 
	gzoWidthS
 = 0x200B;

93 cڡ 
UCh
 
	gzoWidthNoBakS
 = 0xFEFF;

98 
usg
 
	gWTF
::
Unicode
::
ALogo
;

99 
usg
 
	gWTF
::
Unicode
::
gnWdSLe
;

100 
usg
 
	gWTF
::
Unicode
::
gnWdSD
;

101 
usg
 
	gWTF
::
Unicode
::
bckCe
;

102 
usg
 
	gWTF
::
Unicode
::
bckSque
;

103 
usg
 
	gWTF
::
Unicode
::
bckUpPotgTrng
;

104 
usg
 
	gWTF
::
Unicode
::
buΑ
;

105 
usg
 
	gWTF
::
Unicode
::
buΣye
;

106 
usg
 
	gWTF
::
Unicode
::
geRu
;

107 
usg
 
	gWTF
::
Unicode
::
hiicPC
;

108 
usg
 
	gWTF
::
Unicode
::
hiicWda
;

109 
usg
 
	gWTF
::
Unicode
::
fisheye
;

110 
usg
 
	gWTF
::
Unicode
::
hebwPunuiGesh
;

111 
usg
 
	gWTF
::
Unicode
::
hebwPunuiGshayim
;

112 
usg
 
	gWTF
::
Unicode
::
HagaLrSmlA
;

113 
usg
 
	gWTF
::
Unicode
::
hizڏlEΝsis
;

114 
usg
 
	gWTF
::
Unicode
::
hyph
;

115 
usg
 
	gWTF
::
Unicode
::
hyphMus
;

116 
usg
 
	gWTF
::
Unicode
::
ideogphicComma
;

117 
usg
 
	gWTF
::
Unicode
::
ideogphicFuSt
;

118 
usg
 
	gWTF
::
Unicode
::
ideogphicS
;

119 
usg
 
	gWTF
::
Unicode
::
DoubQu٩iMk
;

120 
usg
 
	gWTF
::
Unicode
::
SgQu٩iMk
;

121 
usg
 
	gWTF
::
Unicode
::
ToRightEmbed
;

122 
usg
 
	gWTF
::
Unicode
::
ToRightMk
;

123 
usg
 
	gWTF
::
Unicode
::
ToRightOvride
;

124 
usg
 
	gWTF
::
Unicode
::
musSign
;

125 
usg
 
	gWTF
::
Unicode
::
wleCha
;

126 
usg
 
	gWTF
::
Unicode
::
noBakS
;

127 
usg
 
	gWTF
::
Unicode
::
objeRmtCha
;

128 
usg
 
	gWTF
::
Unicode
::
pDeiڮFmtg
;

129 
usg
 
	gWTF
::
Unicode
::
amtCha
;

130 
usg
 
	gWTF
::
Unicode
::
rightDoubQu٩iMk
;

131 
usg
 
	gWTF
::
Unicode
::
rightSgQu٩iMk
;

132 
usg
 
	gWTF
::
Unicode
::
rightToLeEmbed
;

133 
usg
 
	gWTF
::
Unicode
::
rightToLeMk
;

134 
usg
 
	gWTF
::
Unicode
::
rightToLeOvride
;

135 
usg
 
	gWTF
::
Unicode
::
meD
;

136 
usg
 
	gWTF
::
Unicode
::
soHyph
;

137 
usg
 
	gWTF
::
Unicode
::
a
;

138 
usg
 
	gWTF
::
Unicode
::
tibMkIsyabicTsheg
;

139 
usg
 
	gWTF
::
Unicode
::
tibMkDimTshegB
;

140 
usg
 
	gWTF
::
Unicode
::
ugicWdDivid
;

141 
usg
 
	gWTF
::
Unicode
::
wheBuΑ
;

142 
usg
 
	gWTF
::
Unicode
::
wheCe
;

143 
usg
 
	gWTF
::
Unicode
::
wheSemeD
;

144 
usg
 
	gWTF
::
Unicode
::
wheUpPotgTrng
;

145 
usg
 
	gWTF
::
Unicode
::
ySign
;

146 
usg
 
	gWTF
::
Unicode
::
zoWidthJo
;

147 
usg
 
	gWTF
::
Unicode
::
zoWidthNJo
;

148 
usg
 
	gWTF
::
Unicode
::
zoWidthS
;

149 
usg
 
	gWTF
::
Unicode
::
zoWidthNoBakS
;

	@unicode/Collator.h

29 #ide
WTF_Ct_h


30 
	#WTF_Ct_h


	)

32 
	~<unicode/ucfig.h
>

33 
	~<wtf/Ncyab.h
>

35 
	gUCt
;

37 
mea
 
	gWTF
 {

39 
ass
 
	gSgVw
;

41 #i
UCONFIG_NO_COLLATION


43 as
	cCt
 {

44 
	gpublic
:

45 
exic
 
Ct
(cڡ * = 
nuαr
, 
bo
 = 
l
) { }

47 
WTF_EXPORT_PRIVATE
 
cϋ
(
SgVw
, StringView);

48 
WTF_EXPORT_PRIVATE
 
cϋUTF8
(const *, const *);

53 as
	cCt
 {

54 
WTF_MAKE_NONCOPYABLE
(
Ct
);

55 
	gpublic
:

58 
WTF_EXPORT_PRIVATE
 
exic
 
Ct
(cڡ * 
lo
 = 
nuαr
, 
bo
 
shouldStLowF
 = 
l
);

59 
	gWTF_EXPORT_PRIVATE
 ~
Ct
();

61 
WTF_EXPORT_PRIVATE
 
cϋ
(
SgVw
, StringView) const;

62 
WTF_EXPORT_PRIVATE
 
cϋUTF8
(const *, const *) const;

64 
	give
:

65 * 
m_lo
;

66 
bo
 
	gm_shouldStLowF
;

67 
UCt
* 
	gm_ct
;

74 
usg
 
	gWTF
::
Ct
;

	@unicode/CollatorDefault.cpp

29 
	~"cfig.h
"

30 
	~"Ct.h
"

32 #i
UCONFIG_NO_COLLATION


34 
mea
 
	gWTF
 {

36 
	gCt
::
cϋ
(
SgVw
 
a
, SgVw 
b
) const

38 
	gcommLgth
 = 
d
::
m
(
a
.
ngth
(), 
b
.length());

39 
	gi
 = 0; i < 
	gcommLgth
; ++i) {

40 i(
	ga
[
i
] < 
	gb
[i])

42 i(
	ga
[
i
] > 
	gb
[i])

46 i(
	ga
.
ngth
(< 
	gb
.length())

48 i(
	ga
.
ngth
(> 
	gb
.length())

54 
	gCt
::
cϋUTF8
(cڡ * 
a
, cڡ * 
b
) const

56  
cϋ
(
Sg
::
omUTF8
(
a
), Sg::omUTF8(
b
));

	@unicode/UTF8.cpp

27 
	~"cfig.h
"

28 
	~"UTF8.h
"

30 
	~"ASCIICTy.h
"

31 
	~<wtf/SgHash.h
>

32 
	~<wtf/unicode/ChaNames.h
>

34 
mea
 
	gWTF
 {

35 
mea
 
	gUnicode
 {

37 
le
 
leUTF8SequLgthNASCII
(
b0
)

39 i((
	gb0
 & 0xC0) != 0xC0)

41 i((
	gb0
 & 0xE0) == 0xC0)

43 i((
	gb0
 & 0xF0) == 0xE0)

45 i((
	gb0
 & 0xF8) == 0xF0)

50 
le
 
leUTF8SequLgth
(
b0
)

52  
isASCII
(
b0
? 1 : 
leUTF8SequLgthNASCII
(b0);

55 
UTF8SequLgth
(
b0
)

57  
isASCII
(
b0
? 1 : 
leUTF8SequLgthNASCII
(b0);

60 
decodeUTF8Sequ
(cڡ * 
qu
)

63 cڡ 
	gb0
 = 
qu
[0];

64 cڡ 
	gngth
 = 
leUTF8SequLgth
(
b0
);

65 i(
	gngth
 == 0)

69 cڡ 
	gb1
 = 
qu
[1];

70 i(
	gngth
 == 1) {

71 i(
b1
)

73  
	gb0
;

77 i((
	gb1
 & 0xC0) != 0x80)

79 cڡ 
	gb2
 = 
qu
[2];

80 i(
	gngth
 == 2) {

81 i(
b2
)

83 cڡ 
	gc
 = ((
b0
 & 0x1F<< 6| (
b1
 & 0x3F);

84 i(
	gc
 < 0x80)

86  
	gc
;

90 i((
	gb2
 & 0xC0) != 0x80)

92 cڡ 
	gb3
 = 
qu
[3];

93 i(
	gngth
 == 3) {

94 i(
b3
)

96 cڡ 
	gc
 = ((
b0
 & 0xF<< 12| ((
b1
 & 0x3F<< 6| (
b2
 & 0x3F);

97 i(
	gc
 < 0x800)

100 i(
	gc
 >0xD800 && 
c
 <= 0xDFFF)

102  
	gc
;

106 i((
	gb3
 & 0xC0) != 0x80)

108 cڡ 
	gb4
 = 
qu
[4];

109 i(
	gngth
 == 4) {

110 i(
b4
)

112 cڡ 
	gc
 = ((
b0
 & 0x7<< 18| ((
b1
 & 0x3F<< 12| ((
b2
 & 0x3F<< 6| (
b3
 & 0x3F);

113 i(
	gc
 < 0x10000 || c > 0x10FFFF)

115  
	gc
;

126 cڡ 
	gfByMk
[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };

128 
CvsiResu
 
cvtL1ToUTF8
(

129 cڡ 
LCh
** 
sourS
, cڡ LCh* 
sourEnd
,

130 ** 
rgS
, * 
rgEnd
)

132 
CvsiResu
 
	gsu
 = 
cvsiOK
;

133 cڡ 
LCh
* 
	gsour
 = *
sourS
;

134 * 
	grg
 = *
rgS
;

135 
	gsour
 < 
	gsourEnd
) {

136 
UCh32
 
	gch
;

137 
	gbysToWre
 = 0;

138 cڡ 
UCh32
 
	gbyMask
 = 0xBF;

139 cڡ 
UCh32
 
	gbyMk
 = 0x80;

140 cڡ 
LCh
* 
	gdSour
 = 
sour
;

141 
	gch
 = 
ic_
<>(*
sour
++);

144 i(
	gch
 < (
	gUCh32
)0x80)

145 
	gbysToWre
 = 1;

147 
	gbysToWre
 = 2;

149 
	grg
 +
bysToWre
;

150 i(
	grg
 > 
	grgEnd
) {

151 
	gsour
 = 
dSour
;

152 
	grg
 -
bysToWre
;

153 
	gsu
 = 
rgExhaued
;

156 
	gbysToWre
) {

158 *--
rg
 = ()((
ch
 | 
byMk
& 
byMask
);

159 
	gch
 >>= 6;

160 
	gFALLTHROUGH
;

162 *--
rg
 = ()(
ch
 | 
fByMk
[
bysToWre
]);

164 
	grg
 +
bysToWre
;

166 *
	gsourS
 = 
sour
;

167 *
	grgS
 = 
rg
;

168  
	gsu
;

171 
CvsiResu
 
cvtUTF16ToUTF8
(

172 cڡ 
UCh
** 
sourS
, cڡ UCh* 
sourEnd
,

173 ** 
rgS
, * 
rgEnd
, 
bo
 
ri
)

175 
CvsiResu
 
	gsu
 = 
cvsiOK
;

176 cڡ 
UCh
* 
	gsour
 = *
sourS
;

177 * 
	grg
 = *
rgS
;

178 
	gsour
 < 
	gsourEnd
) {

179 
UCh32
 
	gch
;

180 
	gbysToWre
 = 0;

181 cڡ 
UCh32
 
	gbyMask
 = 0xBF;

182 cڡ 
UCh32
 
	gbyMk
 = 0x80;

183 cڡ 
UCh
* 
	gdSour
 = 
sour
;

184 
	gch
 = 
ic_
<>(*
sour
++);

186 i(
	gch
 >0xD800 && 
ch
 <= 0xDBFF) {

188 i(
sour
 < 
sourEnd
) {

189 
UCh32
 
ch2
 = 
ic_
<>(*
sour
);

191 i(
	gch2
 >0xDC00 && 
ch2
 <= 0xDFFF) {

192 
ch
 = ((ch - 0xD800<< 10+ (
ch2
 - 0xDC00) + 0x0010000;

193 ++
	gsour
;

194 } i(
	gri
) {

195 --
	gsour
;

196 
	gsu
 = 
sourIeg
;

200 --
	gsour
;

201 
	gsu
 = 
sourExhaued
;

204 } i(
	gri
) {

206 i(
	gch
 >0xDC00 && 
ch
 <= 0xDFFF) {

207 --
sour
;

208 
	gsu
 = 
sourIeg
;

213 i(
	gch
 < (
	gUCh32
)0x80) {

214 
	gbysToWre
 = 1;

215 } i(
	gch
 < (
	gUCh32
)0x800) {

216 
	gbysToWre
 = 2;

217 } i(
	gch
 < (
	gUCh32
)0x10000) {

218 
	gbysToWre
 = 3;

219 } i(
	gch
 < (
	gUCh32
)0x110000) {

220 
	gbysToWre
 = 4;

222 
	gbysToWre
 = 3;

223 
	gch
 = 
amtCha
;

226 
	grg
 +
bysToWre
;

227 i(
	grg
 > 
	grgEnd
) {

228 
	gsour
 = 
dSour
;

229 
	grg
 -
bysToWre
;

230 
	gsu
 = 
rgExhaued
;

233 
	gbysToWre
) {

234 4: *--
rg
 = ()((
ch
 | 
byMk
& 
byMask
); 
	gch
 >>6; 
	gFALLTHROUGH
;

235 3: *--
rg
 = ()((
ch
 | 
byMk
& 
byMask
); 
	gch
 >>6; 
	gFALLTHROUGH
;

236 2: *--
rg
 = ()((
ch
 | 
byMk
& 
byMask
); 
	gch
 >>6; 
	gFALLTHROUGH
;

237 1: *--
rg
 = ()(
ch
 | 
fByMk
[
bysToWre
]);

239 
	grg
 +
bysToWre
;

241 *
	gsourS
 = 
sour
;

242 *
	grgS
 = 
rg
;

243  
	gsu
;

249 
bo
 
isLegUTF8
(cڡ * 
sour
, 
ngth
)

251 
	ga
;

252 cڡ * 
	g
 = 
sour
 + 
ngth
;

253 
	gngth
) {

254 :  
l
;

256 4: i((
a
 = (*--

)< 0x80 || > 0xBF 
l
; 
	gFALLTHROUGH
;

257 3: i((
a
 = (*--

)< 0x80 || > 0xBF 
l
; 
	gFALLTHROUGH
;

258 2: i((
a
 = (*--

)> 0xBF 
l
;

260 *
	gsour
) {

262 0xE0: i(
a
 < 0xA0 
l
; ;

263 0xED: i(
a
 > 0x9F 
l
; ;

264 0xF0: i(
a
 < 0x90 
l
; ;

265 0xF4: i(
a
 > 0x8F 
l
; ;

266 : i(
a
 < 0x80 
l
;

268 
	gFALLTHROUGH
;

270 1: i(*
sour
 >0x80 && *sour < 0xC2 
l
;

272 i(*
	gsour
 > 0xF4)

273  
	gl
;

274  
	gue
;

280 cڡ 
UCh32
 
	gofftsFromUTF8
[6] = { 0x00000000UL, 0x00003080UL, 0x000E2080UL, 0x03C82080UL, 
ic_
<UChar32>(0xFA082080UL), static_cast<UChar32>(0x82082080UL) };

282 
le
 
UCh32
 
adUTF8Sequ
(cڡ *& 
qu
, 
ngth
)

284 
UCh32
 
	gcha
 = 0;

287 
	gngth
) {

288 6: 
cha
 +
ic_
<>(*
qu
++); 
	gcha
 <<6; 
	gFALLTHROUGH
;

289 5: 
cha
 +
ic_
<>(*
qu
++); 
	gcha
 <<6; 
	gFALLTHROUGH
;

290 4: 
cha
 +
ic_
<>(*
qu
++); 
	gcha
 <<6; 
	gFALLTHROUGH
;

291 3: 
cha
 +
ic_
<>(*
qu
++); 
	gcha
 <<6; 
	gFALLTHROUGH
;

292 2: 
cha
 +
ic_
<>(*
qu
++); 
	gcha
 <<6; 
	gFALLTHROUGH
;

293 1: 
cha
 +
ic_
<>(*
qu
++);

296  
	gcha
 - 
	gofftsFromUTF8
[
ngth
 - 1];

299 
CvsiResu
 
cvtUTF8ToUTF16
(

300 cڡ ** 
sourS
, cڡ * 
sourEnd
,

301 
UCh
** 
rgS
, UCh* 
rgEnd
, 
bo
* 
sourAASCII
, bo 
ri
)

303 
CvsiResu
 
	gsu
 = 
cvsiOK
;

304 cڡ * 
	gsour
 = *
sourS
;

305 
UCh
* 
	grg
 = *
rgS
;

306 
UCh
 
	gADa
 = 0;

307 
	gsour
 < 
	gsourEnd
) {

308 
	gutf8SequLgth
 = 
leUTF8SequLgth
(*
sour
);

309 i(
	gsourEnd
 - 
	gsour
 < 
	gutf8SequLgth
) {

310 
	gsu
 = 
sourExhaued
;

314 i(!
isLegUTF8
(
t_
<cڡ *>(
sour
), 
utf8SequLgth
)) {

315 
	gsu
 = 
sourIeg
;

319 
UCh32
 
	gcha
 = 
adUTF8Sequ
(
sour
, 
utf8SequLgth
);

321 i(
	grg
 >
rgEnd
) {

322 
sour
 -
utf8SequLgth
;

323 
	gsu
 = 
rgExhaued
;

327 i(
U_IS_BMP
(
cha
)) {

329 i(
U_IS_SURROGATE
(
cha
)) {

330 i(
	gri
) {

331 
	gsour
 -
utf8SequLgth
;

332 
	gsu
 = 
sourIeg
;

335 *
	grg
++ = 
amtCha
;

336 
	gADa
 |
amtCha
;

339 *
	grg
++ = 
cha
;

340 
	gADa
 |
cha
;

342 } i(
U_IS_SUPPLEMENTARY
(
cha
)) {

344 i(
	grg
 + 1 >
rgEnd
) {

345 
sour
 -
utf8SequLgth
;

346 
	gsu
 = 
rgExhaued
;

349 *
	grg
++ = 
U16_LEAD
(
cha
);

350 *
	grg
++ = 
U16_TRAIL
(
cha
);

351 
	gADa
 = 0xffff;

353 i(
	gri
) {

354 
	gsour
 -
utf8SequLgth
;

355 
	gsu
 = 
sourIeg
;

358 *
	grg
++ = 
amtCha
;

359 
	gADa
 |
amtCha
;

363 *
	gsourS
 = 
sour
;

364 *
	grgS
 = 
rg
;

366 i(
	gsourAASCII
)

367 *
	gsourAASCII
 = !(
ADa
 & ~0x7f);

369  
	gsu
;

372 
lcuϋSgHashAndLgthFromUTF8MaskgT8Bs
(cڡ * 
da
, cڡ * 
daEnd
, & 
daLgth
, & 
utf16Lgth
)

374 i(!
	gda
)

377 
SgHash
 
	grgHash
;

378 
	gdaLgth
 = 0;

379 
	gutf16Lgth
 = 0;

381 
	gda
 < 
	gdaEnd
 || (!dataEnd && *data)) {

382 i(
isASCII
(*
da
)) {

383 
	grgHash
.
addCha
(*
da
++);

384 
	gdaLgth
++;

385 
	gutf16Lgth
++;

389 
	gutf8SequLgth
 = 
leUTF8SequLgthNASCII
(*
da
);

390 
	gdaLgth
 +
utf8SequLgth
;

392 i(!
	gdaEnd
) {

393 
	gi
 = 1; i < 
	gutf8SequLgth
; ++i) {

394 i(!
	gda
[
i
])

397 } i(
	gdaEnd
 - 
	gda
 < 
	gutf8SequLgth
)

400 i(!
isLegUTF8
(
t_
<cڡ *>(
da
), 
utf8SequLgth
))

403 
UCh32
 
	gcha
 = 
adUTF8Sequ
(
da
, 
utf8SequLgth
);

404 
ASSERT
(!
isASCII
(
cha
));

406 i(
U_IS_BMP
(
cha
)) {

408 i(
U_IS_SURROGATE
(
cha
))

410 
	grgHash
.
addCha
(
ic_
<
UCh
>(
cha
));

411 
	gutf16Lgth
++;

412 } i(
U_IS_SUPPLEMENTARY
(
cha
)) {

413 
	grgHash
.
addChas
(
ic_
<
UCh
>(
U16_LEAD
(
cha
)),

414 
ic_
<
UCh
>(
U16_TRAIL
(
cha
)));

415 
	gutf16Lgth
 += 2;

420  
	grgHash
.
hashWhT8BsMasked
();

423 
bo
 
equUTF16WhUTF8
(cڡ 
UCh
* 
a
, cڡ * 
b
, cڡ * 
bEnd
)

425 
	gb
 < 
	gbEnd
) {

426 i(
isASCII
(*
a
|| isASCII(*
b
)) {

427 i(*
	ga
++ !*
b
++)

428  
l
;

432 
	gutf8SequLgth
 = 
leUTF8SequLgthNASCII
(*
b
);

434 i(
	gbEnd
 - 
	gb
 < 
	gutf8SequLgth
)

435  
	gl
;

437 i(!
isLegUTF8
(
t_
<cڡ *>(
b
), 
utf8SequLgth
))

438  
	gl
;

440 
UCh32
 
	gcha
 = 
adUTF8Sequ
(
b
, 
utf8SequLgth
);

441 
ASSERT
(!
isASCII
(
cha
));

443 i(
U_IS_BMP
(
cha
)) {

445 i(
U_IS_SURROGATE
(
cha
))

446  
	gl
;

447 i(*
	ga
++ !
cha
)

448  
l
;

449 } i(
U_IS_SUPPLEMENTARY
(
cha
)) {

450 i(*
	ga
++ !
U16_LEAD
(
cha
))

451  
l
;

452 i(*
	ga
++ !
U16_TRAIL
(
cha
))

453  
l
;

455  
	gl
;

458  
	gue
;

461 
bo
 
equL1WhUTF8
(cڡ 
LCh
* 
a
, cڡ * 
b
, cڡ * 
bEnd
)

463 
	gb
 < 
	gbEnd
) {

464 i(
isASCII
(*
a
|| isASCII(*
b
)) {

465 i(*
	ga
++ !*
b
++)

466  
l
;

470 i(
	gb
 + 1 =
bEnd
)

471  
l
;

473 i((
	gb
[0] & 0xE0!0xC0 || (
b
[1] & 0xC0) != 0x80)

474  
l
;

476 
LCh
 
	gcha
 = ((
b
[0] & 0x1F) << 6) | (b[1] & 0x3F);

478 
	gb
 += 2;

480 i(*
	ga
++ !
cha
)

481  
l
;

484  
	gue
;

	@unicode/UTF8.h

26 #ide
WTF_UTF8_h


27 
	#WTF_UTF8_h


	)

29 
	~<unicode/utys.h
>

30 
	~<wtf/xt/LCh.h
>

32 
mea
 
	gWTF
 {

33 
mea
 
	gUnicode
 {

38 
WTF_EXPORT_PRIVATE
 
UTF8SequLgth
();

43 
WTF_EXPORT_PRIVATE
 
decodeUTF8Sequ
(const *);

46 
	gcvsiOK
,

47 
	gsourExhaued
,

48 
	grgExhaued
,

49 
	gsourIeg


50 } 
	tCvsiResu
;

66 
WTF_EXPORT_PRIVATE
 
CvsiResu
 
cvtUTF8ToUTF16
(

67 cڡ ** 
sourS
, cڡ * 
sourEnd
,

68 
UCh
** 
rgS
, UCh* 
rgEnd
, 
bo
* 
isSourAASCII
 = 0, bo 
ri
 = 
ue
);

70 
WTF_EXPORT_PRIVATE
 
CvsiResu
 
cvtL1ToUTF8
(

71 cڡ 
LCh
** 
sourS
, cڡ LCh* 
sourEnd
,

72 ** 
rgS
, * 
rgEnd
);

74 
WTF_EXPORT_PRIVATE
 
CvsiResu
 
cvtUTF16ToUTF8
(

75 cڡ 
UCh
** 
sourS
, cڡ UCh* 
sourEnd
,

76 ** 
rgS
, * 
rgEnd
, 
bo
 
ri
 = 
ue
);

78 
WTF_EXPORT_PRIVATE
 
lcuϋSgHashAndLgthFromUTF8MaskgT8Bs
(cڡ * 
da
, cڡ * 
daEnd
, & 
daLgth
, & 
utf16Lgth
);

81 
bo
 
equUTF16WhUTF8
(cڡ 
UCh
* 
rgInUTF16
, cڡ * 
rgInUTF8
, cڡ * 
rgInUTF8End
);

82 
bo
 
equL1WhUTF8
(cڡ 
LCh
* 
rgInL1
, cڡ * 
rgInUTF8
, cڡ * 
rgInUTF8End
);

	@unicode/icu/CollatorICU.cpp

29 
	~"cfig.h
"

30 
	~<wtf/unicode/Ct.h
>

34 #i!
UCONFIG_NO_COLLATION


36 
	~<mux
>

37 
	~<unicode/uc.h
>

38 
	~<wtf/NevDeroyed.h
>

39 
	~<wtf/SgExas.h
>

40 
	~<wtf/xt/SgVw.h
>

42 #i
OS
(
DARWIN
&& 
USE
(
CF
)

43 
	~<CeFoundi/CeFoundi.h
>

44 
	~<wtf/RaP.h
>

47 
mea
 
	gWTF
 {

49 
UCt
* 
	gchedCt
;

50 * 
	gchedCtLo
;

51 
bo
 
	gchedCtShouldStLowF
;

53 
	gd
::
mux
& 
chedCtMux
()

55 
d
::
_ag
 
Fg
;

57 
	gLazyNevDeroyed
<
	gd
::
mux
> mutex;

58 
	gd
::
_
(
Fg
, []{

59 
mux
.
cڡru
();

62  
	gmux
;

65 #i!(
OS
(
DARWIN
&& 
USE
(
CF
))

67 
le
 cڡ * 
sveDeuLo
(cڡ * 
lo
)

69  
	glo
;

74 
le
 * 
cyShtASCIISg
(
CFSgRef
 
rg
)

77 
	gbufr
[256];

78 i(!
	grg
 || !
CFSgGCSg
(
rg
, 
bufr
, (bufr), 
kCFSgEncodgASCII
))

79  
rdup
("");

80  
rdup
(
bufr
);

83 * 
cyDeuLo
()

85 #i!
PLATFORM
(
IOS
)

86  
cyShtASCIISg
(
ic_
<
CFSgRef
>(
CFLoGVue
(
adtCF
(
CFLoCyCut
()).
g
(), 
kCFLoCtIdtifr
)));

89  
cyShtASCIISg
(
adtCF
(
ic_
<
CFSgRef
>(
CFPnsCyVue
(
CFSTR
("ACtiOrd"), 
kCFPnsAnyAliti
, 
kCFPnsCutUr
, 
kCFPnsAnyHo
))).
g
());

93 
le
 cڡ * 
sveDeuLo
(cڡ * 
lo
)

95 i(
	glo
)

96  
	glo
;

99 * 
	gdeuLo
;

100 
	gd
::
_ag
 
lizeDeuLoOn
;

101 
	gd
::
_
(
lizeDeuLoOn
, []{

102 
deuLo
 = 
cyDeuLo
();

104  
	gdeuLo
;

109 
le
 
bo
 
losMch
(cڡ * 
a
, cڡ * 
b
)

112  
	ga
 =
b
 || (
a
 && b && !
rcmp
(a, b));

115 
	gCt
::
Ct
(cڡ * 
lo
, 
bo
 
shouldStLowF
)

117 
UECode
 
	gus
 = 
U_ZERO_ERROR
;

120 
	gd
::
lock_gud
<
d
::
mux
> 
lock
(
chedCtMux
());

121 i(
	gchedCt
 && 
losMch
(
chedCtLo
, 
lo
&& 
	gchedCtShouldStLowF
 =
shouldStLowF
) {

122 
m_ct
 = 
chedCt
;

123 
	gm_lo
 = 
chedCtLo
;

124 
	gm_shouldStLowF
 = 
shouldStLowF
;

125 
	gchedCt
 = 
nuαr
;

126 
	gchedCtLo
 = 
nuαr
;

131 
	gm_ct
 = 
uc_ݒ
(
sveDeuLo
(
lo
), &
us
);

132 i(
U_FAILURE
(
us
)) {

133 
	gus
 = 
U_ZERO_ERROR
;

134 
	gm_ct
 = 
uc_ݒ
("", &
us
);

136 
ASSERT
(
U_SUCCESS
(
us
));

138 
uc_tAribu
(
m_ct
, 
UCOL_CASE_FIRST
, 
shouldStLowF
 ? 
UCOL_LOWER_FIRST
 : 
UCOL_UPPER_FIRST
, &
us
);

139 
ASSERT
(
U_SUCCESS
(
us
));

141 
uc_tAribu
(
m_ct
, 
UCOL_NORMALIZATION_MODE
, 
UCOL_ON
, &
us
);

142 
ASSERT
(
U_SUCCESS
(
us
));

144 
	gm_lo
 = 
lo
 ? 
rdup
o: 
nuαr
;

145 
	gm_shouldStLowF
 = 
shouldStLowF
;

148 
	gCt
::~
Ct
()

151 
d
::
lock_gud
<d::
mux
> 
lock
(
chedCtMux
());

152 i(
	gchedCt
)

153 
uc_o
(
chedCt
);

154 
	gchedCt
 = 
m_ct
;

155 
	gchedCtLo
 = 
m_lo
;

156 
	gchedCtShouldStLowF
 = 
m_shouldStLowF
;

157 
	gm_ct
 = 
nuαr
;

158 
	gm_lo
 = 
nuαr
;

161 

(
m_lo
);

164 
t32_t
 
gIndexL1
(
UChIt
* 

, 
UChItOrig
 
ig
)

166 
	gig
) {

167 
	gUITER_START
:

168  

->
t
;

169 
	gUITER_CURRENT
:

170  

->
dex
;

171 
	gUITER_LIMIT
:

172  

->
lim
;

173 
	gUITER_ZERO
:

175 
	gUITER_LENGTH
:

176  

->
ngth
;

178 
ASSERT_NOT_REACHED
();

179  
	gU_SENTINEL
;

182 
t32_t
 
moveL1
(
UChIt
* 

, i32_
d
, 
UChItOrig
 
ig
)

184  
	g
->
	gdex
 = 
gIndexL1
(

, 
ig
+ 
	gd
;

187 
UBo
 
hasNextL1
(
UChIt
* 

)

189  
	g
->
	gdex
 < it->
	glim
;

192 
UBo
 
hasPviousL1
(
UChIt
* 

)

194  
	g
->
	gdex
 > it->
	gt
;

197 
UCh32
 
cutL1
(
UChIt
* 

)

199 
ASSERT
(

->
dex
 >𙔩->
t
);

200 i(
	g
->
	gdex
 >

->
lim
)

201  
U_SENTINEL
;

202  
	gic_
<cڡ 
	gLCh
*>(
	g
->
	gcڋxt
)[

->
dex
];

205 
UCh32
 
xtL1
(
UChIt
* 

)

207 
ASSERT
(

->
dex
 >𙔩->
t
);

208 i(
	g
->
	gdex
 >

->
lim
)

209  
U_SENTINEL
;

210  
	gic_
<cڡ 
	gLCh
*>(
	g
->
	gcڋxt
)[

->
dex
++];

213 
UCh32
 
eviousL1
(
UChIt
* 

)

215 i(
	g
->
	gdex
 <

->
t
)

216  
U_SENTINEL
;

217  
	gic_
<cڡ 
	gLCh
*>(
	g
->
	gcڋxt
)[--

->
dex
];

220 
ut32_t
 
gSL1
(cڡ 
UChIt
* 

)

222  
	g
->
	gdex
;

225 
tSL1
(
UChIt
* 

, 
ut32_t
 
e
, 
UECode
*)

227 
	g
->
	gdex
 = 
e
;

230 
UChIt
 
L1It
(cڡ 
LCh
* 
chas
, 
ngth
)

232 
UChIt
 
	g
;

233 
	g
.
	gcڋxt
 = 
chas
;

234 
	g
.
	gngth
 = 
ngth
;

235 
	g
.
	gt
 = 0;

236 
	g
.
	gdex
 = 0;

237 
	g
.
	glim
 = 
ngth
;

238 
	g
.
	grvedFld
 = 0;

239 
	g
.
	ggIndex
 = 
gIndexL1
;

240 
	g
.
	gmove
 = 
moveL1
;

241 
	g
.
	ghasNext
 = 
hasNextL1
;

242 
	g
.
	ghasPvious
 = 
hasPviousL1
;

243 
	g
.
	gcut
 = 
cutL1
;

244 
	g
.
	gxt
 = 
xtL1
;

245 
	g
.
	gevious
 = 
eviousL1
;

246 
	g
.
	grvedFn
 = 
nuαr
;

247 
	g
.
	ggS
 = 
gSL1
;

248 
	g
.
	gtS
 = 
tSL1
;

249  
	g
;

252 
UChIt
 
It
(
SgVw
 
rg
)

254 i(
	grg
.
is8B
())

255  
L1It
(
rg
.
chas8
(), sg.
ngth
());

256 
UChIt
 
	g
;

257 
u_tSg
(&

, 
rg
.
chas16
(), sg.
ngth
());

258  
	g
;

261 
	gCt
::
cϋ
(
SgVw
 
a
, SgVw 
b
) const

263 
UChIt
 
	gA
 = 
It
(
a
);

264 
UChIt
 
	gB
 = 
It
(
b
);

265 
UECode
 
	gus
 = 
U_ZERO_ERROR
;

266 
	gsu
 = 
uc_rclIr
(
m_ct
, &
A
, &
B
, &
us
);

267 
ASSERT
(
U_SUCCESS
(
us
));

268  
	gsu
;

271 
UChIt
 
ItUTF8
(cڡ * 
rg
)

273 
UChIt
 
	g
;

274 
u_tUTF8
(&

, 
rg
, 

(string));

275  
	g
;

278 
	gCt
::
cϋUTF8
(cڡ * 
a
, cڡ * 
b
) const

280 
UChIt
 
	gA
 = 
ItUTF8
(
a
);

281 
UChIt
 
	gB
 = 
ItUTF8
(
b
);

282 
UECode
 
	gus
 = 
U_ZERO_ERROR
;

283 
	gsu
 = 
uc_rclIr
(
m_ct
, &
A
, &
B
, &
us
);

284 
ASSERT
(
U_SUCCESS
(
us
));

285  
	gsu
;

	@win/GDIObject.h

26 #ide
GDIObje_h


27 
	#GDIObje_h


	)

29 
	~<gܙhm
>

30 
	~<cddef
>

31 
	~<memy
>

32 
	~<wdows.h
>

33 
	~<wtf/Asis.h
>

34 
	~<wtf/Ncyab.h
>

36 
mea
 
	gWTF
 {

38 
	gme
<
tyme
 
	gT
> 
deObje
(
T
);

40 
	gme
<
tyme
 
	gT
> cs
	cGDIObje
 {

41 
WTF_MAKE_NONCOPYABLE
(
GDIObje
);

42 
	gpublic
:

43 
GDIObje
(: 
m_obje
(0) { }

44 
GDIObje
(
d
::
nuαr_t
: 
m_obje
(0) { }

45 ~
GDIObje
({ 
deObje
<
T
>(
m_obje
); }

47 
T
 
g
(cڡ {  
	gm_obje
; }

49 
r
();

50 
T
 
ak
(
	gWARN_UNUSED_RETURN
;

52 
bo
 
	gݔ
!(cڡ {  !
	gm_obje
; }

55 cڡ * 
	tUnecifdBoTy
;

56 
ݔ
 
UnecifdBoTy
(cڡ {  
	gm_obje
 ? 
	gt_
<
	gUnecifdBoTy
>(&m_object) : 0; }

58 
	gGDIObje
<
	gT
>& 
	gݔ
=(
d
::
nuαr_t
{ 
r
();  *
	gthis
; }

60 
GDIObje
(GDIObject&&);

61 
	gme
<
tyme
 
	gU
> 
GDIObje
(GDIObje<
U
>&&);

63 
	gGDIObje
& 
	gݔ
=(
GDIObje
&&);

64 
	gme
<
tyme
 
	gU
> 
	gGDIObje
& 
	gݔ
=(
GDIObje
<
U
>&&);

66 
sw
(
GDIObje
& 
o
{ 
	gd
::sw(
m_obje
, o.m_object); }

68 
	give
:

69 
me
<
tyme
 
U
> 
nd
 
GDIObje
<U> 
adtGDIObje
(U);

70 
GDIObje
(
T
 
obje
: 
m_obje
(object) { }

72 
GDIObje
<
T
>& 
ݔ
=(T);

74 
T
 
	gm_obje
;

77 
	gme
<
tyme
 
	gT
> 
le
 
	gGDIObje
<T>::
	$r
()

79 
T
 
obje
 = 
m_obje
;

80 
m_obje
 = 0;

81 
	`deObje
(
obje
);

82 
	}
}

84 
	gme
<
tyme
 
	gT
> 
le
 
T
 
	gGDIObje
<T>::
	$ak
()

86 
T
 
obje
 = 
m_obje
;

87 
m_obje
 = 0;

88  
obje
;

89 
	}
}

91 
	gme
<
tyme
 
	gT
> 
le
 
	gGDIObje
<T>::
GDIObje
(GDIObje<
T
>&& 
h
)

92 : 
m_obje
(
h
.
	$ak
())

94 
	}
}

96 
me
<
tyme
 
T
> 
le
 
GDIObje
<T>& GDIObje<T>::
ݔ
=(GDIObje<T>&& 
h
)

98 aut
obje
 = 
WTF
::
move
(
h
);

99 
sw
(
obje
);

100  *
	gthis
;

103 
	gme
<
tyme
 
	gT
> 
le
 
	gGDIObje
<T> 
	$adtGDIObje
(
T
 
obje
)

105  
GDIObje
<
T
>(
obje
);

106 
	}
}

108 
	gme
<
tyme
 
	gT
> 
le
 
sw
(
GDIObje
<
T
>& 
a
, GDIObje<T>& 
b
)

110 
	ga
.
sw
(
b
);

114 
	gme
<
tyme
 
	gT
> 
le
 
	gdeObje
<T>(
T
 
	gobje
)

116 i(
	gobje
)

117 ::
DeObje
(
obje
);

120 
	gme
<> 
le
 
	gdeObje
<
	gHDC
>(
HDC
 
	ghdc
)

122 i(
	ghdc
)

123 ::
DeDC
(
hdc
);

128 
usg
 
	gWTF
::
GDIObje
;

129 
usg
 
	gWTF
::
adtGDIObje
;

	@win/MainThreadWin.cpp

30 
	~"cfig.h
"

31 
	~"MaThad.h
"

33 
	~"Asis.h
"

34 
	~"Thadg.h
"

35 
	~"WdowsExas.h
"

37 
mea
 
	gWTF
 {

39 
HWND
 
	gthadgWdowHd
;

40 
UINT
 
	gthadgFedMesge
;

41 cڡ 
LPCWSTR
 
	gkThadgWdowCssName
 = 
L
"ThreadingWindowClass";

43 
LRESULT
 
CALLBACK
 
ThadgWdowWndProc
(
HWND
 
hWnd
, 
UINT
 
mesge
, 
WPARAM
 
wPam
, 
LPARAM
 
lPam
)

45 i(
	gmesge
 =
thadgFedMesge
)

46 
dichFunisFromMaThad
();

48  
DefWdowProc
(
hWnd
, 
mesge
, 
wPam
, 
lPam
);

52 
lizeMaThadPtfm
()

54 i(
	gthadgWdowHd
)

57 
WNDCLASSW
 
	gwx
;

58 
memt
(&
wx
, 0, (
WNDCLASSW
));

59 
	gwx
.
	gWndProc
 = 
ThadgWdowWndProc
;

60 
	gwx
.
	gszCssName
 = 
kThadgWdowCssName
;

61 
RegiCssW
(&
wx
);

63 
	gthadgWdowHd
 = 
CeWdowW
(
kThadgWdowCssName
, 0, 0,

64 
CW_USEDEFAULT
, 0, CW_USEDEFAULT, 0, 
HWND_MESSAGE
, 0, 0, 0);

65 
	gthadgFedMesge
 = 
RegiWdowMesgeW
(
L
"com.apple.WebKit.MainThreadFired");

67 
lizeCutThadIl
("Main Thread");

70 
scheduDichFunisOnMaThad
()

72 
ASSERT
(
thadgWdowHd
);

73 
PoMesge
(
thadgWdowHd
, 
thadgFedMesge
, 0, 0);

	@win/RunLoopWin.cpp

26 
	~"cfig.h
"

27 
	~"RunLo.h
"

29 
	~<wtf/CutTime.h
>

30 
	~<wtf/WdowsExas.h
>

32 
mea
 
	gWTF
 {

34 cڡ 
UINT
 
	gPfmWkMesge
 = 
WM_USER
 + 1;

35 cڡ 
LPWSTR
 
	gkRunLoMesgeWdowCssName
 = 
L
"RunLoopMessageWindow";

37 
LRESULT
 
CALLBACK
 
	gRunLo
::
RunLoWndProc
(
HWND
 
hWnd
, 
UINT
 
mesge
, 
WPARAM
 
wPam
, 
LPARAM
 
lPam
)

39 i(
RunLo
* 
	grunLo
 = 
ic_
<RunLo*>(
gWdowPor
(
hWnd
, 0)))

40  
	grunLo
->
wndProc
(
hWnd
, 
mesge
, 
wPam
, 
lPam
);

42 i(
	gmesge
 =
WM_CREATE
) {

43 
LPCREATESTRUCT
 
Su
 = 
t_
<LPCREATESTRUCT>(
lPam
);

46 
tWdowPor
(
hWnd
, 0, 
Su
->
CePams
);

50  ::
DefWdowProc
(
hWnd
, 
mesge
, 
wPam
, 
lPam
);

53 
LRESULT
 
	gRunLo
::
wndProc
(
HWND
 
hWnd
, 
UINT
 
mesge
, 
WPARAM
 
wPam
, 
LPARAM
 
lPam
)

55 
	gmesge
) {

56 
	gPfmWkMesge
:

57 
rfmWk
();

59 
	gWM_TIMER
:

60 
RunLo
::
TimBa
::
timFed
(
this
, 
wPam
);

64  ::
DefWdowProc
(
hWnd
, 
mesge
, 
wPam
, 
lPam
);

67 
	gRunLo
::
run
()

69 
MSG
 
mesge
;

70 
BOOL
 
	gsu
 = ::
GMesge
(&
mesge
, 0, 0, 0)) {

71 i(
	gsu
 == -1)

73 ::
TneMesge
(&
mesge
);

74 ::
DichMesge
(&
mesge
);

78 
	gRunLo
::

()

80 ::
PoQuMesge
(0);

83 
bo
 
	gRunLo
::
giRunLoMesgeWdowCss
()

87 
WNDCLASS
 
wdowCss
 = { 0 };

88 
	gwdowCss
.
	gWndProc
 = 
RunLo
::
RunLoWndProc
;

89 
	gwdowCss
.
	gcbWndExa
 = (
RunLo
*);

90 
	gwdowCss
.
	gszCssName
 = 
kRunLoMesgeWdowCssName
;

92  !!::
RegiCss
(&
wdowCss
);

95 
	gRunLo
::
RunLo
()

97 
giRunLoMesgeWdowCss
();

99 
	gm_runLoMesgeWdow
 = ::
CeWdow
(
kRunLoMesgeWdowCssName
, 0, 0,

100 
CW_USEDEFAULT
, 0, CW_USEDEFAULT, 0, 
HWND_MESSAGE
, 0, 0, 
this
);

101 
ASSERT
(::
IsWdow
(
m_runLoMesgeWdow
));

104 
	gRunLo
::~
RunLo
()

109 
RunLo
::
wakeUp
()

113 ::
PoMesge
(
m_runLoMesgeWdow
, 
PfmWkMesge
, 
t_
<
WPARAM
>(
this
), 0);

118 
	gRunLo
::
TimBa
::
timFed
(
RunLo
* 
runLo
, 
ut64_t
 
ID
)

120 
	gTimM
::

 

 = 
runLo
->
m_aiveTims
.
fd
(
ID
);

121 i(
	g
 =
runLo
->
m_aiveTims
.
d
()) {

126 
TimBa
* 
	gtim
 = 

->
vue
;

128 i(!
	gtim
->
	gm_isRtg
) {

129 
	grunLo
->
	gm_aiveTims
.
move
(

);

130 ::
KlTim
(
runLo
->
m_runLoMesgeWdow
, 
ID
);

133 
	gtim
->
fed
();

136 
ut64_t
 
geTimID
()

138 
ut64_t
 
	guniqueTimID
 = 1;

139  
	guniqueTimID
++;

142 
	gRunLo
::
TimBa
::TimBa(
RunLo
& 
runLo
)

143 : 
m_runLo
(
runLo
)

144 , 
m_ID
(
geTimID
())

145 , 
m_isRtg
(
l
)

149 
	gRunLo
::
TimBa
::~TimerBase()

151 

();

154 
	gRunLo
::
TimBa
::
t
(
xtFeIv
, 
bo
 

)

156 
	gm_isRtg
 = 

;

157 
	gm_runLo
.
	gm_aiveTims
.
t
(
m_ID
, 
this
);

158 ::
STim
(
m_runLo
.
m_runLoMesgeWdow
, 
m_ID
, 
xtFeIv
 * 1000, 0);

161 
	gRunLo
::
TimBa
::

()

163 
TimM
::

 

 = 
m_runLo
.
m_aiveTims
.
fd
(
m_ID
);

164 i(
	g
 =
m_runLo
.
m_aiveTims
.
d
())

167 
	gm_runLo
.
	gm_aiveTims
.
move
(

);

168 ::
KlTim
(
m_runLo
.
m_runLoMesgeWdow
, 
m_ID
);

171 
bo
 
	gRunLo
::
TimBa
::
isAive
() const

173  
m_runLo
.
m_aiveTims
.
cڏs
(
m_ID
);

	@/usr/include/arpa/inet.h

18 #ide
_ARPA_INET_H


19 
	#_ARPA_INET_H
 1

	)

21 
	~<us.h
>

22 
	~<t/.h
>

25 #ide
__sockn_t_defed


26 
__sockn_t
 
	tsockn_t
;

27 
	#__sockn_t_defed


	)

30 
__BEGIN_DECLS


34 
_addr_t
 
	$_addr
 (cڡ *
__

__THROW
;

37 
_addr_t
 
	$_aof
 (
_addr
 
__

__THROW
;

41 
_addr
 
	$_makddr
 (
_addr_t
 
__t
, in_addr_
__ho
)

42 
__THROW
;

45 
_addr_t
 
	$_tof
 (
_addr
 
__

__THROW
;

49 
_addr_t
 
	$_twk
 (cڡ *
__

__THROW
;

53 *
	$_
 (
_addr
 
__

__THROW
;

58 
	$_
 (
__af
, cڡ *
__ri
 
__
,

59 *
__ri
 
__buf

__THROW
;

64 cڡ *
	$_
 (
__af
, cڡ *
__ri
 
__
,

65 *
__ri
 
__buf
, 
sockn_t
 
__n
)

66 
__THROW
;

70 #ifde
__USE_MISC


73 
	$_
 (cڡ *
__
, 
_addr
 *
__p

__THROW
;

77 *
	$_Ï
 (
_addr_t
 
__t
, *
__buf
, 
size_t
 
__n

__THROW
;

82 *
	$_t_
 (
__af
, cڡ *
__
, 
__bs
,

83 *
__buf
, 
size_t
 
__n

__THROW
;

88 
	$_t_
 (
__af
, cڡ *
__
,

89 *
__buf
, 
size_t
 
__n

__THROW
;

94 
	$_np_addr
 (cڡ *
__
,

95 *
__buf
, 
__n

__THROW
;

99 *
	$_np_
 (
__n
, cڡ *
__
,

100 *
__buf

__THROW
;

103 
__END_DECLS


	@/usr/include/ctype.h

22 #idef 
_CTYPE_H


23 
	#_CTYPE_H
 1

	)

25 
	~<us.h
>

26 
	~<bs/tys.h
>

28 
	g__BEGIN_DECLS


30 #ide
_ISb


39 
	~<dn.h
>

40 #i
__BYTE_ORDER
 =
__BIG_ENDIAN


41 
	#_ISb
(
b
(1 << (b))

	)

43 
	#_ISb
(
b
((b< 8 ? ((1 << (b)<< 8: ((1 << (b)>> 8))

	)

48 
	m_ISu
 = 
_ISb
 (0),

49 
	m_ISlow
 = 
_ISb
 (1),

50 
	m_ISpha
 = 
_ISb
 (2),

51 
	m_ISdig
 = 
_ISb
 (3),

52 
	m_ISxdig
 = 
_ISb
 (4),

53 
	m_ISa
 = 
_ISb
 (5),

54 
	m_ISt
 = 
_ISb
 (6),

55 
	m_ISgph
 = 
_ISb
 (7),

56 
	m_ISbnk
 = 
_ISb
 (8),

57 
	m_ISl
 = 
_ISb
 (9),

58 
	m_ISpun
 = 
_ISb
 (10),

59 
	m_ISnum
 = 
_ISb
 (11)

79 cڡ **
	$__y_b_loc
 ()

80 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

81 cڡ 
__t32_t
 **
	$__y_tow_loc
 ()

82 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

83 cڡ 
__t32_t
 **
	$__y_tou_loc
 ()

84 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

87 #ide
__lulus


88 
	#__isy
(
c
, 
ty
) \

89 ((*
	`__y_b_loc
 ())[((
c
)] & (
ty
)

	)

90 #i
defed
 
__USE_EXTERN_INLINES


91 
	#__isy_f
(
ty
) \

92 
__ex_le
 \

93 
is
##
	`ty
 (
__c

__THROW
 \

95  (*
	`__y_b_loc
 ())[((
__c
)] & (
_IS
##
ty
; \

96 
	}

	)
}

99 
	#__iscii
(
c
(((c& ~0x7f=0

	)

100 
	#__tscii
(
c
((c& 0x7f

	)

102 
	#__exy
(
me

	`me
 (
__THROW


	)

104 
__BEGIN_NAMESPACE_STD


110 
__exy
 (
ium
);

111 
__exy
 (
iha
);

112 
__exy
 (
isl
);

113 
__exy
 (
isdig
);

114 
__exy
 (
iow
);

115 
__exy
 (
isgph
);

116 
__exy
 (
irt
);

117 
__exy
 (
iun
);

118 
__exy
 (
isa
);

119 
__exy
 (
isu
);

120 
__exy
 (
isxdig
);

124 
	$tow
 (
__c

__THROW
;

127 
	$tou
 (
__c

__THROW
;

129 
__END_NAMESPACE_STD


133 #ifdef 
__USE_ISOC99


134 
__BEGIN_NAMESPACE_C99


136 
	`__exy
 (
isbnk
);

138 
__END_NAMESPACE_C99


141 #ifde
__USE_GNU


143 
	$isy
 (
__c
, 
__mask

__THROW
;

146 #i
defed
 
__USE_SVID
 || defed 
__USE_MISC
 || defed 
__USE_XOPEN


150 
	$iscii
 (
__c

__THROW
;

154 
	$tscii
 (
__c

__THROW
;

158 
	`__exy
 (
_tou
);

159 
	`__exy
 (
_tow
);

163 
	#__tobody
(
c
, 
f
, 
a
, 
gs
) \

164 (
__exnsi__
 \

165 ({ 
__s
; \

166 i( (
c
) > 1) \

168 i(
	`__but_cڡt_p
 (
c
)) \

170 
__c
 = (
c
); \

171 
__s
 = 
__c
 < -128 || __> 255 ? __: (
a
)[__c]; \

174 
__s
 = 
f
 
gs
; \

177 
__s
 = (
a
)[((
c
)]; \

178 
__s
; 
	}
}))

	)

180 #i!
defed
 
__NO_CTYPE


181 #ifde
__isy_f


182 
	$__isy_f
 (
num
)

183 
	$__isy_f
 (
pha
)

184 
	$__isy_f
 (
l
)

185 
	$__isy_f
 (
dig
)

186 
	$__isy_f
 (
low
)

187 
	$__isy_f
 (
gph
)

188 
	$__isy_f
 (
t
)

189 
	$__isy_f
 (
pun
)

190 
	$__isy_f
 (
a
)

191 
	$__isy_f
 (
u
)

192 
	$__isy_f
 (
xdig
)

193 #ifde
__USE_ISOC99


194 
	$__isy_f
 (
bnk
)

196 #i
defed
 
__isy


197 
	#ium
(
c

	`__isy
((c), 
_ISnum
)

	)

198 
	#iha
(
c

	`__isy
((c), 
_ISpha
)

	)

199 
	#isl
(
c

	`__isy
((c), 
_ISl
)

	)

200 
	#isdig
(
c

	`__isy
((c), 
_ISdig
)

	)

201 
	#iow
(
c

	`__isy
((c), 
_ISlow
)

	)

202 
	#isgph
(
c

	`__isy
((c), 
_ISgph
)

	)

203 
	#irt
(
c

	`__isy
((c), 
_ISt
)

	)

204 
	#iun
(
c

	`__isy
((c), 
_ISpun
)

	)

205 
	#isa
(
c

	`__isy
((c), 
_ISa
)

	)

206 
	#isu
(
c

	`__isy
((c), 
_ISu
)

	)

207 
	#isxdig
(
c

	`__isy
((c), 
_ISxdig
)

	)

208 #ifde
__USE_ISOC99


209 
	#isbnk
(
c

	`__isy
((c), 
_ISbnk
)

	)

213 #ifde
__USE_EXTERN_INLINES


214 
__ex_le
 

215 
	`__NTH
 (
	$tow
 (
__c
))

217  
__c
 >-128 && __< 256 ? (*
	`__y_tow_loc
 ())[__c] : __c;

218 
	}
}

220 
__ex_le
 

221 
__NTH
 (
	$tou
 (
__c
))

223  
__c
 >-128 && __< 256 ? (*
	`__y_tou_loc
 ())[__c] : __c;

224 
	}
}

227 #i
__GNUC__
 >2 && 
defed
 
__OPTIMIZE__
 && !defed 
__lulus


228 
	#tow
(
c

	`__tobody
 (c, 
tow
, *
	`__y_tow_loc
 (), (c))

	)

229 
	#tou
(
c

	`__tobody
 (c, 
tou
, *
	`__y_tou_loc
 (), (c))

	)

232 #i
defed
 
__USE_SVID
 || defed 
__USE_MISC
 || defed 
__USE_XOPEN


233 
	#iscii
(
c

	`__iscii
 (c)

	)

234 
	#tscii
(
c

	`__tscii
 (c)

	)

236 
	#_tow
(
c
(((*
	`__y_tow_loc
 ())[((c)])

	)

237 
	#_tou
(
c
(((*
	`__y_tou_loc
 ())[((c)])

	)

243 #ifde
__USE_XOPEN2K8


257 
	~<xlo.h
>

261 
	#__isy_l
(
c
, 
ty
, 
lo
) \

262 ((
lo
)->
__y_b
[((
c
)] & (
ty
)

	)

264 
	#__exy_l
(
me
) \

265 
	`me
 (, 
__lo_t

__THROW


	)

271 
__exy_l
 (
ium_l
);

272 
__exy_l
 (
iha_l
);

273 
__exy_l
 (
isl_l
);

274 
__exy_l
 (
isdig_l
);

275 
__exy_l
 (
iow_l
);

276 
__exy_l
 (
isgph_l
);

277 
__exy_l
 (
irt_l
);

278 
__exy_l
 (
iun_l
);

279 
__exy_l
 (
isa_l
);

280 
__exy_l
 (
isu_l
);

281 
__exy_l
 (
isxdig_l
);

283 
__exy_l
 (
isbnk_l
);

287 
	$__tow_l
 (
__c
, 
__lo_t
 
__l

__THROW
;

288 
	$tow_l
 (
__c
, 
__lo_t
 
__l

__THROW
;

291 
	$__tou_l
 (
__c
, 
__lo_t
 
__l

__THROW
;

292 
	$tou_l
 (
__c
, 
__lo_t
 
__l

__THROW
;

294 #i
__GNUC__
 >2 && 
defed
 
__OPTIMIZE__
 && !defed 
__lulus


295 
	#__tow_l
(
c
, 
lo
) \

296 
	`__tobody
 (
c
, 
__tow_l
, (
lo
)->
__y_tow
, (c,o))

	)

297 
	#__tou_l
(
c
, 
lo
) \

298 
	`__tobody
 (
c
, 
__tou_l
, (
lo
)->
__y_tou
, (c,o))

	)

299 
	#tow_l
(
c
, 
lo

	`__tow_l
 ((c), (lo))

	)

300 
	#tou_l
(
c
, 
lo

	`__tou_l
 ((c), (lo))

	)

304 #ide
__NO_CTYPE


305 
	#__ium_l
(
c
,
l

	`__isy_l
((c), 
_ISnum
, (l))

	)

306 
	#__iha_l
(
c
,
l

	`__isy_l
((c), 
_ISpha
, (l))

	)

307 
	#__isl_l
(
c
,
l

	`__isy_l
((c), 
_ISl
, (l))

	)

308 
	#__isdig_l
(
c
,
l

	`__isy_l
((c), 
_ISdig
, (l))

	)

309 
	#__iow_l
(
c
,
l

	`__isy_l
((c), 
_ISlow
, (l))

	)

310 
	#__isgph_l
(
c
,
l

	`__isy_l
((c), 
_ISgph
, (l))

	)

311 
	#__irt_l
(
c
,
l

	`__isy_l
((c), 
_ISt
, (l))

	)

312 
	#__iun_l
(
c
,
l

	`__isy_l
((c), 
_ISpun
, (l))

	)

313 
	#__isa_l
(
c
,
l

	`__isy_l
((c), 
_ISa
, (l))

	)

314 
	#__isu_l
(
c
,
l

	`__isy_l
((c), 
_ISu
, (l))

	)

315 
	#__isxdig_l
(
c
,
l

	`__isy_l
((c), 
_ISxdig
, (l))

	)

317 
	#__isbnk_l
(
c
,
l

	`__isy_l
((c), 
_ISbnk
, (l))

	)

319 #i
defed
 
__USE_SVID
 || defed 
__USE_MISC


320 
	#__iscii_l
(
c
,
l
(), 
	`__iscii
 (c))

	)

321 
	#__tscii_l
(
c
,
l
(), 
	`__tscii
 (c))

	)

324 
	#ium_l
(
c
,
l

	`__ium_l
 ((c), (l))

	)

325 
	#iha_l
(
c
,
l

	`__iha_l
 ((c), (l))

	)

326 
	#isl_l
(
c
,
l

	`__isl_l
 ((c), (l))

	)

327 
	#isdig_l
(
c
,
l

	`__isdig_l
 ((c), (l))

	)

328 
	#iow_l
(
c
,
l

	`__iow_l
 ((c), (l))

	)

329 
	#isgph_l
(
c
,
l

	`__isgph_l
 ((c), (l))

	)

330 
	#irt_l
(
c
,
l

	`__irt_l
 ((c), (l))

	)

331 
	#iun_l
(
c
,
l

	`__iun_l
 ((c), (l))

	)

332 
	#isa_l
(
c
,
l

	`__isa_l
 ((c), (l))

	)

333 
	#isu_l
(
c
,
l

	`__isu_l
 ((c), (l))

	)

334 
	#isxdig_l
(
c
,
l

	`__isxdig_l
 ((c), (l))

	)

336 
	#isbnk_l
(
c
,
l

	`__isbnk_l
 ((c), (l))

	)

338 #i
defed
 
__USE_SVID
 || defed 
__USE_MISC


339 
	#iscii_l
(
c
,
l

	`__iscii_l
 ((c), (l))

	)

340 
	#tscii_l
(
c
,
l

	`__tscii_l
 ((c), (l))

	)

347 
__END_DECLS


	@/usr/include/dlfcn.h

19 #idef 
_DLFCN_H


20 
	#_DLFCN_H
 1

	)

22 
	~<us.h
>

23 
	#__ed_size_t


	)

24 
	~<ddef.h
>

27 
	~<bs/dlf.h
>

30 #ifde
__USE_GNU


35 
	#RTLD_NEXT
 ((*-1l)

	)

40 
	#RTLD_DEFAULT
 ((*0)

	)

44 
	tLmid_t
;

47 
	#LM_ID_BASE
 0

	)

48 
	#LM_ID_NEWLM
 -1

	)

52 
__BEGIN_DECLS


56 *
	$dlݒ
 (cڡ *
__fe
, 
__mode

__THROWNL
;

60 
	$dlo
 (*
__hd

__THROWNL
 
	`__nnu
 ((1));

64 *
	$dlsym
 (*
__ri
 
__hd
,

65 cڡ *
__ri
 
__me

__THROW
 
	`__nnu
 ((2));

67 #ifde
__USE_GNU


69 *
	$dlmݒ
 (
Lmid_t
 
__nsid
, cڡ *
__fe
, 
__mode

__THROWNL
;

73 *
	$dlvsym
 (*
__ri
 
__hd
,

74 cڡ *
__ri
 
__me
,

75 cڡ *
__ri
 
__vsi
)

76 
__THROW
 
	`__nnu
 ((2, 3));

82 *
	$d˼
 (
__THROW
;

85 #ifde
__USE_GNU


90 cڡ *
dli_ame
;

91 *
dli_fba
;

92 cڡ *
dli_ame
;

93 *
dli_ddr
;

94 } 
	tDl_fo
;

98 
	$dddr
 (cڡ *
__addss
, 
Dl_fo
 *
__fo
)

99 
__THROW
 
	`__nnu
 ((2));

102 
	$dddr1
 (cڡ *
__addss
, 
Dl_fo
 *
__fo
,

103 **
__exa_fo
, 
__ags

__THROW
 
	`__nnu
 ((2));

111 
RTLD_DL_SYMENT
 = 1,

114 
RTLD_DL_LINKMAP
 = 2

123 
	$dlfo
 (*
__ri
 
__hd
,

124 
__que
, *
__ri
 
__g
)

125 
__THROW
 
	`__nnu
 ((1, 3));

131 
RTLD_DI_LMID
 = 1,

135 
RTLD_DI_LINKMAP
 = 2,

137 
RTLD_DI_CONFIGADDR
 = 3,

144 
RTLD_DI_SERINFO
 = 4,

145 
RTLD_DI_SERINFOSIZE
 = 5,

149 
RTLD_DI_ORIGIN
 = 6,

151 
RTLD_DI_PROFILENAME
 = 7,

152 
RTLD_DI_PROFILEOUT
 = 8,

157 
RTLD_DI_TLS_MODID
 = 9,

163 
RTLD_DI_TLS_DATA
 = 10,

165 
RTLD_DI_MAX
 = 10

173 *
dls_me
;

174 
dls_ags
;

175 } 
	tDl_h
;

181 
size_t
 
dls_size
;

182 
dls_t
;

183 
Dl_h
 
dls_h
[1];

184 } 
	tDl_rfo
;

188 
__END_DECLS


	@/usr/include/errno.h

22 #idef 
_ERRNO_H


26 #idef 
__ed_Emh


27 
	#_ERRNO_H
 1

	)

28 
	~<us.h
>

31 
	g__BEGIN_DECLS


35 
	~<bs/o.h
>

36 #unde
__ed_Emh


38 #ifdef 
_ERRNO_H


45 #idef 
o


46 
o
;

49 #ifde
__USE_GNU


54 *
ogm_voti_me
, *
ogm_voti_sht_me
;

58 
	g__END_DECLS


66 #i
defed
 
__USE_GNU
 || defed 
__ed_r_t


67 #ide
__r_t_defed


68 
	tr_t
;

69 
	#__r_t_defed
 1

	)

71 #unde
__ed_r_t


	@/usr/include/execinfo.h

18 #ide
_EXECINFO_H


19 
	#_EXECINFO_H
 1

	)

21 
	~<us.h
>

23 
__BEGIN_DECLS


27 
	$backa
 (**
__y
, 
__size

	`__nnu
 ((1));

32 **
	$backa_symbs
 (*cڡ *
__y
, 
__size
)

33 
__THROW
 
	`__nnu
 ((1));

38 
	$backa_symbs_fd
 (*cڡ *
__y
, 
__size
, 
__fd
)

39 
__THROW
 
	`__nnu
 ((1));

41 
__END_DECLS


	@/usr/include/fcntl.h

22 #idef 
_FCNTL_H


23 
	#_FCNTL_H
 1

	)

25 
	~<us.h
>

28 
	g__BEGIN_DECLS


31 
	~<bs/tys.h
>

35 
	~<bs/f.h
>

40 #ide
__mode_t_defed


41 
__mode_t
 
	tmode_t
;

42 
	#__mode_t_defed


	)

45 #ide
__off_t_defed


46 #ide
__USE_FILE_OFFSET64


47 
__off_t
 
	toff_t
;

49 
__off64_t
 
	toff_t
;

51 
	#__off_t_defed


	)

54 #i
defed
 
__USE_LARGEFILE64
 && !defed 
__off64_t_defed


55 
__off64_t
 
	toff64_t
;

56 
	#__off64_t_defed


	)

59 #ide
__pid_t_defed


60 
__pid_t
 
	tpid_t
;

61 
	#__pid_t_defed


	)

65 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8


66 
	#__ed_timeec


	)

67 
	~<time.h
>

68 
	~<bs/.h
>

70 
	#S_IFMT
 
__S_IFMT


	)

71 
	#S_IFDIR
 
__S_IFDIR


	)

72 
	#S_IFCHR
 
__S_IFCHR


	)

73 
	#S_IFBLK
 
__S_IFBLK


	)

74 
	#S_IFREG
 
__S_IFREG


	)

75 #ifde
__S_IFIFO


76 
	#S_IFIFO
 
__S_IFIFO


	)

78 #ifde
__S_IFLNK


79 
	#S_IFLNK
 
__S_IFLNK


	)

81 #i(
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K8
&& defed 
__S_IFSOCK


82 
	#S_IFSOCK
 
__S_IFSOCK


	)

87 
	#S_ISUID
 
__S_ISUID


	)

88 
	#S_ISGID
 
__S_ISGID


	)

90 #i
defed
 
__USE_BSD
 || defed 
__USE_MISC
 || defed 
__USE_XOPEN


92 
	#S_ISVTX
 
__S_ISVTX


	)

95 
	#S_IRUSR
 
__S_IREAD


	)

96 
	#S_IWUSR
 
__S_IWRITE


	)

97 
	#S_IXUSR
 
__S_IEXEC


	)

99 
	#S_IRWXU
 (
__S_IREAD
|
__S_IWRITE
|
__S_IEXEC
)

	)

101 
	#S_IRGRP
 (
S_IRUSR
 >> 3

	)

102 
	#S_IWGRP
 (
S_IWUSR
 >> 3

	)

103 
	#S_IXGRP
 (
S_IXUSR
 >> 3

	)

105 
	#S_IRWXG
 (
S_IRWXU
 >> 3)

	)

107 
	#S_IROTH
 (
S_IRGRP
 >> 3

	)

108 
	#S_IWOTH
 (
S_IWGRP
 >> 3

	)

109 
	#S_IXOTH
 (
S_IXGRP
 >> 3

	)

111 
	#S_IRWXO
 (
S_IRWXG
 >> 3)

	)

114 #ifdef 
__USE_MISC


115 #ide
R_OK


118 
	#R_OK
 4

	)

119 
	#W_OK
 2

	)

120 
	#X_OK
 1

	)

121 
	#F_OK
 0

	)

126 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8


127 
	#SEEK_SET
 0

	)

128 
	#SEEK_CUR
 1

	)

129 
	#SEEK_END
 2

	)

137 
f
 (
__fd
, 
__cmd
, ...);

145 #ide
__USE_FILE_OFFSET64


146 
	$ݒ
 (cڡ *
__fe
, 
__oag
, ...
	`__nnu
 ((1));

148 #ifde
__REDIRECT


149 
	`__REDIRECT
 (
ݒ
, (cڡ *
__fe
, 
__oag
, ...), 
ݒ64
)

150 
	`__nnu
 ((1));

152 
	#ݒ
 
ݒ64


	)

155 #ifde
__USE_LARGEFILE64


156 
	$ݒ64
 (cڡ *
__fe
, 
__oag
, ...
	`__nnu
 ((1));

159 #ifde
__USE_ATFILE


169 #ide
__USE_FILE_OFFSET64


170 
	$ݒ
 (
__fd
, cڡ *
__fe
, 
__oag
, ...)

171 
	`__nnu
 ((2));

173 #ifde
__REDIRECT


174 
	`__REDIRECT
 (
ݒ
, (
__fd
, cڡ *
__fe
, 
__oag
,

175 ...), 
ݒ64

	`__nnu
 ((2));

177 
	#ݒ
 
ݒ64


	)

180 #ifde
__USE_LARGEFILE64


181 
	$ݒ64
 (
__fd
, cڡ *
__fe
, 
__oag
, ...)

182 
	`__nnu
 ((2));

191 #ide
__USE_FILE_OFFSET64


192 
	$t
 (cڡ *
__fe
, 
mode_t
 
__mode

	`__nnu
 ((1));

194 #ifde
__REDIRECT


195 
	`__REDIRECT
 (
t
, (cڡ *
__fe
, 
mode_t
 
__mode
),

196 
t64

	`__nnu
 ((1));

198 
	#t
 
t64


	)

201 #ifde
__USE_LARGEFILE64


202 
	$t64
 (cڡ *
__fe
, 
mode_t
 
__mode

	`__nnu
 ((1));

205 #i!
defed
 
F_LOCK
 && (defed 
__USE_MISC
 || (defed 
__USE_XOPEN_EXTENDED
 \

206 && !
defed
 
__USE_POSIX
))

215 
	#F_ULOCK
 0

	)

216 
	#F_LOCK
 1

	)

217 
	#F_TLOCK
 2

	)

218 
	#F_TEST
 3

	)

220 #ide
__USE_FILE_OFFSET64


221 
	`lockf
 (
__fd
, 
__cmd
, 
off_t
 
__n
);

223 #ifde
__REDIRECT


224 
	`__REDIRECT
 (
lockf
, (
__fd
, 
__cmd
, 
__off64_t
 
__n
), 
lockf64
);

226 
	#lockf
 
lockf64


	)

229 #ifde
__USE_LARGEFILE64


230 
	`lockf64
 (
__fd
, 
__cmd
, 
off64_t
 
__n
);

234 #ifde
__USE_XOPEN2K


237 #ide
__USE_FILE_OFFSET64


238 
	$posix_dvi
 (
__fd
, 
off_t
 
__offt
, off_
__n
,

239 
__advi

__THROW
;

241 #ifde
__REDIRECT_NTH


242 
	`__REDIRECT_NTH
 (
posix_dvi
, (
__fd
, 
__off64_t
 
__offt
,

243 
__off64_t
 
__n
, 
__advi
),

244 
posix_dvi64
);

246 
	#posix_dvi
 
posix_dvi64


	)

249 #ifde
__USE_LARGEFILE64


250 
	$posix_dvi64
 (
__fd
, 
off64_t
 
__offt
, off64_
__n
,

251 
__advi

__THROW
;

259 #ide
__USE_FILE_OFFSET64


260 
	`posix_o
 (
__fd
, 
off_t
 
__offt
, off_
__n
);

262 #ifde
__REDIRECT


263 
	`__REDIRECT
 (
posix_o
, (
__fd
, 
__off64_t
 
__offt
,

264 
__off64_t
 
__n
),

265 
posix_o64
);

267 
	#posix_o
 
posix_o64


	)

270 #ifde
__USE_LARGEFILE64


271 
	`posix_o64
 (
__fd
, 
off64_t
 
__offt
, off64_
__n
);

277 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi
 \

278 && 
defed
 
__va_g_ck_n


279 
	~<bs/f2.h
>

282 
__END_DECLS


	@/usr/include/inttypes.h

22 #ide
_INTTYPES_H


23 
	#_INTTYPES_H
 1

	)

25 
	~<us.h
>

27 
	~<dt.h
>

30 #ide
____gwch_t_defed


31 #ifde
__lulus


32 
	#__gwch_t
 
wch_t


	)

33 #i
defed
 
__WCHAR_TYPE__


34 
__WCHAR_TYPE__
 
	t__gwch_t
;

36 
	#__ed_wch_t


	)

37 
	~<ddef.h
>

38 
wch_t
 
	t__gwch_t
;

40 
	#____gwch_t_defed
 1

	)

43 #i
__WORDSIZE
 == 64

44 
	#__PRI64_PREFIX
 "l"

	)

45 
	#__PRIPTR_PREFIX
 "l"

	)

47 
	#__PRI64_PREFIX
 ""

	)

48 
	#__PRIPTR_PREFIX


	)

54 
	#PRId8
 "d"

	)

55 
	#PRId16
 "d"

	)

56 
	#PRId32
 "d"

	)

57 
	#PRId64
 
__PRI64_PREFIX
 "d"

	)

59 
	#PRIdLEAST8
 "d"

	)

60 
	#PRIdLEAST16
 "d"

	)

61 
	#PRIdLEAST32
 "d"

	)

62 
	#PRIdLEAST64
 
__PRI64_PREFIX
 "d"

	)

64 
	#PRIdFAST8
 "d"

	)

65 
	#PRIdFAST16
 
__PRIPTR_PREFIX
 "d"

	)

66 
	#PRIdFAST32
 
__PRIPTR_PREFIX
 "d"

	)

67 
	#PRIdFAST64
 
__PRI64_PREFIX
 "d"

	)

70 
	#PRIi8
 "i"

	)

71 
	#PRIi16
 "i"

	)

72 
	#PRIi32
 "i"

	)

73 
	#PRIi64
 
__PRI64_PREFIX
 "i"

	)

75 
	#PRIiLEAST8
 "i"

	)

76 
	#PRIiLEAST16
 "i"

	)

77 
	#PRIiLEAST32
 "i"

	)

78 
	#PRIiLEAST64
 
__PRI64_PREFIX
 "i"

	)

80 
	#PRIiFAST8
 "i"

	)

81 
	#PRIiFAST16
 
__PRIPTR_PREFIX
 "i"

	)

82 
	#PRIiFAST32
 
__PRIPTR_PREFIX
 "i"

	)

83 
	#PRIiFAST64
 
__PRI64_PREFIX
 "i"

	)

86 
	#PRIo8
 "o"

	)

87 
	#PRIo16
 "o"

	)

88 
	#PRIo32
 "o"

	)

89 
	#PRIo64
 
__PRI64_PREFIX
 "o"

	)

91 
	#PRIoLEAST8
 "o"

	)

92 
	#PRIoLEAST16
 "o"

	)

93 
	#PRIoLEAST32
 "o"

	)

94 
	#PRIoLEAST64
 
__PRI64_PREFIX
 "o"

	)

96 
	#PRIoFAST8
 "o"

	)

97 
	#PRIoFAST16
 
__PRIPTR_PREFIX
 "o"

	)

98 
	#PRIoFAST32
 
__PRIPTR_PREFIX
 "o"

	)

99 
	#PRIoFAST64
 
__PRI64_PREFIX
 "o"

	)

102 
	#PRIu8
 "u"

	)

103 
	#PRIu16
 "u"

	)

104 
	#PRIu32
 "u"

	)

105 
	#PRIu64
 
__PRI64_PREFIX
 "u"

	)

107 
	#PRIuLEAST8
 "u"

	)

108 
	#PRIuLEAST16
 "u"

	)

109 
	#PRIuLEAST32
 "u"

	)

110 
	#PRIuLEAST64
 
__PRI64_PREFIX
 "u"

	)

112 
	#PRIuFAST8
 "u"

	)

113 
	#PRIuFAST16
 
__PRIPTR_PREFIX
 "u"

	)

114 
	#PRIuFAST32
 
__PRIPTR_PREFIX
 "u"

	)

115 
	#PRIuFAST64
 
__PRI64_PREFIX
 "u"

	)

118 
	#PRIx8
 "x"

	)

119 
	#PRIx16
 "x"

	)

120 
	#PRIx32
 "x"

	)

121 
	#PRIx64
 
__PRI64_PREFIX
 "x"

	)

123 
	#PRIxLEAST8
 "x"

	)

124 
	#PRIxLEAST16
 "x"

	)

125 
	#PRIxLEAST32
 "x"

	)

126 
	#PRIxLEAST64
 
__PRI64_PREFIX
 "x"

	)

128 
	#PRIxFAST8
 "x"

	)

129 
	#PRIxFAST16
 
__PRIPTR_PREFIX
 "x"

	)

130 
	#PRIxFAST32
 
__PRIPTR_PREFIX
 "x"

	)

131 
	#PRIxFAST64
 
__PRI64_PREFIX
 "x"

	)

134 
	#PRIX8
 "X"

	)

135 
	#PRIX16
 "X"

	)

136 
	#PRIX32
 "X"

	)

137 
	#PRIX64
 
__PRI64_PREFIX
 "X"

	)

139 
	#PRIXLEAST8
 "X"

	)

140 
	#PRIXLEAST16
 "X"

	)

141 
	#PRIXLEAST32
 "X"

	)

142 
	#PRIXLEAST64
 
__PRI64_PREFIX
 "X"

	)

144 
	#PRIXFAST8
 "X"

	)

145 
	#PRIXFAST16
 
__PRIPTR_PREFIX
 "X"

	)

146 
	#PRIXFAST32
 
__PRIPTR_PREFIX
 "X"

	)

147 
	#PRIXFAST64
 
__PRI64_PREFIX
 "X"

	)

151 
	#PRIdMAX
 
__PRI64_PREFIX
 "d"

	)

152 
	#PRIiMAX
 
__PRI64_PREFIX
 "i"

	)

153 
	#PRIoMAX
 
__PRI64_PREFIX
 "o"

	)

154 
	#PRIuMAX
 
__PRI64_PREFIX
 "u"

	)

155 
	#PRIxMAX
 
__PRI64_PREFIX
 "x"

	)

156 
	#PRIXMAX
 
__PRI64_PREFIX
 "X"

	)

160 
	#PRIdPTR
 
__PRIPTR_PREFIX
 "d"

	)

161 
	#PRIiPTR
 
__PRIPTR_PREFIX
 "i"

	)

162 
	#PRIoPTR
 
__PRIPTR_PREFIX
 "o"

	)

163 
	#PRIuPTR
 
__PRIPTR_PREFIX
 "u"

	)

164 
	#PRIxPTR
 
__PRIPTR_PREFIX
 "x"

	)

165 
	#PRIXPTR
 
__PRIPTR_PREFIX
 "X"

	)

171 
	#SCNd8
 "hhd"

	)

172 
	#SCNd16
 "hd"

	)

173 
	#SCNd32
 "d"

	)

174 
	#SCNd64
 
__PRI64_PREFIX
 "d"

	)

176 
	#SCNdLEAST8
 "hhd"

	)

177 
	#SCNdLEAST16
 "hd"

	)

178 
	#SCNdLEAST32
 "d"

	)

179 
	#SCNdLEAST64
 
__PRI64_PREFIX
 "d"

	)

181 
	#SCNdFAST8
 "hhd"

	)

182 
	#SCNdFAST16
 
__PRIPTR_PREFIX
 "d"

	)

183 
	#SCNdFAST32
 
__PRIPTR_PREFIX
 "d"

	)

184 
	#SCNdFAST64
 
__PRI64_PREFIX
 "d"

	)

187 
	#SCNi8
 "hhi"

	)

188 
	#SCNi16
 "hi"

	)

189 
	#SCNi32
 "i"

	)

190 
	#SCNi64
 
__PRI64_PREFIX
 "i"

	)

192 
	#SCNiLEAST8
 "hhi"

	)

193 
	#SCNiLEAST16
 "hi"

	)

194 
	#SCNiLEAST32
 "i"

	)

195 
	#SCNiLEAST64
 
__PRI64_PREFIX
 "i"

	)

197 
	#SCNiFAST8
 "hhi"

	)

198 
	#SCNiFAST16
 
__PRIPTR_PREFIX
 "i"

	)

199 
	#SCNiFAST32
 
__PRIPTR_PREFIX
 "i"

	)

200 
	#SCNiFAST64
 
__PRI64_PREFIX
 "i"

	)

203 
	#SCNu8
 "hhu"

	)

204 
	#SCNu16
 "hu"

	)

205 
	#SCNu32
 "u"

	)

206 
	#SCNu64
 
__PRI64_PREFIX
 "u"

	)

208 
	#SCNuLEAST8
 "hhu"

	)

209 
	#SCNuLEAST16
 "hu"

	)

210 
	#SCNuLEAST32
 "u"

	)

211 
	#SCNuLEAST64
 
__PRI64_PREFIX
 "u"

	)

213 
	#SCNuFAST8
 "hhu"

	)

214 
	#SCNuFAST16
 
__PRIPTR_PREFIX
 "u"

	)

215 
	#SCNuFAST32
 
__PRIPTR_PREFIX
 "u"

	)

216 
	#SCNuFAST64
 
__PRI64_PREFIX
 "u"

	)

219 
	#SCNo8
 "hho"

	)

220 
	#SCNo16
 "ho"

	)

221 
	#SCNo32
 "o"

	)

222 
	#SCNo64
 
__PRI64_PREFIX
 "o"

	)

224 
	#SCNoLEAST8
 "hho"

	)

225 
	#SCNoLEAST16
 "ho"

	)

226 
	#SCNoLEAST32
 "o"

	)

227 
	#SCNoLEAST64
 
__PRI64_PREFIX
 "o"

	)

229 
	#SCNoFAST8
 "hho"

	)

230 
	#SCNoFAST16
 
__PRIPTR_PREFIX
 "o"

	)

231 
	#SCNoFAST32
 
__PRIPTR_PREFIX
 "o"

	)

232 
	#SCNoFAST64
 
__PRI64_PREFIX
 "o"

	)

235 
	#SCNx8
 "hhx"

	)

236 
	#SCNx16
 "hx"

	)

237 
	#SCNx32
 "x"

	)

238 
	#SCNx64
 
__PRI64_PREFIX
 "x"

	)

240 
	#SCNxLEAST8
 "hhx"

	)

241 
	#SCNxLEAST16
 "hx"

	)

242 
	#SCNxLEAST32
 "x"

	)

243 
	#SCNxLEAST64
 
__PRI64_PREFIX
 "x"

	)

245 
	#SCNxFAST8
 "hhx"

	)

246 
	#SCNxFAST16
 
__PRIPTR_PREFIX
 "x"

	)

247 
	#SCNxFAST32
 
__PRIPTR_PREFIX
 "x"

	)

248 
	#SCNxFAST64
 
__PRI64_PREFIX
 "x"

	)

252 
	#SCNdMAX
 
__PRI64_PREFIX
 "d"

	)

253 
	#SCNiMAX
 
__PRI64_PREFIX
 "i"

	)

254 
	#SCNoMAX
 
__PRI64_PREFIX
 "o"

	)

255 
	#SCNuMAX
 
__PRI64_PREFIX
 "u"

	)

256 
	#SCNxMAX
 
__PRI64_PREFIX
 "x"

	)

259 
	#SCNdPTR
 
__PRIPTR_PREFIX
 "d"

	)

260 
	#SCNiPTR
 
__PRIPTR_PREFIX
 "i"

	)

261 
	#SCNoPTR
 
__PRIPTR_PREFIX
 "o"

	)

262 
	#SCNuPTR
 
__PRIPTR_PREFIX
 "u"

	)

263 
	#SCNxPTR
 
__PRIPTR_PREFIX
 "x"

	)

266 
	g__BEGIN_DECLS


268 #i
__WORDSIZE
 == 64

273 
	mqu
;

274 
	mm
;

275 } 
	timaxdiv_t
;

282 
__exnsi__
 
	mqu
;

283 
__exnsi__
 
	mm
;

284 } 
	timaxdiv_t
;

290 
tmax_t
 
	$imaxabs
 (
tmax_t
 
__n

__THROW
 
	`__ibu__
 ((
__cڡ__
));

293 
imaxdiv_t
 
	$imaxdiv
 (
tmax_t
 
__num
, imax_
__dom
)

294 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

297 
tmax_t
 
	$oimax
 (cڡ *
__ri
 
__Ō
,

298 **
__ri
 
__dr
, 
__ba

__THROW
;

301 
utmax_t
 
	$oumax
 (cڡ *
__ri
 
__Ō
,

302 ** 
__ri
 
__dr
, 
__ba

__THROW
;

305 
tmax_t
 
	$wcoimax
 (cڡ 
__gwch_t
 *
__ri
 
__Ō
,

306 
__gwch_t
 **
__ri
 
__dr
, 
__ba
)

307 
__THROW
;

310 
utmax_t
 
	$wcoumax
 (cڡ 
__gwch_t
 *
__ri
 
__Ō
,

311 
__gwch_t
 ** 
__ri
 
__dr
, 
__ba
)

312 
__THROW
;

314 #ifde
__USE_EXTERN_INLINES


316 #i
__WORDSIZE
 == 64

318 
	$___
 (cڡ *
__ri
 
__Ō
,

319 **
__ri
 
__dr
,

320 
__ba
, 
__group
)

321 
__THROW
 
	`__nnu
 ((1)
__wur
;

323 
__ex_le
 
tmax_t


324 
	`__NTH
 (
	$oimax
 (cڡ *
__ri
 
Ō
, **__ri 
dr
,

325 
ba
))

327  
	`___
 (
Ō
, 
dr
, 
ba
, 0);

328 
	}
}

330 
	$__oul_
 (cڡ *
__ri
 
__Ō
,

331 ** 
__ri
 
__dr
,

332 
__ba
, 
__group
)

333 
__THROW
 
	`__nnu
 ((1)
__wur
;

335 
__ex_le
 
utmax_t


336 
	`__NTH
 (
	$oumax
 (cڡ *
__ri
 
Ō
, **__ri 
dr
,

337 
ba
))

339  
	`__oul_
 (
Ō
, 
dr
, 
ba
, 0);

340 
	}
}

342 
	$__wc_
 (cڡ 
__gwch_t
 * 
__ri
 
__Ō
,

343 
__gwch_t
 **
__ri
 
__dr
,

344 
__ba
, 
__group
)

345 
__THROW
 
	`__nnu
 ((1)
__wur
;

347 
__ex_le
 
tmax_t


348 
	`__NTH
 (
	$wcoimax
 (cڡ 
__gwch_t
 *
__ri
 
Ō
,

349 
__gwch_t
 **
__ri
 
dr
, 
ba
))

351  
	`__wc_
 (
Ō
, 
dr
, 
ba
, 0);

352 
	}
}

354 
	$__wcoul_
 (cڡ 
__gwch_t
 *

355 
__ri
 
__Ō
,

356 
__gwch_t
 **

357 
__ri
 
__dr
,

358 
__ba
, 
__group
)

359 
__THROW
 
	`__nnu
 ((1)
__wur
;

361 
__ex_le
 
utmax_t


362 
	`__NTH
 (
	$wcoumax
 (cڡ 
__gwch_t
 *
__ri
 
Ō
,

363 
__gwch_t
 **
__ri
 
dr
, 
ba
))

365  
	`__wcoul_
 (
Ō
, 
dr
, 
ba
, 0);

366 
	}
}

370 
__exnsi__


371 
	$__l_
 (cڡ *
__ri
 
__Ō
,

372 **
__ri
 
__dr
,

373 
__ba
, 
__group
)

374 
__THROW
 
	`__nnu
 ((1)
__wur
;

376 
__ex_le
 
tmax_t


377 
	`__NTH
 (
	$oimax
 (cڡ *
__ri
 
Ō
, **__ri 
dr
,

378 
ba
))

380  
	`__l_
 (
Ō
, 
dr
, 
ba
, 0);

381 
	}
}

383 
__exnsi__


384 
	$__ou_
 (const *

385 
__ri
 
__Ō
,

387 
__ri
 
__dr
,

388 
__ba
,

389 
__group
)

390 
__THROW
 
	`__nnu
 ((1)
__wur
;

392 
__ex_le
 
utmax_t


393 
	`__NTH
 (
	$oumax
 (cڡ *
__ri
 
Ō
, **__ri 
dr
,

394 
ba
))

396  
	`__ou_
 (
Ō
, 
dr
, 
ba
, 0);

397 
	}
}

399 
__exnsi__


400 
	$__wcl_
 (cڡ 
__gwch_t
 *
__ri
 
__Ō
,

401 
__gwch_t
 **
__ri
 
__dr
,

402 
__ba
, 
__group
)

403 
__THROW
 
	`__nnu
 ((1)
__wur
;

405 
__ex_le
 
tmax_t


406 
	`__NTH
 (
	$wcoimax
 (cڡ 
__gwch_t
 *
__ri
 
Ō
,

407 
__gwch_t
 **
__ri
 
dr
, 
ba
))

409  
	`__wcl_
 (
Ō
, 
dr
, 
ba
, 0);

410 
	}
}

413 
__exnsi__


414 
	$__wcou_
 (cڡ 
__gwch_t
 *

415 
__ri
 
__Ō
,

416 
__gwch_t
 **

417 
__ri
 
__dr
,

418 
__ba
,

419 
__group
)

420 
__THROW
 
	`__nnu
 ((1)
__wur
;

422 
__ex_le
 
utmax_t


423 
	`__NTH
 (
	$wcoumax
 (cڡ 
__gwch_t
 *
__ri
 
Ō
,

424 
__gwch_t
 **
__ri
 
dr
, 
ba
))

426  
	`__wcou_
 (
Ō
, 
dr
, 
ba
, 0);

427 
	}
}

432 
	g__END_DECLS


	@/usr/include/limits.h

22 #ide
_LIBC_LIMITS_H_


23 
	#_LIBC_LIMITS_H_
 1

	)

25 
	~<us.h
>

31 
	#MB_LEN_MAX
 16

	)

36 #i!
defed
 
__GNUC__
 || __GNUC__ < 2

41 #ide
_LIMITS_H


42 
	#_LIMITS_H
 1

	)

44 
	~<bs/wdsize.h
>

53 
	#CHAR_BIT
 8

	)

56 
	#SCHAR_MIN
 (-128)

	)

57 
	#SCHAR_MAX
 127

	)

60 
	#UCHAR_MAX
 255

	)

63 #ifde
__CHAR_UNSIGNED__


64 
	#CHAR_MIN
 0

	)

65 
	#CHAR_MAX
 
UCHAR_MAX


	)

67 
	#CHAR_MIN
 
SCHAR_MIN


	)

68 
	#CHAR_MAX
 
SCHAR_MAX


	)

72 
	#SHRT_MIN
 (-32768)

	)

73 
	#SHRT_MAX
 32767

	)

76 
	#USHRT_MAX
 65535

	)

79 
	#INT_MIN
 (-
INT_MAX
 - 1)

	)

80 
	#INT_MAX
 2147483647

	)

83 
	#UINT_MAX
 4294967295U

	)

86 #i
__WORDSIZE
 == 64

87 
	#LONG_MAX
 9223372036854775807L

	)

89 
	#LONG_MAX
 2147483647L

	)

91 
	#LONG_MIN
 (-
LONG_MAX
 - 1L)

	)

94 #i
__WORDSIZE
 == 64

95 
	#ULONG_MAX
 18446744073709551615UL

	)

97 
	#ULONG_MAX
 4294967295UL

	)

100 #ifde
__USE_ISOC99


103 
	#LLONG_MAX
 9223372036854775807LL

	)

104 
	#LLONG_MIN
 (-
LLONG_MAX
 - 1LL)

	)

107 
	#ULLONG_MAX
 18446744073709551615ULL

	)

121 #i
defed
 
__GNUC__
 && !defed 
_GCC_LIMITS_H_


123 #ude_x<
lims
.
h
>

129 #i
defed
 
__USE_ISOC99
 && defed 
__GNUC__


130 #ide
LLONG_MIN


131 
	#LLONG_MIN
 (-
LLONG_MAX
-1)

	)

133 #ide
LLONG_MAX


134 
	#LLONG_MAX
 
__LONG_LONG_MAX__


	)

136 #ide
ULLONG_MAX


137 
	#ULLONG_MAX
 (
LLONG_MAX
 * 2ULL + 1)

	)

141 #ifdef 
__USE_POSIX


143 
	~<bs/posix1_lim.h
>

146 #ifdef 
__USE_POSIX2


147 
	~<bs/posix2_lim.h
>

150 #ifdef 
__USE_XOPEN


151 
	~<bs/xݒ_lim.h
>

	@/usr/include/malloc.h

19 #ide
_MALLOC_H


20 
	#_MALLOC_H
 1

	)

22 
	~<us.h
>

23 
	~<ddef.h
>

24 
	~<dio.h
>

26 #ifde
_LIBC


27 
	#__MALLOC_HOOK_VOLATILE


	)

28 
	#__MALLOC_DEPRECATED


	)

30 
	#__MALLOC_HOOK_VOLATILE
 vީe

	)

31 
	#__MALLOC_DEPRECATED
 
__ibu_dd__


	)

35 
__BEGIN_DECLS


38 *
	$mloc
 (
size_t
 
__size

__THROW
 
__ibu_mloc__
 
__wur
;

41 *
	$oc
 (
size_t
 
__nmemb
, size_
__size
)

42 
__THROW
 
__ibu_mloc__
 
__wur
;

49 *
	$loc
 (*
__r
, 
size_t
 
__size
)

50 
__THROW
 
__ibu_wn_unud_su__
;

53 
	$
 (*
__r

__THROW
;

56 
	$c
 (*
__r

__THROW
;

59 *
	$memign
 (
size_t
 
__ignmt
, size_
__size
)

60 
__THROW
 
__ibu_mloc__
 
__wur
;

63 *
	$vloc
 (
size_t
 
__size

__THROW
 
__ibu_mloc__
 
__wur
;

67 *
	$pvloc
 (
size_t
 
__size

__THROW
 
__ibu_mloc__
 
__wur
;

71 *(*
__mece
(
rdiff_t
 
__size
);

74 *
	$__deu_mece
 (
rdiff_t
 
__size
)

75 
__THROW
 
__ibu_mloc__
;

79 
	smlfo


81 
a
;

82 
dblks
;

83 
smblks
;

84 
hblks
;

85 
hblkhd
;

86 
usmblks
;

87 
fsmblks
;

88 
udblks
;

89 
fdblks
;

90 
kpco
;

94 
mlfo
 
	$mlfo
 (
__THROW
;

97 #ide
M_MXFAST


98 
	#M_MXFAST
 1

	)

100 #ide
M_NLBLKS


101 
	#M_NLBLKS
 2

	)

103 #ide
M_GRAIN


104 
	#M_GRAIN
 3

	)

106 #ide
M_KEEP


107 
	#M_KEEP
 4

	)

111 
	#M_TRIM_THRESHOLD
 -1

	)

112 
	#M_TOP_PAD
 -2

	)

113 
	#M_MMAP_THRESHOLD
 -3

	)

114 
	#M_MMAP_MAX
 -4

	)

115 
	#M_CHECK_ACTION
 -5

	)

116 
	#M_PERTURB
 -6

	)

117 
	#M_ARENA_TEST
 -7

	)

118 
	#M_ARENA_MAX
 -8

	)

121 
	$mlt
 (
__m
, 
__v

__THROW
;

125 
	$mloc_im
 (
size_t
 
__d

__THROW
;

129 
size_t
 
	$mloc_ub_size
 (*
__r

__THROW
;

132 
	$mloc_s
 (
__THROW
;

135 
	$mloc_fo
 (
__tis
, 
FILE
 *
__

__THROW
;

138 *
	$mloc_g_e
 (
__THROW
;

142 
	$mloc_t_e
 (*
__r

__THROW
;

147 (*
__MALLOC_HOOK_VOLATILE
 
__mloc_lize_hook
) ()

148 
__MALLOC_DEPRECATED
;

150 (*
__MALLOC_HOOK_VOLATILE
 
___hook
(*
__r
,

152 
__MALLOC_DEPRECATED
;

153 *(*
__MALLOC_HOOK_VOLATILE
 
__mloc_hook
)(
size_t
 
__size
,

155 
__MALLOC_DEPRECATED
;

156 *(*
__MALLOC_HOOK_VOLATILE
 
__loc_hook
)(*
__r
,

157 
size_t
 
__size
,

159 
__MALLOC_DEPRECATED
;

160 *(*
__MALLOC_HOOK_VOLATILE
 
__memign_hook
)(
size_t
 
__ignmt
,

161 
size_t
 
__size
,

163 
__MALLOC_DEPRECATED
;

164 (*
__MALLOC_HOOK_VOLATILE
 
__a_mece_hook
) ();

167 
	$__mloc_check_
 (
__THROW
 
__MALLOC_DEPRECATED
;

170 
__END_DECLS


	@/usr/include/math.h

23 #idef 
_MATH_H


24 
	#_MATH_H
 1

	)

26 
	~<us.h
>

28 
	g__BEGIN_DECLS


32 
	~<bs/huge_v.h
>

33 #ifde
__USE_ISOC99


34 
	~<bs/huge_vf.h
>

35 
	~<bs/huge_vl.h
>

38 
	~<bs/f.h
>

41 
	~<bs/n.h
>

45 
	~<bs/mhdef.h
>

52 
	#__MATHCALL
(
funi
,
suffix
, 
gs
) \

53 
	`__MATHDECL
 (
_Mdoub_
,
funi
,
suffix
, 
gs
)

	)

54 
	#__MATHDECL
(
ty
, 
funi
,
suffix
, 
gs
) \

55 
	`__MATHDECL_1
(
ty
, 
funi
,
suffix
, 
gs
); \

56 
	`__MATHDECL_1
(
ty
, 
	`__CONCAT
(
__
,
funi
),
suffix
, 
gs
)

	)

57 
	#__MATHCALLX
(
funi
,
suffix
, 
gs
, 
ib
) \

58 
	`__MATHDECLX
 (
_Mdoub_
,
funi
,
suffix
, 
gs
, 
ib
)

	)

59 
	#__MATHDECLX
(
ty
, 
funi
,
suffix
, 
gs
, 
ib
) \

60 
	`__MATHDECL_1
(
ty
, 
funi
,
suffix
, 
gs

	`__ibu__
 (
ib
); \

61 
	`__MATHDECL_1
(
ty
, 
	`__CONCAT
(
__
,
funi
),
suffix
, 
gs

	`__ibu__
 (
ib
)

	)

62 
	#__MATHDECL_1
(
ty
, 
funi
,
suffix
, 
gs
) \

63 
ty
 
	`__MATH_PRECNAME
(
funi
,
suffix

gs
 
__THROW


	)

65 
	#_Mdoub_
 

	)

66 
	#__MATH_PRECNAME
(
me
,
r

	`__CONCAT
ame,r)

	)

67 
	#_Mdoub_BEGIN_NAMESPACE
 
__BEGIN_NAMESPACE_STD


	)

68 
	#_Mdoub_END_NAMESPACE
 
__END_NAMESPACE_STD


	)

69 
	~<bs/mhs.h
>

70 #unde
_Mdoub_


71 #unde
_Mdoub_BEGIN_NAMESPACE


72 #unde
_Mdoub_END_NAMESPACE


73 #unde
__MATH_PRECNAME


75 #i
defed
 
__USE_MISC
 || defed 
__USE_ISOC99


81 #ide
_Mt_


82 
	#_Mt_
 

	)

84 
	#_Mdoub_
 
_Mt_


	)

85 
	#__MATH_PRECNAME
(
me
,
r
me##
f
##
	)
r

86 
	#_Mdoub_BEGIN_NAMESPACE
 
__BEGIN_NAMESPACE_C99


	)

87 
	#_Mdoub_END_NAMESPACE
 
__END_NAMESPACE_C99


	)

88 
	~<bs/mhs.h
>

89 #unde
_Mdoub_


90 #unde
_Mdoub_BEGIN_NAMESPACE


91 #unde
_Mdoub_END_NAMESPACE


92 #unde
__MATH_PRECNAME


94 #i!(
defed
 
__NO_LONG_DOUBLE_MATH
 && defed 
_LIBC
) \

95 || 
defed
 
__LDBL_COMPAT


96 #ifde
__LDBL_COMPAT


98 #ifde
__USE_ISOC99


99 
	$__dbl_xowdf
 (
__x
, 
__y
)

100 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

101 #ifde
__REDIRECT_NTH


102 
	`__REDIRECT_NTH
 (
xowdf
, (
__x
, 
__y
),

103 
__dbl_xowdf
)

104 
	`__ibu__
 ((
__cڡ__
));

105 
	`__REDIRECT_NTH
 (
xowd
, (
__x
, 
__y
),

106 
x

	`__ibu__
 ((
__cڡ__
));

107 
	`__REDIRECT_NTH
 (
xowdl
,

108 (
__x
, 
__y
),

109 
x

	`__ibu__
 ((
__cڡ__
));

113 #unde
__MATHDECL_1


114 
	#__MATHDECL_2
(
ty
, 
funi
,
suffix
, 
gs
, 
s
) \

115 
ty
 
	`__REDIRECT_NTH
(
	`__MATH_PRECNAME
(
funi
,
suffix
), \

116 
gs
, 
s
)

	)

117 
	#__MATHDECL_1
(
ty
, 
funi
,
suffix
, 
gs
) \

118 
	`__MATHDECL_2
(
ty
, 
funi
,
suffix
, 
gs
, 
	`__CONCAT
(funi,suffix))

	)

124 #ide
_Mlg_doub_


125 
	#_Mlg_doub_
 

	)

127 
	#_Mdoub_
 
_Mlg_doub_


	)

128 
	#__MATH_PRECNAME
(
me
,
r
me##
l
##
	)
r

129 
	#_Mdoub_BEGIN_NAMESPACE
 
__BEGIN_NAMESPACE_C99


	)

130 
	#_Mdoub_END_NAMESPACE
 
__END_NAMESPACE_C99


	)

131 
	#__MATH_DECLARE_LDOUBLE
 1

	)

132 
	~<bs/mhs.h
>

133 #unde
_Mdoub_


134 #unde
_Mdoub_BEGIN_NAMESPACE


135 #unde
_Mdoub_END_NAMESPACE


136 #unde
__MATH_PRECNAME


141 #unde
__MATHDECL_1


142 #unde
__MATHDECL


143 #unde
__MATHCALL


146 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN


148 
signgam
;

153 #ifde
__USE_ISOC99


191 
FP_NAN
 =

192 
	#FP_NAN
 0

	)

193 
FP_NAN
,

194 
FP_INFINITE
 =

195 
	#FP_INFINITE
 1

	)

196 
FP_INFINITE
,

197 
FP_ZERO
 =

198 
	#FP_ZERO
 2

	)

199 
FP_ZERO
,

200 
FP_SUBNORMAL
 =

201 
	#FP_SUBNORMAL
 3

	)

202 
FP_SUBNORMAL
,

203 
FP_NORMAL
 =

204 
	#FP_NORMAL
 4

	)

205 
FP_NORMAL


209 #ifde
__NO_LONG_DOUBLE_MATH


210 
	#assify
(
x
) \

211 ( (
x
= (? 
	`__assifyf
 (x: 
	`__assify
 (x))

	)

213 
	#assify
(
x
) \

214 ( (
x
) ==  () \

215 ? 
	`__assifyf
 (
x
) \

216 :  (
x
) ==  () \

217 ? 
	`__assify
 (
x
: 
	`__assifyl
 (x))

	)

221 #ifde
__NO_LONG_DOUBLE_MATH


222 
	#signb
(
x
) \

223 ( (
x
= (? 
	`__signbf
 (x: 
	`__signb
 (x))

	)

225 
	#signb
(
x
) \

226 ( (
x
) ==  () \

227 ? 
	`__signbf
 (
x
) \

228 :  (
x
) ==  () \

229 ? 
	`__signb
 (
x
: 
	`__signbl
 (x))

	)

233 #ifde
__NO_LONG_DOUBLE_MATH


234 
	#isfe
(
x
) \

235 ( (
x
= (? 
	`__fef
 (x: 
	`__fe
 (x))

	)

237 
	#isfe
(
x
) \

238 ( (
x
) ==  () \

239 ? 
	`__fef
 (
x
) \

240 :  (
x
) ==  () \

241 ? 
	`__fe
 (
x
: 
	`__f
 (x))

	)

245 
	#im
(
x
(
	`assify
 (x=
FP_NORMAL
)

	)

249 #ifde
__NO_LONG_DOUBLE_MATH


250 
	#i
(
x
) \

251 ( (
x
= (? 
	`__if
 (x: 
	`__i
 (x))

	)

253 
	#i
(
x
) \

254 ( (
x
) ==  () \

255 ? 
	`__if
 (
x
) \

256 :  (
x
) ==  () \

257 ? 
	`__i
 (
x
: 
	`__il
 (x))

	)

261 #ifde
__NO_LONG_DOUBLE_MATH


262 
	#isf
(
x
) \

263 ( (
x
= (? 
	`__isff
 (x: 
	`__isf
 (x))

	)

265 
	#isf
(
x
) \

266 ( (
x
) ==  () \

267 ? 
	`__isff
 (
x
) \

268 :  (
x
) ==  () \

269 ? 
	`__isf
 (
x
: 
	`__is
 (x))

	)

273 
	#MATH_ERRNO
 1

	)

274 
	#MATH_ERREXCEPT
 2

	)

279 #ide
__FAST_MATH__


280 
	#mh_rhdlg
 (
MATH_ERRNO
 | 
MATH_ERREXCEPT
)

	)

285 #ifde
__USE_GNU


287 #ifde
__NO_LONG_DOUBLE_MATH


288 
	#issiglg
(
x
) \

289 ( (
x
= (? 
	`__issiglgf
 (x: 
	`__issiglg
 (x))

	)

291 
	#issiglg
(
x
) \

292 ( (
x
) ==  () \

293 ? 
	`__issiglgf
 (
x
) \

294 :  (
x
) ==  () \

295 ? 
	`__issiglg
 (
x
: 
	`__issiglgl
 (x))

	)

299 #ifdef 
__USE_MISC


303 
_IEEE_
 = -1,

304 
_SVID_
,

305 
_XOPEN_
,

306 
_POSIX_
,

307 
_ISOC_


308 } 
	t_LIB_VERSION_TYPE
;

313 
_LIB_VERSION_TYPE
 
_LIB_VERSION
;

317 #ifde
__USE_SVID


323 #ifde
__lulus


324 
__exi


326 
exi


329 
ty
;

330 *
me
;

331 
g1
;

332 
g2
;

333 
tv
;

334 
	}
};

336 #ifde
__lulus


337 
	$mhr
 (
__exi
 *
__exc

	`throw
 ();

339 
	`mhr
 (
exi
 *
__exc
);

342 
	#X_TLOSS
 1.41484755040568800000e+16

	)

345 
	#DOMAIN
 1

	)

346 
	#SING
 2

	)

347 
	#OVERFLOW
 3

	)

348 
	#UNDERFLOW
 4

	)

349 
	#TLOSS
 5

	)

350 
	#PLOSS
 6

	)

353 
	#HUGE
 3.40282347e+38F

	)

357 #ifde
__USE_XOPEN


359 
	#MAXFLOAT
 3.40282347e+38F

	)

366 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN


367 
	#M_E
 2.7182818284590452354

	)

368 
	#M_LOG2E
 1.4426950408889634074

	)

369 
	#M_LOG10E
 0.43429448190325182765

	)

370 
	#M_LN2
 0.69314718055994530942

	)

371 
	#M_LN10
 2.30258509299404568402

	)

372 
	#M_PI
 3.14159265358979323846

	)

373 
	#M_PI_2
 1.57079632679489661923

	)

374 
	#M_PI_4
 0.78539816339744830962

	)

375 
	#M_1_PI
 0.31830988618379067154

	)

376 
	#M_2_PI
 0.63661977236758134308

	)

377 
	#M_2_SQRTPI
 1.12837916709551257390

	)

378 
	#M_SQRT2
 1.41421356237309504880

	)

379 
	#M_SQRT1_2
 0.70710678118654752440

	)

385 #ifde
__USE_GNU


386 
	#M_El
 2.718281828459045235360287471352662498L

	)

387 
	#M_LOG2El
 1.442695040888963407359924681001892137L

	)

388 
	#M_LOG10El
 0.434294481903251827651128918916605082L

	)

389 
	#M_LN2l
 0.693147180559945309417232121458176568L

	)

390 
	#M_LN10l
 2.302585092994045684017991454684364208L

	)

391 
	#M_PIl
 3.141592653589793238462643383279502884L

	)

392 
	#M_PI_2l
 1.570796326794896619231321691639751442L

	)

393 
	#M_PI_4l
 0.785398163397448309615660845819875721L

	)

394 
	#M_1_PIl
 0.318309886183790671537767526745028724L

	)

395 
	#M_2_PIl
 0.636619772367581343075535053490057448L

	)

396 
	#M_2_SQRTPIl
 1.128379167095512573896158903121545172L

	)

397 
	#M_SQRT2l
 1.414213562373095048801688724209698079L

	)

398 
	#M_SQRT1_2l
 0.707106781186547524400844362104849039L

	)

405 #i
defed
 
__STRICT_ANSI__
 && !defed 
__NO_MATH_INLINES


406 
	#__NO_MATH_INLINES
 1

	)

409 #i
defed
 
__USE_ISOC99
 && 
	`__GNUC_PREREQ
(2,97)

416 
	#isg
(
x
, 
y

	`__but_isg
(x, y)

	)

417 
	#isgequ
(
x
, 
y

	`__but_isgequ
(x, y)

	)

418 
	#iess
(
x
, 
y

	`__but_iess
(x, y)

	)

419 
	#iesqu
(
x
, 
y

	`__but_iesqu
(x, y)

	)

420 
	#iessg
(
x
, 
y

	`__but_iessg
(x, y)

	)

421 
	#isunded
(
u
, 
v

	`__but_isunded
(u, v)

	)

425 #ifde
__USE_EXTERN_INLINES


426 
	~<bs/mhle.h
>

431 #i
defed
 
__FINITE_MATH_ONLY__
 && __FINITE_MATH_ONLY__ > 0

432 
	~<bs/mh-fe.h
>

435 #ifde
__USE_ISOC99


439 #ide
isg


440 
	#isg
(
x
, 
y
) \

441 (
__exnsi__
 \

442 ({ 
	`__tyof__
(
x

__x
 = (x); __tyof__(
y

__y
 = (y); \

443 !
	`isunded
 (
__x
, 
__y
&& __x > __y; 
	}
}))

	)

447 #ide
isgequ


448 
	#isgequ
(
x
, 
y
) \

449 (
__exnsi__
 \

450 ({ 
	`__tyof__
(
x

__x
 = (x); __tyof__(
y

__y
 = (y); \

451 !
	`isunded
 (
__x
, 
__y
&& __x >__y; }))

	)

455 #ide
iess


456 
	#iess
(
x
, 
y
) \

457 (
__exnsi__
 \

458 ({ 
	`__tyof__
(
x

__x
 = (x); __tyof__(
y

__y
 = (y); \

459 !
	`isunded
 (
__x
, 
__y
&& __x < __y; }))

	)

463 #ide
iesqu


464 
	#iesqu
(
x
, 
y
) \

465 (
__exnsi__
 \

466 ({ 
	`__tyof__
(
x

__x
 = (x); __tyof__(
y

__y
 = (y); \

467 !
	`isunded
 (
__x
, 
__y
&& __x <__y; }))

	)

471 #ide
iessg


472 
	#iessg
(
x
, 
y
) \

473 (
__exnsi__
 \

474 ({ 
	`__tyof__
(
x

__x
 = (x); __tyof__(
y

__y
 = (y); \

475 !
	`isunded
 (
__x
, 
__y
&& (__x < __y || __y < __x); }))

	)

479 #ide
isunded


480 
	#isunded
(
u
, 
v
) \

481 (
__exnsi__
 \

482 ({ 
	`__tyof__
(
u

__u
 = (u); __tyof__(
v

__v
 = (v); \

483 
	`assify
 (
__u
=
FP_NAN
 || fpassify (
__v
=FP_NAN; }))

	)

488 
	g__END_DECLS


	@/usr/include/pthread.h

18 #ide
_PTHREAD_H


19 
	#_PTHREAD_H
 1

	)

21 
	~<us.h
>

22 
	~<dn.h
>

23 
	~<sched.h
>

24 
	~<time.h
>

26 
	~<bs/hadtys.h
>

27 
	~<bs/tjmp.h
>

28 
	~<bs/wdsize.h
>

34 
	mPTHREAD_CREATE_JOINABLE
,

35 
	#PTHREAD_CREATE_JOINABLE
 
PTHREAD_CREATE_JOINABLE


	)

36 
	mPTHREAD_CREATE_DETACHED


37 
	#PTHREAD_CREATE_DETACHED
 
PTHREAD_CREATE_DETACHED


	)

44 
	mPTHREAD_MUTEX_TIMED_NP
,

45 
	mPTHREAD_MUTEX_RECURSIVE_NP
,

46 
	mPTHREAD_MUTEX_ERRORCHECK_NP
,

47 
	mPTHREAD_MUTEX_ADAPTIVE_NP


48 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K8


50 
	mPTHREAD_MUTEX_NORMAL
 = 
PTHREAD_MUTEX_TIMED_NP
,

51 
	mPTHREAD_MUTEX_RECURSIVE
 = 
PTHREAD_MUTEX_RECURSIVE_NP
,

52 
	mPTHREAD_MUTEX_ERRORCHECK
 = 
PTHREAD_MUTEX_ERRORCHECK_NP
,

53 
	mPTHREAD_MUTEX_DEFAULT
 = 
PTHREAD_MUTEX_NORMAL


55 #ifde
__USE_GNU


57 , 
	mPTHREAD_MUTEX_FAST_NP
 = 
PTHREAD_MUTEX_TIMED_NP


62 #ifde
__USE_XOPEN2K


66 
	mPTHREAD_MUTEX_STALLED
,

67 
	mPTHREAD_MUTEX_STALLED_NP
 = 
PTHREAD_MUTEX_STALLED
,

68 
	mPTHREAD_MUTEX_ROBUST
,

69 
	mPTHREAD_MUTEX_ROBUST_NP
 = 
PTHREAD_MUTEX_ROBUST


74 #i
defed
 
__USE_POSIX199506
 || defed 
__USE_UNIX98


78 
	mPTHREAD_PRIO_NONE
,

79 
	mPTHREAD_PRIO_INHERIT
,

80 
	mPTHREAD_PRIO_PROTECT


86 #i
__PTHREAD_MUTEX_HAVE_ELISION
 == 1

87 
	#__PTHREAD_SPINS
 0, 0

	)

88 #i
__PTHREAD_MUTEX_HAVE_ELISION
 == 2

89 
	#__PTHREAD_SPINS
 { 0, 0 }

	)

91 
	#__PTHREAD_SPINS
 0

	)

94 #ifde
__PTHREAD_MUTEX_HAVE_PREV


95 
	#PTHREAD_MUTEX_INITIALIZER
 \

96 { { 0, 0, 0, 0, 0, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

97 #ifde
__USE_GNU


98 
	#PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
 \

99 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_RECURSIVE_NP
, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

100 
	#PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
 \

101 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_ERRORCHECK_NP
, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

102 
	#PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
 \

103 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_ADAPTIVE_NP
, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

104 
	#PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
 \

105 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_ADAPTIVE_NP
, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

109 
	#PTHREAD_MUTEX_INITIALIZER
 \

110 { { 0, 0, 0, 0, 0, { 
__PTHREAD_SPINS
 } } }

	)

111 #ifde
__USE_GNU


112 
	#PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
 \

113 { { 0, 0, 0, 
PTHREAD_MUTEX_RECURSIVE_NP
, 0, { 
__PTHREAD_SPINS
 } } }

	)

114 
	#PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
 \

115 { { 0, 0, 0, 
PTHREAD_MUTEX_ERRORCHECK_NP
, 0, { 
__PTHREAD_SPINS
 } } }

	)

116 
	#PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
 \

117 { { 0, 0, 0, 
PTHREAD_MUTEX_ADAPTIVE_NP
, 0, { 
__PTHREAD_SPINS
 } } }

	)

124 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K


127 
	mPTHREAD_RWLOCK_PREFER_READER_NP
,

128 
	mPTHREAD_RWLOCK_PREFER_WRITER_NP
,

129 
	mPTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
,

130 
	mPTHREAD_RWLOCK_DEFAULT_NP
 = 
PTHREAD_RWLOCK_PREFER_READER_NP


136 #ide
__PTHREAD_RWLOCK_INT_FLAGS_SHARED


137 #i
__WORDSIZE
 == 64

138 
	#__PTHREAD_RWLOCK_INT_FLAGS_SHARED
 1

	)

143 
	#PTHREAD_RWLOCK_INITIALIZER
 \

144 { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }

	)

145 #ifde
__USE_GNU


146 #ifde
__PTHREAD_RWLOCK_INT_FLAGS_SHARED


147 
	#PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP
 \

149 
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
 } }

	)

151 #i
__BYTE_ORDER
 =
__LITTLE_ENDIAN


152 
	#PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP
 \

153 { { 0, 0, 0, 0, 0, 0, 
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
, \

154 0, 0, 0, 0 } }

	)

156 
	#PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP
 \

157 { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
,\

158 0 } }

	)

168 
	mPTHREAD_INHERIT_SCHED
,

169 
	#PTHREAD_INHERIT_SCHED
 
PTHREAD_INHERIT_SCHED


	)

170 
	mPTHREAD_EXPLICIT_SCHED


171 
	#PTHREAD_EXPLICIT_SCHED
 
PTHREAD_EXPLICIT_SCHED


	)

178 
	mPTHREAD_SCOPE_SYSTEM
,

179 
	#PTHREAD_SCOPE_SYSTEM
 
PTHREAD_SCOPE_SYSTEM


	)

180 
	mPTHREAD_SCOPE_PROCESS


181 
	#PTHREAD_SCOPE_PROCESS
 
PTHREAD_SCOPE_PROCESS


	)

188 
	mPTHREAD_PROCESS_PRIVATE
,

189 
	#PTHREAD_PROCESS_PRIVATE
 
PTHREAD_PROCESS_PRIVATE


	)

190 
	mPTHREAD_PROCESS_SHARED


191 
	#PTHREAD_PROCESS_SHARED
 
PTHREAD_PROCESS_SHARED


	)

197 
	#PTHREAD_COND_INITIALIZER
 { { 0, 0, 0, 0, 0, (*0, 0, 0 } }

	)

201 
	s_had_nup_bufr


203 (*
	m__route
) (*);

204 *
	m__g
;

205 
	m__ny
;

206 
_had_nup_bufr
 *
	m__ev
;

212 
	mPTHREAD_CANCEL_ENABLE
,

213 
	#PTHREAD_CANCEL_ENABLE
 
PTHREAD_CANCEL_ENABLE


	)

214 
	mPTHREAD_CANCEL_DISABLE


215 
	#PTHREAD_CANCEL_DISABLE
 
PTHREAD_CANCEL_DISABLE


	)

219 
	mPTHREAD_CANCEL_DEFERRED
,

220 
	#PTHREAD_CANCEL_DEFERRED
 
PTHREAD_CANCEL_DEFERRED


	)

221 
	mPTHREAD_CANCEL_ASYNCHRONOUS


222 
	#PTHREAD_CANCEL_ASYNCHRONOUS
 
PTHREAD_CANCEL_ASYNCHRONOUS


	)

224 
	#PTHREAD_CANCELED
 ((*-1)

	)

228 
	#PTHREAD_ONCE_INIT
 0

	)

231 #ifde
__USE_XOPEN2K


235 
	#PTHREAD_BARRIER_SERIAL_THREAD
 -1

	)

239 
__BEGIN_DECLS


244 
had_
 (
had_t
 *
__ri
 
__wthad
,

245 cڡ 
had__t
 *
__ri
 
__
,

246 *(*
__t_route
) (*),

247 *
__ri
 
__g

__THROWNL
 
__nnu
 ((1, 3));

253 
	$had_ex
 (*
__tv

	`__ibu__
 ((
__nܑu__
));

261 
	`had_jo
 (
had_t
 
__th
, **
__thad_tu
);

263 #ifde
__USE_GNU


266 
	$had_yjo_
 (
had_t
 
__th
, **
__thad_tu

__THROW
;

274 
	`had_timedjo_
 (
had_t
 
__th
, **
__thad_tu
,

275 cڡ 
timeec
 *
__abime
);

282 
	$had_dach
 (
had_t
 
__th

__THROW
;

286 
had_t
 
	$had_lf
 (
__THROW
 
	`__ibu__
 ((
__cڡ__
));

289 
	$had_equ
 (
had_t
 
__thad1
,thad_
__thad2
)

290 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

298 
	$had__
 (
had__t
 *
__

__THROW
 
	`__nnu
 ((1));

301 
	$had__deroy
 (
had__t
 *
__
)

302 
__THROW
 
	`__nnu
 ((1));

305 
	$had__gdache
 (cڡ 
had__t
 *
__
,

306 *
__dache
)

307 
__THROW
 
	`__nnu
 ((1, 2));

310 
	$had__tdache
 (
had__t
 *
__
,

311 
__dache
)

312 
__THROW
 
	`__nnu
 ((1));

316 
	$had__ggudsize
 (cڡ 
had__t
 *
__
,

317 
size_t
 *
__gudsize
)

318 
__THROW
 
	`__nnu
 ((1, 2));

321 
	$had__tgudsize
 (
had__t
 *
__
,

322 
size_t
 
__gudsize
)

323 
__THROW
 
	`__nnu
 ((1));

327 
	$had__gschedm
 (cڡ 
had__t
 *
__ri
 
__
,

328 
sched_m
 *
__ri
 
__m
)

329 
__THROW
 
	`__nnu
 ((1, 2));

332 
	$had__tschedm
 (
had__t
 *
__ri
 
__
,

333 cڡ 
sched_m
 *
__ri


334 
__m

__THROW
 
	`__nnu
 ((1, 2));

337 
	$had__gschedpicy
 (cڡ 
had__t
 *
__ri


338 
__
, *
__ri
 
__picy
)

339 
__THROW
 
	`__nnu
 ((1, 2));

342 
	$had__tschedpicy
 (
had__t
 *
__
, 
__picy
)

343 
__THROW
 
	`__nnu
 ((1));

346 
	$had__ghsched
 (cڡ 
had__t
 *
__ri


347 
__
, *
__ri
 
__h
)

348 
__THROW
 
	`__nnu
 ((1, 2));

351 
	$had__thsched
 (
had__t
 *
__
,

352 
__h
)

353 
__THROW
 
	`__nnu
 ((1));

357 
	$had__gsce
 (cڡ 
had__t
 *
__ri
 
__
,

358 *
__ri
 
__sce
)

359 
__THROW
 
	`__nnu
 ((1, 2));

362 
	$had__tsce
 (
had__t
 *
__
, 
__sce
)

363 
__THROW
 
	`__nnu
 ((1));

366 
	$had__gackaddr
 (cڡ 
had__t
 *
__ri


367 
__
, **
__ri
 
__ackaddr
)

368 
__THROW
 
	`__nnu
 ((1, 2)
__ibu_dd__
;

374 
	$had__tackaddr
 (
had__t
 *
__
,

375 *
__ackaddr
)

376 
__THROW
 
	`__nnu
 ((1)
__ibu_dd__
;

379 
	$had__gacksize
 (cڡ 
had__t
 *
__ri


380 
__
, 
size_t
 *
__ri
 
__acksize
)

381 
__THROW
 
	`__nnu
 ((1, 2));

386 
	$had__tacksize
 (
had__t
 *
__
,

387 
size_t
 
__acksize
)

388 
__THROW
 
	`__nnu
 ((1));

390 #ifde
__USE_XOPEN2K


392 
	$had__gack
 (cڡ 
had__t
 *
__ri
 
__
,

393 **
__ri
 
__ackaddr
,

394 
size_t
 *
__ri
 
__acksize
)

395 
__THROW
 
	`__nnu
 ((1, 2, 3));

400 
	$had__tack
 (
had__t
 *
__
, *
__ackaddr
,

401 
size_t
 
__acksize

__THROW
 
	`__nnu
 ((1));

404 #ifde
__USE_GNU


407 
	$had__ffy_
 (
had__t
 *
__
,

408 
size_t
 
__utsize
,

409 cڡ 
u_t_t
 *
__ut
)

410 
__THROW
 
	`__nnu
 ((1, 3));

414 
	$had__gaffy_
 (cڡ 
had__t
 *
__
,

415 
size_t
 
__utsize
,

416 
u_t_t
 *
__ut
)

417 
__THROW
 
	`__nnu
 ((1, 3));

420 
	$had_g_deu_
 (
had__t
 *
__
)

421 
__THROW
 
	`__nnu
 ((1));

425 
	$had_r_deu_
 (cڡ 
had__t
 *
__
)

426 
__THROW
 
	`__nnu
 ((1));

431 
	$had_g_
 (
had_t
 
__th
, 
had__t
 *
__
)

432 
__THROW
 
	`__nnu
 ((2));

440 
	$had_tschedm
 (
had_t
 
__rg_thad
, 
__picy
,

441 cڡ 
sched_m
 *
__m
)

442 
__THROW
 
	`__nnu
 ((3));

445 
	$had_gschedm
 (
had_t
 
__rg_thad
,

446 *
__ri
 
__picy
,

447 
sched_m
 *
__ri
 
__m
)

448 
__THROW
 
	`__nnu
 ((2, 3));

451 
	$had_tschedio
 (
had_t
 
__rg_thad
, 
__io
)

452 
__THROW
;

455 #ifde
__USE_GNU


457 
	$had_gme_
 (
had_t
 
__rg_thad
, *
__buf
,

458 
size_t
 
__bu
)

459 
__THROW
 
	`__nnu
 ((2));

462 
	$had_ame_
 (
had_t
 
__rg_thad
, cڡ *
__me
)

463 
__THROW
 
	`__nnu
 ((2));

467 #ifde
__USE_UNIX98


469 
	$had_gccucy
 (
__THROW
;

472 
	$had_tccucy
 (
__v

__THROW
;

475 #ifde
__USE_GNU


480 
	$had_yld
 (
__THROW
;

485 
	$had_ffy_
 (
had_t
 
__th
, 
size_t
 
__utsize
,

486 cڡ 
u_t_t
 *
__ut
)

487 
__THROW
 
	`__nnu
 ((3));

490 
	$had_gaffy_
 (
had_t
 
__th
, 
size_t
 
__utsize
,

491 
u_t_t
 *
__ut
)

492 
__THROW
 
	`__nnu
 ((3));

505 
	`had_
 (
had__t
 *
___cڌ
,

506 (*
___route
()
	`__nnu
 ((1, 2));

517 
	`had_tnle
 (
__e
, *
__de
);

521 
	`had_tny
 (
__ty
, *
__dty
);

524 
	`had_nl
 (
had_t
 
__th
);

529 
	`had_nl
 ();

538 
__jmp_buf
 
__nl_jmp_buf
;

539 
__mask_was_ved
;

540 } 
__nl_jmp_buf
[1];

541 *
__d
[4];

542 } 
	t__had_unwd_buf_t
 
	t__ibu__
 ((
	t__igd__
));

545 #ide
__nup_f_ibu


546 
	#__nup_f_ibu


	)

551 
	s__had_nup_ame


553 (*
__nl_route
) (*);

554 *
__nl_g
;

555 
__do_
;

556 
__nl_ty
;

559 #i
defed
 
__GNUC__
 && defed 
__EXCEPTIONS


560 #ifde
__lulus


562 as
	c__had_nup_ass


564 (*
__nl_route
) (*);

565 *
__nl_g
;

566 
__do_
;

567 
__nl_ty
;

569 
public
:

570 
	`__had_nup_ass
 ((*
__f
(*), *
__g
)

571 : 
	`__nl_route
 (
__f
), 
	`__nl_g
 (
__g
), 
	$__do_
 (1) { }

572 ~
	$__had_nup_ass
 ({ i(
__do_

	`__nl_route
 (
__nl_g
); 
	}
}

573 
	$__tdo
 (
__wv
{ 
__do_
 = __wv; 
	}
}

574 
	$__der
 ({ 
	`had_tny
 (
PTHREAD_CANCEL_DEFERRED
,

575 &
__nl_ty
); 
	}
}

576 
	$__e
 (cڡ { 
	`had_tny
 (
__nl_ty
, 0); 
	}
}

586 
	#had_nup_push
(
route
, 
g
) \

588 
__had_nup_ass
 
	`__ame
 (
route
, 
g
)

	)

592 
	#had_nup_p
(
execu
) \

593 
__ame
.
	`__tdo
 (
execu
); \

594 } 0)

	)

596 #ifde
__USE_GNU


600 
	#had_nup_push_der_
(
route
, 
g
) \

602 
__had_nup_ass
 
	`__ame
 (
route
, 
g
); \

603 
__ame
.
	`__der
 ()

	)

608 
	#had_nup_p_e_
(
execu
) \

609 
__ame
.
	`__e
 (); \

610 
__ame
.
	`__tdo
 (
execu
); \

611 } 0)

	)

618 
__ex_le
 

619 
	$__had_nup_route
 (
__had_nup_ame
 *
__ame
)

621 i(
__ame
->
__do_
)

622 
__ame
->
	`__nl_route
 (__ame->
__nl_g
);

623 
	}
}

632 
	#had_nup_push
(
route
, 
g
) \

634 
__had_nup_ame
 
__ame
 \

635 
	`__ibu__
 ((
	`__nup__
 (
__had_nup_route
))) \

636 { .
__nl_route
 = (
route
), .
__nl_g
 = (
g
), \

637 .
__do_
 = 1 };

	)

641 
	#had_nup_p
(
execu
) \

642 
__ame
.
__do_
 = (
execu
); \

643 } 0)

	)

645 #ifde
__USE_GNU


649 
	#had_nup_push_der_
(
route
, 
g
) \

651 
__had_nup_ame
 
__ame
 \

652 
	`__ibu__
 ((
	`__nup__
 (
__had_nup_route
))) \

653 { .
__nl_route
 = (
route
), .
__nl_g
 = (
g
), \

654 .
__do_
 = 1 }; \

655 (
	`had_tny
 (
PTHREAD_CANCEL_DEFERRED
, \

656 &
__ame
.
__nl_ty
)

	)

661 
	#had_nup_p_e_
(
execu
) \

662 (
	`had_tny
 (
__ame
.
__nl_ty
, 
NULL
); \

663 
__ame
.
__do_
 = (
execu
); \

664 } 0)

	)

675 
	#had_nup_push
(
route
, 
g
) \

677 
__had_unwd_buf_t
 
__nl_buf
; \

678 (*
__nl_route
(*(
route
); \

679 *
__nl_g
 = (
g
); \

680 
__n_f_
 = 
	`__sigtjmp
 ((
__jmp_buf_g
 *) (*) \

681 
__nl_buf
.
__nl_jmp_buf
, 0); \

682 i(
	`__glibc_uiky
 (
__n_f_
)) \

684 
	`__nl_route
 (
__nl_g
); \

685 
	`__had_unwd_xt
 (&
__nl_buf
); \

689 
	`__had_gi_nl
 (&
__nl_buf
); \

690 d{

	)

691 
__had_gi_nl
 (
__had_unwd_buf_t
 *
__buf
)

692 
__nup_f_ibu
;

696 
	#had_nup_p
(
execu
) \

699 
	`__had_uegi_nl
 (&
__nl_buf
); \

700 i(
execu
) \

701 
	`__nl_route
 (
__nl_g
); \

702 } 0)

	)

703 
	$__had_uegi_nl
 (
__had_unwd_buf_t
 *
__buf
)

704 
__nup_f_ibu
;

706 #ifde
__USE_GNU


710 
	#had_nup_push_der_
(
route
, 
g
) \

712 
__had_unwd_buf_t
 
__nl_buf
; \

713 (*
__nl_route
(*(
route
); \

714 *
__nl_g
 = (
g
); \

715 
__n_f_
 = 
	`__sigtjmp
 ((
__jmp_buf_g
 *) (*) \

716 
__nl_buf
.
__nl_jmp_buf
, 0); \

717 i(
	`__glibc_uiky
 (
__n_f_
)) \

719 
	`__nl_route
 (
__nl_g
); \

720 
	`__had_unwd_xt
 (&
__nl_buf
); \

724 
	`__had_gi_nl_der
 (&
__nl_buf
); \

725 d{

	)

726 
	`__had_gi_nl_der
 (
__had_unwd_buf_t
 *
__buf
)

727 
__nup_f_ibu
;

732 
	#had_nup_p_e_
(
execu
) \

735 
	`__had_uegi_nl_e
 (&
__nl_buf
); \

736 i(
execu
) \

737 
	`__nl_route
 (
__nl_g
); \

738 
	}
} 0)

	)

739 
	$__had_uegi_nl_e
 (
__had_unwd_buf_t
 *
__buf
)

740 
__nup_f_ibu
;

744 
	$__had_unwd_xt
 (
__had_unwd_buf_t
 *
__buf
)

745 
__nup_f_ibu
 
	`__ibu__
 ((
__nܑu__
))

746 #ide
SHARED


747 
	`__ibu__
 ((
__wk__
))

753 
__jmp_buf_g
;

754 
	$__sigtjmp
 (
__jmp_buf_g
 *
__v
, 
__vemask

__THROWNL
;

760 
	$had_mux_
 (
had_mux_t
 *
__mux
,

761 cڡ 
had_mux_t
 *
__mux
)

762 
__THROW
 
	`__nnu
 ((1));

765 
	$had_mux_deroy
 (
had_mux_t
 *
__mux
)

766 
__THROW
 
	`__nnu
 ((1));

769 
	$had_mux_ylock
 (
had_mux_t
 *
__mux
)

770 
__THROWNL
 
	`__nnu
 ((1));

773 
	$had_mux_lock
 (
had_mux_t
 *
__mux
)

774 
__THROWNL
 
	`__nnu
 ((1));

776 #ifde
__USE_XOPEN2K


778 
	$had_mux_timedlock
 (
had_mux_t
 *
__ri
 
__mux
,

779 cڡ 
timeec
 *
__ri


780 
__abime

__THROWNL
 
	`__nnu
 ((1, 2));

784 
	$had_mux_uock
 (
had_mux_t
 *
__mux
)

785 
__THROWNL
 
	`__nnu
 ((1));

789 
	$had_mux_giog
 (cڡ 
had_mux_t
 *

790 
__ri
 
__mux
,

791 *
__ri
 
__iog
)

792 
__THROW
 
	`__nnu
 ((1, 2));

796 
	$had_mux_riog
 (
had_mux_t
 *
__ri
 
__mux
,

797 
__iog
,

798 *
__ri
 
__d_g
)

799 
__THROW
 
	`__nnu
 ((1, 3));

802 #ifde
__USE_XOPEN2K8


804 
	$had_mux_csit
 (
had_mux_t
 *
__mux
)

805 
__THROW
 
	`__nnu
 ((1));

806 #ifde
__USE_GNU


807 
	$had_mux_csit_
 (
had_mux_t
 *
__mux
)

808 
__THROW
 
	`__nnu
 ((1));

817 
	$had_mux_
 (
had_mux_t
 *
__
)

818 
__THROW
 
	`__nnu
 ((1));

821 
	$had_mux_deroy
 (
had_mux_t
 *
__
)

822 
__THROW
 
	`__nnu
 ((1));

825 
	$had_mux_gpshed
 (cڡ 
had_mux_t
 *

826 
__ri
 
__
,

827 *
__ri
 
__pshed
)

828 
__THROW
 
	`__nnu
 ((1, 2));

831 
	$had_mux_shed
 (
had_mux_t
 *
__
,

832 
__pshed
)

833 
__THROW
 
	`__nnu
 ((1));

835 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K8


837 
	$had_mux_gty
 (cڡ 
had_mux_t
 *
__ri


838 
__
, *
__ri
 
__kd
)

839 
__THROW
 
	`__nnu
 ((1, 2));

844 
	$had_mux_y
 (
had_mux_t
 *
__
, 
__kd
)

845 
__THROW
 
	`__nnu
 ((1));

849 
	$had_mux_goc
 (cڡ 
had_mux_t
 *

850 
__ri
 
__
,

851 *
__ri
 
__oc
)

852 
__THROW
 
	`__nnu
 ((1, 2));

856 
	$had_mux_roc
 (
had_mux_t
 *
__
,

857 
__oc
)

858 
__THROW
 
	`__nnu
 ((1));

861 
	$had_mux_giog
 (cڡ 
had_mux_t
 *

862 
__ri
 
__
,

863 *
__ri
 
__iog
)

864 
__THROW
 
	`__nnu
 ((1, 2));

867 
	$had_mux_riog
 (
had_mux_t
 *
__
,

868 
__iog
)

869 
__THROW
 
	`__nnu
 ((1));

871 #ifde
__USE_XOPEN2K


873 
	$had_mux_grobu
 (cڡ 
had_mux_t
 *
__
,

874 *
__robuss
)

875 
__THROW
 
	`__nnu
 ((1, 2));

876 #ifde
__USE_GNU


877 
	$had_mux_grobu_
 (cڡ 
had_mux_t
 *
__
,

878 *
__robuss
)

879 
__THROW
 
	`__nnu
 ((1, 2));

883 
	$had_mux_obu
 (
had_mux_t
 *
__
,

884 
__robuss
)

885 
__THROW
 
	`__nnu
 ((1));

886 #ifde
__USE_GNU


887 
	$had_mux_obu_
 (
had_mux_t
 *
__
,

888 
__robuss
)

889 
__THROW
 
	`__nnu
 ((1));

894 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K


899 
	$had_rwlock_
 (
had_rwlock_t
 *
__ri
 
__rwlock
,

900 cڡ 
had_rwlock_t
 *
__ri


901 
__

__THROW
 
	`__nnu
 ((1));

904 
	$had_rwlock_deroy
 (
had_rwlock_t
 *
__rwlock
)

905 
__THROW
 
	`__nnu
 ((1));

908 
	$had_rwlock_rdlock
 (
had_rwlock_t
 *
__rwlock
)

909 
__THROWNL
 
	`__nnu
 ((1));

912 
	$had_rwlock_yrdlock
 (
had_rwlock_t
 *
__rwlock
)

913 
__THROWNL
 
	`__nnu
 ((1));

915 #ifde
__USE_XOPEN2K


917 
	$had_rwlock_timedrdlock
 (
had_rwlock_t
 *
__ri
 
__rwlock
,

918 cڡ 
timeec
 *
__ri


919 
__abime

__THROWNL
 
	`__nnu
 ((1, 2));

923 
	$had_rwlock_wock
 (
had_rwlock_t
 *
__rwlock
)

924 
__THROWNL
 
	`__nnu
 ((1));

927 
	$had_rwlock_ywock
 (
had_rwlock_t
 *
__rwlock
)

928 
__THROWNL
 
	`__nnu
 ((1));

930 #ifde
__USE_XOPEN2K


932 
	$had_rwlock_timedwock
 (
had_rwlock_t
 *
__ri
 
__rwlock
,

933 cڡ 
timeec
 *
__ri


934 
__abime

__THROWNL
 
	`__nnu
 ((1, 2));

938 
	$had_rwlock_uock
 (
had_rwlock_t
 *
__rwlock
)

939 
__THROWNL
 
	`__nnu
 ((1));

945 
	$had_rwlock_
 (
had_rwlock_t
 *
__
)

946 
__THROW
 
	`__nnu
 ((1));

949 
	$had_rwlock_deroy
 (
had_rwlock_t
 *
__
)

950 
__THROW
 
	`__nnu
 ((1));

953 
	$had_rwlock_gpshed
 (cڡ 
had_rwlock_t
 *

954 
__ri
 
__
,

955 *
__ri
 
__pshed
)

956 
__THROW
 
	`__nnu
 ((1, 2));

959 
	$had_rwlock_shed
 (
had_rwlock_t
 *
__
,

960 
__pshed
)

961 
__THROW
 
	`__nnu
 ((1));

964 
	$had_rwlock_gkd_
 (cڡ 
had_rwlock_t
 *

965 
__ri
 
__
,

966 *
__ri
 
__ef
)

967 
__THROW
 
	`__nnu
 ((1, 2));

970 
	$had_rwlock_tkd_
 (
had_rwlock_t
 *
__
,

971 
__ef

__THROW
 
	`__nnu
 ((1));

979 
	$had_cd_
 (
had_cd_t
 *
__ri
 
__cd
,

980 cڡ 
had_cd_t
 *
__ri
 
__cd_
)

981 
__THROW
 
	`__nnu
 ((1));

984 
	$had_cd_deroy
 (
had_cd_t
 *
__cd
)

985 
__THROW
 
	`__nnu
 ((1));

988 
	$had_cd_sigl
 (
had_cd_t
 *
__cd
)

989 
__THROWNL
 
	`__nnu
 ((1));

992 
	$had_cd_brd
 (
had_cd_t
 *
__cd
)

993 
__THROWNL
 
	`__nnu
 ((1));

1000 
	$had_cd_wa
 (
had_cd_t
 *
__ri
 
__cd
,

1001 
had_mux_t
 *
__ri
 
__mux
)

1002 
	`__nnu
 ((1, 2));

1011 
	$had_cd_timedwa
 (
had_cd_t
 *
__ri
 
__cd
,

1012 
had_mux_t
 *
__ri
 
__mux
,

1013 cڡ 
timeec
 *
__ri
 
__abime
)

1014 
	`__nnu
 ((1, 2, 3));

1019 
	$had_cd_
 (
had_cd_t
 *
__
)

1020 
__THROW
 
	`__nnu
 ((1));

1023 
	$had_cd_deroy
 (
had_cd_t
 *
__
)

1024 
__THROW
 
	`__nnu
 ((1));

1027 
	$had_cd_gpshed
 (cڡ 
had_cd_t
 *

1028 
__ri
 
__
,

1029 *
__ri
 
__pshed
)

1030 
__THROW
 
	`__nnu
 ((1, 2));

1033 
	$had_cd_shed
 (
had_cd_t
 *
__
,

1034 
__pshed

__THROW
 
	`__nnu
 ((1));

1036 #ifde
__USE_XOPEN2K


1038 
	$had_cd_gock
 (cڡ 
had_cd_t
 *

1039 
__ri
 
__
,

1040 
__ockid_t
 *
__ri
 
__ock_id
)

1041 
__THROW
 
	`__nnu
 ((1, 2));

1044 
	$had_cd_tock
 (
had_cd_t
 *
__
,

1045 
__ockid_t
 
__ock_id
)

1046 
__THROW
 
	`__nnu
 ((1));

1050 #ifde
__USE_XOPEN2K


1055 
	$had__
 (
had_lock_t
 *
__lock
, 
__pshed
)

1056 
__THROW
 
	`__nnu
 ((1));

1059 
	$had__deroy
 (
had_lock_t
 *
__lock
)

1060 
__THROW
 
	`__nnu
 ((1));

1063 
	$had__lock
 (
had_lock_t
 *
__lock
)

1064 
__THROWNL
 
	`__nnu
 ((1));

1067 
	$had__ylock
 (
had_lock_t
 *
__lock
)

1068 
__THROWNL
 
	`__nnu
 ((1));

1071 
	$had__uock
 (
had_lock_t
 *
__lock
)

1072 
__THROWNL
 
	`__nnu
 ((1));

1079 
	$had_brr_
 (
had_brr_t
 *
__ri
 
__brr
,

1080 cڡ 
had_brr_t
 *
__ri


1081 
__
, 
__cou
)

1082 
__THROW
 
	`__nnu
 ((1));

1085 
	$had_brr_deroy
 (
had_brr_t
 *
__brr
)

1086 
__THROW
 
	`__nnu
 ((1));

1089 
	$had_brr_wa
 (
had_brr_t
 *
__brr
)

1090 
__THROWNL
 
	`__nnu
 ((1));

1094 
	$had_brr_
 (
had_brr_t
 *
__
)

1095 
__THROW
 
	`__nnu
 ((1));

1098 
	$had_brr_deroy
 (
had_brr_t
 *
__
)

1099 
__THROW
 
	`__nnu
 ((1));

1102 
	$had_brr_gpshed
 (cڡ 
had_brr_t
 *

1103 
__ri
 
__
,

1104 *
__ri
 
__pshed
)

1105 
__THROW
 
	`__nnu
 ((1, 2));

1108 
	$had_brr_shed
 (
had_brr_t
 *
__
,

1109 
__pshed
)

1110 
__THROW
 
	`__nnu
 ((1));

1122 
	`had_key_
 (
had_key_t
 *
__key
,

1123 (*
__der_funi
) (*))

1124 
__THROW
 
	`__nnu
 ((1));

1127 
	$had_key_de
 (
had_key_t
 
__key

__THROW
;

1130 *
	$had_gecific
 (
had_key_t
 
__key

__THROW
;

1133 
	$had_tecific
 (
had_key_t
 
__key
,

1134 cڡ *
__por

__THROW
 ;

1137 #ifde
__USE_XOPEN2K


1139 
	$had_guockid
 (
had_t
 
__thad_id
,

1140 
__ockid_t
 *
__ock_id
)

1141 
__THROW
 
	`__nnu
 ((2));

1156 
	`had_fk
 ((*
__e
) (),

1157 (*
__
) (),

1158 (*
__chd
()
__THROW
;

1161 #ifde
__USE_EXTERN_INLINES


1163 
__ex_le
 

1164 
	`__NTH
 (
	$had_equ
 (
had_t
 
__thad1
,thad_
__thad2
))

1166  
__thad1
 =
__thad2
;

1167 
	}
}

1170 
	g__END_DECLS


	@/usr/include/sched.h

19 #idef 
_SCHED_H


20 
	#_SCHED_H
 1

	)

22 
	~<us.h
>

25 
	~<bs/tys.h
>

27 
	#__ed_size_t


	)

28 
	~<ddef.h
>

30 
	#__ed_time_t


	)

31 
	#__ed_timeec


	)

32 
	~<time.h
>

34 #ide
__pid_t_defed


35 
__pid_t
 
	tpid_t
;

36 
	#__pid_t_defed


	)

41 
	~<bs/sched.h
>

43 
	#sched_iܙy
 
__sched_iܙy


	)

46 
__BEGIN_DECLS


49 
	$sched_am
 (
__pid_t
 
__pid
, cڡ 
sched_m
 *
__m
)

50 
__THROW
;

53 
	$sched_gm
 (
__pid_t
 
__pid
, 
sched_m
 *
__m

__THROW
;

56 
	$sched_tschedur
 (
__pid_t
 
__pid
, 
__picy
,

57 cڡ 
sched_m
 *
__m

__THROW
;

60 
	$sched_gschedur
 (
__pid_t
 
__pid

__THROW
;

63 
	$sched_yld
 (
__THROW
;

66 
	$sched_g_iܙy_max
 (
__gܙhm

__THROW
;

69 
	$sched_g_iܙy_m
 (
__gܙhm

__THROW
;

72 
	$sched__g_rv
 (
__pid_t
 
__pid
, 
timeec
 *
__t

__THROW
;

75 #ifde
__USE_GNU


77 
	#CPU_SETSIZE
 
__CPU_SETSIZE


	)

78 
	#CPU_SET
(
u
, 
u

	`__CPU_SET_S
 (u,  (
u_t_t
), cpu)

	)

79 
	#CPU_CLR
(
u
, 
u

	`__CPU_CLR_S
 (u,  (
u_t_t
), cpu)

	)

80 
	#CPU_ISSET
(
u
, 
u

	`__CPU_ISSET_S
 (u,  (
u_t_t
), \

81 
u
)

	)

82 
	#CPU_ZERO
(
u

	`__CPU_ZERO_S
 ( (
u_t_t
), cpu)

	)

83 
	#CPU_COUNT
(
u

	`__CPU_COUNT_S
 ( (
u_t_t
), cpu)

	)

85 
	#CPU_SET_S
(
u
, 
tsize
, 
u

	`__CPU_SET_S
 (u, ssize, cpu)

	)

86 
	#CPU_CLR_S
(
u
, 
tsize
, 
u

	`__CPU_CLR_S
 (u, ssize, cpu)

	)

87 
	#CPU_ISSET_S
(
u
, 
tsize
, 
u

	`__CPU_ISSET_S
 (cpu, setsize, \

88 
u
)

	)

89 
	#CPU_ZERO_S
(
tsize
, 
u

	`__CPU_ZERO_S
 (tsize, cpu)

	)

90 
	#CPU_COUNT_S
(
tsize
, 
u

	`__CPU_COUNT_S
 (tsize, cpu)

	)

92 
	#CPU_EQUAL
(
u1
, 
u2
) \

93 
	`__CPU_EQUAL_S
 ( (
u_t_t
), 
u1
, 
u2
)

	)

94 
	#CPU_EQUAL_S
(
tsize
, 
u1
, 
u2
) \

95 
	`__CPU_EQUAL_S
 (
tsize
, 
u1
, 
u2
)

	)

97 
	#CPU_AND
(
det
, 
ct1
, 
ct2
) \

98 
	`__CPU_OP_S
 ( (
u_t_t
), 
det
, 
ct1
, 
ct2
, &)

	)

99 
	#CPU_OR
(
det
, 
ct1
, 
ct2
) \

100 
	`__CPU_OP_S
 ( (
u_t_t
), 
det
, 
ct1
, 
ct2
, |)

	)

101 
	#CPU_XOR
(
det
, 
ct1
, 
ct2
) \

102 
	`__CPU_OP_S
 ( (
u_t_t
), 
det
, 
ct1
, 
ct2
, ^)

	)

103 
	#CPU_AND_S
(
tsize
, 
det
, 
ct1
, 
ct2
) \

104 
	`__CPU_OP_S
 (
tsize
, 
det
, 
ct1
, 
ct2
, &)

	)

105 
	#CPU_OR_S
(
tsize
, 
det
, 
ct1
, 
ct2
) \

106 
	`__CPU_OP_S
 (
tsize
, 
det
, 
ct1
, 
ct2
, |)

	)

107 
	#CPU_XOR_S
(
tsize
, 
det
, 
ct1
, 
ct2
) \

108 
	`__CPU_OP_S
 (
tsize
, 
det
, 
ct1
, 
ct2
, ^)

	)

110 
	#CPU_ALLOC_SIZE
(
cou

	`__CPU_ALLOC_SIZE
 (cou)

	)

111 
	#CPU_ALLOC
(
cou

	`__CPU_ALLOC
 (cou)

	)

112 
	#CPU_FREE
(
ut

	`__CPU_FREE
 (ut)

	)

116 
	$sched_ffy
 (
__pid_t
 
__pid
, 
size_t
 
__utsize
,

117 cڡ 
u_t_t
 *
__ut

__THROW
;

120 
	$sched_gaffy
 (
__pid_t
 
__pid
, 
size_t
 
__utsize
,

121 
u_t_t
 *
__ut

__THROW
;

124 
__END_DECLS


	@/usr/include/signal.h

22 #idef 
_SIGNAL_H


24 #i!
defed
 
__ed_sig_omic_t
 && !defed 
__ed_sigt_t


25 
	#_SIGNAL_H


	)

28 
	~<us.h
>

30 
	g__BEGIN_DECLS


32 
	~<bs/sigt.h
>

36 #i
defed
 
__ed_sig_omic_t
 || defed 
_SIGNAL_H


37 #ide
__sig_omic_t_defed


38 
	#__sig_omic_t_defed


	)

39 
__BEGIN_NAMESPACE_STD


40 
__sig_omic_t
 
	tsig_omic_t
;

41 
	g__END_NAMESPACE_STD


43 #unde
__ed_sig_omic_t


46 #i
defed
 
__ed_sigt_t
 || (defed 
_SIGNAL_H
 && defed 
__USE_POSIX
)

47 #ide
__sigt_t_defed


48 
	#__sigt_t_defed


	)

49 
__sigt_t
 
	tsigt_t
;

51 #unde
__ed_sigt_t


54 #ifde
_SIGNAL_H


56 
	~<bs/tys.h
>

57 
	~<bs/signum.h
>

59 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K


60 #ide
__pid_t_defed


61 
__pid_t
 
	tpid_t
;

62 
	#__pid_t_defed


	)

64 #ifde
__USE_XOPEN


66 #ide
__uid_t_defed


67 
__uid_t
 
	tuid_t
;

68 
	#__uid_t_defed


	)

72 #ifde
__USE_POSIX199309


74 
	#__ed_timeec


	)

75 
	~<time.h
>

78 #i
defed
 
__USE_POSIX199309
 || defed 
__USE_XOPEN_EXTENDED


80 
	~<bs/sigfo.h
>

85 (*
	t__sighdr_t
) ();

90 
__sighdr_t
 
	$__sysv_sigl
 (
__sig
, 
__sighdr_t
 
__hdr
)

91 
__THROW
;

92 #ifde
__USE_GNU


93 
__sighdr_t
 
	$sysv_sigl
 (
__sig
, 
__sighdr_t
 
__hdr
)

94 
__THROW
;

100 
__BEGIN_NAMESPACE_STD


101 #ifde
__USE_BSD


102 
__sighdr_t
 
	$sigl
 (
__sig
, 
__sighdr_t
 
__hdr
)

103 
__THROW
;

106 #ifde
__REDIRECT_NTH


107 
__sighdr_t
 
	`__REDIRECT_NTH
 (
sigl
,

108 (
__sig
, 
__sighdr_t
 
__hdr
),

109 
__sysv_sigl
);

111 
	#sigl
 
__sysv_sigl


	)

114 
__END_NAMESPACE_STD


116 #ifde
__USE_XOPEN


119 
__sighdr_t
 
	$bsd_sigl
 (
__sig
, 
__sighdr_t
 
__hdr
)

120 
__THROW
;

126 #ifde
__USE_POSIX


127 
	$kl
 (
__pid_t
 
__pid
, 
__sig

__THROW
;

130 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


134 
	$kg
 (
__pid_t
 
__pg
, 
__sig

__THROW
;

137 
__BEGIN_NAMESPACE_STD


139 
	$i
 (
__sig

__THROW
;

140 
__END_NAMESPACE_STD


142 #ifde
__USE_SVID


144 
__sighdr_t
 
	$ssigl
 (
__sig
, 
__sighdr_t
 
__hdr
)

145 
__THROW
;

146 
	$gsigl
 (
__sig

__THROW
;

149 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN2K


151 
	`psigl
 (
__sig
, cڡ *
__s
);

154 #ifde
__USE_XOPEN2K


156 
	`psigfo
 (cڡ 
sigfo_t
 *
__pfo
, cڡ *
__s
);

167 
	`__sigu
 (
__sig__mask
, 
__is_sig
);

169 #ifde
__USE_XOPEN


170 #ifde
__GNUC__


171 
	$sigu
 (
__sig

	`__asm__
 ("__xpg_sigpause");

174 
	#sigu
(
sig

	`__sigu
 ((sig), 1)

	)

179 #ifde
__USE_BSD


186 
	#sigmask
(
sig

	`__sigmask
(sig)

	)

189 
	$sigblock
 (
__mask

__THROW
 
__ibu_dd__
;

192 
	$sigtmask
 (
__mask

__THROW
 
__ibu_dd__
;

195 
	$siggmask
 (
__THROW
 
__ibu_dd__
;

199 #ifde
__USE_MISC


200 
	#NSIG
 
_NSIG


	)

203 #ifde
__USE_GNU


204 
__sighdr_t
 
	tsighdr_t
;

208 #ifde
__USE_BSD


209 
__sighdr_t
 
	tsig_t
;

212 #ifde
__USE_POSIX


215 
	$sigemyt
 (
sigt_t
 *
__t

__THROW
 
	`__nnu
 ((1));

218 
	$sigflt
 (
sigt_t
 *
__t

__THROW
 
	`__nnu
 ((1));

221 
	$sigaddt
 (
sigt_t
 *
__t
, 
__signo

__THROW
 
	`__nnu
 ((1));

224 
	$sigdt
 (
sigt_t
 *
__t
, 
__signo

__THROW
 
	`__nnu
 ((1));

227 
	$sigismemb
 (cڡ 
sigt_t
 *
__t
, 
__signo
)

228 
__THROW
 
	`__nnu
 ((1));

230 #ifde
__USE_GNU


232 
	$sigimyt
 (cڡ 
sigt_t
 *
__t

__THROW
 
	`__nnu
 ((1));

235 
	$sigdt
 (
sigt_t
 *
__t
, cڡ sigt_*
__
,

236 cڡ 
sigt_t
 *
__right

__THROW
 
	`__nnu
 ((1, 2, 3));

239 
	$sigܣt
 (
sigt_t
 *
__t
, cڡ sigt_*
__
,

240 cڡ 
sigt_t
 *
__right

__THROW
 
	`__nnu
 ((1, 2, 3));

245 
	~<bs/sigai.h
>

248 
	$sigocmask
 (
__how
, cڡ 
sigt_t
 *
__ri
 
__t
,

249 
sigt_t
 *
__ri
 
__ot

__THROW
;

256 
	$sigsud
 (cڡ 
sigt_t
 *
__t

	`__nnu
 ((1));

259 
	$sigai
 (
__sig
, cڡ 
sigai
 *
__ri
 
__a
,

260 
sigai
 *
__ri
 
__

__THROW
;

263 
	$signdg
 (
sigt_t
 *
__t

__THROW
 
	`__nnu
 ((1));

270 
	$sigwa
 (cڡ 
sigt_t
 *
__ri
 
__t
, *__ri 
__sig
)

271 
	`__nnu
 ((1, 2));

273 #ifde
__USE_POSIX199309


278 
	$sigwafo
 (cڡ 
sigt_t
 *
__ri
 
__t
,

279 
sigfo_t
 *
__ri
 
__fo

	`__nnu
 ((1));

286 
	$sigtimedwa
 (cڡ 
sigt_t
 *
__ri
 
__t
,

287 
sigfo_t
 *
__ri
 
__fo
,

288 cڡ 
timeec
 *
__ri
 
__timeout
)

289 
	`__nnu
 ((1));

293 
	$sigqueue
 (
__pid_t
 
__pid
, 
__sig
, cڡ 
sigv
 
__v
)

294 
__THROW
;

299 #ifde
__USE_BSD


303 cڡ *cڡ 
_sys_sigli
[
_NSIG
];

304 cڡ *cڡ 
sys_sigli
[
_NSIG
];

307 
	ssigvec


309 
__sighdr_t
 
sv_hdr
;

310 
sv_mask
;

312 
sv_ags
;

313 
	#sv_ڡack
 
sv_ags


	)

317 
	#SV_ONSTACK
 (1 << 0)

	)

318 
	#SV_INTERRUPT
 (1 << 1)

	)

319 
	#SV_RESETHAND
 (1 << 2)

	)

327 
	$sigvec
 (
__sig
, cڡ 
sigvec
 *
__vec
,

328 
sigvec
 *
__ovec

__THROW
;

332 
	~<bs/sigcڋxt.h
>

335 
	$sigtu
 (
sigcڋxt
 *
__s

__THROW
;

340 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K8


341 
	#__ed_size_t


	)

342 
	~<ddef.h
>

347 
	$sigu
 (
__sig
, 
__u

__THROW
;

349 
	~<bs/sigack.h
>

350 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8


352 
	~<sys/ucڋxt.h
>

358 
	$sigack
 (
sigack
 *
__ss
, sigack *
__oss
)

359 
__THROW
 
__ibu_dd__
;

363 
	$sigtack
 (cڡ 
sigtack
 *
__ri
 
__ss
,

364 
sigtack
 *
__ri
 
__oss

__THROW
;

368 #ifde
__USE_XOPEN_EXTENDED


372 
	$sighd
 (
__sig

__THROW
;

375 
	$sigl
 (
__sig

__THROW
;

378 
	$sigigne
 (
__sig

__THROW
;

381 
__sighdr_t
 
	$sigt
 (
__sig
, 
__sighdr_t
 
__di

__THROW
;

384 #i
defed
 
__USE_POSIX199506
 || defed 
__USE_UNIX98


387 
	~<bs/hadtys.h
>

388 
	~<bs/sigthad.h
>

395 
	$__libc_cut_sigm
 (
__THROW
;

397 
	$__libc_cut_sigmax
 (
__THROW
;

401 
__END_DECLS


	@/usr/include/stdint.h

22 #ide
_STDINT_H


23 
	#_STDINT_H
 1

	)

25 
	~<us.h
>

26 
	~<bs/wch.h
>

27 
	~<bs/wdsize.h
>

34 #ide
__t8_t_defed


35 
	#__t8_t_defed


	)

36 sigd 
	tt8_t
;

37 
	tt16_t
;

38 
	tt32_t
;

39 #i
__WORDSIZE
 == 64

40 
	tt64_t
;

42 
__exnsi__


43 
	tt64_t
;

48 
	tut8_t
;

49 
	tut16_t
;

50 #ide
__ut32_t_defed


51 
	tut32_t
;

52 
	#__ut32_t_defed


	)

54 #i
__WORDSIZE
 == 64

55 
	tut64_t
;

57 
__exnsi__


58 
	tut64_t
;

65 sigd 
	tt_a8_t
;

66 
	tt_a16_t
;

67 
	tt_a32_t
;

68 #i
__WORDSIZE
 == 64

69 
	tt_a64_t
;

71 
__exnsi__


72 
	tt_a64_t
;

76 
	tut_a8_t
;

77 
	tut_a16_t
;

78 
	tut_a32_t
;

79 #i
__WORDSIZE
 == 64

80 
	tut_a64_t
;

82 
__exnsi__


83 
	tut_a64_t
;

90 sigd 
	tt_8_t
;

91 #i
__WORDSIZE
 == 64

92 
	tt_16_t
;

93 
	tt_32_t
;

94 
	tt_64_t
;

96 
	tt_16_t
;

97 
	tt_32_t
;

98 
__exnsi__


99 
	tt_64_t
;

103 
	tut_8_t
;

104 #i
__WORDSIZE
 == 64

105 
	tut_16_t
;

106 
	tut_32_t
;

107 
	tut_64_t
;

109 
	tut_16_t
;

110 
	tut_32_t
;

111 
__exnsi__


112 
	tut_64_t
;

117 #i
__WORDSIZE
 == 64

118 #ide
___t_defed


119 
	t_t
;

120 
	#___t_defed


	)

122 
	tu_t
;

124 #ide
___t_defed


125 
	t_t
;

126 
	#___t_defed


	)

128 
	tu_t
;

133 #i
__WORDSIZE
 == 64

134 
	ttmax_t
;

135 
	tutmax_t
;

137 
__exnsi__


138 
	ttmax_t
;

139 
__exnsi__


140 
	tutmax_t
;

144 #i
__WORDSIZE
 == 64

145 
	#__INT64_C
(
c
## 
L


	)

146 
	#__UINT64_C
(
c
## 
UL


	)

148 
	#__INT64_C
(
c
## 
LL


	)

149 
	#__UINT64_C
(
c
## 
ULL


	)

155 
	#INT8_MIN
 (-128)

	)

156 
	#INT16_MIN
 (-32767-1)

	)

157 
	#INT32_MIN
 (-2147483647-1)

	)

158 
	#INT64_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

160 
	#INT8_MAX
 (127)

	)

161 
	#INT16_MAX
 (32767)

	)

162 
	#INT32_MAX
 (2147483647)

	)

163 
	#INT64_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

166 
	#UINT8_MAX
 (255)

	)

167 
	#UINT16_MAX
 (65535)

	)

168 
	#UINT32_MAX
 (4294967295U)

	)

169 
	#UINT64_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

173 
	#INT_LEAST8_MIN
 (-128)

	)

174 
	#INT_LEAST16_MIN
 (-32767-1)

	)

175 
	#INT_LEAST32_MIN
 (-2147483647-1)

	)

176 
	#INT_LEAST64_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

178 
	#INT_LEAST8_MAX
 (127)

	)

179 
	#INT_LEAST16_MAX
 (32767)

	)

180 
	#INT_LEAST32_MAX
 (2147483647)

	)

181 
	#INT_LEAST64_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

184 
	#UINT_LEAST8_MAX
 (255)

	)

185 
	#UINT_LEAST16_MAX
 (65535)

	)

186 
	#UINT_LEAST32_MAX
 (4294967295U)

	)

187 
	#UINT_LEAST64_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

191 
	#INT_FAST8_MIN
 (-128)

	)

192 #i
__WORDSIZE
 == 64

193 
	#INT_FAST16_MIN
 (-9223372036854775807L-1)

	)

194 
	#INT_FAST32_MIN
 (-9223372036854775807L-1)

	)

196 
	#INT_FAST16_MIN
 (-2147483647-1)

	)

197 
	#INT_FAST32_MIN
 (-2147483647-1)

	)

199 
	#INT_FAST64_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

201 
	#INT_FAST8_MAX
 (127)

	)

202 #i
__WORDSIZE
 == 64

203 
	#INT_FAST16_MAX
 (9223372036854775807L)

	)

204 
	#INT_FAST32_MAX
 (9223372036854775807L)

	)

206 
	#INT_FAST16_MAX
 (2147483647)

	)

207 
	#INT_FAST32_MAX
 (2147483647)

	)

209 
	#INT_FAST64_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

212 
	#UINT_FAST8_MAX
 (255)

	)

213 #i
__WORDSIZE
 == 64

214 
	#UINT_FAST16_MAX
 (18446744073709551615UL)

	)

215 
	#UINT_FAST32_MAX
 (18446744073709551615UL)

	)

217 
	#UINT_FAST16_MAX
 (4294967295U)

	)

218 
	#UINT_FAST32_MAX
 (4294967295U)

	)

220 
	#UINT_FAST64_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

224 #i
__WORDSIZE
 == 64

225 
	#INTPTR_MIN
 (-9223372036854775807L-1)

	)

226 
	#INTPTR_MAX
 (9223372036854775807L)

	)

227 
	#UINTPTR_MAX
 (18446744073709551615UL)

	)

229 
	#INTPTR_MIN
 (-2147483647-1)

	)

230 
	#INTPTR_MAX
 (2147483647)

	)

231 
	#UINTPTR_MAX
 (4294967295U)

	)

236 
	#INTMAX_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

238 
	#INTMAX_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

241 
	#UINTMAX_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

247 #i
__WORDSIZE
 == 64

248 
	#PTRDIFF_MIN
 (-9223372036854775807L-1)

	)

249 
	#PTRDIFF_MAX
 (9223372036854775807L)

	)

251 
	#PTRDIFF_MIN
 (-2147483647-1)

	)

252 
	#PTRDIFF_MAX
 (2147483647)

	)

256 
	#SIG_ATOMIC_MIN
 (-2147483647-1)

	)

257 
	#SIG_ATOMIC_MAX
 (2147483647)

	)

260 #i
__WORDSIZE
 == 64

261 
	#SIZE_MAX
 (18446744073709551615UL)

	)

263 
	#SIZE_MAX
 (4294967295U)

	)

267 #ide
WCHAR_MIN


269 
	#WCHAR_MIN
 
__WCHAR_MIN


	)

270 
	#WCHAR_MAX
 
__WCHAR_MAX


	)

274 
	#WINT_MIN
 (0u)

	)

275 
	#WINT_MAX
 (4294967295u)

	)

278 
	#INT8_C
(
c

	)
c

279 
	#INT16_C
(
c

	)
c

280 
	#INT32_C
(
c

	)
c

281 #i
__WORDSIZE
 == 64

282 
	#INT64_C
(
c
## 
L


	)

284 
	#INT64_C
(
c
## 
LL


	)

288 
	#UINT8_C
(
c

	)
c

289 
	#UINT16_C
(
c

	)
c

290 
	#UINT32_C
(
c
## 
U


	)

291 #i
__WORDSIZE
 == 64

292 
	#UINT64_C
(
c
## 
UL


	)

294 
	#UINT64_C
(
c
## 
ULL


	)

298 #i
__WORDSIZE
 == 64

299 
	#INTMAX_C
(
c
## 
L


	)

300 
	#UINTMAX_C
(
c
## 
UL


	)

302 
	#INTMAX_C
(
c
## 
LL


	)

303 
	#UINTMAX_C
(
c
## 
ULL


	)

	@/usr/include/stdio.h

23 #ide
_STDIO_H


25 #i!
defed
 
__ed_FILE
 && !defed 
__ed___FILE


26 
	#_STDIO_H
 1

	)

27 
	~<us.h
>

29 
	g__BEGIN_DECLS


31 
	#__ed_size_t


	)

32 
	#__ed_NULL


	)

33 
	~<ddef.h
>

35 
	~<bs/tys.h
>

36 
	#__ed_FILE


	)

37 
	#__ed___FILE


	)

41 #i!
defed
 
__FILE_defed
 && defed 
__ed_FILE


44 
	g_IO_FILE
;

46 
__BEGIN_NAMESPACE_STD


48 
_IO_FILE
 
	tFILE
;

49 
	g__END_NAMESPACE_STD


50 #i
defed
 
__USE_LARGEFILE64
 || defed 
__USE_SVID
 || defed 
__USE_POSIX
 \

51 || 
defed
 
	g__USE_BSD
 || defed 
	g__USE_ISOC99
 || defed 
	g__USE_XOPEN
 \

52 || 
defed
 
__USE_POSIX2


53 
	$__USING_NAMESPACE_STD
(
FILE
)

56 
	#__FILE_defed
 1

	)

58 #unde
__ed_FILE


61 #i!
defed
 
____FILE_defed
 && defed 
__ed___FILE


64 
_IO_FILE
 
	t__FILE
;

66 
	#____FILE_defed
 1

	)

68 #unde
__ed___FILE


71 #ifdef 
_STDIO_H


72 
	#_STDIO_USES_IOSTREAM


	)

74 
	~<libio.h
>

76 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8


77 #ifde
__GNUC__


78 #ide
_VA_LIST_DEFINED


79 
_G_va_li
 
	tva_li
;

80 
	#_VA_LIST_DEFINED


	)

83 
	~<dg.h
>

87 #ifde
__USE_XOPEN2K8


88 #ide
__off_t_defed


89 #ide
__USE_FILE_OFFSET64


90 
__off_t
 
	toff_t
;

92 
__off64_t
 
	toff_t
;

94 
	#__off_t_defed


	)

96 #i
defed
 
__USE_LARGEFILE64
 && !defed 
__off64_t_defed


97 
__off64_t
 
	toff64_t
;

98 
	#__off64_t_defed


	)

101 #ide
__ssize_t_defed


102 
__ssize_t
 
	tssize_t
;

103 
	#__ssize_t_defed


	)

108 
__BEGIN_NAMESPACE_STD


109 #ide
__USE_FILE_OFFSET64


110 
_G_os_t
 
	tos_t
;

112 
_G_os64_t
 
	tos_t
;

114 
__END_NAMESPACE_STD


115 #ifde
__USE_LARGEFILE64


116 
_G_os64_t
 
	tos64_t
;

120 
	#_IOFBF
 0

	)

121 
	#_IOLBF
 1

	)

122 
	#_IONBF
 2

	)

126 #ide
BUFSIZ


127 
	#BUFSIZ
 
_IO_BUFSIZ


	)

133 #ide
EOF


134 
	#EOF
 (-1)

	)

140 
	#SEEK_SET
 0

	)

141 
	#SEEK_CUR
 1

	)

142 
	#SEEK_END
 2

	)

143 #ifde
__USE_GNU


144 
	#SEEK_DATA
 3

	)

145 
	#SEEK_HOLE
 4

	)

149 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN


151 
	#P_tmpd
 "/tmp"

	)

164 
	~<bs/dio_lim.h
>

168 
_IO_FILE
 *
d
;

169 
_IO_FILE
 *
dout
;

170 
_IO_FILE
 *
dr
;

172 
	#d
 
d


	)

173 
	#dout
 
dout


	)

174 
	#dr
 
dr


	)

176 
__BEGIN_NAMESPACE_STD


178 
	$move
 (cڡ *
__fame

__THROW
;

180 
	$me
 (cڡ *
__d
, cڡ *
__w

__THROW
;

181 
__END_NAMESPACE_STD


183 #ifde
__USE_ATFILE


185 
	$mt
 (
__dfd
, cڡ *
__d
, 
__wfd
,

186 cڡ *
__w

__THROW
;

189 
__BEGIN_NAMESPACE_STD


194 #ide
__USE_FILE_OFFSET64


195 
FILE
 *
	$tmpfe
 (
__wur
;

197 #ifde
__REDIRECT


198 
FILE
 *
	`__REDIRECT
 (
tmpfe
, (), 
tmpfe64

__wur
;

200 
	#tmpfe
 
tmpfe64


	)

204 #ifde
__USE_LARGEFILE64


205 
FILE
 *
	$tmpfe64
 (
__wur
;

209 *
	$tmam
 (*
__s

__THROW
 
__wur
;

210 
__END_NAMESPACE_STD


212 #ifde
__USE_MISC


215 *
	$tmam_r
 (*
__s

__THROW
 
__wur
;

219 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN


227 *
	$mam
 (cڡ *
__d
, cڡ *
__pfx
)

228 
__THROW
 
__ibu_mloc__
 
__wur
;

232 
__BEGIN_NAMESPACE_STD


237 
	`fo
 (
FILE
 *
__am
);

242 
	`fush
 (
FILE
 *
__am
);

243 
__END_NAMESPACE_STD


245 #ifde
__USE_MISC


252 
	`fush_uocked
 (
FILE
 *
__am
);

255 #ifde
__USE_GNU


262 
	`fol
 ();

266 
__BEGIN_NAMESPACE_STD


267 #ide
__USE_FILE_OFFSET64


272 
FILE
 *
	$fݒ
 (cڡ *
__ri
 
__fame
,

273 cڡ *
__ri
 
__modes

__wur
;

278 
FILE
 *
	$eݒ
 (cڡ *
__ri
 
__fame
,

279 cڡ *
__ri
 
__modes
,

280 
FILE
 *
__ri
 
__am

__wur
;

282 #ifde
__REDIRECT


283 
FILE
 *
	`__REDIRECT
 (
fݒ
, (cڡ *
__ri
 
__fame
,

284 cڡ *
__ri
 
__modes
), 
fݒ64
)

285 
__wur
;

286 
FILE
 *
	`__REDIRECT
 (
eݒ
, (cڡ *
__ri
 
__fame
,

287 cڡ *
__ri
 
__modes
,

288 
FILE
 *
__ri
 
__am
), 
eݒ64
)

289 
__wur
;

291 
	#fݒ
 
fݒ64


	)

292 
	#eݒ
 
eݒ64


	)

295 
__END_NAMESPACE_STD


296 #ifde
__USE_LARGEFILE64


297 
FILE
 *
	$fݒ64
 (cڡ *
__ri
 
__fame
,

298 cڡ *
__ri
 
__modes

__wur
;

299 
FILE
 *
	$eݒ64
 (cڡ *
__ri
 
__fame
,

300 cڡ *
__ri
 
__modes
,

301 
FILE
 *
__ri
 
__am

__wur
;

304 #ifdef 
__USE_POSIX


306 
FILE
 *
	$fdݒ
 (
__fd
, cڡ *
__modes

__THROW
 
__wur
;

309 #ifdef 
__USE_GNU


312 
FILE
 *
	$fݒcook
 (*
__ri
 
__magic_cook
,

313 cڡ *
__ri
 
__modes
,

314 
_IO_cook_io_funis_t
 
__io_funcs

__THROW
 
__wur
;

317 #ifde
__USE_XOPEN2K8


319 
FILE
 *
	$fmemݒ
 (*
__s
, 
size_t
 
__n
, cڡ *
__modes
)

320 
__THROW
 
__wur
;

325 
FILE
 *
	$ݒ_memam
 (**
__buoc
, 
size_t
 *
__sizoc

__THROW
 
__wur
;

329 
__BEGIN_NAMESPACE_STD


332 
	$tbuf
 (
FILE
 *
__ri
 
__am
, *__ri 
__buf

__THROW
;

336 
	$tvbuf
 (
FILE
 *
__ri
 
__am
, *__ri 
__buf
,

337 
__modes
, 
size_t
 
__n

__THROW
;

338 
__END_NAMESPACE_STD


340 #ifdef 
__USE_BSD


343 
	$tbufr
 (
FILE
 *
__ri
 
__am
, *__ri 
__buf
,

344 
size_t
 
__size

__THROW
;

347 
	$ebuf
 (
FILE
 *
__am

__THROW
;

351 
__BEGIN_NAMESPACE_STD


356 
	`rtf
 (
FILE
 *
__ri
 
__am
,

357 cڡ *
__ri
 
__fm
, ...);

362 
	`tf
 (cڡ *
__ri
 
__fm
, ...);

364 
	$rtf
 (*
__ri
 
__s
,

365 cڡ *
__ri
 
__fm
, ...
__THROWNL
;

371 
	`vrtf
 (
FILE
 *
__ri
 
__s
, cڡ *__ri 
__fm
,

372 
_G_va_li
 
__g
);

377 
	`vtf
 (cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
);

379 
	$vrtf
 (*
__ri
 
__s
, cڡ *__ri 
__fm
,

380 
_G_va_li
 
__g

__THROWNL
;

381 
__END_NAMESPACE_STD


383 #i
defed
 
__USE_BSD
 || defed 
__USE_ISOC99
 || defed 
__USE_UNIX98


384 
__BEGIN_NAMESPACE_C99


386 
	$tf
 (*
__ri
 
__s
, 
size_t
 
__maxn
,

387 cڡ *
__ri
 
__fm
, ...)

388 
__THROWNL
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 4)));

390 
	$vtf
 (*
__ri
 
__s
, 
size_t
 
__maxn
,

391 cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
)

392 
__THROWNL
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 0)));

393 
__END_NAMESPACE_C99


396 #ifde
__USE_GNU


399 
	$vartf
 (**
__ri
 
__r
, cڡ *__ri 
__f
,

400 
_G_va_li
 
__g
)

401 
__THROWNL
 
	`__ibu__
 ((
	$__fm__
 (
__tf__
, 2, 0))
__wur
;

402 
	$__artf
 (**
__ri
 
__r
,

403 cڡ *
__ri
 
__fmt
, ...)

404 
__THROWNL
 
	`__ibu__
 ((
	$__fm__
 (
__tf__
, 2, 3))
__wur
;

405 
	$artf
 (**
__ri
 
__r
,

406 cڡ *
__ri
 
__fmt
, ...)

407 
__THROWNL
 
	`__ibu__
 ((
	$__fm__
 (
__tf__
, 2, 3))
__wur
;

410 #ifde
__USE_XOPEN2K8


412 
	$vdtf
 (
__fd
, cڡ *
__ri
 
__fmt
,

413 
_G_va_li
 
__g
)

414 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 2, 0)));

415 
	$dtf
 (
__fd
, cڡ *
__ri
 
__fmt
, ...)

416 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 2, 3)));

420 
__BEGIN_NAMESPACE_STD


425 
	$fsnf
 (
FILE
 *
__ri
 
__am
,

426 cڡ *
__ri
 
__fm
, ...
__wur
;

431 
	$snf
 (cڡ *
__ri
 
__fm
, ...
__wur
;

433 
	$ssnf
 (cڡ *
__ri
 
__s
,

434 cڡ *
__ri
 
__fm
, ...
__THROW
;

436 #i
defed
 
__USE_ISOC99
 && !defed 
__USE_GNU
 \

437 && (!
defed
 
__LDBL_COMPAT
 || !defed 
__REDIRECT
) \

438 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

439 #ifde
__REDIRECT


443 
	`__REDIRECT
 (
fsnf
, (
FILE
 *
__ri
 
__am
,

444 cڡ *
__ri
 
__fm
, ...),

445 
__isoc99_fsnf

__wur
;

446 
	`__REDIRECT
 (
snf
, (cڡ *
__ri
 
__fm
, ...),

447 
__isoc99_snf

__wur
;

448 
	`__REDIRECT_NTH
 (
ssnf
, (cڡ *
__ri
 
__s
,

449 cڡ *
__ri
 
__fm
, ...),

450 
__isoc99_ssnf
);

452 
	$__isoc99_fsnf
 (
FILE
 *
__ri
 
__am
,

453 cڡ *
__ri
 
__fm
, ...
__wur
;

454 
	$__isoc99_snf
 (cڡ *
__ri
 
__fm
, ...
__wur
;

455 
	$__isoc99_ssnf
 (cڡ *
__ri
 
__s
,

456 cڡ *
__ri
 
__fm
, ...
__THROW
;

457 
	#fsnf
 
__isoc99_fsnf


	)

458 
	#snf
 
__isoc99_snf


	)

459 
	#ssnf
 
__isoc99_ssnf


	)

463 
__END_NAMESPACE_STD


465 #ifdef 
__USE_ISOC99


466 
__BEGIN_NAMESPACE_C99


471 
	$vfsnf
 (
FILE
 *
__ri
 
__s
, cڡ *__ri 
__fm
,

472 
_G_va_li
 
__g
)

473 
	`__ibu__
 ((
	$__fm__
 (
__snf__
, 2, 0))
__wur
;

479 
	$vsnf
 (cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
)

480 
	`__ibu__
 ((
	$__fm__
 (
__snf__
, 1, 0))
__wur
;

483 
	$vssnf
 (cڡ *
__ri
 
__s
,

484 cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
)

485 
__THROW
 
	`__ibu__
 ((
	`__fm__
 (
__snf__
, 2, 0)));

487 #i!
defed
 
__USE_GNU
 \

488 && (!
defed
 
__LDBL_COMPAT
 || !defed 
__REDIRECT
) \

489 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

490 #ifde
__REDIRECT


494 
	`__REDIRECT
 (
vfsnf
,

495 (
FILE
 *
__ri
 
__s
,

496 cڡ *
__ri
 
__fm
, 
_G_va_li
 
__g
),

497 
__isoc99_vfsnf
)

498 
	`__ibu__
 ((
	$__fm__
 (
__snf__
, 2, 0))
__wur
;

499 
	`__REDIRECT
 (
vsnf
, (cڡ *
__ri
 
__fm
,

500 
_G_va_li
 
__g
), 
__isoc99_vsnf
)

501 
	`__ibu__
 ((
	$__fm__
 (
__snf__
, 1, 0))
__wur
;

502 
	`__REDIRECT_NTH
 (
vssnf
,

503 (cڡ *
__ri
 
__s
,

504 cڡ *
__ri
 
__fm
,

505 
_G_va_li
 
__g
), 
__isoc99_vssnf
)

506 
	`__ibu__
 ((
	`__fm__
 (
__snf__
, 2, 0)));

508 
	$__isoc99_vfsnf
 (
FILE
 *
__ri
 
__s
,

509 cڡ *
__ri
 
__fm
,

510 
_G_va_li
 
__g

__wur
;

511 
	$__isoc99_vsnf
 (cڡ *
__ri
 
__fm
,

512 
_G_va_li
 
__g

__wur
;

513 
	$__isoc99_vssnf
 (cڡ *
__ri
 
__s
,

514 cڡ *
__ri
 
__fm
,

515 
_G_va_li
 
__g

__THROW
;

516 
	#vfsnf
 
__isoc99_vfsnf


	)

517 
	#vsnf
 
__isoc99_vsnf


	)

518 
	#vssnf
 
__isoc99_vssnf


	)

522 
__END_NAMESPACE_C99


526 
__BEGIN_NAMESPACE_STD


531 
	`fgc
 (
FILE
 *
__am
);

532 
	`gc
 (
FILE
 *
__am
);

538 
	`gch
 ();

539 
__END_NAMESPACE_STD


543 
	#gc
(
_

	`_IO_gc
 (_)

	)

545 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


550 
	`gc_uocked
 (
FILE
 *
__am
);

551 
	`gch_uocked
 ();

554 #ifde
__USE_MISC


561 
	`fgc_uocked
 (
FILE
 *
__am
);

565 
__BEGIN_NAMESPACE_STD


573 
	`utc
 (
__c
, 
FILE
 *
__am
);

574 
	`putc
 (
__c
, 
FILE
 *
__am
);

580 
	`putch
 (
__c
);

581 
__END_NAMESPACE_STD


585 
	#putc
(
_ch
, 
_

	`_IO_putc
 (_ch, _)

	)

587 #ifde
__USE_MISC


594 
	`utc_uocked
 (
__c
, 
FILE
 *
__am
);

597 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


602 
	`putc_uocked
 (
__c
, 
FILE
 *
__am
);

603 
	`putch_uocked
 (
__c
);

607 #i
defed
 
__USE_SVID
 || defed 
__USE_MISC
 \

608 || (
defed
 
__USE_XOPEN
 && !defed 
__USE_XOPEN2K
)

610 
	`gw
 (
FILE
 *
__am
);

613 
	`putw
 (
__w
, 
FILE
 *
__am
);

617 
__BEGIN_NAMESPACE_STD


622 *
	$fgs
 (*
__ri
 
__s
, 
__n
, 
FILE
 *__ri 
__am
)

623 
__wur
;

625 #i!
defed
 
__USE_ISOC11
 \

626 || (
defed
 
__lulus
 && __cplusplus <= 201103L)

638 *
	$gs
 (*
__s

__wur
 
__ibu_dd__
;

640 
__END_NAMESPACE_STD


642 #ifde
__USE_GNU


649 *
	$fgs_uocked
 (*
__ri
 
__s
, 
__n
,

650 
FILE
 *
__ri
 
__am

__wur
;

654 #ifdef 
__USE_XOPEN2K8


665 
_IO_ssize_t
 
	$__gdim
 (**
__ri
 
__l
,

666 
size_t
 *
__ri
 
__n
, 
__dim
,

667 
FILE
 *
__ri
 
__am

__wur
;

668 
_IO_ssize_t
 
	$gdim
 (**
__ri
 
__l
,

669 
size_t
 *
__ri
 
__n
, 
__dim
,

670 
FILE
 *
__ri
 
__am

__wur
;

678 
_IO_ssize_t
 
	$gle
 (**
__ri
 
__l
,

679 
size_t
 *
__ri
 
__n
,

680 
FILE
 *
__ri
 
__am

__wur
;

684 
__BEGIN_NAMESPACE_STD


689 
	`uts
 (cڡ *
__ri
 
__s
, 
FILE
 *__ri 
__am
);

695 
	`puts
 (cڡ *
__s
);

702 
	`ungc
 (
__c
, 
FILE
 *
__am
);

709 
size_t
 
	$d
 (*
__ri
 
__r
, 
size_t
 
__size
,

710 
size_t
 
__n
, 
FILE
 *
__ri
 
__am

__wur
;

715 
size_t
 
	`fwre
 (cڡ *
__ri
 
__r
, size_
__size
,

716 
size_t
 
__n
, 
FILE
 *
__ri
 
__s
);

717 
__END_NAMESPACE_STD


719 #ifde
__USE_GNU


726 
	`uts_uocked
 (cڡ *
__ri
 
__s
,

727 
FILE
 *
__ri
 
__am
);

730 #ifde
__USE_MISC


737 
size_t
 
	$d_uocked
 (*
__ri
 
__r
, 
size_t
 
__size
,

738 
size_t
 
__n
, 
FILE
 *
__ri
 
__am

__wur
;

739 
size_t
 
	`fwre_uocked
 (cڡ *
__ri
 
__r
, size_
__size
,

740 
size_t
 
__n
, 
FILE
 *
__ri
 
__am
);

744 
__BEGIN_NAMESPACE_STD


749 
	`fek
 (
FILE
 *
__am
, 
__off
, 
__wh
);

754 
	$l
 (
FILE
 *
__am

__wur
;

759 
	`wd
 (
FILE
 *
__am
);

760 
__END_NAMESPACE_STD


767 #i
defed
 
__USE_LARGEFILE
 || defed 
__USE_XOPEN2K


768 #ide
__USE_FILE_OFFSET64


773 
	`feko
 (
FILE
 *
__am
, 
__off_t
 
__off
, 
__wh
);

778 
__off_t
 
	$lo
 (
FILE
 *
__am

__wur
;

780 #ifde
__REDIRECT


781 
	`__REDIRECT
 (
feko
,

782 (
FILE
 *
__am
, 
__off64_t
 
__off
, 
__wh
),

783 
feko64
);

784 
__off64_t
 
	`__REDIRECT
 (
lo
, (
FILE
 *
__am
), 
lo64
);

786 
	#feko
 
feko64


	)

787 
	#lo
 
lo64


	)

792 
__BEGIN_NAMESPACE_STD


793 #ide
__USE_FILE_OFFSET64


798 
	`fgpos
 (
FILE
 *
__ri
 
__am
, 
os_t
 *__ri 
__pos
);

803 
	`fos
 (
FILE
 *
__am
, cڡ 
os_t
 *
__pos
);

805 #ifde
__REDIRECT


806 
	`__REDIRECT
 (
fgpos
, (
FILE
 *
__ri
 
__am
,

807 
os_t
 *
__ri
 
__pos
), 
fgpos64
);

808 
	`__REDIRECT
 (
fos
,

809 (
FILE
 *
__am
, cڡ 
os_t
 *
__pos
), 
fos64
);

811 
	#fgpos
 
fgpos64


	)

812 
	#fos
 
fos64


	)

815 
__END_NAMESPACE_STD


817 #ifde
__USE_LARGEFILE64


818 
	`feko64
 (
FILE
 *
__am
, 
__off64_t
 
__off
, 
__wh
);

819 
__off64_t
 
	$lo64
 (
FILE
 *
__am

__wur
;

820 
	`fgpos64
 (
FILE
 *
__ri
 
__am
, 
os64_t
 *__ri 
__pos
);

821 
	`fos64
 (
FILE
 *
__am
, cڡ 
os64_t
 *
__pos
);

824 
__BEGIN_NAMESPACE_STD


826 
	$
 (
FILE
 *
__am

__THROW
;

828 
	$of
 (
FILE
 *
__am

__THROW
 
__wur
;

830 
	$
 (
FILE
 *
__am

__THROW
 
__wur
;

831 
__END_NAMESPACE_STD


833 #ifde
__USE_MISC


835 
	$_uocked
 (
FILE
 *
__am

__THROW
;

836 
	$of_uocked
 (
FILE
 *
__am

__THROW
 
__wur
;

837 
	$_uocked
 (
FILE
 *
__am

__THROW
 
__wur
;

841 
__BEGIN_NAMESPACE_STD


846 
	`
 (cڡ *
__s
);

847 
__END_NAMESPACE_STD


853 
	~<bs/sys_i.h
>

856 #ifdef 
__USE_POSIX


858 
	$fo
 (
FILE
 *
__am

__THROW
 
__wur
;

861 #ifde
__USE_MISC


863 
	$fo_uocked
 (
FILE
 *
__am

__THROW
 
__wur
;

867 #i(
defed
 
__USE_POSIX2
 || defed 
__USE_SVID
 || defed 
__USE_BSD
 || \

868 
defed
 
__USE_MISC
)

873 
FILE
 *
	$pݒ
 (cڡ *
__commd
, cڡ *
__modes

__wur
;

879 
	`po
 (
FILE
 *
__am
);

883 #ifdef 
__USE_POSIX


885 *
	$mid
 (*
__s

__THROW
;

889 #ifde
__USE_XOPEN


891 *
	`curid
 (*
__s
);

895 #ifdef 
__USE_GNU


896 
oback
;

899 
	$oback_tf
 (
oback
 *
__ri
 
__oback
,

900 cڡ *
__ri
 
__fm
, ...)

901 
__THROWNL
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 2, 3)));

902 
	$oback_vtf
 (
oback
 *
__ri
 
__oback
,

903 cڡ *
__ri
 
__fm
,

904 
_G_va_li
 
__gs
)

905 
__THROWNL
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 2, 0)));

909 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


913 
	$ockfe
 (
FILE
 *
__am

__THROW
;

917 
	$rylockfe
 (
FILE
 *
__am

__THROW
 
__wur
;

920 
	$fuockfe
 (
FILE
 *
__am

__THROW
;

923 #i
defed
 
__USE_XOPEN
 && !defed 
__USE_XOPEN2K
 && !defed 
__USE_GNU


927 
	#__ed_gt


	)

928 
	~<gt.h
>

933 #ifde
__USE_EXTERN_INLINES


934 
	~<bs/dio.h
>

936 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ex_ways_le


937 
	~<bs/dio2.h
>

939 #ifde
__LDBL_COMPAT


940 
	~<bs/dio-ldbl.h
>

943 
__END_DECLS


	@/usr/include/stdlib.h

22 #idef 
_STDLIB_H


24 
	~<us.h
>

27 
	#__ed_size_t


	)

28 #ide
__ed_mloc_d_oc


29 
	#__ed_wch_t


	)

30 
	#__ed_NULL


	)

32 
	~<ddef.h
>

34 
	g__BEGIN_DECLS


36 #ide
__ed_mloc_d_oc


37 
	#_STDLIB_H
 1

	)

39 #i(
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8
&& !defed 
_SYS_WAIT_H


41 
	~<bs/waags.h
>

42 
	~<bs/waus.h
>

44 #ifde
__USE_BSD


49 #i
defed
 
__GNUC__
 && !defed 
__lulus


50 
	#__WAIT_INT
(
us
) \

51 (
	`__exnsi__
 (((uni { 
	`__tyof
(
us

__
; 
__i
; }) \

52 { .
__
 = (
us
}).
__i
))

	)

54 
	#__WAIT_INT
(
us
(*(*&(us))

	)

62 #i!
defed
 
__GNUC__
 || __GNUC__ < 2 || defed 
__lulus


63 
	#__WAIT_STATUS
 *

	)

64 
	#__WAIT_STATUS_DEFN
 *

	)

69 
wa
 *
	m__ur
;

70 *
	m__
;

71 } 
	t__WAIT_STATUS
 
	t__ibu__
 ((
	t__t_uni__
));

72 
	#__WAIT_STATUS_DEFN
 *

	)

77 
	#__WAIT_INT
(
us
(us)

	)

78 
	#__WAIT_STATUS
 *

	)

79 
	#__WAIT_STATUS_DEFN
 *

	)

84 
	#WEXITSTATUS
(
us

	`__WEXITSTATUS
 (
	`__WAIT_INT
 (us))

	)

85 
	#WTERMSIG
(
us

	`__WTERMSIG
 (
	`__WAIT_INT
 (us))

	)

86 
	#WSTOPSIG
(
us

	`__WSTOPSIG
 (
	`__WAIT_INT
 (us))

	)

87 
	#WIFEXITED
(
us

	`__WIFEXITED
 (
	`__WAIT_INT
 (us))

	)

88 
	#WIFSIGNALED
(
us

	`__WIFSIGNALED
 (
	`__WAIT_INT
 (us))

	)

89 
	#WIFSTOPPED
(
us

	`__WIFSTOPPED
 (
	`__WAIT_INT
 (us))

	)

90 #ifde
__WIFCONTINUED


91 
	#WIFCONTINUED
(
us

	`__WIFCONTINUED
 (
	`__WAIT_INT
 (us))

	)

95 
__BEGIN_NAMESPACE_STD


99 
	mqu
;

100 
	mm
;

101 } 
	tdiv_t
;

104 #ide
__ldiv_t_defed


107 
	mqu
;

108 
	mm
;

109 } 
	tldiv_t
;

110 
	#__ldiv_t_defed
 1

	)

112 
	g__END_NAMESPACE_STD


114 #i
defed
 
__USE_ISOC99
 && !defed 
__div_t_defed


115 
__BEGIN_NAMESPACE_C99


117 
__exnsi__
 struct

119 
	mqu
;

120 
	mm
;

121 } 
	tdiv_t
;

122 
	#__div_t_defed
 1

	)

123 
	g__END_NAMESPACE_C99


128 
	#RAND_MAX
 2147483647

	)

133 
	#EXIT_FAILURE
 1

	)

134 
	#EXIT_SUCCESS
 0

	)

138 
	#MB_CUR_MAX
 (
	`__y_g_mb_cur_max
 ())

	)

139 
size_t
 
	$__y_g_mb_cur_max
 (
__THROW
 
__wur
;

142 
__BEGIN_NAMESPACE_STD


144 
	$of
 (cڡ *
__Ō
)

145 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

147 
	$oi
 (cڡ *
__Ō
)

148 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

150 
	$
 (cڡ *
__Ō
)

151 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

152 
__END_NAMESPACE_STD


154 #i
defed
 
__USE_ISOC99
 || defed 
__USE_MISC


155 
__BEGIN_NAMESPACE_C99


157 
__exnsi__
 
	$l
 (cڡ *
__Ō
)

158 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

159 
__END_NAMESPACE_C99


162 
__BEGIN_NAMESPACE_STD


164 
	$od
 (cڡ *
__ri
 
__Ō
,

165 **
__ri
 
__dr
)

166 
__THROW
 
	`__nnu
 ((1));

167 
__END_NAMESPACE_STD


169 #ifdef 
__USE_ISOC99


170 
__BEGIN_NAMESPACE_C99


172 
	$of
 (cڡ *
__ri
 
__Ō
,

173 **
__ri
 
__dr

__THROW
 
	`__nnu
 ((1));

175 
	$d
 (cڡ *
__ri
 
__Ō
,

176 **
__ri
 
__dr
)

177 
__THROW
 
	`__nnu
 ((1));

178 
__END_NAMESPACE_C99


181 
__BEGIN_NAMESPACE_STD


183 
	$
 (cڡ *
__ri
 
__Ō
,

184 **
__ri
 
__dr
, 
__ba
)

185 
__THROW
 
	`__nnu
 ((1));

187 
	$oul
 (cڡ *
__ri
 
__Ō
,

188 **
__ri
 
__dr
, 
__ba
)

189 
__THROW
 
	`__nnu
 ((1));

190 
__END_NAMESPACE_STD


192 #ifde
__USE_BSD


194 
__exnsi__


195 
	$oq
 (cڡ *
__ri
 
__Ō
,

196 **
__ri
 
__dr
, 
__ba
)

197 
__THROW
 
	`__nnu
 ((1));

199 
__exnsi__


200 
	$ouq
 (cڡ *
__ri
 
__Ō
,

201 **
__ri
 
__dr
, 
__ba
)

202 
__THROW
 
	`__nnu
 ((1));

205 #i
defed
 
__USE_ISOC99
 || defed 
__USE_MISC


206 
__BEGIN_NAMESPACE_C99


208 
__exnsi__


209 
	$l
 (cڡ *
__ri
 
__Ō
,

210 **
__ri
 
__dr
, 
__ba
)

211 
__THROW
 
	`__nnu
 ((1));

213 
__exnsi__


214 
	$ou
 (cڡ *
__ri
 
__Ō
,

215 **
__ri
 
__dr
, 
__ba
)

216 
__THROW
 
	`__nnu
 ((1));

217 
__END_NAMESPACE_C99


221 #ifde
__USE_GNU


235 
	~<xlo.h
>

239 
	$_l
 (cڡ *
__ri
 
__Ō
,

240 **
__ri
 
__dr
, 
__ba
,

241 
__lo_t
 
__loc

__THROW
 
	`__nnu
 ((1, 4));

243 
	$oul_l
 (cڡ *
__ri
 
__Ō
,

244 **
__ri
 
__dr
,

245 
__ba
, 
__lo_t
 
__loc
)

246 
__THROW
 
	`__nnu
 ((1, 4));

248 
__exnsi__


249 
	$l_l
 (cڡ *
__ri
 
__Ō
,

250 **
__ri
 
__dr
, 
__ba
,

251 
__lo_t
 
__loc
)

252 
__THROW
 
	`__nnu
 ((1, 4));

254 
__exnsi__


255 
	$ou_l
 (cڡ *
__ri
 
__Ō
,

256 **
__ri
 
__dr
,

257 
__ba
, 
__lo_t
 
__loc
)

258 
__THROW
 
	`__nnu
 ((1, 4));

260 
	$od_l
 (cڡ *
__ri
 
__Ō
,

261 **
__ri
 
__dr
, 
__lo_t
 
__loc
)

262 
__THROW
 
	`__nnu
 ((1, 3));

264 
	$of_l
 (cڡ *
__ri
 
__Ō
,

265 **
__ri
 
__dr
, 
__lo_t
 
__loc
)

266 
__THROW
 
	`__nnu
 ((1, 3));

268 
	$d_l
 (cڡ *
__ri
 
__Ō
,

269 **
__ri
 
__dr
,

270 
__lo_t
 
__loc
)

271 
__THROW
 
	`__nnu
 ((1, 3));

275 #ifde
__USE_EXTERN_INLINES


276 
__BEGIN_NAMESPACE_STD


277 
__ex_le
 

278 
	`__NTH
 (
	$oi
 (cڡ *
__Ō
))

280  (
	`
 (
__Ō
, (**
NULL
, 10);

281 
	}
}

282 
__ex_le
 

283 
__NTH
 (
	$
 (cڡ *
__Ō
))

285  
	`
 (
__Ō
, (**
NULL
, 10);

286 
	}
}

287 
	g__END_NAMESPACE_STD


289 #i
defed
 
__USE_MISC
 || defed 
__USE_ISOC99


290 
__BEGIN_NAMESPACE_C99


291 
__exnsi__
 
__ex_le
 

292 
__NTH
 (
	$l
 (cڡ *
__Ō
))

294  
	`l
 (
__Ō
, (**
NULL
, 10);

295 
	}
}

296 
	g__END_NAMESPACE_C99


301 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN_EXTENDED


305 *
	$l64a
 (
__n

__THROW
 
__wur
;

308 
	$a64l
 (cڡ *
__s
)

309 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1)
__wur
;

313 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_BSD


314 
	~<sys/tys.h
>

321 
	$ndom
 (
__THROW
;

324 
	$dom
 (
__ed

__THROW
;

330 *
	$e
 (
__ed
, *
__ebuf
,

331 
size_t
 
__

__THROW
 
	`__nnu
 ((2));

335 *
	$te
 (*
__ebuf

__THROW
 
	`__nnu
 ((1));

338 #ifde
__USE_MISC


343 
	sndom_da


345 
t32_t
 *

;

346 
t32_t
 *

;

347 
t32_t
 *
e
;

348 
nd_ty
;

349 
nd_deg
;

350 
nd_p
;

351 
t32_t
 *
d_r
;

354 
	$ndom_r
 (
ndom_da
 *
__ri
 
__buf
,

355 
t32_t
 *
__ri
 
__su

__THROW
 
	`__nnu
 ((1, 2));

357 
	$dom_r
 (
__ed
, 
ndom_da
 *
__buf
)

358 
__THROW
 
	`__nnu
 ((2));

360 
	$e_r
 (
__ed
, *
__ri
 
__ebuf
,

361 
size_t
 
__
,

362 
ndom_da
 *
__ri
 
__buf
)

363 
__THROW
 
	`__nnu
 ((2, 4));

365 
	$te_r
 (*
__ri
 
__ebuf
,

366 
ndom_da
 *
__ri
 
__buf
)

367 
__THROW
 
	`__nnu
 ((1, 2));

372 
__BEGIN_NAMESPACE_STD


374 
	$nd
 (
__THROW
;

376 
	$d
 (
__ed

__THROW
;

377 
__END_NAMESPACE_STD


379 #ifde
__USE_POSIX


381 
	$nd_r
 (*
__ed

__THROW
;

385 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN


389 
	$dnd48
 (
__THROW
;

390 
	$d48
 (
__xsubi
[3]
__THROW
 
	`__nnu
 ((1));

393 
	$̪d48
 (
__THROW
;

394 
	$Īd48
 (
__xsubi
[3])

395 
__THROW
 
	`__nnu
 ((1));

398 
	$mnd48
 (
__THROW
;

399 
	$jnd48
 (
__xsubi
[3])

400 
__THROW
 
	`__nnu
 ((1));

403 
	$d48
 (
__edv

__THROW
;

404 *
	$ed48
 (
__ed16v
[3])

405 
__THROW
 
	`__nnu
 ((1));

406 
	$lcg48
 (
__m
[7]
__THROW
 
	`__nnu
 ((1));

408 #ifde
__USE_MISC


412 
	sdnd48_da


414 
__x
[3];

415 
__d_x
[3];

416 
__c
;

417 
__
;

418 
__exnsi__
 
__a
;

423 
	$dnd48_r
 (
dnd48_da
 *
__ri
 
__bufr
,

424 *
__ri
 
__su

__THROW
 
	`__nnu
 ((1, 2));

425 
	$d48_r
 (
__xsubi
[3],

426 
dnd48_da
 *
__ri
 
__bufr
,

427 *
__ri
 
__su

__THROW
 
	`__nnu
 ((1, 2));

430 
	$̪d48_r
 (
dnd48_da
 *
__ri
 
__bufr
,

431 *
__ri
 
__su
)

432 
__THROW
 
	`__nnu
 ((1, 2));

433 
	$Īd48_r
 (
__xsubi
[3],

434 
dnd48_da
 *
__ri
 
__bufr
,

435 *
__ri
 
__su
)

436 
__THROW
 
	`__nnu
 ((1, 2));

439 
	$mnd48_r
 (
dnd48_da
 *
__ri
 
__bufr
,

440 *
__ri
 
__su
)

441 
__THROW
 
	`__nnu
 ((1, 2));

442 
	$jnd48_r
 (
__xsubi
[3],

443 
dnd48_da
 *
__ri
 
__bufr
,

444 *
__ri
 
__su
)

445 
__THROW
 
	`__nnu
 ((1, 2));

448 
	$d48_r
 (
__edv
, 
dnd48_da
 *
__bufr
)

449 
__THROW
 
	`__nnu
 ((2));

451 
	$ed48_r
 (
__ed16v
[3],

452 
dnd48_da
 *
__bufr

__THROW
 
	`__nnu
 ((1, 2));

454 
	$lcg48_r
 (
__m
[7],

455 
dnd48_da
 *
__bufr
)

456 
__THROW
 
	`__nnu
 ((1, 2));

462 #ide
__mloc_d_oc_defed


463 
	#__mloc_d_oc_defed


	)

464 
__BEGIN_NAMESPACE_STD


466 *
	$mloc
 (
size_t
 
__size

__THROW
 
__ibu_mloc__
 
__wur
;

468 *
	$oc
 (
size_t
 
__nmemb
, size_
__size
)

469 
__THROW
 
__ibu_mloc__
 
__wur
;

470 
__END_NAMESPACE_STD


473 #ide
__ed_mloc_d_oc


474 
__BEGIN_NAMESPACE_STD


480 *
	$loc
 (*
__r
, 
size_t
 
__size
)

481 
__THROW
 
__ibu_wn_unud_su__
;

483 
	$
 (*
__r

__THROW
;

484 
__END_NAMESPACE_STD


486 #ifdef 
__USE_MISC


488 
	$c
 (*
__r

__THROW
;

491 #i
defed
 
__USE_GNU
 || defed 
__USE_BSD
 || defed 
__USE_MISC


492 
	~<lo.h
>

495 #i(
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_XOPEN2K
) \

496 || 
defed
 
__USE_BSD


498 *
	$vloc
 (
size_t
 
__size

__THROW
 
__ibu_mloc__
 
__wur
;

501 #ifde
__USE_XOPEN2K


503 
	$posix_memign
 (**
__memr
, 
size_t
 
__ignmt
, size_
__size
)

504 
__THROW
 
	`__nnu
 ((1)
__wur
;

507 #ifde
__USE_ISOC11


509 *
	$igd_loc
 (
size_t
 
__ignmt
, size_
__size
)

510 
__THROW
 
__ibu_mloc__
 
	`__ibu_loc_size__
 ((2)
__wur
;

513 
__BEGIN_NAMESPACE_STD


515 
	$abt
 (
__THROW
 
	`__ibu__
 ((
__nܑu__
));

519 
	`ex
 ((*
__func
()
__THROW
 
	`__nnu
 ((1));

521 #i
defed
 
__USE_ISOC11
 || defed 
__USE_ISOCXX11


523 #ifde
__lulus


524 "C++" 
	`_quick_ex
 ((*
__func
) ())

525 
__THROW
 
	`__asm
 ("_quick_ex"
	`__nnu
 ((1));

527 
	`_quick_ex
 ((*
__func
()
__THROW
 
	`__nnu
 ((1));

530 
__END_NAMESPACE_STD


532 #ifdef 
__USE_MISC


535 
	`_ex
 ((*
__func
(
__us
, *
__g
), *__arg)

536 
__THROW
 
	`__nnu
 ((1));

539 
__BEGIN_NAMESPACE_STD


543 
	$ex
 (
__us

__THROW
 
	`__ibu__
 ((
__nܑu__
));

545 #i
defed
 
__USE_ISOC11
 || defed 
__USE_ISOCXX11


549 
	$quick_ex
 (
__us

__THROW
 
	`__ibu__
 ((
__nܑu__
));

551 
__END_NAMESPACE_STD


553 #ifde
__USE_ISOC99


554 
__BEGIN_NAMESPACE_C99


557 
	$_Ex
 (
__us

__THROW
 
	`__ibu__
 ((
__nܑu__
));

558 
__END_NAMESPACE_C99


562 
__BEGIN_NAMESPACE_STD


564 *
	$gv
 (cڡ *
__me

__THROW
 
	`__nnu
 ((1)
__wur
;

565 
__END_NAMESPACE_STD


567 #ifde
__USE_GNU


570 *
	$cu_gv
 (cڡ *
__me
)

571 
__THROW
 
	`__nnu
 ((1)
__wur
;

574 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN


578 
	$punv
 (*
__rg

__THROW
 
	`__nnu
 ((1));

581 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN2K


584 
	$nv
 (cڡ *
__me
, cڡ *
__vue
, 
__a
)

585 
__THROW
 
	`__nnu
 ((2));

588 
	$unnv
 (cڡ *
__me

__THROW
 
	`__nnu
 ((1));

591 #ifdef 
__USE_MISC


595 
	$nv
 (
__THROW
;

599 #i
defed
 
__USE_MISC
 \

600 || (
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_XOPEN2K8
)

606 *
	$mkmp
 (*
__me

__THROW
 
	`__nnu
 ((1));

609 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN_EXTENDED
 \

610 || 
defed
 
__USE_XOPEN2K8


619 #ide
__USE_FILE_OFFSET64


620 
	$mkemp
 (*
__me

	`__nnu
 ((1)
__wur
;

622 #ifde
__REDIRECT


623 
	`__REDIRECT
 (
mkemp
, (*
__me
), 
mkemp64
)

624 
	`__nnu
 ((1)
__wur
;

626 
	#mkemp
 
mkemp64


	)

629 #ifde
__USE_LARGEFILE64


630 
	$mkemp64
 (*
__me

	`__nnu
 ((1)
__wur
;

634 #ifde
__USE_MISC


641 #ide
__USE_FILE_OFFSET64


642 
	$mkemps
 (*
__me
, 
__suffixn

	`__nnu
 ((1)
__wur
;

644 #ifde
__REDIRECT


645 
	`__REDIRECT
 (
mkemps
, (*
__me
, 
__suffixn
),

646 
mkemps64

	`__nnu
 ((1)
__wur
;

648 
	#mkemps
 
mkemps64


	)

651 #ifde
__USE_LARGEFILE64


652 
	$mkemps64
 (*
__me
, 
__suffixn
)

653 
	`__nnu
 ((1)
__wur
;

657 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN2K8


663 *
	$mkdmp
 (*
__me

__THROW
 
	`__nnu
 ((1)
__wur
;

666 #ifde
__USE_GNU


673 #ide
__USE_FILE_OFFSET64


674 
	$mkoemp
 (*
__me
, 
__ags

	`__nnu
 ((1)
__wur
;

676 #ifde
__REDIRECT


677 
	`__REDIRECT
 (
mkoemp
, (*
__me
, 
__ags
), 
mkoemp64
)

678 
	`__nnu
 ((1)
__wur
;

680 
	#mkoemp
 
mkoemp64


	)

683 #ifde
__USE_LARGEFILE64


684 
	$mkoemp64
 (*
__me
, 
__ags

	`__nnu
 ((1)
__wur
;

693 #ide
__USE_FILE_OFFSET64


694 
	$mkoemps
 (*
__me
, 
__suffixn
, 
__ags
)

695 
	`__nnu
 ((1)
__wur
;

697 #ifde
__REDIRECT


698 
	`__REDIRECT
 (
mkoemps
, (*
__me
, 
__suffixn
,

699 
__ags
), 
mkoemps64
)

700 
	`__nnu
 ((1)
__wur
;

702 
	#mkoemps
 
mkoemps64


	)

705 #ifde
__USE_LARGEFILE64


706 
	$mkoemps64
 (*
__me
, 
__suffixn
, 
__ags
)

707 
	`__nnu
 ((1)
__wur
;

712 
__BEGIN_NAMESPACE_STD


717 
	$syem
 (cڡ *
__commd

__wur
;

718 
__END_NAMESPACE_STD


721 #ifdef 
__USE_GNU


724 *
	$nilize_fe_me
 (cڡ *
__me
)

725 
__THROW
 
	`__nnu
 ((1)
__wur
;

728 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


734 *
	$th
 (cڡ *
__ri
 
__me
,

735 *
__ri
 
__sved

__THROW
 
__wur
;

740 #ide
__COMPAR_FN_T


741 
	#__COMPAR_FN_T


	)

742 (*
	t__comr__t
) (const *, const *);

744 #ifdef 
__USE_GNU


745 
__comr__t
 
	tcomris__t
;

748 #ifde
__USE_GNU


749 (*
	t__comr_d__t
) (const *, const *, *);

752 
__BEGIN_NAMESPACE_STD


755 *
	$bch
 (cڡ *
__key
, cڡ *
__ba
,

756 
size_t
 
__nmemb
, size_
__size
, 
__comr__t
 
__comr
)

757 
	`__nnu
 ((1, 2, 5)
__wur
;

759 #ifde
__USE_EXTERN_INLINES


760 
	~<bs/dlib-bch.h
>

765 
	$qst
 (*
__ba
, 
size_t
 
__nmemb
, size_
__size
,

766 
__comr__t
 
__comr

	`__nnu
 ((1, 4));

767 #ifde
__USE_GNU


768 
	$qst_r
 (*
__ba
, 
size_t
 
__nmemb
, size_
__size
,

769 
__comr_d__t
 
__comr
, *
__g
)

770 
	`__nnu
 ((1, 4));

775 
	$abs
 (
__x

__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

776 
	$bs
 (
__x

__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

777 
__END_NAMESPACE_STD


779 #ifde
__USE_ISOC99


780 
__exnsi__
 
	$abs
 (
__x
)

781 
__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

785 
__BEGIN_NAMESPACE_STD


789 
div_t
 
	$div
 (
__num
, 
__dom
)

790 
__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

791 
ldiv_t
 
	$ldiv
 (
__num
, 
__dom
)

792 
__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

793 
__END_NAMESPACE_STD


795 #ifde
__USE_ISOC99


796 
__BEGIN_NAMESPACE_C99


797 
__exnsi__
 
div_t
 
	$div
 (
__num
,

798 
__dom
)

799 
__THROW
 
	`__ibu__
 ((
__cڡ__
)
__wur
;

800 
__END_NAMESPACE_C99


804 #i(
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_XOPEN2K8
) \

805 || 
defed
 
__USE_SVID


812 *
	$ecvt
 (
__vue
, 
__ndig
, *
__ri
 
__det
,

813 *
__ri
 
__sign

__THROW
 
	`__nnu
 ((3, 4)
__wur
;

818 *
	$fcvt
 (
__vue
, 
__ndig
, *
__ri
 
__det
,

819 *
__ri
 
__sign

__THROW
 
	`__nnu
 ((3, 4)
__wur
;

824 *
	$gcvt
 (
__vue
, 
__ndig
, *
__buf
)

825 
__THROW
 
	`__nnu
 ((3)
__wur
;

828 #ifde
__USE_MISC


830 *
	$qecvt
 (
__vue
, 
__ndig
,

831 *
__ri
 
__det
, *__ri 
__sign
)

832 
__THROW
 
	`__nnu
 ((3, 4)
__wur
;

833 *
	$qfcvt
 (
__vue
, 
__ndig
,

834 *
__ri
 
__det
, *__ri 
__sign
)

835 
__THROW
 
	`__nnu
 ((3, 4)
__wur
;

836 *
	$qgcvt
 (
__vue
, 
__ndig
, *
__buf
)

837 
__THROW
 
	`__nnu
 ((3)
__wur
;

842 
	$ecvt_r
 (
__vue
, 
__ndig
, *
__ri
 
__det
,

843 *
__ri
 
__sign
, *__ri 
__buf
,

844 
size_t
 
__n

__THROW
 
	`__nnu
 ((3, 4, 5));

845 
	$fcvt_r
 (
__vue
, 
__ndig
, *
__ri
 
__det
,

846 *
__ri
 
__sign
, *__ri 
__buf
,

847 
size_t
 
__n

__THROW
 
	`__nnu
 ((3, 4, 5));

849 
	$qecvt_r
 (
__vue
, 
__ndig
,

850 *
__ri
 
__det
, *__ri 
__sign
,

851 *
__ri
 
__buf
, 
size_t
 
__n
)

852 
__THROW
 
	`__nnu
 ((3, 4, 5));

853 
	$qfcvt_r
 (
__vue
, 
__ndig
,

854 *
__ri
 
__det
, *__ri 
__sign
,

855 *
__ri
 
__buf
, 
size_t
 
__n
)

856 
__THROW
 
	`__nnu
 ((3, 4, 5));

860 
__BEGIN_NAMESPACE_STD


863 
	$mbn
 (cڡ *
__s
, 
size_t
 
__n

__THROW
;

866 
	$mbtowc
 (
wch_t
 *
__ri
 
__pwc
,

867 cڡ *
__ri
 
__s
, 
size_t
 
__n

__THROW
;

870 
	$womb
 (*
__s
, 
wch_t
 
__wch

__THROW
;

874 
size_t
 
	$mbowcs
 (
wch_t
 *
__ri
 
__pwcs
,

875 cڡ *
__ri
 
__s
, 
size_t
 
__n

__THROW
;

877 
size_t
 
	$wcombs
 (*
__ri
 
__s
,

878 cڡ 
wch_t
 *
__ri
 
__pwcs
, 
size_t
 
__n
)

879 
__THROW
;

880 
__END_NAMESPACE_STD


883 #ifde
__USE_SVID


888 
	$mch
 (cڡ *
__ڣ

__THROW
 
	`__nnu
 ((1)
__wur
;

892 #i
defed
 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K8


899 
	$gsubt
 (**
__ri
 
__tip
,

900 *cڡ *
__ri
 
__toks
,

901 **
__ri
 
__vu
)

902 
__THROW
 
	`__nnu
 ((1, 2, 3)
__wur
;

906 #ifde
__USE_XOPEN


908 
	$tkey
 (cڡ *
__key

__THROW
 
	`__nnu
 ((1));

914 #ifde
__USE_XOPEN2KXSI


916 
	$posix_ݒ
 (
__oag

__wur
;

919 #ifde
__USE_XOPEN


924 
	$g
 (
__fd

__THROW
;

928 
	$uock
 (
__fd

__THROW
;

933 *
	$ame
 (
__fd

__THROW
 
__wur
;

936 #ifde
__USE_GNU


940 
	$ame_r
 (
__fd
, *
__buf
, 
size_t
 
__bu
)

941 
__THROW
 
	`__nnu
 ((2));

944 
	`g
 ();

947 #ifde
__USE_BSD


951 
	$gldavg
 (
__ldavg
[], 
__m
)

952 
__THROW
 
	`__nnu
 ((1));

955 
	~<bs/dlib-t.h
>

958 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


959 
	~<bs/dlib.h
>

961 #ifde
__LDBL_COMPAT


962 
	~<bs/dlib-ldbl.h
>

966 #unde
__ed_mloc_d_oc


968 
__END_DECLS


	@/usr/include/string.h

22 #idef 
_STRING_H


23 
	#_STRING_H
 1

	)

25 
	~<us.h
>

27 
	g__BEGIN_DECLS


30 
	#__ed_size_t


	)

31 
	#__ed_NULL


	)

32 
	~<ddef.h
>

39 #i
defed
 
__lulus
 && (__lulu>199711L || 
__GNUC_PREREQ
 (4, 4))

40 
	#__CORRECT_ISO_CPP_STRING_H_PROTO


	)

44 
__BEGIN_NAMESPACE_STD


46 *
	$memy
 (*
__ri
 
__de
, cڡ *__ri 
__c
,

47 
size_t
 
__n

__THROW
 
	`__nnu
 ((1, 2));

50 *
	$memmove
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
)

51 
__THROW
 
	`__nnu
 ((1, 2));

52 
__END_NAMESPACE_STD


57 #i
defed
 
__USE_SVID
 || defed 
__USE_BSD
 || defed 
__USE_XOPEN


58 *
	$memcy
 (*
__ri
 
__de
, cڡ *__ri 
__c
,

59 
__c
, 
size_t
 
__n
)

60 
__THROW
 
	`__nnu
 ((1, 2));

64 
__BEGIN_NAMESPACE_STD


66 *
	$memt
 (*
__s
, 
__c
, 
size_t
 
__n

__THROW
 
	`__nnu
 ((1));

69 
	$memcmp
 (cڡ *
__s1
, cڡ *
__s2
, 
size_t
 
__n
)

70 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

73 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


76 *
	`memchr
 (*
__s
, 
__c
, 
size_t
 
__n
)

77 
__THROW
 
	`__asm
 ("memchr"
__ibu_pu__
 
	`__nnu
 ((1));

78 cڡ *
	`memchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n
)

79 
__THROW
 
	`__asm
 ("memchr"
__ibu_pu__
 
	`__nnu
 ((1));

81 #ifde
__OPTIMIZE__


82 
__ex_ways_le
 *

83 
	`memchr
 (*
__s
, 
__c
, 
size_t
 
__n

__THROW


85  
	`__but_memchr
 (
__s
, 
__c
, 
__n
);

88 
__ex_ways_le
 const *

89 
	`memchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n

__THROW


91  
	`__but_memchr
 (
__s
, 
__c
, 
__n
);

94 
	}
}

96 *
	$memchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n
)

97 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

99 
__END_NAMESPACE_STD


101 #ifde
__USE_GNU


104 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


105 "C++" *
	$wmemchr
 (*
__s
, 
__c
)

106 
__THROW
 
	`__asm
 ("wmemchr"
__ibu_pu__
 
	`__nnu
 ((1));

107 "C++" cڡ *
	$wmemchr
 (cڡ *
__s
, 
__c
)

108 
__THROW
 
	`__asm
 ("wmemchr"
__ibu_pu__
 
	`__nnu
 ((1));

110 *
	$wmemchr
 (cڡ *
__s
, 
__c
)

111 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

115 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


116 "C++" *
	$memrchr
 (*
__s
, 
__c
, 
size_t
 
__n
)

117 
__THROW
 
	`__asm
 ("memrchr"
__ibu_pu__
 
	`__nnu
 ((1));

118 "C++" cڡ *
	$memrchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n
)

119 
__THROW
 
	`__asm
 ("memrchr"
__ibu_pu__
 
	`__nnu
 ((1));

121 *
	$memrchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n
)

122 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

127 
__BEGIN_NAMESPACE_STD


129 *
	$ry
 (*
__ri
 
__de
, cڡ *__ri 
__c
)

130 
__THROW
 
	`__nnu
 ((1, 2));

132 *
	$y
 (*
__ri
 
__de
,

133 cڡ *
__ri
 
__c
, 
size_t
 
__n
)

134 
__THROW
 
	`__nnu
 ((1, 2));

137 *
	$rt
 (*
__ri
 
__de
, cڡ *__ri 
__c
)

138 
__THROW
 
	`__nnu
 ((1, 2));

140 *
	$t
 (*
__ri
 
__de
, cڡ *__ri 
__c
,

141 
size_t
 
__n

__THROW
 
	`__nnu
 ((1, 2));

144 
	$rcmp
 (cڡ *
__s1
, cڡ *
__s2
)

145 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

147 
	$cmp
 (cڡ *
__s1
, cڡ *
__s2
, 
size_t
 
__n
)

148 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

151 
	$rcl
 (cڡ *
__s1
, cڡ *
__s2
)

152 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

154 
size_t
 
	$rxm
 (*
__ri
 
__de
,

155 cڡ *
__ri
 
__c
, 
size_t
 
__n
)

156 
__THROW
 
	`__nnu
 ((2));

157 
__END_NAMESPACE_STD


159 #ifde
__USE_XOPEN2K8


163 
	~<xlo.h
>

166 
	$rcl_l
 (cڡ *
__s1
, cڡ *
__s2
, 
__lo_t
 
__l
)

167 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2, 3));

169 
size_t
 
	$rxm_l
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
,

170 
__lo_t
 
__l

__THROW
 
	`__nnu
 ((2, 4));

173 #i
defed
 
__USE_SVID
 || defed 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED
 \

174 || 
defed
 
__USE_XOPEN2K8


176 *
	$rdup
 (cڡ *
__s
)

177 
__THROW
 
__ibu_mloc__
 
	`__nnu
 ((1));

183 #i
defed
 
__USE_XOPEN2K8


184 *
	$dup
 (cڡ *
__rg
, 
size_t
 
__n
)

185 
__THROW
 
__ibu_mloc__
 
	`__nnu
 ((1));

188 #i
defed
 
__USE_GNU
 && defed 
__GNUC__


190 
	#rdu
(
s
) \

191 (
__exnsi__
 \

193 cڡ *
__d
 = (
s
); \

194 
size_t
 
__n
 = 
	`
 (
__d
) + 1; \

195 *
__w
 = (*
	`__but_lo
 (
__n
); \

196 (*
	`memy
 (
__w
, 
__d
, 
__n
); \

197 
	}
}))

	)

200 
	#du
(
s
, 
n
) \

201 (
__exnsi__
 \

203 cڡ *
__d
 = (
s
); \

204 
size_t
 
__n
 = 
	`n
 (
__d
, (
n
)); \

205 *
__w
 = (*
	`__but_lo
 (
__n
 + 1); \

206 
__w
[
__n
] = '\0'; \

207 (*
	`memy
 (
__w
, 
__d
, 
__n
); \

208 }))

	)

211 
	g__BEGIN_NAMESPACE_STD


213 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


216 *
rchr
 (*
__s
, 
__c
)

217 
__THROW
 
__asm
 ("rchr"
__ibu_pu__
 
__nnu
 ((1));

218 cڡ *
rchr
 (cڡ *
__s
, 
__c
)

219 
__THROW
 
__asm
 ("rchr"
__ibu_pu__
 
__nnu
 ((1));

221 #ifde
__OPTIMIZE__


222 
__ex_ways_le
 *

223 
rchr
 (*
__s
, 
__c

	g__THROW


225  
__but_rchr
 (
__s
, 
__c
);

228 
__ex_ways_le
 const *

229 
rchr
 (cڡ *
__s
, 
__c

	g__THROW


231  
__but_rchr
 (
__s
, 
__c
);

236 *
	$rchr
 (cڡ *
__s
, 
__c
)

237 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

240 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


243 *
	`chr
 (*
__s
, 
__c
)

244 
__THROW
 
	`__asm
 ("chr"
__ibu_pu__
 
	`__nnu
 ((1));

245 cڡ *
	`chr
 (cڡ *
__s
, 
__c
)

246 
__THROW
 
	`__asm
 ("chr"
__ibu_pu__
 
	`__nnu
 ((1));

248 #ifde
__OPTIMIZE__


249 
__ex_ways_le
 *

250 
	`chr
 (*
__s
, 
__c

__THROW


252  
	`__but_chr
 (
__s
, 
__c
);

255 
__ex_ways_le
 const *

256 
	`chr
 (cڡ *
__s
, 
__c

__THROW


258  
	`__but_chr
 (
__s
, 
__c
);

261 
	}
}

263 *
	$chr
 (cڡ *
__s
, 
__c
)

264 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

266 
__END_NAMESPACE_STD


268 #ifde
__USE_GNU


271 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


272 "C++" *
	$rchul
 (*
__s
, 
__c
)

273 
__THROW
 
	`__asm
 ("rchul"
__ibu_pu__
 
	`__nnu
 ((1));

274 "C++" cڡ *
	$rchul
 (cڡ *
__s
, 
__c
)

275 
__THROW
 
	`__asm
 ("rchul"
__ibu_pu__
 
	`__nnu
 ((1));

277 *
	$rchul
 (cڡ *
__s
, 
__c
)

278 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

282 
__BEGIN_NAMESPACE_STD


285 
size_t
 
	$rcn
 (cڡ *
__s
, cڡ *
__je
)

286 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

289 
size_t
 
	$rn
 (cڡ *
__s
, cڡ *
__ac
)

290 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

292 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


295 *
	`brk
 (*
__s
, cڡ *
__ac
)

296 
__THROW
 
	`__asm
 ("brk"
__ibu_pu__
 
	`__nnu
 ((1, 2));

297 cڡ *
	`brk
 (cڡ *
__s
, cڡ *
__ac
)

298 
__THROW
 
	`__asm
 ("brk"
__ibu_pu__
 
	`__nnu
 ((1, 2));

300 #ifde
__OPTIMIZE__


301 
__ex_ways_le
 *

302 
	`brk
 (*
__s
, cڡ *
__ac

__THROW


304  
	`__but_brk
 (
__s
, 
__ac
);

307 
__ex_ways_le
 const *

308 
	`brk
 (cڡ *
__s
, cڡ *
__ac

__THROW


310  
	`__but_brk
 (
__s
, 
__ac
);

313 
	}
}

315 *
	$brk
 (cڡ *
__s
, cڡ *
__ac
)

316 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

319 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


322 *
	`rr
 (*
__hayack
, cڡ *
__ed
)

323 
__THROW
 
	`__asm
 ("rr"
__ibu_pu__
 
	`__nnu
 ((1, 2));

324 cڡ *
	`rr
 (cڡ *
__hayack
, cڡ *
__ed
)

325 
__THROW
 
	`__asm
 ("rr"
__ibu_pu__
 
	`__nnu
 ((1, 2));

327 #ifde
__OPTIMIZE__


328 
__ex_ways_le
 *

329 
	`rr
 (*
__hayack
, cڡ *
__ed

__THROW


331  
	`__but_rr
 (
__hayack
, 
__ed
);

334 
__ex_ways_le
 const *

335 
	`rr
 (cڡ *
__hayack
, cڡ *
__ed

__THROW


337  
	`__but_rr
 (
__hayack
, 
__ed
);

340 
	}
}

342 *
	$rr
 (cڡ *
__hayack
, cڡ *
__ed
)

343 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

348 *
	$ok
 (*
__ri
 
__s
, cڡ *__ri 
__dim
)

349 
__THROW
 
	`__nnu
 ((2));

350 
__END_NAMESPACE_STD


354 *
	$__ok_r
 (*
__ri
 
__s
,

355 cڡ *
__ri
 
__dim
,

356 **
__ri
 
__ve_r
)

357 
__THROW
 
	`__nnu
 ((2, 3));

358 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


359 *
	$ok_r
 (*
__ri
 
__s
, cڡ *__ri 
__dim
,

360 **
__ri
 
__ve_r
)

361 
__THROW
 
	`__nnu
 ((2, 3));

364 #ifde
__USE_GNU


366 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


367 "C++" *
	$rr
 (*
__hayack
, cڡ *
__ed
)

368 
__THROW
 
	`__asm
 ("rr"
__ibu_pu__
 
	`__nnu
 ((1, 2));

369 "C++" cڡ *
	$rr
 (cڡ *
__hayack
,

370 cڡ *
__ed
)

371 
__THROW
 
	`__asm
 ("rr"
__ibu_pu__
 
	`__nnu
 ((1, 2));

373 *
	$rr
 (cڡ *
__hayack
, cڡ *
__ed
)

374 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

378 #ifde
__USE_GNU


382 *
	$memmem
 (cڡ *
__hayack
, 
size_t
 
__hayackn
,

383 cڡ *
__ed
, 
size_t
 
__edn
)

384 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 3));

388 *
	$__mempy
 (*
__ri
 
__de
,

389 cڡ *
__ri
 
__c
, 
size_t
 
__n
)

390 
__THROW
 
	`__nnu
 ((1, 2));

391 *
	$mempy
 (*
__ri
 
__de
,

392 cڡ *
__ri
 
__c
, 
size_t
 
__n
)

393 
__THROW
 
	`__nnu
 ((1, 2));

397 
__BEGIN_NAMESPACE_STD


399 
size_t
 
	$
 (cڡ *
__s
)

400 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

401 
__END_NAMESPACE_STD


403 #ifdef 
__USE_XOPEN2K8


406 
size_t
 
	$n
 (cڡ *
__rg
, 
size_t
 
__maxn
)

407 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

411 
__BEGIN_NAMESPACE_STD


413 *
	$
 (
__um

__THROW
;

414 
__END_NAMESPACE_STD


415 #i
defed
 
__USE_XOPEN2K
 || defed 
__USE_MISC


423 #i
defed
 
__USE_XOPEN2K
 && !defed 
__USE_GNU


426 #ifde
__REDIRECT_NTH


427 
	`__REDIRECT_NTH
 (
_r
,

428 (
__um
, *
__buf
, 
size_t
 
__bu
),

429 
__xpg__r

	`__nnu
 ((2));

431 
	$__xpg__r
 (
__um
, *
__buf
, 
size_t
 
__bu
)

432 
__THROW
 
	`__nnu
 ((2));

433 
	#_r
 
__xpg__r


	)

438 *
	$_r
 (
__um
, *
__buf
, 
size_t
 
__bu
)

439 
__THROW
 
	`__nnu
 ((2)
__wur
;

443 #ifde
__USE_XOPEN2K8


445 *
	$_l
 (
__um
, 
__lo_t
 
__l

__THROW
;

451 
	$__bzo
 (*
__s
, 
size_t
 
__n

__THROW
 
	`__nnu
 ((1));

453 #ifde
__USE_BSD


455 
	$bcy
 (cڡ *
__c
, *
__de
, 
size_t
 
__n
)

456 
__THROW
 
	`__nnu
 ((1, 2));

459 
	$bzo
 (*
__s
, 
size_t
 
__n

__THROW
 
	`__nnu
 ((1));

462 
	$bcmp
 (cڡ *
__s1
, cڡ *
__s2
, 
size_t
 
__n
)

463 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

466 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


469 *
	`dex
 (*
__s
, 
__c
)

470 
__THROW
 
	`__asm
 ("dex"
__ibu_pu__
 
	`__nnu
 ((1));

471 cڡ *
	`dex
 (cڡ *
__s
, 
__c
)

472 
__THROW
 
	`__asm
 ("dex"
__ibu_pu__
 
	`__nnu
 ((1));

474 #i
defed
 
__OPTIMIZE__
 && !defed 
__CORRECT_ISO_CPP_STRINGS_H_PROTO


475 
__ex_ways_le
 *

476 
	`dex
 (*
__s
, 
__c

__THROW


478  
	`__but_dex
 (
__s
, 
__c
);

481 
__ex_ways_le
 const *

482 
	`dex
 (cڡ *
__s
, 
__c

__THROW


484  
	`__but_dex
 (
__s
, 
__c
);

487 
	}
}

489 *
	$dex
 (cڡ *
__s
, 
__c
)

490 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

494 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


497 *
	`rdex
 (*
__s
, 
__c
)

498 
__THROW
 
	`__asm
 ("rdex"
__ibu_pu__
 
	`__nnu
 ((1));

499 cڡ *
	`rdex
 (cڡ *
__s
, 
__c
)

500 
__THROW
 
	`__asm
 ("rdex"
__ibu_pu__
 
	`__nnu
 ((1));

502 #i
defed
 
__OPTIMIZE__
 && !defed 
__CORRECT_ISO_CPP_STRINGS_H_PROTO


503 
__ex_ways_le
 *

504 
	`rdex
 (*
__s
, 
__c

__THROW


506  
	`__but_rdex
 (
__s
, 
__c
);

509 
__ex_ways_le
 const *

510 
	`rdex
 (cڡ *
__s
, 
__c

__THROW


512  
	`__but_rdex
 (
__s
, 
__c
);

515 
	}
}

517 *
	$rdex
 (cڡ *
__s
, 
__c
)

518 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

523 
	$ffs
 (
__i

__THROW
 
	`__ibu__
 ((
__cڡ__
));

527 #ifdef 
__USE_GNU


528 
	$ff
 (
__l

__THROW
 
	`__ibu__
 ((
__cڡ__
));

529 
__exnsi__
 
	$ffl
 (
__
)

530 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

534 
	$rcmp
 (cڡ *
__s1
, cڡ *
__s2
)

535 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

538 
	$cmp
 (cڡ *
__s1
, cڡ *
__s2
, 
size_t
 
__n
)

539 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

542 #ifdef 
__USE_GNU


545 
	$rcmp_l
 (cڡ *
__s1
, cڡ *
__s2
,

546 
__lo_t
 
__loc
)

547 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2, 3));

549 
	$cmp_l
 (cڡ *
__s1
, cڡ *
__s2
,

550 
size_t
 
__n
, 
__lo_t
 
__loc
)

551 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2, 4));

554 #ifdef 
__USE_BSD


557 *
	$rp
 (**
__ri
 
__rgp
,

558 cڡ *
__ri
 
__dim
)

559 
__THROW
 
	`__nnu
 ((1, 2));

562 #ifdef 
__USE_XOPEN2K8


564 *
	$rsigl
 (
__sig

__THROW
;

567 *
	$__py
 (*
__ri
 
__de
, cڡ *__ri 
__c
)

568 
__THROW
 
	`__nnu
 ((1, 2));

569 *
	$py
 (*
__ri
 
__de
, cڡ *__ri 
__c
)

570 
__THROW
 
	`__nnu
 ((1, 2));

574 *
	$__y
 (*
__ri
 
__de
,

575 cڡ *
__ri
 
__c
, 
size_t
 
__n
)

576 
__THROW
 
	`__nnu
 ((1, 2));

577 *
	$y
 (*
__ri
 
__de
,

578 cڡ *
__ri
 
__c
, 
size_t
 
__n
)

579 
__THROW
 
	`__nnu
 ((1, 2));

582 #ifdef 
__USE_GNU


584 
	$rvscmp
 (cڡ *
__s1
, cڡ *
__s2
)

585 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

588 *
	$ry
 (*
__rg

__THROW
 
	`__nnu
 ((1));

591 *
	$memob
 (*
__s
, 
size_t
 
__n

__THROW
 
	`__nnu
 ((1));

593 #ide
bame


598 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


599 "C++" *
	$bame
 (*
__fame
)

600 
__THROW
 
	`__asm
 ("bame"
	`__nnu
 ((1));

601 "C++" cڡ *
	$bame
 (cڡ *
__fame
)

602 
__THROW
 
	`__asm
 ("bame"
	`__nnu
 ((1));

604 *
	$bame
 (cڡ *
__fame

__THROW
 
	`__nnu
 ((1));

610 #i
defed
 
__GNUC__
 && __GNUC__ >= 2

611 #i
defed
 
__OPTIMIZE__
 && !defed 
__OPTIMIZE_SIZE__
 \

612 && !
defed
 
__NO_INLINE__
 && !defed 
__lulus


632 
	~<bs/rg.h
>

635 
	~<bs/rg2.h
>

638 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


640 
	~<bs/rg3.h
>

644 
__END_DECLS


	@/usr/include/strings.h

18 #idef 
_STRINGS_H


19 
	#_STRINGS_H
 1

	)

24 #i!
defed
 
_STRING_H
 || !defed 
__USE_BSD


26 
	~<us.h
>

27 
	#__ed_size_t


	)

28 
	~<ddef.h
>

35 #i
defed
 
__lulus
 && (__lulu>199711L || 
__GNUC_PREREQ
 (4, 4))

36 
	#__CORRECT_ISO_CPP_STRINGS_H_PROTO


	)

39 
	g__BEGIN_DECLS


41 #i
defed
 
__USE_MISC
 || !defed 
__USE_XOPEN2K8


43 
	$bcmp
 (cڡ *
__s1
, cڡ *
__s2
, 
size_t
 
__n
)

44 
__THROW
 
__ibu_pu__
;

47 
	$bcy
 (cڡ *
__c
, *
__de
, 
size_t
 
__n

__THROW
;

50 
	$bzo
 (*
__s
, 
size_t
 
__n

__THROW
;

53 #ifde
__CORRECT_ISO_CPP_STRINGS_H_PROTO


56 *
	`dex
 (*
__s
, 
__c
)

57 
__THROW
 
	`__asm
 ("dex"
__ibu_pu__
 
	`__nnu
 ((1));

58 cڡ *
	`dex
 (cڡ *
__s
, 
__c
)

59 
__THROW
 
	`__asm
 ("dex"
__ibu_pu__
 
	`__nnu
 ((1));

61 #i
defed
 
__OPTIMIZE__
 && !defed 
__CORRECT_ISO_CPP_STRING_H_PROTO


62 
__ex_ways_le
 *

63 
	`dex
 (*
__s
, 
__c

__THROW


65  
	`__but_dex
 (
__s
, 
__c
);

68 
__ex_ways_le
 const *

69 
	`dex
 (cڡ *
__s
, 
__c

__THROW


71  
	`__but_dex
 (
__s
, 
__c
);

74 
	}
}

76 *
	$dex
 (cڡ *
__s
, 
__c
)

77 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

81 #ifde
__CORRECT_ISO_CPP_STRINGS_H_PROTO


84 *
	`rdex
 (*
__s
, 
__c
)

85 
__THROW
 
	`__asm
 ("rdex"
__ibu_pu__
 
	`__nnu
 ((1));

86 cڡ *
	`rdex
 (cڡ *
__s
, 
__c
)

87 
__THROW
 
	`__asm
 ("rdex"
__ibu_pu__
 
	`__nnu
 ((1));

89 #i
defed
 
__OPTIMIZE__
 && !defed 
__CORRECT_ISO_CPP_STRING_H_PROTO


90 
__ex_ways_le
 *

91 
	`rdex
 (*
__s
, 
__c

__THROW


93  
	`__but_rdex
 (
__s
, 
__c
);

96 
__ex_ways_le
 const *

97 
	`rdex
 (cڡ *
__s
, 
__c

__THROW


99  
	`__but_rdex
 (
__s
, 
__c
);

102 
	}
}

104 *
	$rdex
 (cڡ *
__s
, 
__c
)

105 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

109 #i
defed
 
__USE_MISC
 || !defed 
__USE_XOPEN2K8
 || defed 
__USE_XOPEN2K8XSI


112 
	$ffs
 (
__i

__THROW
 
	`__ibu__
 ((const));

116 
	$rcmp
 (cڡ *
__s1
, cڡ *
__s2
)

117 
__THROW
 
__ibu_pu__
;

120 
	$cmp
 (cڡ *
__s1
, cڡ *
__s2
, 
size_t
 
__n
)

121 
__THROW
 
__ibu_pu__
;

123 #ifdef 
__USE_XOPEN2K8


127 
	~<xlo.h
>

131 
	$rcmp_l
 (cڡ *
__s1
, cڡ *
__s2
, 
__lo_t
 
__loc
)

132 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2, 3));

134 
	$cmp_l
 (cڡ *
__s1
, cڡ *
__s2
,

135 
size_t
 
__n
, 
__lo_t
 
__loc
)

136 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2, 4));

139 
__END_DECLS


	@/usr/include/sys/mman.h

19 #idef 
_SYS_MMAN_H


20 
	#_SYS_MMAN_H
 1

	)

22 
	~<us.h
>

23 
	~<bs/tys.h
>

24 
	#__ed_size_t


	)

25 
	~<ddef.h
>

27 #ide
__off_t_defed


28 #ide
__USE_FILE_OFFSET64


29 
__off_t
 
	toff_t
;

31 
__off64_t
 
	toff_t
;

33 
	#__off_t_defed


	)

36 #ide
__mode_t_defed


37 
__mode_t
 
	tmode_t
;

38 
	#__mode_t_defed


	)

41 
	~<bs/mm.h
>

44 
	#MAP_FAILED
 ((*-1)

	)

46 
	g__BEGIN_DECLS


56 #ide
__USE_FILE_OFFSET64


57 *
	$mm
 (*
__addr
, 
size_t
 
__n
, 
__
,

58 
__ags
, 
__fd
, 
__off_t
 
__offt

__THROW
;

60 #ifde
__REDIRECT_NTH


61 * 
	`__REDIRECT_NTH
 (
mm
,

62 (*
__addr
, 
size_t
 
__n
, 
__
,

63 
__ags
, 
__fd
, 
__off64_t
 
__offt
),

64 
mm64
);

66 
	#mm
 
mm64


	)

69 #ifde
__USE_LARGEFILE64


70 *
	$mm64
 (*
__addr
, 
size_t
 
__n
, 
__
,

71 
__ags
, 
__fd
, 
__off64_t
 
__offt

__THROW
;

76 
	$munm
 (*
__addr
, 
size_t
 
__n

__THROW
;

81 
	$me
 (*
__addr
, 
size_t
 
__n
, 
__

__THROW
;

89 
	`msync
 (*
__addr
, 
size_t
 
__n
, 
__ags
);

91 #ifde
__USE_BSD


94 
	$madvi
 (*
__addr
, 
size_t
 
__n
, 
__advi

__THROW
;

96 #ifde
__USE_XOPEN2K


98 
	$posix_madvi
 (*
__addr
, 
size_t
 
__n
, 
__advi

__THROW
;

103 
	$mlock
 (cڡ *
__addr
, 
size_t
 
__n

__THROW
;

106 
	$muock
 (cڡ *
__addr
, 
size_t
 
__n

__THROW
;

111 
	$mlockl
 (
__ags

__THROW
;

115 
	$muockl
 (
__THROW
;

117 #ifde
__USE_MISC


123 
	$mce
 (*
__t
, 
size_t
 
__n
, *
__vec
)

124 
__THROW
;

127 #ifde
__USE_GNU


133 *
	$mm
 (*
__addr
, 
size_t
 
__d_n
, size_
__w_n
,

134 
__ags
, ...
__THROW
;

138 
	$m_fe_ges
 (*
__t
, 
size_t
 
__size
, 
__
,

139 
size_t
 
__pgoff
, 
__ags

__THROW
;

144 
	`shm_ݒ
 (cڡ *
__me
, 
__oag
, 
mode_t
 
__mode
);

147 
	`shm_uƚk
 (cڡ *
__me
);

149 
__END_DECLS


	@/usr/include/sys/param.h

19 #ide
_SYS_PARAM_H


20 
	#_SYS_PARAM_H
 1

	)

22 
	#__ed_NULL


	)

23 
	~<ddef.h
>

25 
	~<sys/tys.h
>

26 
	~<lims.h
>

27 
	~<dn.h
>

28 
	~<sigl.h
>

31 
	~<bs/m.h
>

36 
	#NBBY
 
CHAR_BIT


	)

38 #i!
defed
 
NGROUPS
 && defed 
NGROUPS_MAX


39 
	#NGROUPS
 
NGROUPS_MAX


	)

41 #i!
defed
 
MAXSYMLINKS
 && defed 
SYMLOOP_MAX


42 
	#MAXSYMLINKS
 
SYMLOOP_MAX


	)

44 #i!
defed
 
CANBSIZ
 && defed 
MAX_CANON


45 
	#CANBSIZ
 
MAX_CANON


	)

47 #i!
defed
 
MAXPATHLEN
 && defed 
PATH_MAX


48 
	#MAXPATHLEN
 
PATH_MAX


	)

50 #i!
defed
 
NOFILE
 && defed 
OPEN_MAX


51 
	#NOFILE
 
OPEN_MAX


	)

53 #ide
NCARGS


54 #ifde
ARG_MAX


55 
	#NCARGS
 
ARG_MAX


	)

59 
	#NCARGS
 
INT_MAX


	)

65 #ide
NOGROUP


66 
	#NOGROUP
 65535

	)

68 #ide
NODEV


69 
	#NODEV
 ((
dev_t
-1

	)

74 #ide
DEV_BSIZE


75 
	#DEV_BSIZE
 512

	)

80 
	#tb
(
a
,
i
()[(i)/
NBBY
] |1<<((i)%NBBY))

	)

81 
	#rb
(
a
,
i
()[(i)/
NBBY
] &~(1<<((i)%NBBY)))

	)

82 
	#ist
(
a
,
i
()[(i)/
NBBY
] & (1<<((i)%NBBY)))

	)

83 
	#isr
(
a
,
i
(()[(i)/
NBBY
] & (1<<((i)%NBBY))=0)

	)

86 #ide
howmy


87 
	#howmy
(
x
, 
y
(((x+ ((y- 1)/ (y))

	)

89 #ifde
__GNUC__


90 
	#roundup
(
x
, 
y
(
	`__but_cڡt_p
 (y&& 
	`powof2
 (y) \

91 ? (((
x
+ (
y
) - 1) & ~((y) - 1)) \

92 : ((((
x
+ ((
y
- 1)/ (y)* (y)))

	)

94 
	#roundup
(
x
, 
y
((((x+ ((y- 1)/ (y)* (y))

	)

96 
	#powof2
(
x
((((x- 1& (x)=0)

	)

99 
	#MIN
(
a
,
b
(()<(b))?):(b))

	)

100 
	#MAX
(
a
,
b
(()>(b))?):(b))

	)

	@/usr/include/sys/sysctl.h

18 #idef 
_SYS_SYSCTL_H


19 
	#_SYS_SYSCTL_H
 1

	)

21 
	~<us.h
>

22 
	#__ed_size_t


	)

23 
	~<ddef.h
>

25 #ide
_LINUX_KERNEL_H


26 
	#_LINUX_KERNEL_H
 1

	)

27 
	#__undef_LINUX_KERNEL_H


	)

29 #ide
_LINUX_TYPES_H


30 
	#_LINUX_TYPES_H
 1

	)

31 
	#__undef_LINUX_TYPES_H


	)

33 #ide
_LINUX_LIST_H


34 
	#_LINUX_LIST_H
 1

	)

35 
	#__undef_LINUX_LIST_H


	)

37 #ide
__LINUX_COMPILER_H


38 
	#__LINUX_COMPILER_H
 1

	)

39 
	#__ur


	)

40 
	#__undef__LINUX_COMPILER_H


	)

43 
	~<lux/sysl.h
>

45 #ifde
__undef_LINUX_KERNEL_H


46 #unde
_LINUX_KERNEL_H


47 #unde
__undef_LINUX_KERNEL_H


49 #ifde
__undef_LINUX_TYPES_H


50 #unde
_LINUX_TYPES_H


51 #unde
__undef_LINUX_TYPES_H


53 #ifde
__undef_LINUX_LIST_H


54 #unde
_LINUX_LIST_H


55 #unde
__undef_LINUX_LIST_H


57 #ifde
__undef__LINUX_COMPILER_H


58 #unde
__LINUX_COMPILER_H


59 #unde
__ur


60 #unde
__undef__LINUX_COMPILER_H


63 
	~<bs/sysl.h
>

65 
__BEGIN_DECLS


68 
	$sysl
 (*
__me
, 
__ƒ
, *
__dv
,

69 
size_t
 *
__d
, *
__wv
, size_
__wn

__THROW
;

71 
__END_DECLS


	@/usr/include/sys/time.h

18 #ide
_SYS_TIME_H


19 
	#_SYS_TIME_H
 1

	)

21 
	~<us.h
>

23 
	~<bs/tys.h
>

24 
	#__ed_time_t


	)

25 
	~<time.h
>

26 
	#__ed_timev


	)

27 
	~<bs/time.h
>

29 
	~<sys/.h
>

31 #ide
__sucds_t_defed


32 
__sucds_t
 
	tsucds_t
;

33 
	#__sucds_t_defed


	)

37 
	g__BEGIN_DECLS


39 #ifde
__USE_GNU


41 
	#TIMEVAL_TO_TIMESPEC
(
tv
, 
ts
) { \

42 (
ts
)->
tv_c
 = (
tv
)->tv_sec; \

43 (
ts
)->
tv_nc
 = (
tv
)->
tv_uc
 * 1000; \

44 }

	)

45 
	#TIMESPEC_TO_TIMEVAL
(
tv
, 
ts
) { \

46 (
tv
)->
tv_c
 = (
ts
)->tv_sec; \

47 (
tv
)->
tv_uc
 = (
ts
)->
tv_nc
 / 1000; \

48 }

	)

52 #ifde
__USE_BSD


55 
	stimeze


57 
	mtz_muswe
;

58 
	mtz_dtime
;

61 
timeze
 *
	t__ri
 
	t__timeze_r_t
;

63 *
	t__ri
 
	t__timeze_r_t
;

71 
	$gtimeofday
 (
timev
 *
__ri
 
__tv
,

72 
__timeze_r_t
 
__tz

__THROW
 
	`__nnu
 ((1));

74 #ifde
__USE_BSD


77 
	$imeofday
 (cڡ 
timev
 *
__tv
,

78 cڡ 
timeze
 *
__tz
)

79 
__THROW
;

85 
	$adjtime
 (cڡ 
timev
 *
__d
,

86 
timev
 *
__dd

__THROW
;

91 
	e__im_which


94 
ITIMER_REAL
 = 0,

95 
	#ITIMER_REAL
 
ITIMER_REAL


	)

97 
ITIMER_VIRTUAL
 = 1,

98 
	#ITIMER_VIRTUAL
 
ITIMER_VIRTUAL


	)

101 
ITIMER_PROF
 = 2

102 
	#ITIMER_PROF
 
ITIMER_PROF


	)

107 
	simv


110 
timev
 
_rv
;

112 
timev
 
_vue
;

115 #i
defed
 
__USE_GNU
 && !defed 
__lulus


118 
__im_which
 
	t__im_which_t
;

120 
	t__im_which_t
;

125 
	$gim
 (
__im_which_t
 
__which
,

126 
imv
 *
__vue

__THROW
;

131 
	$tim
 (
__im_which_t
 
__which
,

132 cڡ 
imv
 *
__ri
 
__w
,

133 
imv
 *
__ri
 
__d

__THROW
;

138 
	$utimes
 (cڡ *
__fe
, cڡ 
timev
 
__tvp
[2])

139 
__THROW
 
	`__nnu
 ((1));

141 #ifde
__USE_BSD


143 
	$lutimes
 (cڡ *
__fe
, cڡ 
timev
 
__tvp
[2])

144 
__THROW
 
	`__nnu
 ((1));

147 
	$futimes
 (
__fd
, cڡ 
timev
 
__tvp
[2]
__THROW
;

150 #ifde
__USE_GNU


154 
	$futimet
 (
__fd
, cڡ *
__fe
,

155 cڡ 
timev
 
__tvp
[2]
__THROW
;

159 #ifde
__USE_BSD


162 
	#timist
(
tvp
(vp)->
tv_c
 || (tvp)->
tv_uc
)

	)

163 
	#timr
(
tvp
(vp)->
tv_c
 = (tvp)->
tv_uc
 = 0)

	)

164 
	#timcmp
(
a
, 
b
, 
CMP
) \

165 (((
a
)->
tv_c
 =(
b
)->tv_sec) ? \

166 ((
a
)->
tv_uc
 
	`CMP
 (
b
)->tv_usec) : \

167 ((
a
)->
tv_c
 
	`CMP
 (
b
)->tv_c))

	)

168 
	#timadd
(
a
, 
b
, 
su
) \

170 (
su
)->
tv_c
 = (
a
)->tv_+ (
b
)->tv_sec; \

171 (
su
)->
tv_uc
 = (
a
)->tv_u+ (
b
)->tv_usec; \

172 i((
su
)->
tv_uc
 >= 1000000) \

174 ++(
su
)->
tv_c
; \

175 (
su
)->
tv_uc
 -= 1000000; \

177 
	}
} 0)

	)

178 
	#timsub
(
a
, 
b
, 
su
) \

180 (
su
)->
tv_c
 = (
a
)->tv_- (
b
)->tv_sec; \

181 (
su
)->
tv_uc
 = (
a
)->tv_u- (
b
)->tv_usec; \

182 i((
su
)->
tv_uc
 < 0) { \

183 --(
su
)->
tv_c
; \

184 (
su
)->
tv_uc
 += 1000000; \

186 } 0)

	)

189 
	g__END_DECLS


	@/usr/include/sys/timeb.h

18 #ide
_SYS_TIMEB_H


19 
	#_SYS_TIMEB_H
 1

	)

21 
	~<us.h
>

23 
	#__ed_time_t


	)

24 
	~<time.h
>

27 
__BEGIN_DECLS


31 
	stimeb


33 
time_t
 
	mtime
;

34 
	mmlm
;

35 
	mtimeze
;

36 
	mdag
;

41 
ime
 (
timeb
 *
__timebuf
);

43 
	g__END_DECLS


	@/usr/include/sys/types.h

22 #idef 
_SYS_TYPES_H


23 
	#_SYS_TYPES_H
 1

	)

25 
	~<us.h
>

27 
	g__BEGIN_DECLS


29 
	~<bs/tys.h
>

31 #ifdef 
__USE_BSD


32 #ide
__u_ch_defed


33 
__u_ch
 
	tu_ch
;

34 
__u_sht
 
	tu_sht
;

35 
__u_t
 
	tu_t
;

36 
__u_lg
 
	tu_lg
;

37 
__quad_t
 
	tquad_t
;

38 
__u_quad_t
 
	tu_quad_t
;

39 
__fsid_t
 
	tfsid_t
;

40 
	#__u_ch_defed


	)

44 
__loff_t
 
	tloff_t
;

46 #ide
__o_t_defed


47 #ide
__USE_FILE_OFFSET64


48 
__o_t
 
	to_t
;

50 
__o64_t
 
	to_t
;

52 
	#__o_t_defed


	)

54 #i
defed
 
__USE_LARGEFILE64
 && !defed 
__o64_t_defed


55 
__o64_t
 
	to64_t
;

56 
	#__o64_t_defed


	)

59 #ide
__dev_t_defed


60 
__dev_t
 
	tdev_t
;

61 
	#__dev_t_defed


	)

64 #ide
__gid_t_defed


65 
__gid_t
 
	tgid_t
;

66 
	#__gid_t_defed


	)

69 #ide
__mode_t_defed


70 
__mode_t
 
	tmode_t
;

71 
	#__mode_t_defed


	)

74 #ide
__ƚk_t_defed


75 
__ƚk_t
 
	tƚk_t
;

76 
	#__ƚk_t_defed


	)

79 #ide
__uid_t_defed


80 
__uid_t
 
	tuid_t
;

81 
	#__uid_t_defed


	)

84 #ide
__off_t_defed


85 #ide
__USE_FILE_OFFSET64


86 
__off_t
 
	toff_t
;

88 
__off64_t
 
	toff_t
;

90 
	#__off_t_defed


	)

92 #i
defed
 
__USE_LARGEFILE64
 && !defed 
__off64_t_defed


93 
__off64_t
 
	toff64_t
;

94 
	#__off64_t_defed


	)

97 #ide
__pid_t_defed


98 
__pid_t
 
	tpid_t
;

99 
	#__pid_t_defed


	)

102 #i(
defed
 
__USE_SVID
 || defed 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8
) \

103 && !
defed
 
__id_t_defed


104 
__id_t
 
	tid_t
;

105 
	#__id_t_defed


	)

108 #ide
__ssize_t_defed


109 
__ssize_t
 
	tssize_t
;

110 
	#__ssize_t_defed


	)

113 #ifdef 
__USE_BSD


114 #ide
__daddr_t_defed


115 
__daddr_t
 
	tdaddr_t
;

116 
__ddr_t
 
	tddr_t
;

117 
	#__daddr_t_defed


	)

121 #i(
defed
 
__USE_SVID
 || defed 
__USE_XOPEN
&& !defed 
__key_t_defed


122 
__key_t
 
	tkey_t
;

123 
	#__key_t_defed


	)

126 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8


127 
	#__ed_ock_t


	)

129 
	#__ed_time_t


	)

130 
	#__ed_tim_t


	)

131 
	#__ed_ockid_t


	)

132 
	~<time.h
>

134 #ifde
__USE_XOPEN


135 #ide
__ucds_t_defed


136 
__ucds_t
 
	tucds_t
;

137 
	#__ucds_t_defed


	)

139 #ide
__sucds_t_defed


140 
__sucds_t
 
	tsucds_t
;

141 
	#__sucds_t_defed


	)

145 
	#__ed_size_t


	)

146 
	~<ddef.h
>

148 #ifde
__USE_MISC


150 
	tulg
;

151 
	tusht
;

152 
	tut
;

157 #i!
__GNUC_PREREQ
 (2, 7)

160 #ide
__t8_t_defed


161 
	#__t8_t_defed


	)

162 
	tt8_t
;

163 
	tt16_t
;

164 
	tt32_t
;

165 #i
__WORDSIZE
 == 64

166 
	tt64_t
;

168 
__exnsi__
 
	tt64_t
;

173 
	tu_t8_t
;

174 
	tu_t16_t
;

175 
	tu_t32_t
;

176 #i
__WORDSIZE
 == 64

177 
	tu_t64_t
;

179 
__exnsi__
 
	tu_t64_t
;

182 
	tgi_t
;

187 
	#__tN_t
(
N
, 
MODE
) \

188 ##
	tN
##
	t_t
 
	t__ibu__
 ((
	t__mode__
 (
	tMODE
)))

	)

189 
	t__u_tN_t
(
	tN
, 
	tMODE
) \

190 
	tu_t
##
	tN
##
	t_t
 
	t__ibu__
 ((
	t__mode__
 (
	tMODE
)))

	)

192 #ide
	t__t8_t_defed


193 
	t__t8_t_defed


	)

194 
	t__tN_t
 (8, 
	t__QI__
);

195 
__tN_t
 (16, 
__HI__
);

196 
__tN_t
 (32, 
__SI__
);

197 
__tN_t
 (64, 
__DI__
);

200 
__u_tN_t
 (8, 
__QI__
);

201 
__u_tN_t
 (16, 
__HI__
);

202 
__u_tN_t
 (32, 
__SI__
);

203 
__u_tN_t
 (64, 
__DI__
);

205 
	tgi_t
 
	t__ibu__
 ((
	t__mode__
 (
	t__wd__
)));

211 
	#__BIT_TYPES_DEFINED__
 1

	)

214 #ifdef 
__USE_BSD


216 
	~<dn.h
>

219 
	~<sys/.h
>

222 
	~<sys/sysmaos.h
>

226 #i(
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K8
) \

227 && !
defed
 
__blksize_t_defed


228 
__blksize_t
 
	tblksize_t
;

229 
	#__blksize_t_defed


	)

233 #ide
__USE_FILE_OFFSET64


234 #ide
__blkt_t_defed


235 
__blkt_t
 
	tblkt_t
;

236 
	#__blkt_t_defed


	)

238 #ide
__fsblkt_t_defed


239 
__fsblkt_t
 
	tfsblkt_t
;

240 
	#__fsblkt_t_defed


	)

242 #ide
__fsft_t_defed


243 
__fsft_t
 
	tfsft_t
;

244 
	#__fsft_t_defed


	)

247 #ide
__blkt_t_defed


248 
__blkt64_t
 
	tblkt_t
;

249 
	#__blkt_t_defed


	)

251 #ide
__fsblkt_t_defed


252 
__fsblkt64_t
 
	tfsblkt_t
;

253 
	#__fsblkt_t_defed


	)

255 #ide
__fsft_t_defed


256 
__fsft64_t
 
	tfsft_t
;

257 
	#__fsft_t_defed


	)

261 #ifde
__USE_LARGEFILE64


262 
__blkt64_t
 
	tblkt64_t
;

263 
__fsblkt64_t
 
	tfsblkt64_t
;

264 
__fsft64_t
 
	tfsft64_t
;

269 #i
defed
 
__USE_POSIX199506
 || defed 
__USE_UNIX98


270 
	~<bs/hadtys.h
>

273 
	g__END_DECLS


	@/usr/include/sys/utsname.h

22 #idef 
_SYS_UTSNAME_H


23 
	#_SYS_UTSNAME_H
 1

	)

25 
	~<us.h
>

27 
	g__BEGIN_DECLS


29 
	~<bs/utame.h
>

31 #ide
_UTSNAME_SYSNAME_LENGTH


32 
	#_UTSNAME_SYSNAME_LENGTH
 
_UTSNAME_LENGTH


	)

34 #ide
_UTSNAME_NODENAME_LENGTH


35 
	#_UTSNAME_NODENAME_LENGTH
 
_UTSNAME_LENGTH


	)

37 #ide
_UTSNAME_RELEASE_LENGTH


38 
	#_UTSNAME_RELEASE_LENGTH
 
_UTSNAME_LENGTH


	)

40 #ide
_UTSNAME_VERSION_LENGTH


41 
	#_UTSNAME_VERSION_LENGTH
 
_UTSNAME_LENGTH


	)

43 #ide
_UTSNAME_MACHINE_LENGTH


44 
	#_UTSNAME_MACHINE_LENGTH
 
_UTSNAME_LENGTH


	)

48 
	sutame


51 
	msyame
[
_UTSNAME_SYSNAME_LENGTH
];

54 
	mnodame
[
_UTSNAME_NODENAME_LENGTH
];

57 
	ma
[
_UTSNAME_RELEASE_LENGTH
];

59 
	mvsi
[
_UTSNAME_VERSION_LENGTH
];

62 
	mmache
[
_UTSNAME_MACHINE_LENGTH
];

64 #i
_UTSNAME_DOMAIN_LENGTH
 - 0

66 #ifde
__USE_GNU


67 
	mdomame
[
_UTSNAME_DOMAIN_LENGTH
];

69 
	m__domame
[
_UTSNAME_DOMAIN_LENGTH
];

74 #ifde
__USE_SVID


76 
	#SYS_NMLN
 
_UTSNAME_LENGTH


	)

81 
	$ume
 (
utame
 *
__me

__THROW
;

84 
__END_DECLS


	@/usr/include/time.h

22 #idef 
_TIME_H


24 #i(! 
defed
 
__ed_time_t
 && !defed 
__ed_ock_t
 && \

25 ! 
defed
 
	g__ed_timeec
)

26 
	#_TIME_H
 1

	)

27 
	~<us.h
>

29 
	g__BEGIN_DECLS


33 #ifdef 
_TIME_H


35 
	#__ed_size_t


	)

36 
	#__ed_NULL


	)

37 
	~<ddef.h
>

41 
	~<bs/time.h
>

44 #i!
defed
 
__STRICT_ANSI__
 && !defed 
__USE_XOPEN2K


45 #ide
CLK_TCK


46 
	#CLK_TCK
 
CLOCKS_PER_SEC


	)

52 #i!
defed
 
__ock_t_defed
 && (defed 
_TIME_H
 || defed 
__ed_ock_t
)

53 
	#__ock_t_defed
 1

	)

55 
	~<bs/tys.h
>

57 
__BEGIN_NAMESPACE_STD


59 
__ock_t
 
	tock_t
;

60 
	g__END_NAMESPACE_STD


61 #i
defed
 
__USE_XOPEN
 || defed 
__USE_POSIX
 || defed 
__USE_MISC


62 
	$__USING_NAMESPACE_STD
(
ock_t
)

66 #unde
__ed_ock_t


68 #i!
defed
 
__time_t_defed
 && (defed 
_TIME_H
 || defed 
__ed_time_t
)

69 
	#__time_t_defed
 1

	)

71 
	~<bs/tys.h
>

73 
__BEGIN_NAMESPACE_STD


75 
__time_t
 
	ttime_t
;

76 
__END_NAMESPACE_STD


77 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC
 || defed 
__USE_SVID


78 
	$__USING_NAMESPACE_STD
(
time_t
)

82 #unde
__ed_time_t


84 #i!
defed
 
__ockid_t_defed
 && \

85 ((
defed
 
_TIME_H
 && defed 
__USE_POSIX199309
|| defed 
__ed_ockid_t
)

86 
	#__ockid_t_defed
 1

	)

88 
	~<bs/tys.h
>

91 
__ockid_t
 
	tockid_t
;

94 #unde
__ockid_time_t


96 #i!
defed
 
__tim_t_defed
 && \

97 ((
defed
 
_TIME_H
 && defed 
__USE_POSIX199309
|| defed 
__ed_tim_t
)

98 
	#__tim_t_defed
 1

	)

100 
	~<bs/tys.h
>

103 
__tim_t
 
	ttim_t
;

106 #unde
__ed_tim_t


109 #i(!
defed
 
__timeec_defed
 \

110 && ((
defed
 
_TIME_H
 \

111 && (
defed
 
__USE_POSIX199309
 || defed 
__USE_MISC
 \

112 || 
defed
 
__USE_ISOC11
)) \

113 || 
defed
 
__ed_timeec
))

114 
	#__timeec_defed
 1

	)

116 
	~<bs/tys.h
>

120 
	stimeec


122 
__time_t
 
tv_c
;

123 
__sys_g_t
 
tv_nc
;

127 #unde
__ed_timeec


130 #ifdef 
_TIME_H


131 
__BEGIN_NAMESPACE_STD


133 
	stm


135 
tm_c
;

136 
tm_m
;

137 
tm_hour
;

138 
tm_mday
;

139 
tm_m
;

140 
tm_yr
;

141 
tm_wday
;

142 
tm_yday
;

143 
tm_isd
;

145 #ifdef 
__USE_BSD


146 
tm_gmtoff
;

147 cڡ *
tm_ze
;

149 
__tm_gmtoff
;

150 cڡ *
__tm_ze
;

153 
__END_NAMESPACE_STD


154 #i
defed
 
__USE_XOPEN
 || defed 
__USE_POSIX
 || defed 
__USE_MISC


155 
	$__USING_NAMESPACE_STD
(
tm
)

159 #ifde
__USE_POSIX199309


161 
	simec


163 
timeec
 
_rv
;

164 
timeec
 
_vue
;

168 
sigevt
;

172 #ifde
__USE_XOPEN2K


173 #ide
__pid_t_defed


174 
__pid_t
 
	tpid_t
;

175 
	#__pid_t_defed


	)

180 #ifde
__USE_ISOC11


182 
	#TIME_UTC
 1

	)

186 
__BEGIN_NAMESPACE_STD


189 
ock_t
 
	$ock
 (
__THROW
;

192 
time_t
 
	$time
 (
time_t
 *
__tim

__THROW
;

195 
	$difime
 (
time_t
 
__time1
,ime_
__time0
)

196 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

199 
time_t
 
	$mktime
 (
tm
 *
__

__THROW
;

205 
size_t
 
	$rime
 (*
__ri
 
__s
, 
size_t
 
__maxsize
,

206 cڡ *
__ri
 
__fm
,

207 cڡ 
tm
 *
__ri
 
__

__THROW
;

208 
__END_NAMESPACE_STD


210 #ifde
__USE_XOPEN


213 *
	$time
 (cڡ *
__ri
 
__s
,

214 cڡ *
__ri
 
__fmt
, 
tm
 *
__
)

215 
__THROW
;

218 #ifde
__USE_XOPEN2K8


221 
	~<xlo.h
>

223 
size_t
 
	$rime_l
 (*
__ri
 
__s
, 
size_t
 
__maxsize
,

224 cڡ *
__ri
 
__fm
,

225 cڡ 
tm
 *
__ri
 
__
,

226 
__lo_t
 
__loc

__THROW
;

229 #ifde
__USE_GNU


230 *
	$time_l
 (cڡ *
__ri
 
__s
,

231 cڡ *
__ri
 
__fmt
, 
tm
 *
__
,

232 
__lo_t
 
__loc

__THROW
;

236 
__BEGIN_NAMESPACE_STD


239 
tm
 *
	$gmtime
 (cڡ 
time_t
 *
__tim

__THROW
;

243 
tm
 *
	$loime
 (cڡ 
time_t
 *
__tim

__THROW
;

244 
__END_NAMESPACE_STD


246 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


249 
tm
 *
	$gmtime_r
 (cڡ 
time_t
 *
__ri
 
__tim
,

250 
tm
 *
__ri
 
__

__THROW
;

254 
tm
 *
	$loime_r
 (cڡ 
time_t
 *
__ri
 
__tim
,

255 
tm
 *
__ri
 
__

__THROW
;

258 
__BEGIN_NAMESPACE_STD


261 *
	$asime
 (cڡ 
tm
 *
__

__THROW
;

264 *
	$ime
 (cڡ 
time_t
 *
__tim

__THROW
;

265 
__END_NAMESPACE_STD


267 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


272 *
	$asime_r
 (cڡ 
tm
 *
__ri
 
__
,

273 *
__ri
 
__buf

__THROW
;

276 *
	$ime_r
 (cڡ 
time_t
 *
__ri
 
__tim
,

277 *
__ri
 
__buf

__THROW
;

282 *
__tzme
[2];

283 
__daylight
;

284 
__timeze
;

287 #ifdef 
__USE_POSIX


289 *
tzme
[2];

293 
	$tzt
 (
__THROW
;

296 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN


297 
daylight
;

298 
timeze
;

301 #ifde
__USE_SVID


304 
	$ime
 (cڡ 
time_t
 *
__wh

__THROW
;

310 
	#__ip
(
yr
) \

311 ((
yr
% 4 =0 && ((yr% 100 !0 || (yr% 400 =0))

	)

314 #ifde
__USE_MISC


319 
time_t
 
	$timegm
 (
tm
 *
__

__THROW
;

322 
time_t
 
	$timol
 (
tm
 *
__

__THROW
;

325 
	$dysize
 (
__yr

__THROW
 
	`__ibu__
 ((
__cڡ__
));

329 #ifde
__USE_POSIX199309


334 
	`nop
 (cڡ 
timeec
 *
__queed_time
,

335 
timeec
 *
__mag
);

339 
	$ock_gs
 (
ockid_t
 
__ock_id
, 
timeec
 *
__s

__THROW
;

342 
	$ock_gtime
 (
ockid_t
 
__ock_id
, 
timeec
 *
__

__THROW
;

345 
	$ock_ime
 (
ockid_t
 
__ock_id
, cڡ 
timeec
 *
__
)

346 
__THROW
;

348 #ifde
__USE_XOPEN2K


353 
	`ock_nop
 (
ockid_t
 
__ock_id
, 
__ags
,

354 cڡ 
timeec
 *
__q
,

355 
timeec
 *
__m
);

358 
	$ock_guockid
 (
pid_t
 
__pid
, 
ockid_t
 *
__ock_id

__THROW
;

363 
	$tim_
 (
ockid_t
 
__ock_id
,

364 
sigevt
 *
__ri
 
__evp
,

365 
tim_t
 *
__ri
 
__timid

__THROW
;

368 
	$tim_de
 (
tim_t
 
__timid

__THROW
;

371 
	$tim_ime
 (
tim_t
 
__timid
, 
__ags
,

372 cڡ 
imec
 *
__ri
 
__vue
,

373 
imec
 *
__ri
 
__ovue

__THROW
;

376 
	$tim_gtime
 (
tim_t
 
__timid
, 
imec
 *
__vue
)

377 
__THROW
;

380 
	$tim_govrun
 (
tim_t
 
__timid

__THROW
;

384 #ifde
__USE_ISOC11


386 
	$timeec_g
 (
timeec
 *
__ts
, 
__ba
)

387 
__THROW
 
	`__nnu
 ((1));

391 #ifde
__USE_XOPEN_EXTENDED


403 
gde_r
;

412 
tm
 *
	`gde
 (cڡ *
__rg
);

415 #ifde
__USE_GNU


426 
	`gde_r
 (cڡ *
__ri
 
__rg
,

427 
tm
 *
__ri
 
__sbu
);

430 
__END_DECLS


	@/usr/include/unistd.h

22 #idef 
_UNISTD_H


23 
	#_UNISTD_H
 1

	)

25 
	~<us.h
>

27 
	g__BEGIN_DECLS


32 #ifde
__USE_XOPEN2K8


34 
	#_POSIX_VERSION
 200809L

	)

35 #i
defed
 
__USE_XOPEN2K


37 
	#_POSIX_VERSION
 200112L

	)

38 #i
defed
 
__USE_POSIX199506


40 
	#_POSIX_VERSION
 199506L

	)

41 #i
defed
 
__USE_POSIX199309


43 
	#_POSIX_VERSION
 199309L

	)

46 
	#_POSIX_VERSION
 199009L

	)

52 #ifde
__USE_XOPEN2K8


53 
	#__POSIX2_THIS_VERSION
 200809L

	)

55 #i
defed
 
__USE_XOPEN2K


57 
	#__POSIX2_THIS_VERSION
 200112L

	)

58 #i
defed
 
__USE_POSIX199506


60 
	#__POSIX2_THIS_VERSION
 199506L

	)

63 
	#__POSIX2_THIS_VERSION
 199209L

	)

67 
	#_POSIX2_VERSION
 
__POSIX2_THIS_VERSION


	)

71 
	#_POSIX2_C_BIND
 
__POSIX2_THIS_VERSION


	)

75 
	#_POSIX2_C_DEV
 
__POSIX2_THIS_VERSION


	)

79 
	#_POSIX2_SW_DEV
 
__POSIX2_THIS_VERSION


	)

83 
	#_POSIX2_LOCALEDEF
 
__POSIX2_THIS_VERSION


	)

86 #ifde
__USE_XOPEN2K8


87 
	#_XOPEN_VERSION
 700

	)

88 #i
defed
 
__USE_XOPEN2K


89 
	#_XOPEN_VERSION
 600

	)

90 #i
defed
 
__USE_UNIX98


91 
	#_XOPEN_VERSION
 500

	)

93 
	#_XOPEN_VERSION
 4

	)

97 
	#_XOPEN_XCU_VERSION
 4

	)

100 
	#_XOPEN_XPG2
 1

	)

101 
	#_XOPEN_XPG3
 1

	)

102 
	#_XOPEN_XPG4
 1

	)

105 
	#_XOPEN_UNIX
 1

	)

108 
	#_XOPEN_CRYPT
 1

	)

112 
	#_XOPEN_ENH_I18N
 1

	)

115 
	#_XOPEN_LEGACY
 1

	)

202 
	~<bs/posix_t.h
>

205 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K


206 
	~<bs/vmts.h
>

210 
	#STDIN_FILENO
 0

	)

211 
	#STDOUT_FILENO
 1

	)

212 
	#STDERR_FILENO
 2

	)

217 
	~<bs/tys.h
>

219 #idef 
__ssize_t_defed


220 
__ssize_t
 
	tssize_t
;

221 
	#__ssize_t_defed


	)

224 
	#__ed_size_t


	)

225 
	#__ed_NULL


	)

226 
	~<ddef.h
>

228 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K


231 #ide
__gid_t_defed


232 
__gid_t
 
	tgid_t
;

233 
	#__gid_t_defed


	)

236 #ide
__uid_t_defed


237 
__uid_t
 
	tuid_t
;

238 
	#__uid_t_defed


	)

241 #ide
__off_t_defed


242 #ide
__USE_FILE_OFFSET64


243 
__off_t
 
	toff_t
;

245 
__off64_t
 
	toff_t
;

247 
	#__off_t_defed


	)

249 #i
defed
 
__USE_LARGEFILE64
 && !defed 
__off64_t_defed


250 
__off64_t
 
	toff64_t
;

251 
	#__off64_t_defed


	)

254 #ide
__ucds_t_defed


255 
__ucds_t
 
	tucds_t
;

256 
	#__ucds_t_defed


	)

259 #ide
__pid_t_defed


260 
__pid_t
 
	tpid_t
;

261 
	#__pid_t_defed


	)

265 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K


266 #ide
___t_defed


267 
___t
 
	t_t
;

268 
	#___t_defed


	)

272 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN


273 #ide
__sockn_t_defed


274 
__sockn_t
 
	tsockn_t
;

275 
	#__sockn_t_defed


	)

281 
	#R_OK
 4

	)

282 
	#W_OK
 2

	)

283 
	#X_OK
 1

	)

284 
	#F_OK
 0

	)

287 
	$acss
 (cڡ *
__me
, 
__ty

__THROW
 
	`__nnu
 ((1));

289 #ifde
__USE_GNU


292 
	$euidacss
 (cڡ *
__me
, 
__ty
)

293 
__THROW
 
	`__nnu
 ((1));

296 
	$css
 (cڡ *
__me
, 
__ty
)

297 
__THROW
 
	`__nnu
 ((1));

300 #ifde
__USE_ATFILE


304 
	$cst
 (
__fd
, cڡ *
__fe
, 
__ty
, 
__ag
)

305 
__THROW
 
	`__nnu
 ((2)
__wur
;

310 #idef 
_STDIO_H


311 
	#SEEK_SET
 0

	)

312 
	#SEEK_CUR
 1

	)

313 
	#SEEK_END
 2

	)

314 #ifde
__USE_GNU


315 
	#SEEK_DATA
 3

	)

316 
	#SEEK_HOLE
 4

	)

320 #i
defed
 
__USE_BSD
 && !defed 
L_SET


322 
	#L_SET
 
SEEK_SET


	)

323 
	#L_INCR
 
SEEK_CUR


	)

324 
	#L_XTND
 
SEEK_END


	)

333 #ide
__USE_FILE_OFFSET64


334 
__off_t
 
	$lek
 (
__fd
, 
__off_t
 
__offt
, 
__wh

__THROW
;

336 #ifde
__REDIRECT_NTH


337 
__off64_t
 
	`__REDIRECT_NTH
 (
lek
,

338 (
__fd
, 
__off64_t
 
__offt
, 
__wh
),

339 
lek64
);

341 
	#lek
 
lek64


	)

344 #ifde
__USE_LARGEFILE64


345 
__off64_t
 
	$lek64
 (
__fd
, 
__off64_t
 
__offt
, 
__wh
)

346 
__THROW
;

353 
	`o
 (
__fd
);

360 
ssize_t
 
	$ad
 (
__fd
, *
__buf
, 
size_t
 
__nbys

__wur
;

366 
ssize_t
 
	$wre
 (
__fd
, cڡ *
__buf
, 
size_t
 
__n

__wur
;

368 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K8


369 #ide
__USE_FILE_OFFSET64


376 
ssize_t
 
	$d
 (
__fd
, *
__buf
, 
size_t
 
__nbys
,

377 
__off_t
 
__offt

__wur
;

384 
ssize_t
 
	$pwre
 (
__fd
, cڡ *
__buf
, 
size_t
 
__n
,

385 
__off_t
 
__offt

__wur
;

387 #ifde
__REDIRECT


388 
ssize_t
 
	`__REDIRECT
 (
d
, (
__fd
, *
__buf
, 
size_t
 
__nbys
,

389 
__off64_t
 
__offt
),

390 
d64

__wur
;

391 
ssize_t
 
	`__REDIRECT
 (
pwre
, (
__fd
, cڡ *
__buf
,

392 
size_t
 
__nbys
, 
__off64_t
 
__offt
),

393 
pwre64

__wur
;

395 
	#d
 
d64


	)

396 
	#pwre
 
pwre64


	)

400 #ifde
__USE_LARGEFILE64


404 
ssize_t
 
	$d64
 (
__fd
, *
__buf
, 
size_t
 
__nbys
,

405 
__off64_t
 
__offt

__wur
;

408 
ssize_t
 
	$pwre64
 (
__fd
, cڡ *
__buf
, 
size_t
 
__n
,

409 
__off64_t
 
__offt

__wur
;

417 
	$pe
 (
__pedes
[2]
__THROW
 
__wur
;

419 #ifde
__USE_GNU


422 
	$pe2
 (
__pedes
[2], 
__ags

__THROW
 
__wur
;

432 
	$m
 (
__cds

__THROW
;

444 
	`p
 (
__cds
);

446 #i(
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_XOPEN2K8
) \

447 || 
defed
 
__USE_BSD


452 
__ucds_t
 
	$um
 (
__ucds_t
 
__vue
, __ucds_
__rv
)

453 
__THROW
;

460 
	`up
 (
__ucds_t
 
__ucds
);

469 
	`u
 ();

473 
	$chown
 (cڡ *
__fe
, 
__uid_t
 
__owr
, 
__gid_t
 
__group
)

474 
__THROW
 
	`__nnu
 ((1)
__wur
;

476 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K8


478 
	$fchown
 (
__fd
, 
__uid_t
 
__owr
, 
__gid_t
 
__group

__THROW
 
__wur
;

483 
	$lchown
 (cڡ *
__fe
, 
__uid_t
 
__owr
, 
__gid_t
 
__group
)

484 
__THROW
 
	`__nnu
 ((1)
__wur
;

488 #ifde
__USE_ATFILE


491 
	$fchowt
 (
__fd
, cڡ *
__fe
, 
__uid_t
 
__owr
,

492 
__gid_t
 
__group
, 
__ag
)

493 
__THROW
 
	`__nnu
 ((2)
__wur
;

497 
	$chd
 (cڡ *
__th

__THROW
 
	`__nnu
 ((1)
__wur
;

499 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K8


501 
	$fchd
 (
__fd

__THROW
 
__wur
;

511 *
	$gcwd
 (*
__buf
, 
size_t
 
__size

__THROW
 
__wur
;

513 #ifdef 
__USE_GNU


517 *
	$g_cut_d_me
 (
__THROW
;

520 #i(
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_XOPEN2K8
) \

521 || 
defed
 
__USE_BSD


525 *
	$gwd
 (*
__buf
)

526 
__THROW
 
	`__nnu
 ((1)
__ibu_dd__
 
__wur
;

531 
	$dup
 (
__fd

__THROW
 
__wur
;

534 
	$dup2
 (
__fd
, 
__fd2

__THROW
;

536 #ifde
__USE_GNU


539 
	$dup3
 (
__fd
, 
__fd2
, 
__ags

__THROW
;

543 **
__v
;

544 #ifde
__USE_GNU


545 **
v
;

551 
	$execve
 (cڡ *
__th
, *cڡ 
__gv
[],

552 *cڡ 
__vp
[]
__THROW
 
	`__nnu
 ((1, 2));

554 #ifde
__USE_XOPEN2K8


557 
	$xecve
 (
__fd
, *cڡ 
__gv
[], *cڡ 
__vp
[])

558 
__THROW
 
	`__nnu
 ((2));

563 
	$execv
 (cڡ *
__th
, *cڡ 
__gv
[])

564 
__THROW
 
	`__nnu
 ((1, 2));

568 
	$exee
 (cڡ *
__th
, cڡ *
__g
, ...)

569 
__THROW
 
	`__nnu
 ((1, 2));

573 
	$exe
 (cڡ *
__th
, cڡ *
__g
, ...)

574 
__THROW
 
	`__nnu
 ((1, 2));

578 
	$execvp
 (cڡ *
__fe
, *cڡ 
__gv
[])

579 
__THROW
 
	`__nnu
 ((1, 2));

584 
	$exep
 (cڡ *
__fe
, cڡ *
__g
, ...)

585 
__THROW
 
	`__nnu
 ((1, 2));

587 #ifde
__USE_GNU


590 
	$execv
 (cڡ *
__fe
, *cڡ 
__gv
[],

591 *cڡ 
__vp
[])

592 
__THROW
 
	`__nnu
 ((1, 2));

596 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN


598 
	$ni
 (
__c

__THROW
 
__wur
;

603 
	$_ex
 (
__us

	`__ibu__
 ((
__nܑu__
));

609 
	~<bs/came.h
>

612 
	$thcf
 (cڡ *
__th
, 
__me
)

613 
__THROW
 
	`__nnu
 ((1));

616 
	$hcf
 (
__fd
, 
__me

__THROW
;

619 
	$syscf
 (
__me

__THROW
;

621 #ifdef 
__USE_POSIX2


623 
size_t
 
	$cfr
 (
__me
, *
__buf
, 
size_t
 
__n

__THROW
;

628 
__pid_t
 
	$gpid
 (
__THROW
;

631 
__pid_t
 
	$gid
 (
__THROW
;

634 
__pid_t
 
	$gpg
 (
__THROW
;

637 
__pid_t
 
	$__gpgid
 (
__pid_t
 
__pid

__THROW
;

638 #i
defed
 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K8


639 
__pid_t
 
	$gpgid
 (
__pid_t
 
__pid

__THROW
;

646 
	$gid
 (
__pid_t
 
__pid
, __pid_
__pgid

__THROW
;

648 #i
defed
 
__USE_SVID
 || defed 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


660 
	$g
 (
__THROW
;

667 
__pid_t
 
	$tsid
 (
__THROW
;

669 #i
defed
 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K8


671 
__pid_t
 
	$gsid
 (
__pid_t
 
__pid

__THROW
;

675 
__uid_t
 
	$guid
 (
__THROW
;

678 
__uid_t
 
	$geuid
 (
__THROW
;

681 
__gid_t
 
	$ggid
 (
__THROW
;

684 
__gid_t
 
	$gegid
 (
__THROW
;

689 
	$ggroups
 (
__size
, 
__gid_t
 
__li
[]
__THROW
 
__wur
;

691 #ifdef 
__USE_GNU


693 
	$group_memb
 (
__gid_t
 
__gid

__THROW
;

700 
	$tuid
 (
__uid_t
 
__uid

__THROW
 
__wur
;

702 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


705 
	$euid
 (
__uid_t
 
__ruid
, __uid_
__euid

__THROW
 
__wur
;

708 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN2K


710 
	$uid
 (
__uid_t
 
__uid

__THROW
 
__wur
;

717 
	$tgid
 (
__gid_t
 
__gid

__THROW
 
__wur
;

719 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


722 
	$egid
 (
__gid_t
 
__rgid
, __gid_
__egid

__THROW
 
__wur
;

725 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN2K


727 
	$gid
 (
__gid_t
 
__gid

__THROW
 
__wur
;

730 #ifde
__USE_GNU


733 
	$gsuid
 (
__uid_t
 *
__ruid
, __uid_*
__euid
, __uid_*
__suid
)

734 
__THROW
;

738 
	$gsgid
 (
__gid_t
 *
__rgid
, __gid_*
__egid
, __gid_*
__sgid
)

739 
__THROW
;

743 
	$esuid
 (
__uid_t
 
__ruid
, __uid_
__euid
, __uid_
__suid
)

744 
__THROW
 
__wur
;

748 
	$esgid
 (
__gid_t
 
__rgid
, __gid_
__egid
, __gid_
__sgid
)

749 
__THROW
 
__wur
;

756 
__pid_t
 
	$fk
 (
__THROWNL
;

758 #i(
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_XOPEN2K8
) \

759 || 
defed
 
__USE_BSD


764 
__pid_t
 
	$vfk
 (
__THROW
;

770 *
	$yme
 (
__fd

__THROW
;

774 
	$yme_r
 (
__fd
, *
__buf
, 
size_t
 
__bu
)

775 
__THROW
 
	`__nnu
 ((2)
__wur
;

779 
	$iy
 (
__fd

__THROW
;

781 #i
defed
 
__USE_BSD
 \

782 || (
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_UNIX98
)

785 
	$y
 (
__THROW
;

790 
	$lk
 (cڡ *
__om
, cڡ *
__to
)

791 
__THROW
 
	`__nnu
 ((1, 2)
__wur
;

793 #ifde
__USE_ATFILE


796 
	$lk
 (
__omfd
, cڡ *
__om
, 
__tofd
,

797 cڡ *
__to
, 
__ags
)

798 
__THROW
 
	`__nnu
 ((2, 4)
__wur
;

801 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K


803 
	$symlk
 (cڡ *
__om
, cڡ *
__to
)

804 
__THROW
 
	`__nnu
 ((1, 2)
__wur
;

809 
ssize_t
 
	$adlk
 (cڡ *
__ri
 
__th
,

810 *
__ri
 
__buf
, 
size_t
 
__n
)

811 
__THROW
 
	`__nnu
 ((1, 2)
__wur
;

814 #ifde
__USE_ATFILE


816 
	$symlk
 (cڡ *
__om
, 
__tofd
,

817 cڡ *
__to

__THROW
 
	`__nnu
 ((1, 3)
__wur
;

820 
ssize_t
 
	$adlk
 (
__fd
, cڡ *
__ri
 
__th
,

821 *
__ri
 
__buf
, 
size_t
 
__n
)

822 
__THROW
 
	`__nnu
 ((2, 3)
__wur
;

826 
	$uƚk
 (cڡ *
__me

__THROW
 
	`__nnu
 ((1));

828 #ifde
__USE_ATFILE


830 
	$uƚk
 (
__fd
, cڡ *
__me
, 
__ag
)

831 
__THROW
 
	`__nnu
 ((2));

835 
	$rmd
 (cڡ *
__th

__THROW
 
	`__nnu
 ((1));

839 
__pid_t
 
	$tcgpg
 (
__fd

__THROW
;

842 
	$tcg
 (
__fd
, 
__pid_t
 
__pg_id

__THROW
;

849 *
	`glog
 ();

850 #i
defed
 
__USE_REENTRANT
 || defed 
__USE_POSIX199506


857 
	$glog_r
 (*
__me
, 
size_t
 
__me_n

	`__nnu
 ((1));

860 #ifdef 
__USE_BSD


862 
	$og
 (cڡ *
__me

__THROW
 
	`__nnu
 ((1));

866 #ifdef 
__USE_POSIX2


870 
	#__ed_gt


	)

871 
	~<gt.h
>

875 #i
defed
 
__USE_BSD
 || defed 
__USE_UNIX98
 || defed 
__USE_XOPEN2K


879 
	$ghome
 (*
__me
, 
size_t
 
__n

__THROW
 
	`__nnu
 ((1));

883 #i
defed
 
__USE_BSD
 || (defed 
__USE_XOPEN
 && !defed 
__USE_UNIX98
)

886 
	$thome
 (cڡ *
__me
, 
size_t
 
__n
)

887 
__THROW
 
	`__nnu
 ((1)
__wur
;

891 
	$thoid
 (
__id

__THROW
 
__wur
;

897 
	$gdomame
 (*
__me
, 
size_t
 
__n
)

898 
__THROW
 
	`__nnu
 ((1)
__wur
;

899 
	$tdomame
 (cڡ *
__me
, 
size_t
 
__n
)

900 
__THROW
 
	`__nnu
 ((1)
__wur
;

906 
	$vhgup
 (
__THROW
;

909 
	$voke
 (cڡ *
__fe

__THROW
 
	`__nnu
 ((1)
__wur
;

917 
	$of
 (*
__me_bufr
, 
size_t
 
__size
,

918 
size_t
 
__offt
, 
__s
)

919 
__THROW
 
	`__nnu
 ((1));

925 
	$ac
 (cڡ *
__me

__THROW
;

929 *
	$gurshl
 (
__THROW
;

930 
	$durshl
 (
__THROW
;

931 
	$turshl
 (
__THROW
;

937 
	$dm
 (
__nochd
, 
__noo

__THROW
 
__wur
;

941 #i
defed
 
__USE_BSD
 || (defed 
__USE_XOPEN
 && !defed 
__USE_XOPEN2K
)

944 
	$chro
 (cڡ *
__th

__THROW
 
	`__nnu
 ((1)
__wur
;

948 *
	$gss
 (cڡ *
__om

	`__nnu
 ((1));

956 
	`fsync
 (
__fd
);

959 #ifde
__USE_GNU


962 
	$syncfs
 (
__fd

__THROW
;

966 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


969 
	`ghoid
 ();

972 
	$sync
 (
__THROW
;

975 #i
defed
 
__USE_BSD
 || !defed 
__USE_XOPEN2K


978 
	$ggesize
 (
__THROW
 
	`__ibu__
 ((
__cڡ__
));

983 
	$gdbsize
 (
__THROW
;

989 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K8


992 #ide
__USE_FILE_OFFSET64


993 
	$un
 (cڡ *
__fe
, 
__off_t
 
__ngth
)

994 
__THROW
 
	`__nnu
 ((1)
__wur
;

996 #ifde
__REDIRECT_NTH


997 
	`__REDIRECT_NTH
 (
un
,

998 (cڡ *
__fe
, 
__off64_t
 
__ngth
),

999 
un64

	`__nnu
 ((1)
__wur
;

1001 
	#un
 
un64


	)

1004 #ifde
__USE_LARGEFILE64


1005 
	$un64
 (cڡ *
__fe
, 
__off64_t
 
__ngth
)

1006 
__THROW
 
	`__nnu
 ((1)
__wur
;

1011 #i
defed
 
__USE_BSD
 || defed 
__USE_POSIX199309
 \

1012 || 
defed
 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K


1015 #ide
__USE_FILE_OFFSET64


1016 
	$run
 (
__fd
, 
__off_t
 
__ngth

__THROW
 
__wur
;

1018 #ifde
__REDIRECT_NTH


1019 
	`__REDIRECT_NTH
 (
run
, (
__fd
, 
__off64_t
 
__ngth
),

1020 
run64

__wur
;

1022 
	#run
 
run64


	)

1025 #ifde
__USE_LARGEFILE64


1026 
	$run64
 (
__fd
, 
__off64_t
 
__ngth

__THROW
 
__wur
;

1032 #i(
defed
 
__USE_XOPEN_EXTENDED
 && !defed 
__USE_XOPEN2K
) \

1033 || 
defed
 
__USE_MISC


1037 
	$brk
 (*
__addr

__THROW
 
__wur
;

1043 *
	$sbrk
 (
_t
 
__d

__THROW
;

1047 #ifde
__USE_MISC


1058 
	$sys
 (
__syo
, ...
__THROW
;

1063 #i(
defed
 
__USE_MISC
 || defed 
__USE_XOPEN_EXTENDED
&& !defed 
F_LOCK


1075 
	#F_ULOCK
 0

	)

1076 
	#F_LOCK
 1

	)

1077 
	#F_TLOCK
 2

	)

1078 
	#F_TEST
 3

	)

1080 #ide
__USE_FILE_OFFSET64


1081 
	$lockf
 (
__fd
, 
__cmd
, 
__off_t
 
__n

__wur
;

1083 #ifde
__REDIRECT


1084 
	`__REDIRECT
 (
lockf
, (
__fd
, 
__cmd
, 
__off64_t
 
__n
),

1085 
lockf64

__wur
;

1087 
	#lockf
 
lockf64


	)

1090 #ifde
__USE_LARGEFILE64


1091 
	$lockf64
 (
__fd
, 
__cmd
, 
__off64_t
 
__n

__wur
;

1096 #ifde
__USE_GNU


1101 
	#TEMP_FAILURE_RETRY
(
exessi
) \

1102 (
__exnsi__
 \

1103 ({ 
__su
; \

1104 d
__su
 = ((
exessi
); \

1105 
__su
 =-1L && 
o
 =
EINTR
); \

1106 
__su
; 
	}
}))

	)

1109 #i
defed
 
__USE_POSIX199309
 || defed 
__USE_UNIX98


1112 
fdasync
 (
__fdes
);

1118 #ifdef 
__USE_XOPEN


1120 *
	$y
 (cڡ *
__key
, cڡ *
__
)

1121 
__THROW
 
	`__nnu
 ((1, 2));

1125 
	$y
 (*
__glibc_block
, 
__edag
)

1126 
__THROW
 
	`__nnu
 ((1));

1133 
	$swab
 (cڡ *
__ri
 
__om
, *__ri 
__to
,

1134 
ssize_t
 
__n

__THROW
 
	`__nnu
 ((1, 2));

1140 #i
defed
 
__USE_XOPEN
 && !defed 
__USE_XOPEN2K


1142 *
	$mid
 (*
__s

__THROW
;

1147 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


1148 
	~<bs/unid.h
>

1151 
__END_DECLS


	@/usr/include/zlib.h

31 #ide
ZLIB_H


32 
	#ZLIB_H


	)

34 
	~"zcf.h
"

36 #ifde
__lulus


40 
	#ZLIB_VERSION
 "1.2.8"

	)

41 
	#ZLIB_VERNUM
 0x1280

	)

42 
	#ZLIB_VER_MAJOR
 1

	)

43 
	#ZLIB_VER_MINOR
 2

	)

44 
	#ZLIB_VER_REVISION
 8

	)

45 
	#ZLIB_VER_SUBREVISION
 0

	)

80 
voidpf
 (*
	tloc_func

	tOF
((
	tvoidpf
 
	taque
, 
	tuI
 
	tems
, uI 
	tsize
));

81 (*
_func

	tOF
((
	tvoidpf
 
	taque
, voidp
	taddss
));

83 
_e
;

85 
	sz_am_s
 {

86 
z_cڡ
 
Byf
 *
xt_
;

87 
uI
 
ava_
;

88 
uLg
 
tٮ_
;

90 
Byf
 *
xt_out
;

91 
uI
 
ava_out
;

92 
uLg
 
tٮ_out
;

94 
z_cڡ
 *
msg
;

95 
_e
 
FAR
 *
e
;

97 
loc_func
 
zloc
;

98 
_func
 
z
;

99 
voidpf
 
aque
;

101 
da_ty
;

102 
uLg
 
adr
;

103 
uLg
 
rved
;

104 } 
	tz_am
;

106 
z_am
 
	tFAR
 *
	tz_amp
;

112 
	sgz_hd_s
 {

113 
xt
;

114 
uLg
 
time
;

115 
xags
;

116 
os
;

117 
Byf
 *
exa
;

118 
uI
 
exa_n
;

119 
uI
 
exa_max
;

120 
Byf
 *
me
;

121 
uI
 
me_max
;

122 
Byf
 *
commt
;

123 
uI
 
comm_max
;

124 
hc
;

125 
de
;

127 } 
	tgz_hd
;

129 
gz_hd
 
	tFAR
 *
	tgz_hdp
;

164 
	#Z_NO_FLUSH
 0

	)

165 
	#Z_PARTIAL_FLUSH
 1

	)

166 
	#Z_SYNC_FLUSH
 2

	)

167 
	#Z_FULL_FLUSH
 3

	)

168 
	#Z_FINISH
 4

	)

169 
	#Z_BLOCK
 5

	)

170 
	#Z_TREES
 6

	)

173 
	#Z_OK
 0

	)

174 
	#Z_STREAM_END
 1

	)

175 
	#Z_NEED_DICT
 2

	)

176 
	#Z_ERRNO
 (-1)

	)

177 
	#Z_STREAM_ERROR
 (-2)

	)

178 
	#Z_DATA_ERROR
 (-3)

	)

179 
	#Z_MEM_ERROR
 (-4)

	)

180 
	#Z_BUF_ERROR
 (-5)

	)

181 
	#Z_VERSION_ERROR
 (-6)

	)

186 
	#Z_NO_COMPRESSION
 0

	)

187 
	#Z_BEST_SPEED
 1

	)

188 
	#Z_BEST_COMPRESSION
 9

	)

189 
	#Z_DEFAULT_COMPRESSION
 (-1)

	)

192 
	#Z_FILTERED
 1

	)

193 
	#Z_HUFFMAN_ONLY
 2

	)

194 
	#Z_RLE
 3

	)

195 
	#Z_FIXED
 4

	)

196 
	#Z_DEFAULT_STRATEGY
 0

	)

199 
	#Z_BINARY
 0

	)

200 
	#Z_TEXT
 1

	)

201 
	#Z_ASCII
 
Z_TEXT


	)

202 
	#Z_UNKNOWN
 2

	)

205 
	#Z_DEFLATED
 8

	)

208 
	#Z_NULL
 0

	)

210 
	#zlib_vsi
 
	`zlibVsi
()

	)

216 
ZEXTERN
 cڡ * 
ZEXPORT
 
zlibVsi
 
OF
(());

246 
ZEXTERN
 
ZEXPORT
 
dee
 
OF
((
z_amp
 
rm
, 
ush
));

353 
ZEXTERN
 
ZEXPORT
 
deeEnd
 
OF
((
z_amp
 
rm
));

392 
ZEXTERN
 
ZEXPORT
 
e
 
OF
((
z_amp
 
rm
, 
ush
));

508 
ZEXTERN
 
ZEXPORT
 
eEnd
 
OF
((
z_amp
 
rm
));

587 
ZEXTERN
 
ZEXPORT
 
deeSDiiڬy
 
OF
((
z_amp
 
rm
,

588 cڡ 
Byf
 *
diiڬy
,

589 
uI
 
diLgth
));

631 
ZEXTERN
 
ZEXPORT
 
deeCy
 
OF
((
z_amp
 
de
,

632 
z_amp
 
sour
));

649 
ZEXTERN
 
ZEXPORT
 
deeRet
 
OF
((
z_amp
 
rm
));

660 
ZEXTERN
 
ZEXPORT
 
deePams
 
OF
((
z_amp
 
rm
,

661 
v
,

662 
gy
));

681 
ZEXTERN
 
ZEXPORT
 
deeTu
 
OF
((
z_amp
 
rm
,

682 
good_ngth
,

683 
max_zy
,

684 
ni_ngth
,

685 
max_cha
));

698 
ZEXTERN
 
uLg
 
ZEXPORT
 
deeBound
 
OF
((
z_amp
 
rm
,

699 
uLg
 
sourL
));

713 
ZEXTERN
 
ZEXPORT
 
deePdg
 
OF
((
z_amp
 
rm
,

714 *
ndg
,

715 *
bs
));

728 
ZEXTERN
 
ZEXPORT
 
deePrime
 
OF
((
z_amp
 
rm
,

729 
bs
,

730 
vue
));

745 
ZEXTERN
 
ZEXPORT
 
deeSHd
 
OF
((
z_amp
 
rm
,

746 
gz_hdp
 
hd
));

819 
ZEXTERN
 
ZEXPORT
 
eSDiiڬy
 
OF
((
z_amp
 
rm
,

820 cڡ 
Byf
 *
diiڬy
,

821 
uI
 
diLgth
));

842 
ZEXTERN
 
ZEXPORT
 
eGDiiڬy
 
OF
((
z_amp
 
rm
,

843 
Byf
 *
diiڬy
,

844 
uI
 *
diLgth
));

857 
ZEXTERN
 
ZEXPORT
 
eSync
 
OF
((
z_amp
 
rm
));

876 
ZEXTERN
 
ZEXPORT
 
eCy
 
OF
((
z_amp
 
de
,

877 
z_amp
 
sour
));

892 
ZEXTERN
 
ZEXPORT
 
eRet
 
OF
((
z_amp
 
rm
));

902 
ZEXTERN
 
ZEXPORT
 
eRet2
 
OF
((
z_amp
 
rm
,

903 
wdowBs
));

914 
ZEXTERN
 
ZEXPORT
 
ePrime
 
OF
((
z_amp
 
rm
,

915 
bs
,

916 
vue
));

935 
ZEXTERN
 
ZEXPORT
 
eMk
 
OF
((
z_amp
 
rm
));

963 
ZEXTERN
 
ZEXPORT
 
eGHd
 
OF
((
z_amp
 
rm
,

964 
gz_hdp
 
hd
));

1025 (*
_func

	tOF
((
	tFAR
 *,

1026 
	tz_cڡ
 
	tFAR
 * FAR *));

1027 (*
out_func

	tOF
((
	tFAR
 *, FAR *, ));

1029 
ZEXTERN
 
ZEXPORT
 
eBack
 
OF
((
z_amp
 
rm
,

1030 
_func
 

, 
FAR
 *
_desc
,

1031 
out_func
 
out
, 
FAR
 *
out_desc
));

1099 
ZEXTERN
 
ZEXPORT
 
eBackEnd
 
OF
((
z_amp
 
rm
));

1107 
ZEXTERN
 
uLg
 
ZEXPORT
 
zlibCompeFgs
 
OF
(());

1148 #ide
Z_SOLO


1160 
ZEXTERN
 
ZEXPORT
 
comess
 
OF
((
Byf
 *
de
, 
uLgf
 *
deL
,

1161 cڡ 
Byf
 *
sour
, 
uLg
 
sourL
));

1174 
ZEXTERN
 
ZEXPORT
 
comess2
 
OF
((
Byf
 *
de
, 
uLgf
 *
deL
,

1175 cڡ 
Byf
 *
sour
, 
uLg
 
sourL
,

1176 
v
));

1190 
ZEXTERN
 
uLg
 
ZEXPORT
 
comessBound
 
OF
((uLg 
sourL
));

1197 
ZEXTERN
 
ZEXPORT
 
uncomess
 
OF
((
Byf
 *
de
, 
uLgf
 *
deL
,

1198 cڡ 
Byf
 *
sour
, 
uLg
 
sourL
));

1224 
gzFe_s
 *
	tgzFe
;

1264 
ZEXTERN
 
gzFe
 
ZEXPORT
 
gzdݒ
 
OF
((
fd
, cڡ *
mode
));

1287 
ZEXTERN
 
ZEXPORT
 
gzbufr
 
OF
((
gzFe
 
fe
, 
size
));

1304 
ZEXTERN
 
ZEXPORT
 
gzams
 
OF
((
gzFe
 
fe
, 
v
, 
gy
));

1313 
ZEXTERN
 
ZEXPORT
 
gzad
 
OF
((
gzFe
 
fe
, 
voidp
 
buf
, 
n
));

1341 
ZEXTERN
 
ZEXPORT
 
gzwre
 
OF
((
gzFe
 
fe
,

1342 
voidpc
 
buf
, 
n
));

1349 
ZEXTERN
 
ZEXPORTVA
 
gztf
 
Z_ARG
((
gzFe
 
fe
, cڡ *
fm
, ...));

1364 
ZEXTERN
 
ZEXPORT
 
gzputs
 
OF
((
gzFe
 
fe
, cڡ *
s
));

1372 
ZEXTERN
 * 
ZEXPORT
 
gzgs
 
OF
((
gzFe
 
fe
, *
buf
, 
n
));

1385 
ZEXTERN
 
ZEXPORT
 
gzputc
 
OF
((
gzFe
 
fe
, 
c
));

1391 
ZEXTERN
 
ZEXPORT
 
gzgc
 
OF
((
gzFe
 
fe
));

1400 
ZEXTERN
 
ZEXPORT
 
gzungc
 
OF
((
c
, 
gzFe
 
fe
));

1412 
ZEXTERN
 
ZEXPORT
 
gzush
 
OF
((
gzFe
 
fe
, 
ush
));

1447 
ZEXTERN
 
ZEXPORT
 
gzwd
 
OF
((
gzFe
 
fe
));

1475 
ZEXTERN
 
ZEXPORT
 
gzeof
 
OF
((
gzFe
 
fe
));

1490 
ZEXTERN
 
ZEXPORT
 
gzde
 
OF
((
gzFe
 
fe
));

1511 
ZEXTERN
 
ZEXPORT
 
gzo
 
OF
((
gzFe
 
fe
));

1524 
ZEXTERN
 
ZEXPORT
 
gzo_r
 
OF
((
gzFe
 
fe
));

1525 
ZEXTERN
 
ZEXPORT
 
gzo_w
 
OF
((
gzFe
 
fe
));

1536 
ZEXTERN
 cڡ * 
ZEXPORT
 
gzr
 
OF
((
gzFe
 
fe
, *
um
));

1552 
ZEXTERN
 
ZEXPORT
 
gz
 
OF
((
gzFe
 
fe
));

1569 
ZEXTERN
 
uLg
 
ZEXPORT
 
adr32
 
OF
((uLg 
adr
, cڡ 
Byf
 *
buf
, 
uI
 
n
));

1600 
ZEXTERN
 
uLg
 
ZEXPORT
 
c32
 
OF
((uLg 
c
, cڡ 
Byf
 *
buf
, 
uI
 
n
));

1633 
ZEXTERN
 
ZEXPORT
 
deeIn_
 
OF
((
z_amp
 
rm
, 
v
,

1634 cڡ *
vsi
, 
am_size
));

1635 
ZEXTERN
 
ZEXPORT
 
eIn_
 
OF
((
z_amp
 
rm
,

1636 cڡ *
vsi
, 
am_size
));

1637 
ZEXTERN
 
ZEXPORT
 
deeIn2_
 
OF
((
z_amp
 
rm
, 
v
, 
mhod
,

1638 
wdowBs
, 
memLev
,

1639 
gy
, cڡ *
vsi
,

1640 
am_size
));

1641 
ZEXTERN
 
ZEXPORT
 
eIn2_
 
OF
((
z_amp
 
rm
, 
wdowBs
,

1642 cڡ *
vsi
, 
am_size
));

1643 
ZEXTERN
 
ZEXPORT
 
eBackIn_
 
OF
((
z_amp
 
rm
, 
wdowBs
,

1644 
FAR
 *
wdow
,

1645 cڡ *
vsi
,

1646 
am_size
));

1647 
	#deeIn
(
rm
, 
v
) \

1648 
	`deeIn_
((
rm
), (
v
), 
ZLIB_VERSION
, ()(
z_am
))

	)

1649 
	#eIn
(
rm
) \

1650 
	`eIn_
((
rm
), 
ZLIB_VERSION
, ()(
z_am
))

	)

1651 
	#deeIn2
(
rm
, 
v
, 
mhod
, 
wdowBs
, 
memLev
, 
gy
) \

1652 
	`deeIn2_
((
rm
),(
v
),(
mhod
),(
wdowBs
),(
memLev
),\

1653 (
gy
), 
ZLIB_VERSION
, ()(
z_am
))

	)

1654 
	#eIn2
(
rm
, 
wdowBs
) \

1655 
	`eIn2_
((
rm
), (
wdowBs
), 
ZLIB_VERSION
, \

1656 ()(
z_am
))

	)

1657 
	#eBackIn
(
rm
, 
wdowBs
, 
wdow
) \

1658 
	`eBackIn_
((
rm
), (
wdowBs
), (
wdow
), \

1659 
ZLIB_VERSION
, ()(
z_am
))

	)

1661 #ide
Z_SOLO


1670 
	sgzFe_s
 {

1671 
have
;

1672 *
xt
;

1673 
z_off64_t
 
pos
;

1675 
ZEXTERN
 
ZEXPORT
 
gzgc_
 
OF
((
gzFe
 
fe
));

1676 #ifde
Z_PREFIX_SET


1677 #unde
z_gzgc


1678 
	#z_gzgc
(
g
) \

1679 ((
g
)->
have
 ? ((g)->have--, (g)->
pos
++, *((g)->
xt
)++: 
	`gzgc
(g))

	)

1681 
	#gzgc
(
g
) \

1682 ((
g
)->
have
 ? ((g)->have--, (g)->
pos
++, *((g)->
xt
)++: 
	`gzgc
(g))

	)

1691 #ifde
Z_LARGE64


1692 
ZEXTERN
 
gzFe
 
ZEXPORT
 
gzݒ64
 
OF
((const *, const *));

1693 
ZEXTERN
 
z_off64_t
 
ZEXPORT
 
gzek64
 
OF
((
gzFe
, z_off64_t, ));

1694 
ZEXTERN
 
z_off64_t
 
ZEXPORT
 
gz64
 
OF
((
gzFe
));

1695 
ZEXTERN
 
z_off64_t
 
ZEXPORT
 
gzofft64
 
OF
((
gzFe
));

1696 
ZEXTERN
 
uLg
 
ZEXPORT
 
adr32_combe64
 
OF
((uLg, uLg, 
z_off64_t
));

1697 
ZEXTERN
 
uLg
 
ZEXPORT
 
c32_combe64
 
OF
((uLg, uLg, 
z_off64_t
));

1700 #i!
defed
(
ZLIB_INTERNAL
&& defed(
Z_WANT64
)

1701 #ifde
Z_PREFIX_SET


1702 
	#z_gzݒ
 
z_gzݒ64


	)

1703 
	#z_gzek
 
z_gzek64


	)

1704 
	#z_gz
 
z_gz64


	)

1705 
	#z_gzofft
 
z_gzofft64


	)

1706 
	#z_adr32_combe
 
z_adr32_combe64


	)

1707 
	#z_c32_combe
 
z_c32_combe64


	)

1709 
	#gzݒ
 
gzݒ64


	)

1710 
	#gzek
 
gzek64


	)

1711 
	#gz
 
gz64


	)

1712 
	#gzofft
 
gzofft64


	)

1713 
	#adr32_combe
 
adr32_combe64


	)

1714 
	#c32_combe
 
c32_combe64


	)

1716 #ide
Z_LARGE64


1717 
ZEXTERN
 
gzFe
 
ZEXPORT
 
gzݒ64
 
OF
((const *, const *));

1718 
ZEXTERN
 
z_off_t
 
ZEXPORT
 
gzek64
 
OF
((
gzFe
, z_off_t, ));

1719 
ZEXTERN
 
z_off_t
 
ZEXPORT
 
gz64
 
OF
((
gzFe
));

1720 
ZEXTERN
 
z_off_t
 
ZEXPORT
 
gzofft64
 
OF
((
gzFe
));

1721 
ZEXTERN
 
uLg
 
ZEXPORT
 
adr32_combe64
 
OF
((uLg, uLg, 
z_off_t
));

1722 
ZEXTERN
 
uLg
 
ZEXPORT
 
c32_combe64
 
OF
((uLg, uLg, 
z_off_t
));

1725 
ZEXTERN
 
gzFe
 
ZEXPORT
 
gzݒ
 
OF
((const *, const *));

1726 
ZEXTERN
 
z_off_t
 
ZEXPORT
 
gzek
 
OF
((
gzFe
, z_off_t, ));

1727 
ZEXTERN
 
z_off_t
 
ZEXPORT
 
gz
 
OF
((
gzFe
));

1728 
ZEXTERN
 
z_off_t
 
ZEXPORT
 
gzofft
 
OF
((
gzFe
));

1729 
ZEXTERN
 
uLg
 
ZEXPORT
 
adr32_combe
 
OF
((uLg, uLg, 
z_off_t
));

1730 
ZEXTERN
 
uLg
 
ZEXPORT
 
c32_combe
 
OF
((uLg, uLg, 
z_off_t
));

1735 
ZEXTERN
 
uLg
 
ZEXPORT
 
adr32_combe
 
OF
((uLg, uLg, 
z_off_t
));

1736 
ZEXTERN
 
uLg
 
ZEXPORT
 
c32_combe
 
OF
((uLg, uLg, 
z_off_t
));

1741 #i!
defed
(
ZUTIL_H
&& !defed(
NO_DUMMY_DECL
)

1742 
	s_e
 {
dummy
;};

1746 
ZEXTERN
 cڡ * 
ZEXPORT
 
zE
 
OF
(());

1747 
ZEXTERN
 
ZEXPORT
 
eSyncPot
 
OF
((
z_amp
));

1748 
ZEXTERN
 cڡ 
z_c_t
 
FAR
 * 
ZEXPORT
 
g_c_b
 
OF
(());

1749 
ZEXTERN
 
ZEXPORT
 
eUndme
 
OF
((
z_amp
, ));

1750 
ZEXTERN
 
ZEXPORT
 
eRetKp
 
OF
((
z_amp
));

1751 
ZEXTERN
 
ZEXPORT
 
deeRetKp
 
OF
((
z_amp
));

1752 #i
defed
(
_WIN32
&& !defed(
Z_SOLO
)

1753 
ZEXTERN
 
gzFe
 
ZEXPORT
 
gzݒ_w
 
OF
((cڡ 
wch_t
 *
th
,

1754 cڡ *
mode
));

1756 #i
defed
(
STDC
|| defed(
Z_HAVE_STDARG_H
)

1757 #ide
Z_SOLO


1758 
ZEXTERN
 
ZEXPORTVA
 
gzvtf
 
Z_ARG
((
gzFe
 
fe
,

1759 cڡ *
fm
,

1760 
va_li
 
va
));

1764 #ifde
__lulus


	@/usr/include/alloca.h

18 #idef 
_ALLOCA_H


19 
	#_ALLOCA_H
 1

	)

21 
	~<us.h
>

23 
	#__ed_size_t


	)

24 
	~<ddef.h
>

26 
	g__BEGIN_DECLS


29 #unde
lo


32 *
	$lo
 (
size_t
 
__size

__THROW
;

34 #ifdef 
__GNUC__


35 
	#lo
(
size

	`__but_lo
 (size)

	)

38 
__END_DECLS


	@/usr/include/bits/confname.h

19 #ide
_UNISTD_H


26 
	m_PC_LINK_MAX
,

27 
	#_PC_LINK_MAX
 
_PC_LINK_MAX


	)

28 
	m_PC_MAX_CANON
,

29 
	#_PC_MAX_CANON
 
_PC_MAX_CANON


	)

30 
	m_PC_MAX_INPUT
,

31 
	#_PC_MAX_INPUT
 
_PC_MAX_INPUT


	)

32 
	m_PC_NAME_MAX
,

33 
	#_PC_NAME_MAX
 
_PC_NAME_MAX


	)

34 
	m_PC_PATH_MAX
,

35 
	#_PC_PATH_MAX
 
_PC_PATH_MAX


	)

36 
	m_PC_PIPE_BUF
,

37 
	#_PC_PIPE_BUF
 
_PC_PIPE_BUF


	)

38 
	m_PC_CHOWN_RESTRICTED
,

39 
	#_PC_CHOWN_RESTRICTED
 
_PC_CHOWN_RESTRICTED


	)

40 
	m_PC_NO_TRUNC
,

41 
	#_PC_NO_TRUNC
 
_PC_NO_TRUNC


	)

42 
	m_PC_VDISABLE
,

43 
	#_PC_VDISABLE
 
_PC_VDISABLE


	)

44 
	m_PC_SYNC_IO
,

45 
	#_PC_SYNC_IO
 
_PC_SYNC_IO


	)

46 
	m_PC_ASYNC_IO
,

47 
	#_PC_ASYNC_IO
 
_PC_ASYNC_IO


	)

48 
	m_PC_PRIO_IO
,

49 
	#_PC_PRIO_IO
 
_PC_PRIO_IO


	)

50 
	m_PC_SOCK_MAXBUF
,

51 
	#_PC_SOCK_MAXBUF
 
_PC_SOCK_MAXBUF


	)

52 
	m_PC_FILESIZEBITS
,

53 
	#_PC_FILESIZEBITS
 
_PC_FILESIZEBITS


	)

54 
	m_PC_REC_INCR_XFER_SIZE
,

55 
	#_PC_REC_INCR_XFER_SIZE
 
_PC_REC_INCR_XFER_SIZE


	)

56 
	m_PC_REC_MAX_XFER_SIZE
,

57 
	#_PC_REC_MAX_XFER_SIZE
 
_PC_REC_MAX_XFER_SIZE


	)

58 
	m_PC_REC_MIN_XFER_SIZE
,

59 
	#_PC_REC_MIN_XFER_SIZE
 
_PC_REC_MIN_XFER_SIZE


	)

60 
	m_PC_REC_XFER_ALIGN
,

61 
	#_PC_REC_XFER_ALIGN
 
_PC_REC_XFER_ALIGN


	)

62 
	m_PC_ALLOC_SIZE_MIN
,

63 
	#_PC_ALLOC_SIZE_MIN
 
_PC_ALLOC_SIZE_MIN


	)

64 
	m_PC_SYMLINK_MAX
,

65 
	#_PC_SYMLINK_MAX
 
_PC_SYMLINK_MAX


	)

66 
	m_PC_2_SYMLINKS


67 
	#_PC_2_SYMLINKS
 
_PC_2_SYMLINKS


	)

73 
	m_SC_ARG_MAX
,

74 
	#_SC_ARG_MAX
 
_SC_ARG_MAX


	)

75 
	m_SC_CHILD_MAX
,

76 
	#_SC_CHILD_MAX
 
_SC_CHILD_MAX


	)

77 
	m_SC_CLK_TCK
,

78 
	#_SC_CLK_TCK
 
_SC_CLK_TCK


	)

79 
	m_SC_NGROUPS_MAX
,

80 
	#_SC_NGROUPS_MAX
 
_SC_NGROUPS_MAX


	)

81 
	m_SC_OPEN_MAX
,

82 
	#_SC_OPEN_MAX
 
_SC_OPEN_MAX


	)

83 
	m_SC_STREAM_MAX
,

84 
	#_SC_STREAM_MAX
 
_SC_STREAM_MAX


	)

85 
	m_SC_TZNAME_MAX
,

86 
	#_SC_TZNAME_MAX
 
_SC_TZNAME_MAX


	)

87 
	m_SC_JOB_CONTROL
,

88 
	#_SC_JOB_CONTROL
 
_SC_JOB_CONTROL


	)

89 
	m_SC_SAVED_IDS
,

90 
	#_SC_SAVED_IDS
 
_SC_SAVED_IDS


	)

91 
	m_SC_REALTIME_SIGNALS
,

92 
	#_SC_REALTIME_SIGNALS
 
_SC_REALTIME_SIGNALS


	)

93 
	m_SC_PRIORITY_SCHEDULING
,

94 
	#_SC_PRIORITY_SCHEDULING
 
_SC_PRIORITY_SCHEDULING


	)

95 
	m_SC_TIMERS
,

96 
	#_SC_TIMERS
 
_SC_TIMERS


	)

97 
	m_SC_ASYNCHRONOUS_IO
,

98 
	#_SC_ASYNCHRONOUS_IO
 
_SC_ASYNCHRONOUS_IO


	)

99 
	m_SC_PRIORITIZED_IO
,

100 
	#_SC_PRIORITIZED_IO
 
_SC_PRIORITIZED_IO


	)

101 
	m_SC_SYNCHRONIZED_IO
,

102 
	#_SC_SYNCHRONIZED_IO
 
_SC_SYNCHRONIZED_IO


	)

103 
	m_SC_FSYNC
,

104 
	#_SC_FSYNC
 
_SC_FSYNC


	)

105 
	m_SC_MAPPED_FILES
,

106 
	#_SC_MAPPED_FILES
 
_SC_MAPPED_FILES


	)

107 
	m_SC_MEMLOCK
,

108 
	#_SC_MEMLOCK
 
_SC_MEMLOCK


	)

109 
	m_SC_MEMLOCK_RANGE
,

110 
	#_SC_MEMLOCK_RANGE
 
_SC_MEMLOCK_RANGE


	)

111 
	m_SC_MEMORY_PROTECTION
,

112 
	#_SC_MEMORY_PROTECTION
 
_SC_MEMORY_PROTECTION


	)

113 
	m_SC_MESSAGE_PASSING
,

114 
	#_SC_MESSAGE_PASSING
 
_SC_MESSAGE_PASSING


	)

115 
	m_SC_SEMAPHORES
,

116 
	#_SC_SEMAPHORES
 
_SC_SEMAPHORES


	)

117 
	m_SC_SHARED_MEMORY_OBJECTS
,

118 
	#_SC_SHARED_MEMORY_OBJECTS
 
_SC_SHARED_MEMORY_OBJECTS


	)

119 
	m_SC_AIO_LISTIO_MAX
,

120 
	#_SC_AIO_LISTIO_MAX
 
_SC_AIO_LISTIO_MAX


	)

121 
	m_SC_AIO_MAX
,

122 
	#_SC_AIO_MAX
 
_SC_AIO_MAX


	)

123 
	m_SC_AIO_PRIO_DELTA_MAX
,

124 
	#_SC_AIO_PRIO_DELTA_MAX
 
_SC_AIO_PRIO_DELTA_MAX


	)

125 
	m_SC_DELAYTIMER_MAX
,

126 
	#_SC_DELAYTIMER_MAX
 
_SC_DELAYTIMER_MAX


	)

127 
	m_SC_MQ_OPEN_MAX
,

128 
	#_SC_MQ_OPEN_MAX
 
_SC_MQ_OPEN_MAX


	)

129 
	m_SC_MQ_PRIO_MAX
,

130 
	#_SC_MQ_PRIO_MAX
 
_SC_MQ_PRIO_MAX


	)

131 
	m_SC_VERSION
,

132 
	#_SC_VERSION
 
_SC_VERSION


	)

133 
	m_SC_PAGESIZE
,

134 
	#_SC_PAGESIZE
 
_SC_PAGESIZE


	)

135 
	#_SC_PAGE_SIZE
 
_SC_PAGESIZE


	)

136 
	m_SC_RTSIG_MAX
,

137 
	#_SC_RTSIG_MAX
 
_SC_RTSIG_MAX


	)

138 
	m_SC_SEM_NSEMS_MAX
,

139 
	#_SC_SEM_NSEMS_MAX
 
_SC_SEM_NSEMS_MAX


	)

140 
	m_SC_SEM_VALUE_MAX
,

141 
	#_SC_SEM_VALUE_MAX
 
_SC_SEM_VALUE_MAX


	)

142 
	m_SC_SIGQUEUE_MAX
,

143 
	#_SC_SIGQUEUE_MAX
 
_SC_SIGQUEUE_MAX


	)

144 
	m_SC_TIMER_MAX
,

145 
	#_SC_TIMER_MAX
 
_SC_TIMER_MAX


	)

149 
	m_SC_BC_BASE_MAX
,

150 
	#_SC_BC_BASE_MAX
 
_SC_BC_BASE_MAX


	)

151 
	m_SC_BC_DIM_MAX
,

152 
	#_SC_BC_DIM_MAX
 
_SC_BC_DIM_MAX


	)

153 
	m_SC_BC_SCALE_MAX
,

154 
	#_SC_BC_SCALE_MAX
 
_SC_BC_SCALE_MAX


	)

155 
	m_SC_BC_STRING_MAX
,

156 
	#_SC_BC_STRING_MAX
 
_SC_BC_STRING_MAX


	)

157 
	m_SC_COLL_WEIGHTS_MAX
,

158 
	#_SC_COLL_WEIGHTS_MAX
 
_SC_COLL_WEIGHTS_MAX


	)

159 
	m_SC_EQUIV_CLASS_MAX
,

160 
	#_SC_EQUIV_CLASS_MAX
 
_SC_EQUIV_CLASS_MAX


	)

161 
	m_SC_EXPR_NEST_MAX
,

162 
	#_SC_EXPR_NEST_MAX
 
_SC_EXPR_NEST_MAX


	)

163 
	m_SC_LINE_MAX
,

164 
	#_SC_LINE_MAX
 
_SC_LINE_MAX


	)

165 
	m_SC_RE_DUP_MAX
,

166 
	#_SC_RE_DUP_MAX
 
_SC_RE_DUP_MAX


	)

167 
	m_SC_CHARCLASS_NAME_MAX
,

168 
	#_SC_CHARCLASS_NAME_MAX
 
_SC_CHARCLASS_NAME_MAX


	)

170 
	m_SC_2_VERSION
,

171 
	#_SC_2_VERSION
 
_SC_2_VERSION


	)

172 
	m_SC_2_C_BIND
,

173 
	#_SC_2_C_BIND
 
_SC_2_C_BIND


	)

174 
	m_SC_2_C_DEV
,

175 
	#_SC_2_C_DEV
 
_SC_2_C_DEV


	)

176 
	m_SC_2_FORT_DEV
,

177 
	#_SC_2_FORT_DEV
 
_SC_2_FORT_DEV


	)

178 
	m_SC_2_FORT_RUN
,

179 
	#_SC_2_FORT_RUN
 
_SC_2_FORT_RUN


	)

180 
	m_SC_2_SW_DEV
,

181 
	#_SC_2_SW_DEV
 
_SC_2_SW_DEV


	)

182 
	m_SC_2_LOCALEDEF
,

183 
	#_SC_2_LOCALEDEF
 
_SC_2_LOCALEDEF


	)

185 
	m_SC_PII
,

186 
	#_SC_PII
 
_SC_PII


	)

187 
	m_SC_PII_XTI
,

188 
	#_SC_PII_XTI
 
_SC_PII_XTI


	)

189 
	m_SC_PII_SOCKET
,

190 
	#_SC_PII_SOCKET
 
_SC_PII_SOCKET


	)

191 
	m_SC_PII_INTERNET
,

192 
	#_SC_PII_INTERNET
 
_SC_PII_INTERNET


	)

193 
	m_SC_PII_OSI
,

194 
	#_SC_PII_OSI
 
_SC_PII_OSI


	)

195 
	m_SC_POLL
,

196 
	#_SC_POLL
 
_SC_POLL


	)

197 
	m_SC_SELECT
,

198 
	#_SC_SELECT
 
_SC_SELECT


	)

199 
	m_SC_UIO_MAXIOV
,

200 
	#_SC_UIO_MAXIOV
 
_SC_UIO_MAXIOV


	)

201 
	m_SC_IOV_MAX
 = 
_SC_UIO_MAXIOV
,

202 
	#_SC_IOV_MAX
 
_SC_IOV_MAX


	)

203 
	m_SC_PII_INTERNET_STREAM
,

204 
	#_SC_PII_INTERNET_STREAM
 
_SC_PII_INTERNET_STREAM


	)

205 
	m_SC_PII_INTERNET_DGRAM
,

206 
	#_SC_PII_INTERNET_DGRAM
 
_SC_PII_INTERNET_DGRAM


	)

207 
	m_SC_PII_OSI_COTS
,

208 
	#_SC_PII_OSI_COTS
 
_SC_PII_OSI_COTS


	)

209 
	m_SC_PII_OSI_CLTS
,

210 
	#_SC_PII_OSI_CLTS
 
_SC_PII_OSI_CLTS


	)

211 
	m_SC_PII_OSI_M
,

212 
	#_SC_PII_OSI_M
 
_SC_PII_OSI_M


	)

213 
	m_SC_T_IOV_MAX
,

214 
	#_SC_T_IOV_MAX
 
_SC_T_IOV_MAX


	)

217 
	m_SC_THREADS
,

218 
	#_SC_THREADS
 
_SC_THREADS


	)

219 
	m_SC_THREAD_SAFE_FUNCTIONS
,

220 
	#_SC_THREAD_SAFE_FUNCTIONS
 
_SC_THREAD_SAFE_FUNCTIONS


	)

221 
	m_SC_GETGR_R_SIZE_MAX
,

222 
	#_SC_GETGR_R_SIZE_MAX
 
_SC_GETGR_R_SIZE_MAX


	)

223 
	m_SC_GETPW_R_SIZE_MAX
,

224 
	#_SC_GETPW_R_SIZE_MAX
 
_SC_GETPW_R_SIZE_MAX


	)

225 
	m_SC_LOGIN_NAME_MAX
,

226 
	#_SC_LOGIN_NAME_MAX
 
_SC_LOGIN_NAME_MAX


	)

227 
	m_SC_TTY_NAME_MAX
,

228 
	#_SC_TTY_NAME_MAX
 
_SC_TTY_NAME_MAX


	)

229 
	m_SC_THREAD_DESTRUCTOR_ITERATIONS
,

230 
	#_SC_THREAD_DESTRUCTOR_ITERATIONS
 
_SC_THREAD_DESTRUCTOR_ITERATIONS


	)

231 
	m_SC_THREAD_KEYS_MAX
,

232 
	#_SC_THREAD_KEYS_MAX
 
_SC_THREAD_KEYS_MAX


	)

233 
	m_SC_THREAD_STACK_MIN
,

234 
	#_SC_THREAD_STACK_MIN
 
_SC_THREAD_STACK_MIN


	)

235 
	m_SC_THREAD_THREADS_MAX
,

236 
	#_SC_THREAD_THREADS_MAX
 
_SC_THREAD_THREADS_MAX


	)

237 
	m_SC_THREAD_ATTR_STACKADDR
,

238 
	#_SC_THREAD_ATTR_STACKADDR
 
_SC_THREAD_ATTR_STACKADDR


	)

239 
	m_SC_THREAD_ATTR_STACKSIZE
,

240 
	#_SC_THREAD_ATTR_STACKSIZE
 
_SC_THREAD_ATTR_STACKSIZE


	)

241 
	m_SC_THREAD_PRIORITY_SCHEDULING
,

242 
	#_SC_THREAD_PRIORITY_SCHEDULING
 
_SC_THREAD_PRIORITY_SCHEDULING


	)

243 
	m_SC_THREAD_PRIO_INHERIT
,

244 
	#_SC_THREAD_PRIO_INHERIT
 
_SC_THREAD_PRIO_INHERIT


	)

245 
	m_SC_THREAD_PRIO_PROTECT
,

246 
	#_SC_THREAD_PRIO_PROTECT
 
_SC_THREAD_PRIO_PROTECT


	)

247 
	m_SC_THREAD_PROCESS_SHARED
,

248 
	#_SC_THREAD_PROCESS_SHARED
 
_SC_THREAD_PROCESS_SHARED


	)

250 
	m_SC_NPROCESSORS_CONF
,

251 
	#_SC_NPROCESSORS_CONF
 
_SC_NPROCESSORS_CONF


	)

252 
	m_SC_NPROCESSORS_ONLN
,

253 
	#_SC_NPROCESSORS_ONLN
 
_SC_NPROCESSORS_ONLN


	)

254 
	m_SC_PHYS_PAGES
,

255 
	#_SC_PHYS_PAGES
 
_SC_PHYS_PAGES


	)

256 
	m_SC_AVPHYS_PAGES
,

257 
	#_SC_AVPHYS_PAGES
 
_SC_AVPHYS_PAGES


	)

258 
	m_SC_ATEXIT_MAX
,

259 
	#_SC_ATEXIT_MAX
 
_SC_ATEXIT_MAX


	)

260 
	m_SC_PASS_MAX
,

261 
	#_SC_PASS_MAX
 
_SC_PASS_MAX


	)

263 
	m_SC_XOPEN_VERSION
,

264 
	#_SC_XOPEN_VERSION
 
_SC_XOPEN_VERSION


	)

265 
	m_SC_XOPEN_XCU_VERSION
,

266 
	#_SC_XOPEN_XCU_VERSION
 
_SC_XOPEN_XCU_VERSION


	)

267 
	m_SC_XOPEN_UNIX
,

268 
	#_SC_XOPEN_UNIX
 
_SC_XOPEN_UNIX


	)

269 
	m_SC_XOPEN_CRYPT
,

270 
	#_SC_XOPEN_CRYPT
 
_SC_XOPEN_CRYPT


	)

271 
	m_SC_XOPEN_ENH_I18N
,

272 
	#_SC_XOPEN_ENH_I18N
 
_SC_XOPEN_ENH_I18N


	)

273 
	m_SC_XOPEN_SHM
,

274 
	#_SC_XOPEN_SHM
 
_SC_XOPEN_SHM


	)

276 
	m_SC_2_CHAR_TERM
,

277 
	#_SC_2_CHAR_TERM
 
_SC_2_CHAR_TERM


	)

278 
	m_SC_2_C_VERSION
,

279 
	#_SC_2_C_VERSION
 
_SC_2_C_VERSION


	)

280 
	m_SC_2_UPE
,

281 
	#_SC_2_UPE
 
_SC_2_UPE


	)

283 
	m_SC_XOPEN_XPG2
,

284 
	#_SC_XOPEN_XPG2
 
_SC_XOPEN_XPG2


	)

285 
	m_SC_XOPEN_XPG3
,

286 
	#_SC_XOPEN_XPG3
 
_SC_XOPEN_XPG3


	)

287 
	m_SC_XOPEN_XPG4
,

288 
	#_SC_XOPEN_XPG4
 
_SC_XOPEN_XPG4


	)

290 
	m_SC_CHAR_BIT
,

291 
	#_SC_CHAR_BIT
 
_SC_CHAR_BIT


	)

292 
	m_SC_CHAR_MAX
,

293 
	#_SC_CHAR_MAX
 
_SC_CHAR_MAX


	)

294 
	m_SC_CHAR_MIN
,

295 
	#_SC_CHAR_MIN
 
_SC_CHAR_MIN


	)

296 
	m_SC_INT_MAX
,

297 
	#_SC_INT_MAX
 
_SC_INT_MAX


	)

298 
	m_SC_INT_MIN
,

299 
	#_SC_INT_MIN
 
_SC_INT_MIN


	)

300 
	m_SC_LONG_BIT
,

301 
	#_SC_LONG_BIT
 
_SC_LONG_BIT


	)

302 
	m_SC_WORD_BIT
,

303 
	#_SC_WORD_BIT
 
_SC_WORD_BIT


	)

304 
	m_SC_MB_LEN_MAX
,

305 
	#_SC_MB_LEN_MAX
 
_SC_MB_LEN_MAX


	)

306 
	m_SC_NZERO
,

307 
	#_SC_NZERO
 
_SC_NZERO


	)

308 
	m_SC_SSIZE_MAX
,

309 
	#_SC_SSIZE_MAX
 
_SC_SSIZE_MAX


	)

310 
	m_SC_SCHAR_MAX
,

311 
	#_SC_SCHAR_MAX
 
_SC_SCHAR_MAX


	)

312 
	m_SC_SCHAR_MIN
,

313 
	#_SC_SCHAR_MIN
 
_SC_SCHAR_MIN


	)

314 
	m_SC_SHRT_MAX
,

315 
	#_SC_SHRT_MAX
 
_SC_SHRT_MAX


	)

316 
	m_SC_SHRT_MIN
,

317 
	#_SC_SHRT_MIN
 
_SC_SHRT_MIN


	)

318 
	m_SC_UCHAR_MAX
,

319 
	#_SC_UCHAR_MAX
 
_SC_UCHAR_MAX


	)

320 
	m_SC_UINT_MAX
,

321 
	#_SC_UINT_MAX
 
_SC_UINT_MAX


	)

322 
	m_SC_ULONG_MAX
,

323 
	#_SC_ULONG_MAX
 
_SC_ULONG_MAX


	)

324 
	m_SC_USHRT_MAX
,

325 
	#_SC_USHRT_MAX
 
_SC_USHRT_MAX


	)

327 
	m_SC_NL_ARGMAX
,

328 
	#_SC_NL_ARGMAX
 
_SC_NL_ARGMAX


	)

329 
	m_SC_NL_LANGMAX
,

330 
	#_SC_NL_LANGMAX
 
_SC_NL_LANGMAX


	)

331 
	m_SC_NL_MSGMAX
,

332 
	#_SC_NL_MSGMAX
 
_SC_NL_MSGMAX


	)

333 
	m_SC_NL_NMAX
,

334 
	#_SC_NL_NMAX
 
_SC_NL_NMAX


	)

335 
	m_SC_NL_SETMAX
,

336 
	#_SC_NL_SETMAX
 
_SC_NL_SETMAX


	)

337 
	m_SC_NL_TEXTMAX
,

338 
	#_SC_NL_TEXTMAX
 
_SC_NL_TEXTMAX


	)

340 
	m_SC_XBS5_ILP32_OFF32
,

341 
	#_SC_XBS5_ILP32_OFF32
 
_SC_XBS5_ILP32_OFF32


	)

342 
	m_SC_XBS5_ILP32_OFFBIG
,

343 
	#_SC_XBS5_ILP32_OFFBIG
 
_SC_XBS5_ILP32_OFFBIG


	)

344 
	m_SC_XBS5_LP64_OFF64
,

345 
	#_SC_XBS5_LP64_OFF64
 
_SC_XBS5_LP64_OFF64


	)

346 
	m_SC_XBS5_LPBIG_OFFBIG
,

347 
	#_SC_XBS5_LPBIG_OFFBIG
 
_SC_XBS5_LPBIG_OFFBIG


	)

349 
	m_SC_XOPEN_LEGACY
,

350 
	#_SC_XOPEN_LEGACY
 
_SC_XOPEN_LEGACY


	)

351 
	m_SC_XOPEN_REALTIME
,

352 
	#_SC_XOPEN_REALTIME
 
_SC_XOPEN_REALTIME


	)

353 
	m_SC_XOPEN_REALTIME_THREADS
,

354 
	#_SC_XOPEN_REALTIME_THREADS
 
_SC_XOPEN_REALTIME_THREADS


	)

356 
	m_SC_ADVISORY_INFO
,

357 
	#_SC_ADVISORY_INFO
 
_SC_ADVISORY_INFO


	)

358 
	m_SC_BARRIERS
,

359 
	#_SC_BARRIERS
 
_SC_BARRIERS


	)

360 
	m_SC_BASE
,

361 
	#_SC_BASE
 
_SC_BASE


	)

362 
	m_SC_C_LANG_SUPPORT
,

363 
	#_SC_C_LANG_SUPPORT
 
_SC_C_LANG_SUPPORT


	)

364 
	m_SC_C_LANG_SUPPORT_R
,

365 
	#_SC_C_LANG_SUPPORT_R
 
_SC_C_LANG_SUPPORT_R


	)

366 
	m_SC_CLOCK_SELECTION
,

367 
	#_SC_CLOCK_SELECTION
 
_SC_CLOCK_SELECTION


	)

368 
	m_SC_CPUTIME
,

369 
	#_SC_CPUTIME
 
_SC_CPUTIME


	)

370 
	m_SC_THREAD_CPUTIME
,

371 
	#_SC_THREAD_CPUTIME
 
_SC_THREAD_CPUTIME


	)

372 
	m_SC_DEVICE_IO
,

373 
	#_SC_DEVICE_IO
 
_SC_DEVICE_IO


	)

374 
	m_SC_DEVICE_SPECIFIC
,

375 
	#_SC_DEVICE_SPECIFIC
 
_SC_DEVICE_SPECIFIC


	)

376 
	m_SC_DEVICE_SPECIFIC_R
,

377 
	#_SC_DEVICE_SPECIFIC_R
 
_SC_DEVICE_SPECIFIC_R


	)

378 
	m_SC_FD_MGMT
,

379 
	#_SC_FD_MGMT
 
_SC_FD_MGMT


	)

380 
	m_SC_FIFO
,

381 
	#_SC_FIFO
 
_SC_FIFO


	)

382 
	m_SC_PIPE
,

383 
	#_SC_PIPE
 
_SC_PIPE


	)

384 
	m_SC_FILE_ATTRIBUTES
,

385 
	#_SC_FILE_ATTRIBUTES
 
_SC_FILE_ATTRIBUTES


	)

386 
	m_SC_FILE_LOCKING
,

387 
	#_SC_FILE_LOCKING
 
_SC_FILE_LOCKING


	)

388 
	m_SC_FILE_SYSTEM
,

389 
	#_SC_FILE_SYSTEM
 
_SC_FILE_SYSTEM


	)

390 
	m_SC_MONOTONIC_CLOCK
,

391 
	#_SC_MONOTONIC_CLOCK
 
_SC_MONOTONIC_CLOCK


	)

392 
	m_SC_MULTI_PROCESS
,

393 
	#_SC_MULTI_PROCESS
 
_SC_MULTI_PROCESS


	)

394 
	m_SC_SINGLE_PROCESS
,

395 
	#_SC_SINGLE_PROCESS
 
_SC_SINGLE_PROCESS


	)

396 
	m_SC_NETWORKING
,

397 
	#_SC_NETWORKING
 
_SC_NETWORKING


	)

398 
	m_SC_READER_WRITER_LOCKS
,

399 
	#_SC_READER_WRITER_LOCKS
 
_SC_READER_WRITER_LOCKS


	)

400 
	m_SC_SPIN_LOCKS
,

401 
	#_SC_SPIN_LOCKS
 
_SC_SPIN_LOCKS


	)

402 
	m_SC_REGEXP
,

403 
	#_SC_REGEXP
 
_SC_REGEXP


	)

404 
	m_SC_REGEX_VERSION
,

405 
	#_SC_REGEX_VERSION
 
_SC_REGEX_VERSION


	)

406 
	m_SC_SHELL
,

407 
	#_SC_SHELL
 
_SC_SHELL


	)

408 
	m_SC_SIGNALS
,

409 
	#_SC_SIGNALS
 
_SC_SIGNALS


	)

410 
	m_SC_SPAWN
,

411 
	#_SC_SPAWN
 
_SC_SPAWN


	)

412 
	m_SC_SPORADIC_SERVER
,

413 
	#_SC_SPORADIC_SERVER
 
_SC_SPORADIC_SERVER


	)

414 
	m_SC_THREAD_SPORADIC_SERVER
,

415 
	#_SC_THREAD_SPORADIC_SERVER
 
_SC_THREAD_SPORADIC_SERVER


	)

416 
	m_SC_SYSTEM_DATABASE
,

417 
	#_SC_SYSTEM_DATABASE
 
_SC_SYSTEM_DATABASE


	)

418 
	m_SC_SYSTEM_DATABASE_R
,

419 
	#_SC_SYSTEM_DATABASE_R
 
_SC_SYSTEM_DATABASE_R


	)

420 
	m_SC_TIMEOUTS
,

421 
	#_SC_TIMEOUTS
 
_SC_TIMEOUTS


	)

422 
	m_SC_TYPED_MEMORY_OBJECTS
,

423 
	#_SC_TYPED_MEMORY_OBJECTS
 
_SC_TYPED_MEMORY_OBJECTS


	)

424 
	m_SC_USER_GROUPS
,

425 
	#_SC_USER_GROUPS
 
_SC_USER_GROUPS


	)

426 
	m_SC_USER_GROUPS_R
,

427 
	#_SC_USER_GROUPS_R
 
_SC_USER_GROUPS_R


	)

428 
	m_SC_2_PBS
,

429 
	#_SC_2_PBS
 
_SC_2_PBS


	)

430 
	m_SC_2_PBS_ACCOUNTING
,

431 
	#_SC_2_PBS_ACCOUNTING
 
_SC_2_PBS_ACCOUNTING


	)

432 
	m_SC_2_PBS_LOCATE
,

433 
	#_SC_2_PBS_LOCATE
 
_SC_2_PBS_LOCATE


	)

434 
	m_SC_2_PBS_MESSAGE
,

435 
	#_SC_2_PBS_MESSAGE
 
_SC_2_PBS_MESSAGE


	)

436 
	m_SC_2_PBS_TRACK
,

437 
	#_SC_2_PBS_TRACK
 
_SC_2_PBS_TRACK


	)

438 
	m_SC_SYMLOOP_MAX
,

439 
	#_SC_SYMLOOP_MAX
 
_SC_SYMLOOP_MAX


	)

440 
	m_SC_STREAMS
,

441 
	#_SC_STREAMS
 
_SC_STREAMS


	)

442 
	m_SC_2_PBS_CHECKPOINT
,

443 
	#_SC_2_PBS_CHECKPOINT
 
_SC_2_PBS_CHECKPOINT


	)

445 
	m_SC_V6_ILP32_OFF32
,

446 
	#_SC_V6_ILP32_OFF32
 
_SC_V6_ILP32_OFF32


	)

447 
	m_SC_V6_ILP32_OFFBIG
,

448 
	#_SC_V6_ILP32_OFFBIG
 
_SC_V6_ILP32_OFFBIG


	)

449 
	m_SC_V6_LP64_OFF64
,

450 
	#_SC_V6_LP64_OFF64
 
_SC_V6_LP64_OFF64


	)

451 
	m_SC_V6_LPBIG_OFFBIG
,

452 
	#_SC_V6_LPBIG_OFFBIG
 
_SC_V6_LPBIG_OFFBIG


	)

454 
	m_SC_HOST_NAME_MAX
,

455 
	#_SC_HOST_NAME_MAX
 
_SC_HOST_NAME_MAX


	)

456 
	m_SC_TRACE
,

457 
	#_SC_TRACE
 
_SC_TRACE


	)

458 
	m_SC_TRACE_EVENT_FILTER
,

459 
	#_SC_TRACE_EVENT_FILTER
 
_SC_TRACE_EVENT_FILTER


	)

460 
	m_SC_TRACE_INHERIT
,

461 
	#_SC_TRACE_INHERIT
 
_SC_TRACE_INHERIT


	)

462 
	m_SC_TRACE_LOG
,

463 
	#_SC_TRACE_LOG
 
_SC_TRACE_LOG


	)

465 
	m_SC_LEVEL1_ICACHE_SIZE
,

466 
	#_SC_LEVEL1_ICACHE_SIZE
 
_SC_LEVEL1_ICACHE_SIZE


	)

467 
	m_SC_LEVEL1_ICACHE_ASSOC
,

468 
	#_SC_LEVEL1_ICACHE_ASSOC
 
_SC_LEVEL1_ICACHE_ASSOC


	)

469 
	m_SC_LEVEL1_ICACHE_LINESIZE
,

470 
	#_SC_LEVEL1_ICACHE_LINESIZE
 
_SC_LEVEL1_ICACHE_LINESIZE


	)

471 
	m_SC_LEVEL1_DCACHE_SIZE
,

472 
	#_SC_LEVEL1_DCACHE_SIZE
 
_SC_LEVEL1_DCACHE_SIZE


	)

473 
	m_SC_LEVEL1_DCACHE_ASSOC
,

474 
	#_SC_LEVEL1_DCACHE_ASSOC
 
_SC_LEVEL1_DCACHE_ASSOC


	)

475 
	m_SC_LEVEL1_DCACHE_LINESIZE
,

476 
	#_SC_LEVEL1_DCACHE_LINESIZE
 
_SC_LEVEL1_DCACHE_LINESIZE


	)

477 
	m_SC_LEVEL2_CACHE_SIZE
,

478 
	#_SC_LEVEL2_CACHE_SIZE
 
_SC_LEVEL2_CACHE_SIZE


	)

479 
	m_SC_LEVEL2_CACHE_ASSOC
,

480 
	#_SC_LEVEL2_CACHE_ASSOC
 
_SC_LEVEL2_CACHE_ASSOC


	)

481 
	m_SC_LEVEL2_CACHE_LINESIZE
,

482 
	#_SC_LEVEL2_CACHE_LINESIZE
 
_SC_LEVEL2_CACHE_LINESIZE


	)

483 
	m_SC_LEVEL3_CACHE_SIZE
,

484 
	#_SC_LEVEL3_CACHE_SIZE
 
_SC_LEVEL3_CACHE_SIZE


	)

485 
	m_SC_LEVEL3_CACHE_ASSOC
,

486 
	#_SC_LEVEL3_CACHE_ASSOC
 
_SC_LEVEL3_CACHE_ASSOC


	)

487 
	m_SC_LEVEL3_CACHE_LINESIZE
,

488 
	#_SC_LEVEL3_CACHE_LINESIZE
 
_SC_LEVEL3_CACHE_LINESIZE


	)

489 
	m_SC_LEVEL4_CACHE_SIZE
,

490 
	#_SC_LEVEL4_CACHE_SIZE
 
_SC_LEVEL4_CACHE_SIZE


	)

491 
	m_SC_LEVEL4_CACHE_ASSOC
,

492 
	#_SC_LEVEL4_CACHE_ASSOC
 
_SC_LEVEL4_CACHE_ASSOC


	)

493 
	m_SC_LEVEL4_CACHE_LINESIZE
,

494 
	#_SC_LEVEL4_CACHE_LINESIZE
 
_SC_LEVEL4_CACHE_LINESIZE


	)

497 
	m_SC_IPV6
 = 
_SC_LEVEL1_ICACHE_SIZE
 + 50,

498 
	#_SC_IPV6
 
_SC_IPV6


	)

499 
	m_SC_RAW_SOCKETS
,

500 
	#_SC_RAW_SOCKETS
 
_SC_RAW_SOCKETS


	)

502 
	m_SC_V7_ILP32_OFF32
,

503 
	#_SC_V7_ILP32_OFF32
 
_SC_V7_ILP32_OFF32


	)

504 
	m_SC_V7_ILP32_OFFBIG
,

505 
	#_SC_V7_ILP32_OFFBIG
 
_SC_V7_ILP32_OFFBIG


	)

506 
	m_SC_V7_LP64_OFF64
,

507 
	#_SC_V7_LP64_OFF64
 
_SC_V7_LP64_OFF64


	)

508 
	m_SC_V7_LPBIG_OFFBIG
,

509 
	#_SC_V7_LPBIG_OFFBIG
 
_SC_V7_LPBIG_OFFBIG


	)

511 
	m_SC_SS_REPL_MAX
,

512 
	#_SC_SS_REPL_MAX
 
_SC_SS_REPL_MAX


	)

514 
	m_SC_TRACE_EVENT_NAME_MAX
,

515 
	#_SC_TRACE_EVENT_NAME_MAX
 
_SC_TRACE_EVENT_NAME_MAX


	)

516 
	m_SC_TRACE_NAME_MAX
,

517 
	#_SC_TRACE_NAME_MAX
 
_SC_TRACE_NAME_MAX


	)

518 
	m_SC_TRACE_SYS_MAX
,

519 
	#_SC_TRACE_SYS_MAX
 
_SC_TRACE_SYS_MAX


	)

520 
	m_SC_TRACE_USER_EVENT_MAX
,

521 
	#_SC_TRACE_USER_EVENT_MAX
 
_SC_TRACE_USER_EVENT_MAX


	)

523 
	m_SC_XOPEN_STREAMS
,

524 
	#_SC_XOPEN_STREAMS
 
_SC_XOPEN_STREAMS


	)

526 
	m_SC_THREAD_ROBUST_PRIO_INHERIT
,

527 
	#_SC_THREAD_ROBUST_PRIO_INHERIT
 
_SC_THREAD_ROBUST_PRIO_INHERIT


	)

528 
	m_SC_THREAD_ROBUST_PRIO_PROTECT


529 
	#_SC_THREAD_ROBUST_PRIO_PROTECT
 
_SC_THREAD_ROBUST_PRIO_PROTECT


	)

535 
	m_CS_PATH
,

536 
	#_CS_PATH
 
_CS_PATH


	)

538 
	m_CS_V6_WIDTH_RESTRICTED_ENVS
,

539 
	#_CS_V6_WIDTH_RESTRICTED_ENVS
 
_CS_V6_WIDTH_RESTRICTED_ENVS


	)

540 
	#_CS_POSIX_V6_WIDTH_RESTRICTED_ENVS
 
_CS_V6_WIDTH_RESTRICTED_ENVS


	)

542 
	m_CS_GNU_LIBC_VERSION
,

543 
	#_CS_GNU_LIBC_VERSION
 
_CS_GNU_LIBC_VERSION


	)

544 
	m_CS_GNU_LIBPTHREAD_VERSION
,

545 
	#_CS_GNU_LIBPTHREAD_VERSION
 
_CS_GNU_LIBPTHREAD_VERSION


	)

547 
	m_CS_V5_WIDTH_RESTRICTED_ENVS
,

548 
	#_CS_V5_WIDTH_RESTRICTED_ENVS
 
_CS_V5_WIDTH_RESTRICTED_ENVS


	)

549 
	#_CS_POSIX_V5_WIDTH_RESTRICTED_ENVS
 
_CS_V5_WIDTH_RESTRICTED_ENVS


	)

551 
	m_CS_V7_WIDTH_RESTRICTED_ENVS
,

552 
	#_CS_V7_WIDTH_RESTRICTED_ENVS
 
_CS_V7_WIDTH_RESTRICTED_ENVS


	)

553 
	#_CS_POSIX_V7_WIDTH_RESTRICTED_ENVS
 
_CS_V7_WIDTH_RESTRICTED_ENVS


	)

555 
	m_CS_LFS_CFLAGS
 = 1000,

556 
	#_CS_LFS_CFLAGS
 
_CS_LFS_CFLAGS


	)

557 
	m_CS_LFS_LDFLAGS
,

558 
	#_CS_LFS_LDFLAGS
 
_CS_LFS_LDFLAGS


	)

559 
	m_CS_LFS_LIBS
,

560 
	#_CS_LFS_LIBS
 
_CS_LFS_LIBS


	)

561 
	m_CS_LFS_LINTFLAGS
,

562 
	#_CS_LFS_LINTFLAGS
 
_CS_LFS_LINTFLAGS


	)

563 
	m_CS_LFS64_CFLAGS
,

564 
	#_CS_LFS64_CFLAGS
 
_CS_LFS64_CFLAGS


	)

565 
	m_CS_LFS64_LDFLAGS
,

566 
	#_CS_LFS64_LDFLAGS
 
_CS_LFS64_LDFLAGS


	)

567 
	m_CS_LFS64_LIBS
,

568 
	#_CS_LFS64_LIBS
 
_CS_LFS64_LIBS


	)

569 
	m_CS_LFS64_LINTFLAGS
,

570 
	#_CS_LFS64_LINTFLAGS
 
_CS_LFS64_LINTFLAGS


	)

572 
	m_CS_XBS5_ILP32_OFF32_CFLAGS
 = 1100,

573 
	#_CS_XBS5_ILP32_OFF32_CFLAGS
 
_CS_XBS5_ILP32_OFF32_CFLAGS


	)

574 
	m_CS_XBS5_ILP32_OFF32_LDFLAGS
,

575 
	#_CS_XBS5_ILP32_OFF32_LDFLAGS
 
_CS_XBS5_ILP32_OFF32_LDFLAGS


	)

576 
	m_CS_XBS5_ILP32_OFF32_LIBS
,

577 
	#_CS_XBS5_ILP32_OFF32_LIBS
 
_CS_XBS5_ILP32_OFF32_LIBS


	)

578 
	m_CS_XBS5_ILP32_OFF32_LINTFLAGS
,

579 
	#_CS_XBS5_ILP32_OFF32_LINTFLAGS
 
_CS_XBS5_ILP32_OFF32_LINTFLAGS


	)

580 
	m_CS_XBS5_ILP32_OFFBIG_CFLAGS
,

581 
	#_CS_XBS5_ILP32_OFFBIG_CFLAGS
 
_CS_XBS5_ILP32_OFFBIG_CFLAGS


	)

582 
	m_CS_XBS5_ILP32_OFFBIG_LDFLAGS
,

583 
	#_CS_XBS5_ILP32_OFFBIG_LDFLAGS
 
_CS_XBS5_ILP32_OFFBIG_LDFLAGS


	)

584 
	m_CS_XBS5_ILP32_OFFBIG_LIBS
,

585 
	#_CS_XBS5_ILP32_OFFBIG_LIBS
 
_CS_XBS5_ILP32_OFFBIG_LIBS


	)

586 
	m_CS_XBS5_ILP32_OFFBIG_LINTFLAGS
,

587 
	#_CS_XBS5_ILP32_OFFBIG_LINTFLAGS
 
_CS_XBS5_ILP32_OFFBIG_LINTFLAGS


	)

588 
	m_CS_XBS5_LP64_OFF64_CFLAGS
,

589 
	#_CS_XBS5_LP64_OFF64_CFLAGS
 
_CS_XBS5_LP64_OFF64_CFLAGS


	)

590 
	m_CS_XBS5_LP64_OFF64_LDFLAGS
,

591 
	#_CS_XBS5_LP64_OFF64_LDFLAGS
 
_CS_XBS5_LP64_OFF64_LDFLAGS


	)

592 
	m_CS_XBS5_LP64_OFF64_LIBS
,

593 
	#_CS_XBS5_LP64_OFF64_LIBS
 
_CS_XBS5_LP64_OFF64_LIBS


	)

594 
	m_CS_XBS5_LP64_OFF64_LINTFLAGS
,

595 
	#_CS_XBS5_LP64_OFF64_LINTFLAGS
 
_CS_XBS5_LP64_OFF64_LINTFLAGS


	)

596 
	m_CS_XBS5_LPBIG_OFFBIG_CFLAGS
,

597 
	#_CS_XBS5_LPBIG_OFFBIG_CFLAGS
 
_CS_XBS5_LPBIG_OFFBIG_CFLAGS


	)

598 
	m_CS_XBS5_LPBIG_OFFBIG_LDFLAGS
,

599 
	#_CS_XBS5_LPBIG_OFFBIG_LDFLAGS
 
_CS_XBS5_LPBIG_OFFBIG_LDFLAGS


	)

600 
	m_CS_XBS5_LPBIG_OFFBIG_LIBS
,

601 
	#_CS_XBS5_LPBIG_OFFBIG_LIBS
 
_CS_XBS5_LPBIG_OFFBIG_LIBS


	)

602 
	m_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS
,

603 
	#_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS
 
_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS


	)

605 
	m_CS_POSIX_V6_ILP32_OFF32_CFLAGS
,

606 
	#_CS_POSIX_V6_ILP32_OFF32_CFLAGS
 
_CS_POSIX_V6_ILP32_OFF32_CFLAGS


	)

607 
	m_CS_POSIX_V6_ILP32_OFF32_LDFLAGS
,

608 
	#_CS_POSIX_V6_ILP32_OFF32_LDFLAGS
 
_CS_POSIX_V6_ILP32_OFF32_LDFLAGS


	)

609 
	m_CS_POSIX_V6_ILP32_OFF32_LIBS
,

610 
	#_CS_POSIX_V6_ILP32_OFF32_LIBS
 
_CS_POSIX_V6_ILP32_OFF32_LIBS


	)

611 
	m_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS
,

612 
	#_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS
 
_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS


	)

613 
	m_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS
,

614 
	#_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS
 
_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS


	)

615 
	m_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS
,

616 
	#_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS
 
_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS


	)

617 
	m_CS_POSIX_V6_ILP32_OFFBIG_LIBS
,

618 
	#_CS_POSIX_V6_ILP32_OFFBIG_LIBS
 
_CS_POSIX_V6_ILP32_OFFBIG_LIBS


	)

619 
	m_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS
,

620 
	#_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS
 
_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS


	)

621 
	m_CS_POSIX_V6_LP64_OFF64_CFLAGS
,

622 
	#_CS_POSIX_V6_LP64_OFF64_CFLAGS
 
_CS_POSIX_V6_LP64_OFF64_CFLAGS


	)

623 
	m_CS_POSIX_V6_LP64_OFF64_LDFLAGS
,

624 
	#_CS_POSIX_V6_LP64_OFF64_LDFLAGS
 
_CS_POSIX_V6_LP64_OFF64_LDFLAGS


	)

625 
	m_CS_POSIX_V6_LP64_OFF64_LIBS
,

626 
	#_CS_POSIX_V6_LP64_OFF64_LIBS
 
_CS_POSIX_V6_LP64_OFF64_LIBS


	)

627 
	m_CS_POSIX_V6_LP64_OFF64_LINTFLAGS
,

628 
	#_CS_POSIX_V6_LP64_OFF64_LINTFLAGS
 
_CS_POSIX_V6_LP64_OFF64_LINTFLAGS


	)

629 
	m_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS
,

630 
	#_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS
 
_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS


	)

631 
	m_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS
,

632 
	#_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS
 
_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS


	)

633 
	m_CS_POSIX_V6_LPBIG_OFFBIG_LIBS
,

634 
	#_CS_POSIX_V6_LPBIG_OFFBIG_LIBS
 
_CS_POSIX_V6_LPBIG_OFFBIG_LIBS


	)

635 
	m_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS
,

636 
	#_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS
 
_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS


	)

638 
	m_CS_POSIX_V7_ILP32_OFF32_CFLAGS
,

639 
	#_CS_POSIX_V7_ILP32_OFF32_CFLAGS
 
_CS_POSIX_V7_ILP32_OFF32_CFLAGS


	)

640 
	m_CS_POSIX_V7_ILP32_OFF32_LDFLAGS
,

641 
	#_CS_POSIX_V7_ILP32_OFF32_LDFLAGS
 
_CS_POSIX_V7_ILP32_OFF32_LDFLAGS


	)

642 
	m_CS_POSIX_V7_ILP32_OFF32_LIBS
,

643 
	#_CS_POSIX_V7_ILP32_OFF32_LIBS
 
_CS_POSIX_V7_ILP32_OFF32_LIBS


	)

644 
	m_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS
,

645 
	#_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS
 
_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS


	)

646 
	m_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS
,

647 
	#_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS
 
_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS


	)

648 
	m_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS
,

649 
	#_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS
 
_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS


	)

650 
	m_CS_POSIX_V7_ILP32_OFFBIG_LIBS
,

651 
	#_CS_POSIX_V7_ILP32_OFFBIG_LIBS
 
_CS_POSIX_V7_ILP32_OFFBIG_LIBS


	)

652 
	m_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS
,

653 
	#_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS
 
_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS


	)

654 
	m_CS_POSIX_V7_LP64_OFF64_CFLAGS
,

655 
	#_CS_POSIX_V7_LP64_OFF64_CFLAGS
 
_CS_POSIX_V7_LP64_OFF64_CFLAGS


	)

656 
	m_CS_POSIX_V7_LP64_OFF64_LDFLAGS
,

657 
	#_CS_POSIX_V7_LP64_OFF64_LDFLAGS
 
_CS_POSIX_V7_LP64_OFF64_LDFLAGS


	)

658 
	m_CS_POSIX_V7_LP64_OFF64_LIBS
,

659 
	#_CS_POSIX_V7_LP64_OFF64_LIBS
 
_CS_POSIX_V7_LP64_OFF64_LIBS


	)

660 
	m_CS_POSIX_V7_LP64_OFF64_LINTFLAGS
,

661 
	#_CS_POSIX_V7_LP64_OFF64_LINTFLAGS
 
_CS_POSIX_V7_LP64_OFF64_LINTFLAGS


	)

662 
	m_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS
,

663 
	#_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS
 
_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS


	)

664 
	m_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS
,

665 
	#_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS
 
_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS


	)

666 
	m_CS_POSIX_V7_LPBIG_OFFBIG_LIBS
,

667 
	#_CS_POSIX_V7_LPBIG_OFFBIG_LIBS
 
_CS_POSIX_V7_LPBIG_OFFBIG_LIBS


	)

668 
	m_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS
,

669 
	#_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS
 
_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS


	)

671 
	m_CS_V6_ENV
,

672 
	#_CS_V6_ENV
 
_CS_V6_ENV


	)

673 
	m_CS_V7_ENV


674 
	#_CS_V7_ENV
 
_CS_V7_ENV


	)

	@/usr/include/bits/dlfcn.h

19 #ide
_DLFCN_H


24 
	#RTLD_LAZY
 0x00001

	)

25 
	#RTLD_NOW
 0x00002

	)

26 
	#RTLD_BINDING_MASK
 0x3

	)

27 
	#RTLD_NOLOAD
 0x00004

	)

28 
	#RTLD_DEEPBIND
 0x00008

	)

33 
	#RTLD_GLOBAL
 0x00100

	)

38 
	#RTLD_LOCAL
 0

	)

41 
	#RTLD_NODELETE
 0x01000

	)

43 #ifde
__USE_GNU


54 
	#DL_CALL_FCT
(
fp
, 
gs
) \

55 (
	`_dl_mcou_w_check
 ((*(
fp
)), (*(fp)
gs
)

	)

57 
__BEGIN_DECLS


60 
	$_dl_mcou_w_check
 (*
__lc

__THROW
;

62 
__END_DECLS


	@/usr/include/bits/environments.h

18 #ide
_UNISTD_H


22 
	~<bs/wdsize.h
>

42 #i
__WORDSIZE
 == 64

56 
	#_POSIX_V7_LPBIG_OFFBIG
 -1

	)

57 
	#_POSIX_V6_LPBIG_OFFBIG
 -1

	)

58 
	#_XBS5_LPBIG_OFFBIG
 -1

	)

61 
	#_POSIX_V7_LP64_OFF64
 1

	)

62 
	#_POSIX_V6_LP64_OFF64
 1

	)

63 
	#_XBS5_LP64_OFF64
 1

	)

69 
	#_POSIX_V7_ILP32_OFFBIG
 1

	)

70 
	#_POSIX_V6_ILP32_OFFBIG
 1

	)

71 
	#_XBS5_ILP32_OFFBIG
 1

	)

73 #ide
__x86_64__


75 
	#_POSIX_V7_ILP32_OFF32
 1

	)

76 
	#_POSIX_V6_ILP32_OFF32
 1

	)

77 
	#_XBS5_ILP32_OFF32
 1

	)

95 
	#__ILP32_OFF32_CFLAGS
 "-m32"

	)

96 
	#__ILP32_OFF32_LDFLAGS
 "-m32"

	)

97 #i
defed
 
__x86_64__
 && defed 
__ILP32__


98 
	#__ILP32_OFFBIG_CFLAGS
 "-mx32"

	)

99 
	#__ILP32_OFFBIG_LDFLAGS
 "-mx32"

	)

101 
	#__ILP32_OFFBIG_CFLAGS
 "-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64"

	)

102 
	#__ILP32_OFFBIG_LDFLAGS
 "-m32"

	)

104 
	#__LP64_OFF64_CFLAGS
 "-m64"

	)

105 
	#__LP64_OFF64_LDFLAGS
 "-m64"

	)

	@/usr/include/bits/errno.h

19 #ifde
_ERRNO_H


21 #unde
EDOM


22 #unde
EILSEQ


23 #unde
ERANGE


24 
	~<lux/o.h
>

27 
	#ENOTSUP
 
EOPNOTSUPP


	)

30 #ide
ECANCELED


31 
	#ECANCELED
 125

	)

35 #ide
EOWNERDEAD


36 
	#EOWNERDEAD
 130

	)

37 
	#ENOTRECOVERABLE
 131

	)

40 #ide
ERFKILL


41 
	#ERFKILL
 132

	)

44 #ide
EHWPOISON


45 
	#EHWPOISON
 133

	)

48 #ide
__ASSEMBLER__


50 *
	$__o_loti
 (
__THROW
 
	`__ibu__
 ((
__cڡ__
));

52 #i!
defed
 
_LIBC
 || defed 
_LIBC_REENTRANT


54 
	#o
 (*
	`__o_loti
 ())

	)

59 #i!
defed
 
_ERRNO_H
 && defed 
__ed_Emh


63 
	#EDOM
 33

	)

64 
	#EILSEQ
 84

	)

65 
	#ERANGE
 34

	)

	@/usr/include/bits/fcntl.h

19 #ide
_FCNTL_H


23 #ifde
__x86_64__


24 
	#__O_LARGEFILE
 0

	)

27 #ifde
__x86_64__


29 
	#F_GETLK64
 5

	)

30 
	#F_SETLK64
 6

	)

31 
	#F_SETLKW64
 7

	)

35 
	sock


37 
	ml_ty
;

38 
	ml_wh
;

39 #ide
__USE_FILE_OFFSET64


40 
__off_t
 
	ml_t
;

41 
__off_t
 
	ml_n
;

43 
__off64_t
 
	ml_t
;

44 
__off64_t
 
	ml_n
;

46 
__pid_t
 
	ml_pid
;

49 #ifde
__USE_LARGEFILE64


50 
	sock64


52 
	ml_ty
;

53 
	ml_wh
;

54 
__off64_t
 
	ml_t
;

55 
__off64_t
 
	ml_n
;

56 
__pid_t
 
	ml_pid
;

61 
	~<bs/f-lux.h
>

	@/usr/include/bits/fcntl2.h

19 #idef 
_FCNTL_H


25 #ide
__USE_FILE_OFFSET64


26 
	$__ݒ_2
 (cڡ *
__th
, 
__oag

	`__nnu
 ((1));

27 
	`__REDIRECT
 (
__ݒ_s
, (cڡ *
__th
, 
__oag
, ...),

28 
ݒ

	`__nnu
 ((1));

30 
	`__REDIRECT
 (
__ݒ_2
, (cڡ *
__th
, 
__oag
),

31 
__ݒ64_2

	`__nnu
 ((1));

32 
	`__REDIRECT
 (
__ݒ_s
, (cڡ *
__th
, 
__oag
, ...),

33 
ݒ64

	`__nnu
 ((1));

35 
	`__rde
 (
__ݒ_too_my_gs
,

37 
	`__rde
 (
__ݒ_missg_mode
,

40 
__ftify_funi
 

41 
	$ݒ
 (cڡ *
__th
, 
__oag
, ...)

43 i(
	`__va_g_ck_n
 () > 1)

44 
	`__ݒ_too_my_gs
 ();

46 i(
	`__but_cڡt_p
 (
__oag
))

48 i((
__oag
 & 
O_CREAT
!0 && 
	`__va_g_ck_n
 () < 1)

50 
	`__ݒ_missg_mode
 ();

51  
	`__ݒ_2
 (
__th
, 
__oag
);

53  
	`__ݒ_s
 (
__th
, 
__oag
, 
	`__va_g_ck
 ());

56 i(
	`__va_g_ck_n
 () < 1)

57  
	`__ݒ_2
 (
__th
, 
__oag
);

59  
	`__ݒ_s
 (
__th
, 
__oag
, 
	`__va_g_ck
 ());

60 
	}
}

63 #ifde
__USE_LARGEFILE64


64 
	$__ݒ64_2
 (cڡ *
__th
, 
__oag

	`__nnu
 ((1));

65 
	`__REDIRECT
 (
__ݒ64_s
, (cڡ *
__th
, 
__oag
,

66 ...), 
ݒ64

	`__nnu
 ((1));

67 
	`__rde
 (
__ݒ64_too_my_gs
,

69 
	`__rde
 (
__ݒ64_missg_mode
,

72 
__ftify_funi
 

73 
	$ݒ64
 (cڡ *
__th
, 
__oag
, ...)

75 i(
	`__va_g_ck_n
 () > 1)

76 
	`__ݒ64_too_my_gs
 ();

78 i(
	`__but_cڡt_p
 (
__oag
))

80 i((
__oag
 & 
O_CREAT
!0 && 
	`__va_g_ck_n
 () < 1)

82 
	`__ݒ64_missg_mode
 ();

83  
	`__ݒ64_2
 (
__th
, 
__oag
);

85  
	`__ݒ64_s
 (
__th
, 
__oag
, 
	`__va_g_ck
 ());

88 i(
	`__va_g_ck_n
 () < 1)

89  
	`__ݒ64_2
 (
__th
, 
__oag
);

91  
	`__ݒ64_s
 (
__th
, 
__oag
, 
	`__va_g_ck
 ());

92 
	}
}

96 #ifde
__USE_ATFILE


97 #ide
__USE_FILE_OFFSET64


98 
	$__ݒ_2
 (
__fd
, cڡ *
__th
, 
__oag
)

99 
	`__nnu
 ((2));

100 
	`__REDIRECT
 (
__ݒ_s
, (
__fd
, cڡ *
__th
,

101 
__oag
, ...), 
ݒ
)

102 
	`__nnu
 ((2));

104 
	`__REDIRECT
 (
__ݒ_2
, (
__fd
, cڡ *
__th
,

105 
__oag
), 
__ݒ64_2
)

106 
	`__nnu
 ((2));

107 
	`__REDIRECT
 (
__ݒ_s
, (
__fd
, cڡ *
__th
,

108 
__oag
, ...), 
ݒ64
)

109 
	`__nnu
 ((2));

111 
	`__rde
 (
__ݒ_too_my_gs
,

113 
	`__rde
 (
__ݒ_missg_mode
,

116 
__ftify_funi
 

117 
	$ݒ
 (
__fd
, cڡ *
__th
, 
__oag
, ...)

119 i(
	`__va_g_ck_n
 () > 1)

120 
	`__ݒ_too_my_gs
 ();

122 i(
	`__but_cڡt_p
 (
__oag
))

124 i((
__oag
 & 
O_CREAT
!0 && 
	`__va_g_ck_n
 () < 1)

126 
	`__ݒ_missg_mode
 ();

127  
	`__ݒ_2
 (
__fd
, 
__th
, 
__oag
);

129  
	`__ݒ_s
 (
__fd
, 
__th
, 
__oag
, 
	`__va_g_ck
 ());

132 i(
	`__va_g_ck_n
 () < 1)

133  
	`__ݒ_2
 (
__fd
, 
__th
, 
__oag
);

135  
	`__ݒ_s
 (
__fd
, 
__th
, 
__oag
, 
	`__va_g_ck
 ());

136 
	}
}

139 #ifde
__USE_LARGEFILE64


140 
	$__ݒ64_2
 (
__fd
, cڡ *
__th
, 
__oag
)

141 
	`__nnu
 ((2));

142 
	`__REDIRECT
 (
__ݒ64_s
, (
__fd
, cڡ *
__th
,

143 
__oag
, ...), 
ݒ64
)

144 
	`__nnu
 ((2));

145 
	`__rde
 (
__ݒ64_too_my_gs
,

147 
	`__rde
 (
__ݒ64_missg_mode
,

150 
__ftify_funi
 

151 
	$ݒ64
 (
__fd
, cڡ *
__th
, 
__oag
, ...)

153 i(
	`__va_g_ck_n
 () > 1)

154 
	`__ݒ64_too_my_gs
 ();

156 i(
	`__but_cڡt_p
 (
__oag
))

158 i((
__oag
 & 
O_CREAT
!0 && 
	`__va_g_ck_n
 () < 1)

160 
	`__ݒ64_missg_mode
 ();

161  
	`__ݒ64_2
 (
__fd
, 
__th
, 
__oag
);

163  
	`__ݒ64_s
 (
__fd
, 
__th
, 
__oag
, 
	`__va_g_ck
 ());

166 i(
	`__va_g_ck_n
 () < 1)

167  
	`__ݒ64_2
 (
__fd
, 
__th
, 
__oag
);

169  
	`__ݒ64_s
 (
__fd
, 
__th
, 
__oag
, 
	`__va_g_ck
 ());

170 
	}
}

	@/usr/include/bits/huge_val.h

20 #ide
_MATH_H


26 #i
__GNUC_PREREQ
(3,3)

27 
	#HUGE_VAL
 (
	`__but_huge_v
())

	)

28 #i
__GNUC_PREREQ
(2,96)

29 
	#HUGE_VAL
 (
__exnsi__
 0x1.0
p2047
)

	)

30 #i
defed
 
__GNUC__


32 
	#HUGE_VAL
 \

33 (
__exnsi__
 \

34 ((uni { 
__l
 
	`__ibu__
((
	`__mode__
(
__DI__
))); 
__d
; }) \

35 { 
__l
: 0x7ff0000000000000ULL }).
__d
)

	)

39 
	~<dn.h
>

41 uni { 
	m__c
[8]; 
	m__d
; } 
	t__huge_v_t
;

43 #i
__BYTE_ORDER
 =
__BIG_ENDIAN


44 
	#__HUGE_VAL_bys
 { 0x7f, 0xf0, 0, 0, 0, 0, 0, 0 }

	)

46 #i
__BYTE_ORDER
 =
__LITTLE_ENDIAN


47 
	#__HUGE_VAL_bys
 { 0, 0, 0, 0, 0, 0, 0xf0, 0x7}

	)

50 
__huge_v_t
 
	g__huge_v
 = { 
__HUGE_VAL_bys
 };

51 
	#HUGE_VAL
 (
__huge_v
.
__d
)

	)

	@/usr/include/bits/huge_valf.h

20 #ide
_MATH_H


26 #i
__GNUC_PREREQ
(3,3)

27 
	#HUGE_VALF
 (
	`__but_huge_vf
())

	)

28 #i
__GNUC_PREREQ
(2,96)

29 
	#HUGE_VALF
 (
__exnsi__
 0x1.0
p255f
)

	)

30 #i
defed
 
__GNUC__


32 
	#HUGE_VALF
 \

33 (
__exnsi__
 \

34 ((uni { 
__l
 
	`__ibu__
((
	`__mode__
(
__SI__
))); 
__d
; }) \

35 { 
__l
: 0x7f800000UL }).
__d
)

	)

39 uni { 
	m__c
[4]; 
	m__f
; } 
	t__huge_vf_t
;

41 #i
__BYTE_ORDER
 =
__BIG_ENDIAN


42 
	#__HUGE_VALF_bys
 { 0x7f, 0x80, 0, 0 }

	)

44 #i
__BYTE_ORDER
 =
__LITTLE_ENDIAN


45 
	#__HUGE_VALF_bys
 { 0, 0, 0x80, 0x7}

	)

48 
__huge_vf_t
 
	g__huge_vf
 = { 
__HUGE_VALF_bys
 };

49 
	#HUGE_VALF
 (
__huge_vf
.
__f
)

	)

	@/usr/include/bits/huge_vall.h

20 #ide
_MATH_H


24 #i
__GNUC_PREREQ
(3,3)

25 
	#HUGE_VALL
 (
	`__but_huge_vl
())

	)

26 #i
__GNUC_PREREQ
(2,96)

27 
	#HUGE_VALL
 (
__exnsi__
 0x1.0
p32767L
)

	)

30 
	#__HUGE_VALL_bys
 { 0, 0, 0, 0, 0, 0, 0, 0x80, 0xff, 0x7f, 0, 0 }

	)

32 
	#__huge_vl_t
 uni { 
__c
[12]; 
__ld
; }

	)

33 #ifde
__GNUC__


34 
	#HUGE_VALL
 (
__exnsi__
 \

35 ((
__huge_vl_t
{ 
__c
: 
__HUGE_VALL_bys
 }).
__ld
)

	)

37 
__huge_vl_t
 
	g__huge_vl
 = { 
__HUGE_VALL_bys
 };

38 
	#HUGE_VALL
 (
__huge_vl
.
__ld
)

	)

	@/usr/include/bits/inf.h

19 #ide
_MATH_H


25 #i
__GNUC_PREREQ
(3,3)

26 
	#INFINITY
 (
	`__but_ff
())

	)

28 
	#INFINITY
 
HUGE_VALF


	)

	@/usr/include/bits/math-finite.h

19 #ide
_MATH_H


24 
__REDIRECT_NTH
 (
acos
, (), 
__acos_fe
);

25 
__REDIRECT_NTH
 (
acosf
, (), 
__acosf_fe
);

26 #ifde
__MATH_DECLARE_LDOUBLE


27 #ifde
__NO_LONG_DOUBLE_MATH


28 
__REDIRECT_NTH
 (
aco
, (), 
__acos_fe
);

30 
__REDIRECT_NTH
 (
aco
, (), 
__aco_fe
);

34 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_ISOC99


36 
__REDIRECT_NTH
 (
acosh
, (), 
__acosh_fe
);

37 
__REDIRECT_NTH
 (
acoshf
, (), 
__acoshf_fe
);

38 #ifde
__MATH_DECLARE_LDOUBLE


39 #ifde
__NO_LONG_DOUBLE_MATH


40 
__REDIRECT_NTH
 (
acoshl
, (), 
__acosh_fe
);

42 
__REDIRECT_NTH
 (
acoshl
, (), 
__acoshl_fe
);

48 
__REDIRECT_NTH
 (
as
, (), 
__as_fe
);

49 
__REDIRECT_NTH
 (
asf
, (), 
__asf_fe
);

50 #ifde
__MATH_DECLARE_LDOUBLE


51 #ifde
__NO_LONG_DOUBLE_MATH


52 
__REDIRECT_NTH
 (
asl
, (), 
__as_fe
);

54 
__REDIRECT_NTH
 (
asl
, (), 
__asl_fe
);

59 
__REDIRECT_NTH
 (
2
, (, ), 
__2_fe
);

60 
__REDIRECT_NTH
 (
2f
, (, ), 
__2f_fe
);

61 #ifde
__MATH_DECLARE_LDOUBLE


62 #ifde
__NO_LONG_DOUBLE_MATH


63 
__REDIRECT_NTH
 (
2l
, (, ),

64 
__2_fe
);

66 
__REDIRECT_NTH
 (
2l
, (, ),

67 
__2l_fe
);

71 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_ISOC99


73 
__REDIRECT_NTH
 (
h
, (), 
__h_fe
);

74 
__REDIRECT_NTH
 (
hf
, (), 
__hf_fe
);

75 #ifde
__MATH_DECLARE_LDOUBLE


76 #ifde
__NO_LONG_DOUBLE_MATH


77 
__REDIRECT_NTH
 (
hl
, (), 
__h_fe
);

79 
__REDIRECT_NTH
 (
hl
, (), 
__hl_fe
);

85 
__REDIRECT_NTH
 (
cosh
, (), 
__cosh_fe
);

86 
__REDIRECT_NTH
 (
coshf
, (), 
__coshf_fe
);

87 #ifde
__MATH_DECLARE_LDOUBLE


88 #ifde
__NO_LONG_DOUBLE_MATH


89 
__REDIRECT_NTH
 (
coshl
, (), 
__cosh_fe
);

91 
__REDIRECT_NTH
 (
coshl
, (), 
__coshl_fe
);

96 
__REDIRECT_NTH
 (
exp
, (), 
__exp_fe
);

97 
__REDIRECT_NTH
 (
expf
, (), 
__expf_fe
);

98 #ifde
__MATH_DECLARE_LDOUBLE


99 #ifde
__NO_LONG_DOUBLE_MATH


100 
__REDIRECT_NTH
 (
ex
, (), 
__exp_fe
);

102 
__REDIRECT_NTH
 (
ex
, (), 
__ex_fe
);

106 #ifde
__USE_GNU


108 
__REDIRECT_NTH
 (
exp10
, (), 
__exp10_fe
);

109 
__REDIRECT_NTH
 (
exp10f
, (), 
__exp10f_fe
);

110 #ifde
__MATH_DECLARE_LDOUBLE


111 #ifde
__NO_LONG_DOUBLE_MATH


112 
__REDIRECT_NTH
 (
exp10l
, (), 
__exp10_fe
);

114 
__REDIRECT_NTH
 (
exp10l
, (), 
__exp10l_fe
);

119 
__REDIRECT_NTH
 (
pow10
, (), 
__exp10_fe
);

120 
__REDIRECT_NTH
 (
pow10f
, (), 
__exp10f_fe
);

121 #ifde
__MATH_DECLARE_LDOUBLE


122 #ifde
__NO_LONG_DOUBLE_MATH


123 
__REDIRECT_NTH
 (
pow10l
, (), 
__exp10_fe
);

125 
__REDIRECT_NTH
 (
pow10l
, (), 
__exp10l_fe
);

130 #ifde
__USE_ISOC99


132 
__REDIRECT_NTH
 (
exp2
, (), 
__exp2_fe
);

133 
__REDIRECT_NTH
 (
exp2f
, (), 
__exp2f_fe
);

134 #ifde
__MATH_DECLARE_LDOUBLE


135 #ifde
__NO_LONG_DOUBLE_MATH


136 
__REDIRECT_NTH
 (
exp2l
, (), 
__exp2_fe
);

138 
__REDIRECT_NTH
 (
exp2l
, (), 
__exp2l_fe
);

144 
__REDIRECT_NTH
 (
fmod
, (, ), 
__fmod_fe
);

145 
__REDIRECT_NTH
 (
fmodf
, (, ), 
__fmodf_fe
);

146 #ifde
__MATH_DECLARE_LDOUBLE


147 #ifde
__NO_LONG_DOUBLE_MATH


148 
__REDIRECT_NTH
 (
fmodl
, (, ),

149 
__fmod_fe
);

151 
__REDIRECT_NTH
 (
fmodl
, (, ),

152 
__fmodl_fe
);

156 #ifde
__USE_ISOC99


158 
__REDIRECT_NTH
 (
hyp
, (, ), 
__hyp_fe
);

159 
__REDIRECT_NTH
 (
hypf
, (, ), 
__hypf_fe
);

160 #ifde
__MATH_DECLARE_LDOUBLE


161 #ifde
__NO_LONG_DOUBLE_MATH


162 
__REDIRECT_NTH
 (
hypl
, (, ),

163 
__hyp_fe
);

165 
__REDIRECT_NTH
 (
hypl
, (, ),

166 
__hypl_fe
);

171 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN


173 
__REDIRECT_NTH
 (
j0
, (), 
__j0_fe
);

174 
__REDIRECT_NTH
 (
j0f
, (), 
__j0f_fe
);

175 #ifde
__MATH_DECLARE_LDOUBLE


176 #ifde
__NO_LONG_DOUBLE_MATH


177 
__REDIRECT_NTH
 (
j0l
, (), 
__j0_fe
);

179 
__REDIRECT_NTH
 (
j0l
, (), 
__j0l_fe
);

184 
__REDIRECT_NTH
 (
y0
, (), 
__y0_fe
);

185 
__REDIRECT_NTH
 (
y0f
, (), 
__y0f_fe
);

186 #ifde
__MATH_DECLARE_LDOUBLE


187 #ifde
__NO_LONG_DOUBLE_MATH


188 
__REDIRECT_NTH
 (
y0l
, (), 
__y0_fe
);

190 
__REDIRECT_NTH
 (
y0l
, (), 
__y0l_fe
);

195 
__REDIRECT_NTH
 (
j1
, (), 
__j1_fe
);

196 
__REDIRECT_NTH
 (
j1f
, (), 
__j1f_fe
);

197 #ifde
__MATH_DECLARE_LDOUBLE


198 #ifde
__NO_LONG_DOUBLE_MATH


199 
__REDIRECT_NTH
 (
j1l
, (), 
__j1_fe
);

201 
__REDIRECT_NTH
 (
j1l
, (), 
__j1l_fe
);

206 
__REDIRECT_NTH
 (
y1
, (), 
__y1_fe
);

207 
__REDIRECT_NTH
 (
y1f
, (), 
__y1f_fe
);

208 #ifde
__MATH_DECLARE_LDOUBLE


209 #ifde
__NO_LONG_DOUBLE_MATH


210 
__REDIRECT_NTH
 (
y1l
, (), 
__y1_fe
);

212 
__REDIRECT_NTH
 (
y1l
, (), 
__y1l_fe
);

217 
__REDIRECT_NTH
 (
jn
, (, ), 
__jn_fe
);

218 
__REDIRECT_NTH
 (
jnf
, (, ), 
__jnf_fe
);

219 #ifde
__MATH_DECLARE_LDOUBLE


220 #ifde
__NO_LONG_DOUBLE_MATH


221 
__REDIRECT_NTH
 (
j
, (, ), 
__jn_fe
);

223 
__REDIRECT_NTH
 (
j
, (, ), 
__j_fe
);

228 
__REDIRECT_NTH
 (
yn
, (, ), 
__yn_fe
);

229 
__REDIRECT_NTH
 (
ynf
, (, ), 
__ynf_fe
);

230 #ifde
__MATH_DECLARE_LDOUBLE


231 #ifde
__NO_LONG_DOUBLE_MATH


232 
__REDIRECT_NTH
 (
y
, (, ), 
__yn_fe
);

234 
__REDIRECT_NTH
 (
y
, (, ), 
__y_fe
);

239 #ifde
__USE_MISC


241 
__REDIRECT_NTH
 (
lgamma_r
, (, *), 
__lgamma_r_fe
);

242 
__REDIRECT_NTH
 (
lgammaf_r
, (, *), 
__lgammaf_r_fe
);

243 #ifde
__MATH_DECLARE_LDOUBLE


244 #ifde
__NO_LONG_DOUBLE_MATH


245 
__REDIRECT_NTH
 (
lgamm_r
, (, *),

246 
__lgamma_r_fe
);

248 
__REDIRECT_NTH
 (
lgamm_r
, (, *),

249 
__lgamm_r_fe
);

254 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN
 || defed 
__USE_ISOC99


256 
__ex_ways_le
 
__NTH
 (
	$lgamma
 (
__d
))

258 #ifde
__USE_ISOC99


259 
__lol_signgam
 = 0;

260  
	`lgamma_r
 (
__d
, &
__lol_signgam
);

262  
	`lgamma_r
 (
__d
, &
signgam
);

264 
	}
}

265 
__ex_ways_le
 
__NTH
 (
	$lgammaf
 (
__d
))

267 #ifde
__USE_ISOC99


268 
__lol_signgam
 = 0;

269  
	`lgammaf_r
 (
__d
, &
__lol_signgam
);

271  
	`lgammaf_r
 (
__d
, &
signgam
);

273 
	}
}

274 #ifde
__MATH_DECLARE_LDOUBLE


275 
__ex_ways_le
 
__NTH
 (
	$lgamm
 (
__d
))

277 #ifde
__USE_ISOC99


278 
__lol_signgam
 = 0;

279  
	`lgamm_r
 (
__d
, &
__lol_signgam
);

281  
	`lgamm_r
 (
__d
, &
signgam
);

283 
	}
}

287 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN


289 
__ex_ways_le
 
__NTH
 (
	$gamma
 (
__d
))

291 #ifde
__USE_ISOC99


292 
__lol_signgam
 = 0;

293  
	`lgamma_r
 (
__d
, &
__lol_signgam
);

295  
	`lgamma_r
 (
__d
, &
signgam
);

297 
	}
}

298 
__ex_ways_le
 
__NTH
 (
	$gammaf
 (
__d
))

300 #ifde
__USE_ISOC99


301 
__lol_signgam
 = 0;

302  
	`lgammaf_r
 (
__d
, &
__lol_signgam
);

304  
	`lgammaf_r
 (
__d
, &
signgam
);

306 
	}
}

307 #ifde
__MATH_DECLARE_LDOUBLE


308 
__ex_ways_le
 
__NTH
 (
	$gamm
 (
__d
))

310 #ifde
__USE_ISOC99


311 
__lol_signgam
 = 0;

312  
	`lgamm_r
 (
__d
, &
__lol_signgam
);

314  
	`lgamm_r
 (
__d
, &
signgam
);

316 
	}
}

321 
__REDIRECT_NTH
 (
log
, (), 
__log_fe
);

322 
__REDIRECT_NTH
 (
logf
, (), 
__logf_fe
);

323 #ifde
__MATH_DECLARE_LDOUBLE


324 #ifde
__NO_LONG_DOUBLE_MATH


325 
__REDIRECT_NTH
 (
logl
, (), 
__log_fe
);

327 
__REDIRECT_NTH
 (
logl
, (), 
__logl_fe
);

332 
__REDIRECT_NTH
 (
log10
, (), 
__log10_fe
);

333 
__REDIRECT_NTH
 (
log10f
, (), 
__log10f_fe
);

334 #ifde
__MATH_DECLARE_LDOUBLE


335 #ifde
__NO_LONG_DOUBLE_MATH


336 
__REDIRECT_NTH
 (
log10l
, (), 
__log10_fe
);

338 
__REDIRECT_NTH
 (
log10l
, (), 
__log10l_fe
);

342 #ifde
__USE_ISOC99


344 
__REDIRECT_NTH
 (
log2
, (), 
__log2_fe
);

345 
__REDIRECT_NTH
 (
log2f
, (), 
__log2f_fe
);

346 #ifde
__MATH_DECLARE_LDOUBLE


347 #ifde
__NO_LONG_DOUBLE_MATH


348 
__REDIRECT_NTH
 (
log2l
, (), 
__log2_fe
);

350 
__REDIRECT_NTH
 (
log2l
, (), 
__log2l_fe
);

356 
__REDIRECT_NTH
 (
ldexp
, (, ), 
slbn
);

357 
__REDIRECT_NTH
 (
ldexpf
, (, ), 
slbnf
);

358 #ifde
__MATH_DECLARE_LDOUBLE


359 
__REDIRECT_NTH
 (
ldex
, (, ), 
slb
);

363 
__REDIRECT_NTH
 (
pow
, (, ), 
__pow_fe
);

364 
__REDIRECT_NTH
 (
powf
, (, ), 
__powf_fe
);

365 #ifde
__MATH_DECLARE_LDOUBLE


366 #ifde
__NO_LONG_DOUBLE_MATH


367 
__REDIRECT_NTH
 (
powl
, (, ),

368 
__pow_fe
);

370 
__REDIRECT_NTH
 (
powl
, (, ),

371 
__powl_fe
);

376 
__REDIRECT_NTH
 (
mad
, (, ), 
__mad_fe
);

377 
__REDIRECT_NTH
 (
madf
, (, ), 
__madf_fe
);

378 #ifde
__MATH_DECLARE_LDOUBLE


379 #ifde
__NO_LONG_DOUBLE_MATH


380 
__REDIRECT_NTH
 (
madl
, (, ),

381 
__mad_fe
);

383 
__REDIRECT_NTH
 (
madl
, (, ),

384 
__madl_fe
);

388 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN_EXTENDED


390 
__REDIRECT_NTH
 (
slb
, (, ), 
__slb_fe
);

391 
__REDIRECT_NTH
 (
slbf
, (, ), 
__slbf_fe
);

392 #ifde
__MATH_DECLARE_LDOUBLE


393 #ifde
__NO_LONG_DOUBLE_MATH


394 
__REDIRECT_NTH
 (
slbl
, (, ),

395 
__slb_fe
);

397 
__REDIRECT_NTH
 (
slbl
, (, ),

398 
__slbl_fe
);

404 
__REDIRECT_NTH
 (
sh
, (), 
__sh_fe
);

405 
__REDIRECT_NTH
 (
shf
, (), 
__shf_fe
);

406 #ifde
__MATH_DECLARE_LDOUBLE


407 #ifde
__NO_LONG_DOUBLE_MATH


408 
__REDIRECT_NTH
 (
shl
, (), 
__sh_fe
);

410 
__REDIRECT_NTH
 (
shl
, (), 
__shl_fe
);

415 
__REDIRECT_NTH
 (
sq
, (), 
__sq_fe
);

416 
__REDIRECT_NTH
 (
sqf
, (), 
__sqf_fe
);

417 #ifde
__MATH_DECLARE_LDOUBLE


418 #ifde
__NO_LONG_DOUBLE_MATH


419 
__REDIRECT_NTH
 (
sql
, (), 
__sq_fe
);

421 
__REDIRECT_NTH
 (
sql
, (), 
__sql_fe
);

425 #ifde
__USE_ISOC99


427 
__gamma_r_fe
 (, *);

428 
__ex_ways_le
 
__NTH
 (
	$tgamma
 (
__d
))

430 
__lol_signgam
 = 0;

431 
__s
 = 
	`__gamma_r_fe
 (
__d
, &
__lol_signgam
);

432  
__lol_signgam
 < 0 ? -
__s
 : __res;

433 
	}
}

434 
__gammaf_r_fe
 (, *);

435 
__ex_ways_le
 
__NTH
 (
	$tgammaf
 (
__d
))

437 
__lol_signgam
 = 0;

438 
__s
 = 
	`__gammaf_r_fe
 (
__d
, &
__lol_signgam
);

439  
__lol_signgam
 < 0 ? -
__s
 : __res;

440 
	}
}

441 #ifde
__MATH_DECLARE_LDOUBLE


442 
__gamm_r_fe
 (, *);

443 
__ex_ways_le
 
__NTH
 (
	$tgamm
 (
__d
))

445 
__lol_signgam
 = 0;

446 #ifde
__NO_LONG_DOUBLE_MATH


447 
__s
 = 
	`__gamma_r_fe
 (
__d
, &
__lol_signgam
);

449 
__s
 = 
	`__gamm_r_fe
 (
__d
, &
__lol_signgam
);

451  
__lol_signgam
 < 0 ? -
__s
 : __res;

452 
	}
}

	@/usr/include/bits/mathcalls.h

45 #ide
_MATH_H


52 
_Mdoub_BEGIN_NAMESPACE


54 
__MATHCALL
 (
acos
,, (
_Mdoub_
 
__x
));

56 
__MATHCALL
 (
as
,, (
_Mdoub_
 
__x
));

58 
__MATHCALL
 (

,, (
_Mdoub_
 
__x
));

60 
__MATHCALL
 (
2
,, (
_Mdoub_
 
__y
, _Mdoub_ 
__x
));

63 
__MATHCALL
 (
cos
,, (
_Mdoub_
 
__x
));

65 
__MATHCALL
 (
s
,, (
_Mdoub_
 
__x
));

67 
__MATHCALL
 (
n
,, (
_Mdoub_
 
__x
));

72 
__MATHCALL
 (
cosh
,, (
_Mdoub_
 
__x
));

74 
__MATHCALL
 (
sh
,, (
_Mdoub_
 
__x
));

76 
__MATHCALL
 (
nh
,, (
_Mdoub_
 
__x
));

77 
	g_Mdoub_END_NAMESPACE


79 #ifde
__USE_GNU


81 
__MATHDECL
 (,
scos
,,

82 (
_Mdoub_
 
__x
, _Mdoub_ *
__sx
, _Mdoub_ *
__cosx
));

85 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_ISOC99


86 
__BEGIN_NAMESPACE_C99


88 
__MATHCALL
 (
acosh
,, (
_Mdoub_
 
__x
));

90 
__MATHCALL
 (
ash
,, (
_Mdoub_
 
__x
));

92 
__MATHCALL
 (
h
,, (
_Mdoub_
 
__x
));

93 
	g__END_NAMESPACE_C99


98 
_Mdoub_BEGIN_NAMESPACE


100 
__MATHCALL
 (
exp
,, (
_Mdoub_
 
__x
));

103 
__MATHCALL
 (
exp
,, (
_Mdoub_
 
__x
, *
__expڒt
));

106 
__MATHCALL
 (
ldexp
,, (
_Mdoub_
 
__x
, 
__expڒt
));

109 
__MATHCALL
 (
log
,, (
_Mdoub_
 
__x
));

112 
__MATHCALL
 (
log10
,, (
_Mdoub_
 
__x
));

115 
__MATHCALL
 (
modf
,, (
_Mdoub_
 
__x
, _Mdoub_ *
__
)
__nnu
 ((2));

116 
	g_Mdoub_END_NAMESPACE


118 #ifde
__USE_GNU


120 
__MATHCALL
 (
exp10
,, (
_Mdoub_
 
__x
));

122 
__MATHCALL
 (
pow10
,, (
_Mdoub_
 
__x
));

125 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_ISOC99


126 
__BEGIN_NAMESPACE_C99


128 
__MATHCALL
 (
expm1
,, (
_Mdoub_
 
__x
));

131 
__MATHCALL
 (
log1p
,, (
_Mdoub_
 
__x
));

134 
__MATHCALL
 (
logb
,, (
_Mdoub_
 
__x
));

135 
	g__END_NAMESPACE_C99


138 #ifde
__USE_ISOC99


139 
__BEGIN_NAMESPACE_C99


141 
__MATHCALL
 (
exp2
,, (
_Mdoub_
 
__x
));

144 
__MATHCALL
 (
log2
,, (
_Mdoub_
 
__x
));

145 
	g__END_NAMESPACE_C99


151 
_Mdoub_BEGIN_NAMESPACE


153 
__MATHCALL
 (
pow
,, (
_Mdoub_
 
__x
, _Mdoub_ 
__y
));

156 
__MATHCALL
 (
sq
,, (
_Mdoub_
 
__x
));

157 
	g_Mdoub_END_NAMESPACE


159 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN
 || defed 
__USE_ISOC99


160 
__BEGIN_NAMESPACE_C99


162 
__MATHCALL
 (
hyp
,, (
_Mdoub_
 
__x
, _Mdoub_ 
__y
));

163 
	g__END_NAMESPACE_C99


166 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_ISOC99


167 
__BEGIN_NAMESPACE_C99


169 
__MATHCALL
 (
cb
,, (
_Mdoub_
 
__x
));

170 
	g__END_NAMESPACE_C99


176 
_Mdoub_BEGIN_NAMESPACE


178 
__MATHCALLX
 (

,, (
_Mdoub_
 
__x
), (
__cڡ__
));

181 
__MATHCALLX
 (
bs
,, (
_Mdoub_
 
__x
), (
__cڡ__
));

184 
__MATHCALLX
 (
o
,, (
_Mdoub_
 
__x
), (
__cڡ__
));

187 
__MATHCALL
 (
fmod
,, (
_Mdoub_
 
__x
, _Mdoub_ 
__y
));

192 
__MATHDECL_1
 (,
__isf
,, (
_Mdoub_
 
__vue
)
__ibu__
 ((
__cڡ__
));

195 
__MATHDECL_1
 (,
__fe
,, (
_Mdoub_
 
__vue
)
__ibu__
 ((
__cڡ__
));

196 
	g_Mdoub_END_NAMESPACE


198 #ifde
__USE_MISC


201 
__MATHDECL_1
 (,
isf
,, (
_Mdoub_
 
__vue
)
__ibu__
 ((
__cڡ__
));

204 
__MATHDECL_1
 (,
fe
,, (
_Mdoub_
 
__vue
)
__ibu__
 ((
__cڡ__
));

207 
__MATHCALL
 (
dm
,, (
_Mdoub_
 
__x
, _Mdoub_ 
__y
));

211 
__MATHCALL
 (
signifind
,, (
_Mdoub_
 
__x
));

214 #i
defed
 
__USE_MISC
 || defed 
__USE_ISOC99


215 
__BEGIN_NAMESPACE_C99


217 
__MATHCALLX
 (
cysign
,, (
_Mdoub_
 
__x
, _Mdoub_ 
__y
), (
__cڡ__
));

218 
	g__END_NAMESPACE_C99


221 #ifde
__USE_ISOC99


222 
__BEGIN_NAMESPACE_C99


224 
__MATHCALLX
 (
n
,, (cڡ *
__gb
), (
__cڡ__
));

225 
	g__END_NAMESPACE_C99


230 
__MATHDECL_1
 (,
__i
,, (
_Mdoub_
 
__vue
)
__ibu__
 ((
__cڡ__
));

232 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN


234 
__MATHDECL_1
 (,
i
,, (
_Mdoub_
 
__vue
)
__ibu__
 ((
__cڡ__
));

237 
__MATHCALL
 (
j0
,, (
_Mdoub_
));

238 
__MATHCALL
 (
j1
,, (
_Mdoub_
));

239 
__MATHCALL
 (
jn
,, (, 
_Mdoub_
));

240 
__MATHCALL
 (
y0
,, (
_Mdoub_
));

241 
__MATHCALL
 (
y1
,, (
_Mdoub_
));

242 
__MATHCALL
 (
yn
,, (, 
_Mdoub_
));

246 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN
 || defed 
__USE_ISOC99


247 
__BEGIN_NAMESPACE_C99


249 
__MATHCALL
 (
f
,, (
_Mdoub_
));

250 
__MATHCALL
 (
fc
,, (
_Mdoub_
));

251 
__MATHCALL
 (
lgamma
,, (
_Mdoub_
));

252 
	g__END_NAMESPACE_C99


255 #ifde
__USE_ISOC99


256 
__BEGIN_NAMESPACE_C99


258 
__MATHCALL
 (
tgamma
,, (
_Mdoub_
));

259 
	g__END_NAMESPACE_C99


262 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN


264 
__MATHCALL
 (
gamma
,, (
_Mdoub_
));

267 #ifde
__USE_MISC


271 
__MATHCALL
 (
lgamma
,
_r
, (
_Mdoub_
, *
__signgamp
));

275 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_ISOC99


276 
__BEGIN_NAMESPACE_C99


279 
__MATHCALL
 (
rt
,, (
_Mdoub_
 
__x
));

282 
__MATHCALLX
 (
x
,, (
_Mdoub_
 
__x
, _Mdoub_ 
__y
), (
__cڡ__
));

283 #i
defed
 
__USE_ISOC99
 && !defed 
__LDBL_COMPAT


284 
__MATHCALLX
 (
xowd
,, (
_Mdoub_
 
__x
, 
__y
), (
__cڡ__
));

288 
__MATHCALL
 (
mad
,, (
_Mdoub_
 
__x
, _Mdoub_ 
__y
));

290 #i
defed
 
__USE_MISC
 || defed 
__USE_ISOC99


292 
__MATHCALL
 (
slbn
,, (
_Mdoub_
 
__x
, 
__n
));

296 
__MATHDECL
 (,
ogb
,, (
_Mdoub_
 
__x
));

299 #ifde
__USE_ISOC99


301 
__MATHCALL
 (
slb
,, (
_Mdoub_
 
__x
, 
__n
));

305 
__MATHCALL
 (
ìbyt
,, (
_Mdoub_
 
__x
));

309 
__MATHCALLX
 (
round
,, (
_Mdoub_
 
__x
), (
__cڡ__
));

313 
__MATHCALLX
 (
unc
,, (
_Mdoub_
 
__x
), (
__cڡ__
));

318 
__MATHCALL
 (
mquo
,, (
_Mdoub_
 
__x
, _Mdoub_ 
__y
, *
__quo
));

325 
__MATHDECL
 (,
̚t
,, (
_Mdoub_
 
__x
));

326 
__exnsi__


327 
__MATHDECL
 (,
rt
,, (
_Mdoub_
 
__x
));

331 
__MATHDECL
 (,
ound
,, (
_Mdoub_
 
__x
));

332 
__exnsi__


333 
__MATHDECL
 (,
round
,, (
_Mdoub_
 
__x
));

337 
__MATHCALL
 (
fdim
,, (
_Mdoub_
 
__x
, _Mdoub_ 
__y
));

340 
__MATHCALLX
 (
fmax
,, (
_Mdoub_
 
__x
, _Mdoub_ 
__y
), (
__cڡ__
));

343 
__MATHCALLX
 (
fm
,, (
_Mdoub_
 
__x
, _Mdoub_ 
__y
), (
__cڡ__
));

347 
__MATHDECL_1
 (, 
__assify
,, (
_Mdoub_
 
__vue
))

348 
__ibu__
 ((
__cڡ__
));

351 
__MATHDECL_1
 (, 
__signb
,, (
_Mdoub_
 
__vue
))

352 
__ibu__
 ((
__cڡ__
));

356 
__MATHCALL
 (
fma
,, (
_Mdoub_
 
__x
, _Mdoub_ 
__y
, _Mdoub_ 
__z
));

359 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_ISOC99


360 
	g__END_NAMESPACE_C99


363 #ifde
__USE_GNU


365 
__MATHDECL_1
 (, 
__issiglg
,, (
_Mdoub_
 
__vue
))

366 
__ibu__
 ((
__cڡ__
));

369 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN_EXTENDED


371 
__MATHCALL
 (
slb
,, (
_Mdoub_
 
__x
, _Mdoub_ 
__n
));

	@/usr/include/bits/mathdef.h

18 #i!
defed
 
_MATH_H
 && !defed 
_COMPLEX_H


22 #i
defed
 
__USE_ISOC99
 && defed 
_MATH_H
 && !defed 
_MATH_H_MATHDEF


23 
	#_MATH_H_MATHDEF
 1

	)

25 #i
defed
 
__x86_64__
 || (defed 
__FLT_EVAL_METHOD__
 && __FLT_EVAL_METHOD__ == 0)

28 
	tt_t
;

29 
	tdoub_t
;

35 
	tt_t
;

37 
	tdoub_t
;

42 
	#FP_ILOGB0
 (-2147483647 - 1)

	)

43 
	#FP_ILOGBNAN
 (-2147483647 - 1)

	)

47 #i
__FP_FAST_FMA


48 
	#FP_FAST_FMA
 1

	)

51 #i
__FP_FAST_FMAF


52 
	#FP_FAST_FMAF
 1

	)

55 #i
__FP_FAST_FMAL


56 
	#FP_FAST_FMAL
 1

	)

	@/usr/include/bits/mathinline.h

19 #ide
_MATH_H


23 #ide
__ex_ways_le


24 
	#__MATH_INLINE
 
__le


	)

26 
	#__MATH_INLINE
 
__ex_ways_le


	)

30 #i
defed
 
__USE_ISOC99
 && defed 
__GNUC__
 && __GNUC__ >= 2

32 #i!
__GNUC_PREREQ
 (2,97)

37 #unde
isg


38 #unde
isgequ


39 #unde
iess


40 #unde
iesqu


41 #unde
iessg


42 #unde
isunded


43 #ifde
__i686__


46 
	#isg
(
x
, 
y
) \

47 ({ 
__su
; \

48 
	`__asm__
 ("fucomip %%st(1), %%st; seta %%al" \

49 : "" (
__su
: "u" (
y
), "t" (
x
) : "cc", "st"); \

50 
__su
; })

	)

51 
	#isgequ
(
x
, 
y
) \

52 ({ 
__su
; \

53 
	`__asm__
 ("fucomip %%st(1), %%st; setae %%al" \

54 : "" (
__su
: "u" (
y
), "t" (
x
) : "cc", "st"); \

55 
__su
; })

	)

57 
	#iess
(
x
, 
y
) \

58 ({ 
__su
; \

59 
	`__asm__
 ("fucomip %%st(1), %%st; seta %%al" \

60 : "" (
__su
: "u" (
x
), "t" (
y
) : "cc", "st"); \

61 
__su
; })

	)

63 
	#iesqu
(
x
, 
y
) \

64 ({ 
__su
; \

65 
	`__asm__
 ("fucomip %%st(1), %%st; setae %%al" \

66 : "" (
__su
: "u" (
x
), "t" (
y
) : "cc", "st"); \

67 
__su
; })

	)

69 
	#iessg
(
x
, 
y
) \

70 ({ 
__su
; \

71 
	`__asm__
 ("fucomip %%st(1), %%st; setne %%al" \

72 : "" (
__su
: "u" (
y
), "t" (
x
) : "cc", "st"); \

73 
__su
; })

	)

75 
	#isunded
(
x
, 
y
) \

76 ({ 
__su
; \

77 
	`__asm__
 ("fucomip %%st(1), %%st; setp %%al" \

78 : "" (
__su
: "u" (
y
), "t" (
x
) : "cc", "st"); \

79 
__su
; })

	)

82 
	#isg
(
x
, 
y
) \

83 ({ 
__su
; \

84 
	`__asm__
 ("fucompp; fnstsw;estb $0x45, %%ah; setz %%al" \

85 : "" (
__su
: "u" (
y
), "t" (
x
) : "cc", "st", "st(1)"); \

86 
__su
; })

	)

88 
	#isgequ
(
x
, 
y
) \

89 ({ 
__su
; \

90 
	`__asm__
 ("fucompp; fnstsw;estb $0x05, %%ah; setz %%al" \

91 : "" (
__su
: "u" (
y
), "t" (
x
) : "cc", "st", "st(1)"); \

92 
__su
; })

	)

94 
	#iess
(
x
, 
y
) \

95 ({ 
__su
; \

96 
	`__asm__
 ("fucompp; fnstsw;estb $0x45, %%ah; setz %%al" \

97 : "" (
__su
: "u" (
x
), "t" (
y
) : "cc", "st", "st(1)"); \

98 
__su
; })

	)

100 
	#iesqu
(
x
, 
y
) \

101 ({ 
__su
; \

102 
	`__asm__
 ("fucompp; fnstsw;estb $0x05, %%ah; setz %%al" \

103 : "" (
__su
: "u" (
x
), "t" (
y
) : "cc", "st", "st(1)"); \

104 
__su
; })

	)

106 
	#iessg
(
x
, 
y
) \

107 ({ 
__su
; \

108 
	`__asm__
 ("fucompp; fnstsw;estb $0x44, %%ah; setz %%al" \

109 : "" (
__su
: "u" (
y
), "t" (
x
) : "cc", "st", "st(1)"); \

110 
__su
; })

	)

112 
	#isunded
(
x
, 
y
) \

113 ({ 
__su
; \

114 
	`__asm__
 ("fucompp; fnstsw; sahf; setp %%al" \

115 : "" (
__su
: "u" (
y
), "t" (
x
) : "cc", "st", "st(1)"); \

116 
__su
; })

	)

122 #i
__GNUC_PREREQ
 (2, 8)

123 
__BEGIN_NAMESPACE_C99


126 
__MATH_INLINE
 

127 
__NTH
 (
	$__signbf
 (
__x
))

129 #ifde
__SSE2_MATH__


130 
__m
;

131 
	`__asm
 ("pmovmskb %1, %0" : "" (
__m
: "x" (
__x
));

132  (
__m
 & 0x8) != 0;

134 
__exnsi__
 uni { 
__f
; 
__i
; } 
__u
 = { __f: 
__x
 };

135  
__u
.
__i
 < 0;

137 
	}
}

138 
__MATH_INLINE
 

139 
__NTH
 (
	$__signb
 (
__x
))

141 #ifde
__SSE2_MATH__


142 
__m
;

143 
	`__asm
 ("pmovmskb %1, %0" : "" (
__m
: "x" (
__x
));

144  (
__m
 & 0x80) != 0;

146 
__exnsi__
 uni { 
__d
; 
__i
[2]; } 
__u
 = { __d: 
__x
 };

147  
__u
.
__i
[1] < 0;

149 
	}
}

150 
__MATH_INLINE
 

151 
__NTH
 (
	$__signbl
 (
__x
))

153 
__exnsi__
 uni { 
__l
; 
__i
[3]; } 
__u
 = { __l: 
__x
 };

154  (
__u
.
__i
[2] & 0x8000) != 0;

155 
	}
}

157 
	g__END_NAMESPACE_C99


164 #i
__GNUC_PREREQ
 (2, 8)

165 #i!
__GNUC_PREREQ
 (3, 4&& !
defed
 
__NO_MATH_INLINES
 \

166 && 
defed
 
	g__OPTIMIZE__


170 #ifde
__USE_ISOC99


171 
	g__BEGIN_NAMESPACE_C99


174 #ifde
__SSE_MATH__


175 
__MATH_INLINE
 

176 
__NTH
 (
	$̚tf
 (
__x
))

178 
__s
;

183 
__asm
 
	`__vީe__
 ("cvtss2s%1, %0" : "" (
__s
: "xm" (
__x
));

184  
__s
;

185 
	}
}

187 #ifde
__SSE2_MATH__


188 
__MATH_INLINE
 

189 
__NTH
 (
	$̚t
 (
__x
))

191 
__s
;

196 
__asm
 
	`__vީe__
 ("cvtsd2s%1, %0" : "" (
__s
: "xm" (
__x
));

197  
__s
;

198 
	}
}

200 #ifde
__x86_64__


201 
__exnsi__


202 
__MATH_INLINE
 

203 
__NTH
 (
	$rtf
 (
__x
))

205 
__s
;

210 
__asm
 
	`__vީe__
 ("cvtss2s%1, %0" : "" (
__s
: "xm" (
__x
));

211  
__s
;

212 
	}
}

213 
__exnsi__


214 
__MATH_INLINE
 

215 
__NTH
 (
	$rt
 (
__x
))

217 
__s
;

222 
__asm
 
	`__vީe__
 ("cvtsd2s%1, %0" : "" (
__s
: "xm" (
__x
));

223  
__s
;

224 
	}
}

227 #i
defed
 
__FINITE_MATH_ONLY__
 && __FINITE_MATH_ONLY__ > 0 \

228 && 
defed
 
__SSE2_MATH__


230 
__MATH_INLINE
 

231 
__NTH
 (
	$fmaxf
 (
__x
, 
__y
))

233 #ifde
__AVX__


234 
__s
;

235 
	`__asm
 ("vmaxs%2, %1, %0" : "=x" (
__s
: "x" (
x
), "xm" (
__y
));

236  
__s
;

238 
	`__asm
 ("maxs%1, %0" : "+x" (
__x
: "xm" (
__y
));

239  
__x
;

241 
	}
}

242 
__MATH_INLINE
 

243 
__NTH
 (
	$fmax
 (
__x
, 
__y
))

245 #ifde
__AVX__


246 
__s
;

247 
	`__asm
 ("vmaxsd %2, %1, %0" : "=x" (
__s
: "x" (
x
), "xm" (
__y
));

248  
__s
;

250 
	`__asm
 ("maxsd %1, %0" : "+x" (
__x
: "xm" (
__y
));

251  
__x
;

253 
	}
}

256 
__MATH_INLINE
 

257 
__NTH
 (
	$fmf
 (
__x
, 
__y
))

259 #ifde
__AVX__


260 
__s
;

261 
	`__asm
 ("vms%2, %1, %0" : "=x" (
__s
: "x" (
x
), "xm" (
__y
));

262  
__s
;

264 
	`__asm
 ("ms%1, %0" : "+x" (
__x
: "xm" (
__y
));

265  
__x
;

267 
	}
}

268 
__MATH_INLINE
 

269 
__NTH
 (
	$fm
 (
__x
, 
__y
))

271 #ifde
__AVX__


272 
__s
;

273 
	`__asm
 ("vmsd %2, %1, %0" : "=x" (
__s
: "x" (
x
), "xm" (
__y
));

274  
__s
;

276 
	`__asm
 ("msd %1, %0" : "+x" (
__x
: "xm" (
__y
));

277  
__x
;

279 
	}
}

282 
	g__END_NAMESPACE_C99


285 #i
defed
 
__SSE4_1__
 && defed 
__SSE2_MATH__


286 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_ISOC99


287 
__BEGIN_NAMESPACE_C99


290 
__MATH_INLINE
 

291 
__NTH
 (
	$rt
 (
__x
))

293 
__s
;

298 
__asm
 
	`__vީe__
 ("roundsd $4, %1, %0" : "=x" (
__s
: "xm" (
__x
));

299  
__s
;

300 
	}
}

301 
__MATH_INLINE
 

302 
__NTH
 (
	$rtf
 (
__x
))

304 
__s
;

309 
__asm
 
	`__vީe__
 ("rounds$4, %1, %0" : "=x" (
__s
: "xm" (
__x
));

310  
__s
;

311 
	}
}

313 #ifde
__USE_ISOC99


315 
__MATH_INLINE
 

316 
__NTH
 (
	$ìbyt
 (
__x
))

318 
__s
;

323 
__asm
 
	`__vީe__
 ("roundsd $0xc, %1, %0" : "=x" (
__s
: "xm" (
__x
));

324  
__s
;

325 
	}
}

326 
__MATH_INLINE
 

327 
__NTH
 (
	$ìbytf
 (
__x
))

329 
__s
;

334 
__asm
 
	`__vީe__
 ("rounds$0xc, %1, %0" : "=x" (
__s
: "xm" (
__x
));

335  
__s
;

336 
	}
}

339 
	g__END_NAMESPACE_C99


342 
__BEGIN_NAMESPACE_STD


344 
__MATH_INLINE
 

345 
__NTH
 (
	$
 (
__x
))

347 
__s
;

348 
	`__asm
 ("roundsd $2, %1, %0" : "=x" (
__s
: "xm" (
__x
));

349  
__s
;

350 
	}
}

351 
__END_NAMESPACE_STD


353 
__BEGIN_NAMESPACE_C99


354 
__MATH_INLINE
 

355 
__NTH
 (
	$f
 (
__x
))

357 
__s
;

358 
	`__asm
 ("rounds$2, %1, %0" : "=x" (
__s
: "xm" (
__x
));

359  
__s
;

360 
	}
}

361 
__END_NAMESPACE_C99


363 
__BEGIN_NAMESPACE_STD


365 
__MATH_INLINE
 

366 
__NTH
 (
	$o
 (
__x
))

368 
__s
;

369 
	`__asm
 ("roundsd $1, %1, %0" : "=x" (
__s
: "xm" (
__x
));

370  
__s
;

371 
	}
}

372 
__END_NAMESPACE_STD


374 
__BEGIN_NAMESPACE_C99


375 
__MATH_INLINE
 

376 
__NTH
 (
	$of
 (
__x
))

378 
__s
;

379 
	`__asm
 ("rounds$1, %1, %0" : "=x" (
__s
: "xm" (
__x
));

380  
__s
;

381 
	}
}

382 
	g__END_NAMESPACE_C99


387 #ide
__SSE2_MATH__


388 #i((!
defed
 
__NO_MATH_INLINES
 || defed 
__LIBC_INTERNAL_MATH_INLINES
) \

389 && 
defed
 
	g__OPTIMIZE__
)

393 #unde
mh_rhdlg


402 #i
defed
 
__USE_MISC
 || defed 
__USE_ISOC99


403 
	#__le_mh
(
func
, 

) \

404 
	`__le_mh_
 (, 
func
, 

) \

405 
	`__le_mh_
 (, 
	`__CONCAT
(
func
,
f
), 

) \

406 
	`__le_mh_
 (, 
	`__CONCAT
(
func
,
l
), 

)

	)

407 
	#__le_mhNP
(
func
, 

) \

408 
	`__le_mhNP_
 (, 
func
, 

) \

409 
	`__le_mhNP_
 (, 
	`__CONCAT
(
func
,
f
), 

) \

410 
	`__le_mhNP_
 (, 
	`__CONCAT
(
func
,
l
), 

)

	)

412 
	#__le_mh
(
func
, 

) \

413 
	`__le_mh_
 (, 
func
, 

)

	)

414 
	#__le_mhNP
(
func
, 

) \

415 
	`__le_mhNP_
 (, 
func
, 

)

	)

418 
	#__le_mh_
(
t_ty
, 
func
, 

) \

419 
	`__le_mh_de_
 (
t_ty
, 
func
, 

, "0" (
__x
))

	)

420 
	#__le_mhNP_
(
t_ty
, 
func
, 

) \

421 
	`__le_mh_deNP_
 (
t_ty
, 
func
, 

, "0" (
__x
))

	)

424 #i
defed
 
__USE_MISC
 || defed 
__USE_ISOC99


425 
	#__le_mh_de
(
func
, 

, 
ms
...) \

426 
	`__le_mh_de_
 (, 
func
, 

, 
ms
) \

427 
	`__le_mh_de_
 (, 
	`__CONCAT
(
func
,
f
), 

, 
ms
) \

428 
	`__le_mh_de_
 (, 
	`__CONCAT
(
func
,
l
), 

, 
ms
)

	)

429 
	#__le_mh_deNP
(
func
, 

, 
ms
...) \

430 
	`__le_mh_deNP_
 (, 
func
, 

, 
ms
) \

431 
	`__le_mh_deNP_
 (, 
	`__CONCAT
(
func
,
f
), 

, 
ms
) \

432 
	`__le_mh_deNP_
 (, 
	`__CONCAT
(
func
,
l
), 

, 
ms
)

	)

434 
	#__le_mh_de
(
func
, 

, 
ms
...) \

435 
	`__le_mh_de_
 (, 
func
, 

, 
ms
)

	)

436 
	#__le_mh_deNP
(
func
, 

, 
ms
...) \

437 
	`__le_mh_deNP_
 (, 
func
, 

, 
ms
)

	)

440 
	#__le_mh_de_
(
t_ty
, 
func
, 

, 
ms
...) \

441 
__MATH_INLINE
 
t_ty
 
	`func
 (t_ty
__THROW
; \

442 
	`__le_mh_deNP_
 (
t_ty
, 
func
, 

, 
ms
)

	)

444 
	#__le_mh_deNP_
(
t_ty
, 
func
, 

, 
ms
...) \

445 
__MATH_INLINE
 
t_ty
 
	`__NTH
 (
	`func
 (t_ty 
__x
)) \

447 
t_ty
 
__su
; \

448 
__asm
 
	`__vީe__
 (

 : "" (
__su
: 
ms
); \

449  
__su
; \

450 }

	)

453 #i
defed
 
__USE_MISC
 || defed 
__USE_ISOC99


454 
	#__le_mhcode
(
func
, 
g
, 
code
) \

455 
	`__le_mhcode_
 (, 
func
, 
g
, 
code
) \

456 
	`__le_mhcode_
 (, 
	`__CONCAT
(
func
,
f
), 
g
, 
code
) \

457 
	`__le_mhcode_
 (, 
	`__CONCAT
(
func
,
l
), 
g
, 
code
)

	)

458 
	#__le_mhcodeNP
(
func
, 
g
, 
code
) \

459 
	`__le_mhcodeNP_
 (, 
func
, 
g
, 
code
) \

460 
	`__le_mhcodeNP_
 (, 
	`__CONCAT
(
func
,
f
), 
g
, 
code
) \

461 
	`__le_mhcodeNP_
 (, 
	`__CONCAT
(
func
,
l
), 
g
, 
code
)

	)

462 
	#__le_mhcode2
(
func
, 
g1
, 
g2
, 
code
) \

463 
	`__le_mhcode2_
 (, 
func
, 
g1
, 
g2
, 
code
) \

464 
	`__le_mhcode2_
 (, 
	`__CONCAT
(
func
,
f
), 
g1
, 
g2
, 
code
) \

465 
	`__le_mhcode2_
 (, 
	`__CONCAT
(
func
,
l
), 
g1
, 
g2
, 
code
)

	)

466 
	#__le_mhcodeNP2
(
func
, 
g1
, 
g2
, 
code
) \

467 
	`__le_mhcodeNP2_
 (, 
func
, 
g1
, 
g2
, 
code
) \

468 
	`__le_mhcodeNP2_
 (, 
	`__CONCAT
(
func
,
f
), 
g1
, 
g2
, 
code
) \

469 
	`__le_mhcodeNP2_
 (, 
	`__CONCAT
(
func
,
l
), 
g1
, 
g2
, 
code
)

	)

470 
	#__le_mhcode3
(
func
, 
g1
, 
g2
, 
g3
, 
code
) \

471 
	`__le_mhcode3_
 (, 
func
, 
g1
, 
g2
, 
g3
, 
code
) \

472 
	`__le_mhcode3_
 (, 
	`__CONCAT
(
func
,
f
), 
g1
, 
g2
, 
g3
, 
code
) \

473 
	`__le_mhcode3_
 (, 
	`__CONCAT
(
func
,
l
), 
g1
, 
g2
, 
g3
, 
code
)

	)

474 
	#__le_mhcodeNP3
(
func
, 
g1
, 
g2
, 
g3
, 
code
) \

475 
	`__le_mhcodeNP3_
 (, 
func
, 
g1
, 
g2
, 
g3
, 
code
) \

476 
	`__le_mhcodeNP3_
 (, 
	`__CONCAT
(
func
,
f
), 
g1
, 
g2
, 
g3
, 
code
) \

477 
	`__le_mhcodeNP3_
 (, 
	`__CONCAT
(
func
,
l
), 
g1
, 
g2
, 
g3
, 
code
)

	)

479 
	#__le_mhcode
(
func
, 
g
, 
code
) \

480 
	`__le_mhcode_
 (, 
func
, (
g
), 
code
)

	)

481 
	#__le_mhcodeNP
(
func
, 
g
, 
code
) \

482 
	`__le_mhcodeNP_
 (, 
func
, (
g
), 
code
)

	)

483 
	#__le_mhcode2
(
func
, 
g1
, 
g2
, 
code
) \

484 
	`__le_mhcode2_
 (, 
func
, 
g1
, 
g2
, 
code
)

	)

485 
	#__le_mhcodeNP2
(
func
, 
g1
, 
g2
, 
code
) \

486 
	`__le_mhcodeNP2_
 (, 
func
, 
g1
, 
g2
, 
code
)

	)

487 
	#__le_mhcode3
(
func
, 
g1
, 
g2
, 
g3
, 
code
) \

488 
	`__le_mhcode3_
 (, 
func
, 
g1
, 
g2
, 
g3
, 
code
)

	)

489 
	#__le_mhcodeNP3
(
func
, 
g1
, 
g2
, 
g3
, 
code
) \

490 
	`__le_mhcodeNP3_
 (, 
func
, 
g1
, 
g2
, 
g3
, 
code
)

	)

493 
	#__le_mhcode_
(
t_ty
, 
func
, 
g
, 
code
) \

494 
__MATH_INLINE
 
t_ty
 
	`func
 (t_ty
__THROW
; \

495 
	`__le_mhcodeNP_
(
t_ty
, 
func
, 
g
, 
code
)

	)

497 
	#__le_mhcodeNP_
(
t_ty
, 
func
, 
g
, 
code
) \

498 
__MATH_INLINE
 
t_ty
 
	`__NTH
 (
	`func
 (t_ty 
g
)) \

500 
code
; \

501 }

	)

504 
	#__le_mhcode2_
(
t_ty
, 
func
, 
g1
, 
g2
, 
code
) \

505 
__MATH_INLINE
 
t_ty
 
	`func
 (t_ty, flt_ty
__THROW
; \

506 
	`__le_mhcodeNP2_
 (
t_ty
, 
func
, 
g1
, 
g2
, 
code
)

	)

508 
	#__le_mhcodeNP2_
(
t_ty
, 
func
, 
g1
, 
g2
, 
code
) \

509 
__MATH_INLINE
 
t_ty
 
	`__NTH
 (
	`func
 (t_ty 
g1
, flt_ty 
g2
)) \

511 
code
; \

512 }

	)

514 
	#__le_mhcode3_
(
t_ty
, 
func
, 
g1
, 
g2
, 
g3
, 
code
) \

515 
__MATH_INLINE
 
t_ty
 
	`func
 (t_ty, flt_ty, flt_ty
__THROW
; \

516 
	`__le_mhcodeNP3_
(
t_ty
, 
func
, 
g1
, 
g2
, 
g3
, 
code
)

	)

518 
	#__le_mhcodeNP3_
(
t_ty
, 
func
, 
g1
, 
g2
, 
g3
, 
code
) \

519 
__MATH_INLINE
 
t_ty
 
	`__NTH
 (
	`func
 (t_ty 
g1
, flt_ty 
g2
, \

520 
t_ty
 
g3
)) \

522 
code
; \

523 }

	)

527 #i!
defed
 
__NO_MATH_INLINES
 && defed 
__OPTIMIZE__


531 #ifde
__FAST_MATH__


532 #ifde
__USE_GNU


533 
	#__scos_code
 \

534 
__co
; \

535 
__sr
; \

536 
__swtmp
; \

537 
__asm
 
__vީe__
 \

552 : "" (
__co
), "=u" (
__sr
), "" (
__swtmp
: "0" (
__x
)); \

553 *
__sx
 = 
__sr
; \

554 *
__cosx
 = 
__co


	)

556 
__MATH_INLINE
 

557 
__NTH
 (
	$__scos
 (
__x
, *
__sx
, *
__cosx
))

559 
__scos_code
;

560 
	}
}

562 
__MATH_INLINE
 

563 
__NTH
 (
	$__scosf
 (
__x
, *
__sx
, *
__cosx
))

565 
__scos_code
;

566 
	}
}

568 
__MATH_INLINE
 

569 
__NTH
 (
	$__sco
 (
__x
, *
__sx
, *
__cosx
))

571 
__scos_code
;

572 
	}
}

579 #i
__GNUC_PREREQ
 (3, 5)

580 
	#__expm1_code
 \

581 
__mp
; \

582 
__mp
 = 
	`__but_expm1l
 (
__x
); \

583  
__mp
 ? __m: 
__x


	)

585 
	#__expm1_code
 \

586 
__vue
; \

587 
__expڒt
; \

588 
__mp
; \

589 
__asm
 
__vީe__
 \

598 : "" (
__vue
), "=u" (
__expڒt
: "0" (
__x
)); \

599 
__asm
 
__vީe__
 \

601 : "" (
__mp
: "0" (1.0), "u" (
__expڒt
)); \

602 
__mp
 -= 1.0; \

603 
__mp
 +
__vue
; \

604  
__mp
 ? __m: 
__x


	)

606 
	$__le_mhcodeNP_
 (, 
__expm1l
, 
__x
, 
__expm1_code
)

608 #i
	`__GNUC_PREREQ
 (3, 4)

609 
	`__le_mhcodeNP_
 (, 
__ex
, 
__x
,  
	$__but_ex
 (
__x
))

611 
	#__exp_code
 \

612 
__vue
; \

613 
__expڒt
; \

614 
__asm
 
__vީe__
 \

622 : "" (
__vue
), "=u" (
__expڒt
: "0" (
__x
)); \

623 
__vue
 += 1.0; \

624 
__asm
 
__vީe__
 \

626 : "" (
__vue
: "0" (__vue), "u" (
__expڒt
)); \

627  
__vue


	)

628 
	$__le_mhcodeNP
 (
exp
, 
__x
, 
__exp_code
)

629 
	$__le_mhcodeNP_
 (, 
__ex
, 
__x
, 
__exp_code
)

633 #i!
	`__GNUC_PREREQ
 (3, 5)

634 
	`__le_mhcodeNP
 (
n
, 
__x
, \

635 
__vue
; \

636 
__vue2
 
	`__ibu__
 ((
__unud__
)); \

637 
__asm
 
__vީe__
 \

639 : "" (
__vue2
), "=u" (
__vue
: "0" (
__x
)); \

640  
__vue
)

645 #i
	`__GNUC_PREREQ
 (3, 4)

646 
	`__le_mhcodeNP2_
 (, 
__2l
, 
__y
, 
__x
,

647  
	$__but_2l
 (
__y
, 
__x
))

649 
	#__2_code
 \

650 
__vue
; \

651 
__asm
 
__vީe__
 \

653 : "" (
__vue
: "0" (
__x
), "u" (
__y
) : "st(1)"); \

654  
__vue


	)

655 #ifde
__FAST_MATH__


656 
	$__le_mhcodeNP2
 (
2
, 
__y
, 
__x
, 
__2_code
)

658 
	$__le_mhcodeNP2_
 (, 
__2l
, 
__y
, 
__x
, 
__2_code
)

662 #i
defed
 
__FAST_MATH__
 && !
	`__GNUC_PREREQ
 (3, 5)

663 
	`__le_mhcodeNP2
 (
fmod
, 
__x
, 
__y
, \

664 
__vue
; \

665 
__asm
 
__vީe__
 \

670 : "" (
__vue
: "0" (
__x
), "u" (
__y
) : "ax", "cc"); \

671  
__vue
)

675 #ifde
__FAST_MATH__


676 #i!
	`__GNUC_PREREQ
 (3,3)

677 
	`__le_mhNP
 (
sq
, "fsqrt")

678 
	`__le_mhNP_
 (, 
__sql
, "fsqrt")

679 
	#__libc_sql
(
n

	`__sql
 (n)

	)

681 
	#__libc_sql
(
n

	`__but_sql
 (n)

	)

685 #i
	`__GNUC_PREREQ
 (2, 8)

686 
	`__le_mhcodeNP_
 (, 
bs
, 
__x
,  
	$__but_bs
 (
__x
))

687 #i
defed
 
__USE_MISC
 || defed 
__USE_ISOC99


688 
	`__le_mhcodeNP_
 (, 
bsf
, 
__x
,  
	$__but_bsf
 (
__x
))

689 
	`__le_mhcodeNP_
 (, 
b
, 
__x
,  
	$__but_b
 (
__x
))

691 
	`__le_mhcodeNP_
 (, 
__b
, 
__x
,  
	$__but_b
 (
__x
))

693 
	`__le_mh
 (
bs
, "fabs")

694 
	`__le_mh_
 (, 
__b
, "fabs")

697 #ifde
__FAST_MATH__


698 #i!
	`__GNUC_PREREQ
 (3, 4)

700 
	`__le_mhNP
 (
s
, "fsin")

702 
	`__le_mhNP
 (
cos
, "fcos")

704 
	`__le_mh_deNP
 (
log
, "d2; fxch; fyl2x", "0" (
__x
) : "st(1)")

707 #i!
	`__GNUC_PREREQ
 (3, 5)

708 
	`__le_mh_deNP
 (
log10
, "dlg2; fxch; fyl2x", "0" (
__x
) : "st(1)")

710 
	`__le_mhcodeNP
 (
as
, 
__x
,  
	`__2l
 (__x, 
	`__libc_sql
 (1.0 - __x * __x)))

711 
	`__le_mhcodeNP
 (
acos
, 
__x
,  
	`__2l
 (
	`__libc_sql
 (1.0 - __x * __x), __x))

714 #i!
	`__GNUC_PREREQ
 (3, 4)

715 
	`__le_mh_deNP
 (

, "d1; fn", "0" (
__x
) : "st(1)")

719 
	`__le_mhcode_
 (, 
__sgn1l
, 
__x
, \

720 
__exnsi__
 uni { 
__xld
; 
__xi
[3]; } 
__n
 = \

721 { 
__xld
: 
__x
 
	}
}; \

722 
	g__n
.
	g__xi
[2] = (
__n
.
__xi
[2] & 0x8000) | 0x3fff; \

723 
	g__n
.
	g__xi
[1] = 0x80000000; \

724 
	g__n
.
	g__xi
[0] = 0; \

725  
	g__n
.
	g__xld
)

728 #ifde
__FAST_MATH__


730 
__le_mhcodeNP
 (
sh
, 
__x
, \

731 
__exm1
 = 
__expm1l
 (
__b
 (
__x
)); \

732  0.5 * (
__exm1
 / (__exm1 + 1.0+ __exm1* 
	$__sgn1l
 (
__x
))

734 
	`__le_mhcodeNP
 (
cosh
, 
__x
, \

735 
__ex
 = 
	`__ex
 (
__x
); \

736  0.5 * (
__ex
 + 1.0 / __ex))

738 
	`__le_mhcodeNP
 (
nh
, 
__x
, \

739 
__exm1
 = 
	`__expm1l
 (-
	`__b
 (
__x
 + __x)); \

740  
__exm1
 / (__exm1 + 2.0* 
	`__sgn1l
 (-
__x
))

743 
	`__le_mhcodeNP
 (
o
, 
__x
, \

744 
__vue
; \

745 
__igne
; \

746 
__cw
; \

747 
__cwtmp
; \

748 
__asm
 
	`__vީe
 ("fnstcw %3\n\t" \

756 : "" (
__vue
), "=&q" (
__igne
), "=m" (
__cwtmp
), \

757 "=m" (
__cw
) \

758 : "0" (
__x
)); \

759  
__vue
)

761 
	`__le_mhcodeNP
 (

, 
__x
, \

762 
__vue
; \

763 
__igne
; \

764 
__cw
; \

765 
__cwtmp
; \

766 
__asm
 
	`__vީe
 ("fnstcw %3\n\t" \

774 : "" (
__vue
), "=&q" (
__igne
), "=m" (
__cwtmp
), \

775 "=m" (
__cw
) \

776 : "0" (
__x
)); \

777  
__vue
)

779 #ifde
__FAST_MATH__


780 
	#__ldexp_code
 \

781 
__vue
; \

782 
__asm
 
__vީe__
 \

784 : "" (
__vue
: "0" (
__x
), "u" ((
__y
)); \

785  
__vue


	)

787 
__MATH_INLINE
 

788 
	`__NTH
 (
	$ldexp
 (
__x
, 
__y
))

790 
__ldexp_code
;

791 
	}
}

796 #i
defed
 
__USE_ISOC99
 || defed 
__USE_MISC


798 #ifde
__FAST_MATH__


799 
	$__le_mhcodeNP
 (
expm1
, 
__x
, 
__expm1_code
)

803 
	#__M_SQRT2
 1.41421356237309504880L

	)

805 #i!
	`__GNUC_PREREQ
 (3, 5)

806 
	`__le_mhcodeNP
 (
log1p
, 
__x
, \

807 
__vue
; \

808 i(
	`__b
 (
__x
>1.0 - 0.5 * 
__M_SQRT2
) \

809 
__vue
 = 
	`logl
 (1.0 + 
__x
); \

811 
__asm
 
__vީe__
 \

815 : "" (
__vue
: "0" (
__x
) : "st(1)"); \

816  
__vue
)

821 
	`__le_mhcodeNP
 (
ash
, 
__x
, \

822 
__y
 = 
	`__b
 (
__x
); \

823  (
	`log1
 (
__y
 * __y / (
	`__libc_sql
 (__y * __y + 1.0) + 1.0) + __y) \

824 * 
	$__sgn1l
 (
__x
)))

826 
	`__le_mhcodeNP
 (
acosh
, 
__x
, \

827  
	`logl
 (
__x
 + 
	`__libc_sql
 (__x - 1.0) * __libc_sqrtl (__x + 1.0)))

829 
	`__le_mhcodeNP
 (
h
, 
__x
, \

830 
__y
 = 
	`__b
 (
__x
); \

831  -0.5 * 
	`log1
 (-(
__y
 + __y/ (1.0 + __y)* 
	$__sgn1l
 (
__x
))

834 
	`__le_mhcodeNP2
 (
hyp
, 
__x
, 
__y
,

835  
	`__libc_sql
 (
__x
 * __x + 
__y
 * __y))

837 #i!
	`__GNUC_PREREQ
 (3, 5)

838 
	`__le_mhcodeNP
(
logb
, 
__x
, \

839 
__vue
; \

840 
__junk
; \

841 
__asm
 
__vީe__
 \

843 : "" (
__junk
), "=u" (
__vue
: "0" (
__x
)); \

844  
__vue
)

850 #ifde
__USE_ISOC99


851 #ifde
__FAST_MATH__


853 #i!
	`__GNUC_PREREQ
 (3, 5)

854 
	`__le_mh_deNP
 (
log2
, "d1; fxch; fyl2x", "0" (
__x
) : "st(1)")

857 
__MATH_INLINE
 

858 
	`__NTH
 (
	$ldexpf
 (
__x
, 
__y
))

860 
__ldexp_code
;

861 
	}
}

863 
__MATH_INLINE
 

864 
__NTH
 (
	$ldex
 (
__x
, 
__y
))

866 
__ldexp_code
;

867 
	}
}

869 
__le_mhNP
 (
rt
, "frndint")

872 
	#__̚t_code
 \

873 
__̚es
; \

874 
__asm__
 
__vީe__
 \

876 : "=m" (
__̚es
: "t" (
__x
) : "st"); \

877  
__̚es


	)

878 
__MATH_INLINE
 

879 
__NTH
 (
	$̚tf
 (
__x
))

881 
__̚t_code
;

882 
	}
}

883 
__MATH_INLINE
 

884 
__NTH
 (
	$̚t
 (
__x
))

886 
__̚t_code
;

887 
	}
}

888 
__MATH_INLINE
 

889 
__NTH
 (
	$̚
 (
__x
))

891 
__̚t_code
;

892 
	}
}

893 #unde
__̚t_code


895 
	#__rt_code
 \

896 
__res
; \

897 
__asm__
 
__vީe__
 \

899 : "=m" (
__res
: "t" (
__x
) : "st"); \

900  
__res


	)

901 
__exnsi__


902 
__MATH_INLINE
 

903 
__NTH
 (
	$rtf
 (
__x
))

905 
__rt_code
;

906 
	}
}

907 
__exnsi__


908 
__MATH_INLINE
 

909 
__NTH
 (
	$rt
 (
__x
))

911 
__rt_code
;

912 
	}
}

913 
__exnsi__


914 
__MATH_INLINE
 

915 
__NTH
 (
	$r
 (
__x
))

917 
__rt_code
;

918 
	}
}

919 #unde
__rt_code


924 #ifde
__USE_MISC


926 #i
defed
 
__FAST_MATH__
 && !
__GNUC_PREREQ
 (3, 5)

927 
__le_mhcodeNP2
 (
dm
, 
__x
, 
__y
, \

928 
__vue
; \

929 
__obbed
; \

930 
__asm
 
__vީe__
 \

935 : "" (
__vue
), "=&a" (
__obbed
: "0" (
__x
), "u" (
__y
) : "cc"); \

936  
__vue
)

941 
__MATH_INLINE
 

942 
__NTH
 (
	$__fe
 (
__x
))

944  (
__exnsi__


945 (((((uni { 
__d
; 
__i
[2]; }{__d: 
__x
}).__i[1]

947 
	}
}

952 #unde
__2_code


953 #ifde
__FAST_MATH__


954 #unde
__expm1_code


955 #unde
__exp_code


956 #unde
__scos_code


963 #ifde
__LIBC_INTERNAL_MATH_INLINES


964 
__le_mh
 (
__754_sq
, "fsqrt")

965 
__le_mhcode2
 (
__754_2
, 
__y
, 
__x
,

966 
__vue
;

967 
__asm
 
__vީe__
 ("fpatan\n\t"

968 : "" (
__vue
)

969 : "0" (
__x
), "u" (
__y
) : "st(1)");

970  
__vue
;)

	@/usr/include/bits/mman.h

19 #ide
_SYS_MMAN_H


27 #ifde
__USE_MISC


28 
	#MAP_32BIT
 0x40

	)

32 #ifde
__USE_MISC


33 
	#MAP_GROWSDOWN
 0x00100

	)

34 
	#MAP_DENYWRITE
 0x00800

	)

35 
	#MAP_EXECUTABLE
 0x01000

	)

36 
	#MAP_LOCKED
 0x02000

	)

37 
	#MAP_NORESERVE
 0x04000

	)

38 
	#MAP_POPULATE
 0x08000

	)

39 
	#MAP_NONBLOCK
 0x10000

	)

40 
	#MAP_STACK
 0x20000

	)

41 
	#MAP_HUGETLB
 0x40000

	)

45 
	~<bs/mm-lux.h
>

	@/usr/include/bits/nan.h

19 #ide
_MATH_H


26 #i
__GNUC_PREREQ
(3,3)

28 
	#NAN
 (
	`__but_nf
 (""))

	)

30 #i
defed
 
__GNUC__


32 
	#NAN
 \

33 (
__exnsi__
 \

34 ((uni { 
__l
 
	`__ibu__
 ((
	`__mode__
 (
__SI__
))); 
__d
; }) \

35 { 
__l
: 0x7fc00000UL }).
__d
)

	)

39 
	~<dn.h
>

41 #i
__BYTE_ORDER
 =
__BIG_ENDIAN


42 
	#__qn_bys
 { 0x7f, 0xc0, 0, 0 }

	)

44 #i
__BYTE_ORDER
 =
__LITTLE_ENDIAN


45 
	#__qn_bys
 { 0, 0, 0xc0, 0x7}

	)

48 uni { 
	m__c
[4]; 
	m__d
; } 
__qn_uni


49 
__ibu__
 ((
__unud__
){ 
__qn_bys
 };

50 
	#NAN
 (
__qn_uni
.
__d
)

	)

	@/usr/include/bits/param.h

19 #ide
_SYS_PARAM_H


23 #ide
ARG_MAX


24 
	#__undef_ARG_MAX


	)

27 
	~<lux/lims.h
>

28 
	~<lux/m.h
>

31 #ifde
__undef_ARG_MAX


32 #unde
ARG_MAX


33 #unde
__undef_ARG_MAX


36 
	#MAXSYMLINKS
 20

	)

41 
	#NOFILE
 256

	)

42 
	#NCARGS
 131072

	)

	@/usr/include/bits/posix1_lim.h

24 #idef 
_BITS_POSIX1_LIM_H


25 
	#_BITS_POSIX1_LIM_H
 1

	)

31 
	#_POSIX_AIO_LISTIO_MAX
 2

	)

34 
	#_POSIX_AIO_MAX
 1

	)

37 
	#_POSIX_ARG_MAX
 4096

	)

40 #ifde
__USE_XOPEN2K


41 
	#_POSIX_CHILD_MAX
 25

	)

43 
	#_POSIX_CHILD_MAX
 6

	)

47 
	#_POSIX_DELAYTIMER_MAX
 32

	)

51 
	#_POSIX_HOST_NAME_MAX
 255

	)

54 
	#_POSIX_LINK_MAX
 8

	)

57 
	#_POSIX_LOGIN_NAME_MAX
 9

	)

60 
	#_POSIX_MAX_CANON
 255

	)

64 
	#_POSIX_MAX_INPUT
 255

	)

67 
	#_POSIX_MQ_OPEN_MAX
 8

	)

70 
	#_POSIX_MQ_PRIO_MAX
 32

	)

73 
	#_POSIX_NAME_MAX
 14

	)

76 #ifde
__USE_XOPEN2K


77 
	#_POSIX_NGROUPS_MAX
 8

	)

79 
	#_POSIX_NGROUPS_MAX
 0

	)

83 #ifde
__USE_XOPEN2K


84 
	#_POSIX_OPEN_MAX
 20

	)

86 
	#_POSIX_OPEN_MAX
 16

	)

89 #i!
defed
 
__USE_XOPEN2K
 || defed 
__USE_GNU


92 
	#_POSIX_FD_SETSIZE
 
_POSIX_OPEN_MAX


	)

96 
	#_POSIX_PATH_MAX
 256

	)

99 
	#_POSIX_PIPE_BUF
 512

	)

103 
	#_POSIX_RE_DUP_MAX
 255

	)

106 
	#_POSIX_RTSIG_MAX
 8

	)

109 
	#_POSIX_SEM_NSEMS_MAX
 256

	)

112 
	#_POSIX_SEM_VALUE_MAX
 32767

	)

115 
	#_POSIX_SIGQUEUE_MAX
 32

	)

118 
	#_POSIX_SSIZE_MAX
 32767

	)

121 
	#_POSIX_STREAM_MAX
 8

	)

124 
	#_POSIX_SYMLINK_MAX
 255

	)

128 
	#_POSIX_SYMLOOP_MAX
 8

	)

131 
	#_POSIX_TIMER_MAX
 32

	)

134 
	#_POSIX_TTY_NAME_MAX
 9

	)

137 #ifde
__USE_XOPEN2K


138 
	#_POSIX_TZNAME_MAX
 6

	)

140 
	#_POSIX_TZNAME_MAX
 3

	)

143 #i!
defed
 
__USE_XOPEN2K
 || defed 
__USE_GNU


145 
	#_POSIX_QLIMIT
 1

	)

149 
	#_POSIX_HIWAT
 
_POSIX_PIPE_BUF


	)

152 
	#_POSIX_UIO_MAXIOV
 16

	)

156 
	#_POSIX_CLOCKRES_MIN
 20000000

	)

160 
	~<bs/lol_lim.h
>

163 #idef 
SSIZE_MAX


164 
	#SSIZE_MAX
 
LONG_MAX


	)

171 #idef 
NGROUPS_MAX


172 
	#NGROUPS_MAX
 8

	)

	@/usr/include/bits/posix2_lim.h

22 #idef 
_BITS_POSIX2_LIM_H


23 
	#_BITS_POSIX2_LIM_H
 1

	)

27 
	#_POSIX2_BC_BASE_MAX
 99

	)

30 
	#_POSIX2_BC_DIM_MAX
 2048

	)

33 
	#_POSIX2_BC_SCALE_MAX
 99

	)

36 
	#_POSIX2_BC_STRING_MAX
 1000

	)

40 
	#_POSIX2_COLL_WEIGHTS_MAX
 2

	)

44 
	#_POSIX2_EXPR_NEST_MAX
 32

	)

47 
	#_POSIX2_LINE_MAX
 2048

	)

51 
	#_POSIX2_RE_DUP_MAX
 255

	)

55 
	#_POSIX2_CHARCLASS_NAME_MAX
 14

	)

62 #idef 
BC_BASE_MAX


63 
	#BC_BASE_MAX
 
_POSIX2_BC_BASE_MAX


	)

65 #idef 
BC_DIM_MAX


66 
	#BC_DIM_MAX
 
_POSIX2_BC_DIM_MAX


	)

68 #idef 
BC_SCALE_MAX


69 
	#BC_SCALE_MAX
 
_POSIX2_BC_SCALE_MAX


	)

71 #idef 
BC_STRING_MAX


72 
	#BC_STRING_MAX
 
_POSIX2_BC_STRING_MAX


	)

74 #idef 
COLL_WEIGHTS_MAX


75 
	#COLL_WEIGHTS_MAX
 255

	)

77 #idef 
EXPR_NEST_MAX


78 
	#EXPR_NEST_MAX
 
_POSIX2_EXPR_NEST_MAX


	)

80 #idef 
LINE_MAX


81 
	#LINE_MAX
 
_POSIX2_LINE_MAX


	)

83 #idef 
CHARCLASS_NAME_MAX


84 
	#CHARCLASS_NAME_MAX
 2048

	)

88 
	#RE_DUP_MAX
 (0x7fff)

	)

	@/usr/include/bits/posix_opt.h

19 #idef 
_BITS_POSIX_OPT_H


20 
	#_BITS_POSIX_OPT_H
 1

	)

23 
	#_POSIX_JOB_CONTROL
 1

	)

26 
	#_POSIX_SAVED_IDS
 1

	)

29 
	#_POSIX_PRIORITY_SCHEDULING
 200809L

	)

32 
	#_POSIX_SYNCHRONIZED_IO
 200809L

	)

35 
	#_POSIX_FSYNC
 200809L

	)

38 
	#_POSIX_MAPPED_FILES
 200809L

	)

41 
	#_POSIX_MEMLOCK
 200809L

	)

44 
	#_POSIX_MEMLOCK_RANGE
 200809L

	)

47 
	#_POSIX_MEMORY_PROTECTION
 200809L

	)

50 
	#_POSIX_CHOWN_RESTRICTED
 0

	)

54 
	#_POSIX_VDISABLE
 '\0'

	)

57 
	#_POSIX_NO_TRUNC
 1

	)

60 
	#_XOPEN_REALTIME
 1

	)

63 
	#_XOPEN_REALTIME_THREADS
 1

	)

66 
	#_XOPEN_SHM
 1

	)

69 
	#_POSIX_THREADS
 200809L

	)

72 
	#_POSIX_REENTRANT_FUNCTIONS
 1

	)

73 
	#_POSIX_THREAD_SAFE_FUNCTIONS
 200809L

	)

76 
	#_POSIX_THREAD_PRIORITY_SCHEDULING
 200809L

	)

79 
	#_POSIX_THREAD_ATTR_STACKSIZE
 200809L

	)

82 
	#_POSIX_THREAD_ATTR_STACKADDR
 200809L

	)

85 
	#_POSIX_THREAD_PRIO_INHERIT
 200809L

	)

89 
	#_POSIX_THREAD_PRIO_PROTECT
 200809L

	)

91 #ifde
__USE_XOPEN2K8


93 
	#_POSIX_THREAD_ROBUST_PRIO_INHERIT
 200809L

	)

96 
	#_POSIX_THREAD_ROBUST_PRIO_PROTECT
 -1

	)

100 
	#_POSIX_SEMAPHORES
 200809L

	)

103 
	#_POSIX_REALTIME_SIGNALS
 200809L

	)

106 
	#_POSIX_ASYNCHRONOUS_IO
 200809L

	)

107 
	#_POSIX_ASYNC_IO
 1

	)

109 
	#_LFS_ASYNCHRONOUS_IO
 1

	)

111 
	#_POSIX_PRIORITIZED_IO
 200809L

	)

114 
	#_LFS64_ASYNCHRONOUS_IO
 1

	)

117 
	#_LFS_LARGEFILE
 1

	)

118 
	#_LFS64_LARGEFILE
 1

	)

119 
	#_LFS64_STDIO
 1

	)

122 
	#_POSIX_SHARED_MEMORY_OBJECTS
 200809L

	)

125 
	#_POSIX_CPUTIME
 0

	)

128 
	#_POSIX_THREAD_CPUTIME
 0

	)

131 
	#_POSIX_REGEXP
 1

	)

134 
	#_POSIX_READER_WRITER_LOCKS
 200809L

	)

137 
	#_POSIX_SHELL
 1

	)

140 
	#_POSIX_TIMEOUTS
 200809L

	)

143 
	#_POSIX_SPIN_LOCKS
 200809L

	)

146 
	#_POSIX_SPAWN
 200809L

	)

149 
	#_POSIX_TIMERS
 200809L

	)

152 
	#_POSIX_BARRIERS
 200809L

	)

155 
	#_POSIX_MESSAGE_PASSING
 200809L

	)

158 
	#_POSIX_THREAD_PROCESS_SHARED
 200809L

	)

161 
	#_POSIX_MONOTONIC_CLOCK
 0

	)

164 
	#_POSIX_CLOCK_SELECTION
 200809L

	)

167 
	#_POSIX_ADVISORY_INFO
 200809L

	)

170 
	#_POSIX_IPV6
 200809L

	)

173 
	#_POSIX_RAW_SOCKETS
 200809L

	)

176 
	#_POSIX2_CHAR_TERM
 200809L

	)

179 
	#_POSIX_SPORADIC_SERVER
 -1

	)

180 
	#_POSIX_THREAD_SPORADIC_SERVER
 -1

	)

183 
	#_POSIX_TRACE
 -1

	)

184 
	#_POSIX_TRACE_EVENT_FILTER
 -1

	)

185 
	#_POSIX_TRACE_INHERIT
 -1

	)

186 
	#_POSIX_TRACE_LOG
 -1

	)

189 
	#_POSIX_TYPED_MEMORY_OBJECTS
 -1

	)

	@/usr/include/bits/pthreadtypes.h

18 #ide
_BITS_PTHREADTYPES_H


19 
	#_BITS_PTHREADTYPES_H
 1

	)

21 
	~<bs/wdsize.h
>

23 #ifde
__x86_64__


24 #i
__WORDSIZE
 == 64

25 
	#__SIZEOF_PTHREAD_ATTR_T
 56

	)

26 
	#__SIZEOF_PTHREAD_MUTEX_T
 40

	)

27 
	#__SIZEOF_PTHREAD_MUTEXATTR_T
 4

	)

28 
	#__SIZEOF_PTHREAD_COND_T
 48

	)

29 
	#__SIZEOF_PTHREAD_CONDATTR_T
 4

	)

30 
	#__SIZEOF_PTHREAD_RWLOCK_T
 56

	)

31 
	#__SIZEOF_PTHREAD_RWLOCKATTR_T
 8

	)

32 
	#__SIZEOF_PTHREAD_BARRIER_T
 32

	)

33 
	#__SIZEOF_PTHREAD_BARRIERATTR_T
 4

	)

35 
	#__SIZEOF_PTHREAD_ATTR_T
 32

	)

36 
	#__SIZEOF_PTHREAD_MUTEX_T
 32

	)

37 
	#__SIZEOF_PTHREAD_MUTEXATTR_T
 4

	)

38 
	#__SIZEOF_PTHREAD_COND_T
 48

	)

39 
	#__SIZEOF_PTHREAD_CONDATTR_T
 4

	)

40 
	#__SIZEOF_PTHREAD_RWLOCK_T
 44

	)

41 
	#__SIZEOF_PTHREAD_RWLOCKATTR_T
 8

	)

42 
	#__SIZEOF_PTHREAD_BARRIER_T
 20

	)

43 
	#__SIZEOF_PTHREAD_BARRIERATTR_T
 4

	)

46 
	#__SIZEOF_PTHREAD_ATTR_T
 36

	)

47 
	#__SIZEOF_PTHREAD_MUTEX_T
 24

	)

48 
	#__SIZEOF_PTHREAD_MUTEXATTR_T
 4

	)

49 
	#__SIZEOF_PTHREAD_COND_T
 48

	)

50 
	#__SIZEOF_PTHREAD_CONDATTR_T
 4

	)

51 
	#__SIZEOF_PTHREAD_RWLOCK_T
 32

	)

52 
	#__SIZEOF_PTHREAD_RWLOCKATTR_T
 8

	)

53 
	#__SIZEOF_PTHREAD_BARRIER_T
 20

	)

54 
	#__SIZEOF_PTHREAD_BARRIERATTR_T
 4

	)

60 
	thad_t
;

63 
	uhad__t


65 
	m__size
[
__SIZEOF_PTHREAD_ATTR_T
];

66 
	m__ign
;

68 #ide
__have_had__t


69 
had__t
 
	thad__t
;

70 
	#__have_had__t
 1

	)

74 #ifde
__x86_64__


75 
	s__had__li


77 
__had__li
 *
	m__ev
;

78 
__had__li
 *
	m__xt
;

79 } 
	t__had_li_t
;

81 
	s__had__i


83 
__had__i
 *
	m__xt
;

84 } 
	t__had_i_t
;

92 
	s__had_mux_s


94 
	m__lock
;

95 
	m__cou
;

96 
	m__owr
;

97 #ifde
__x86_64__


98 
	m__nurs
;

102 
	m__kd
;

103 #ifde
__x86_64__


104 
	m__s
;

105 
	m__isi
;

106 
__had_li_t
 
	m__li
;

107 
	#__PTHREAD_MUTEX_HAVE_PREV
 1

	)

108 
	#__PTHREAD_MUTEX_HAVE_ELISION
 1

	)

110 
	m__nurs
;

111 
__exnsi__
 union

115 
	m__es
;

116 
	m__isi
;

117 
	#__s
 
d
.
__es


	)

118 
	#__isi
 
d
.
__isi


	)

119 
	#__PTHREAD_MUTEX_HAVE_ELISION
 2

	)

120 } 
	md
;

121 
__had_i_t
 
	m__li
;

124 } 
	m__da
;

125 
	m__size
[
__SIZEOF_PTHREAD_MUTEX_T
];

126 
	m__ign
;

127 } 
	thad_mux_t
;

131 
	m__size
[
__SIZEOF_PTHREAD_MUTEXATTR_T
];

132 
	m__ign
;

133 } 
	thad_mux_t
;

142 
	m__lock
;

143 
	m__fux
;

144 
__exnsi__
 
	m__tٮ_q
;

145 
__exnsi__
 
	m__wakeup_q
;

146 
__exnsi__
 
	m__wok_q
;

147 *
	m__mux
;

148 
	m__nwas
;

149 
	m__brd_q
;

150 } 
	m__da
;

151 
	m__size
[
__SIZEOF_PTHREAD_COND_T
];

152 
__exnsi__
 
	m__ign
;

153 } 
	thad_cd_t
;

157 
	m__size
[
__SIZEOF_PTHREAD_CONDATTR_T
];

158 
	m__ign
;

159 } 
	thad_cd_t
;

163 
	thad_key_t
;

167 
	thad__t
;

170 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K


175 #ifde
__x86_64__


178 
	m__lock
;

179 
	m___ads
;

180 
	m__ads_wakeup
;

181 
	m__wr_wakeup
;

182 
	m___ads_queued
;

183 
	m___wrs_queued
;

184 
	m__wr
;

185 
	m__shed
;

186 
	m__d1
;

187 
	m__d2
;

190 
	m__ags
;

191 
	#__PTHREAD_RWLOCK_INT_FLAGS_SHARED
 1

	)

192 } 
	m__da
;

196 
	m__lock
;

197 
	m___ads
;

198 
	m__ads_wakeup
;

199 
	m__wr_wakeup
;

200 
	m___ads_queued
;

201 
	m___wrs_queued
;

204 
	m__ags
;

205 
	m__shed
;

206 
	m__d1
;

207 
	m__d2
;

208 
	m__wr
;

209 } 
	m__da
;

211 
	m__size
[
__SIZEOF_PTHREAD_RWLOCK_T
];

212 
	m__ign
;

213 } 
	thad_rwlock_t
;

217 
	m__size
[
__SIZEOF_PTHREAD_RWLOCKATTR_T
];

218 
	m__ign
;

219 } 
	thad_rwlock_t
;

223 #ifde
__USE_XOPEN2K


225 vީ
	thad_lock_t
;

232 
	m__size
[
__SIZEOF_PTHREAD_BARRIER_T
];

233 
	m__ign
;

234 } 
	thad_brr_t
;

238 
	m__size
[
__SIZEOF_PTHREAD_BARRIERATTR_T
];

239 
	m__ign
;

240 } 
	thad_brr_t
;

244 #ide
__x86_64__


246 
	#__nup_f_ibu
 
	`__ibu__
 ((
	`__grm__
 (1)))

	)

	@/usr/include/bits/sched.h

20 #ide
__ed_schedm


22 #ide
_SCHED_H


28 
	#SCHED_OTHER
 0

	)

29 
	#SCHED_FIFO
 1

	)

30 
	#SCHED_RR
 2

	)

31 #ifde
__USE_GNU


32 
	#SCHED_BATCH
 3

	)

33 
	#SCHED_IDLE
 5

	)

35 
	#SCHED_RESET_ON_FORK
 0x40000000

	)

38 #ifde
__USE_GNU


40 
	#CSIGNAL
 0x000000f

	)

41 
	#CLONE_VM
 0x00000100

	)

42 
	#CLONE_FS
 0x00000200

	)

43 
	#CLONE_FILES
 0x00000400

	)

44 
	#CLONE_SIGHAND
 0x00000800

	)

45 
	#CLONE_PTRACE
 0x00002000

	)

46 
	#CLONE_VFORK
 0x00004000

	)

48 
	#CLONE_PARENT
 0x00008000

	)

50 
	#CLONE_THREAD
 0x00010000

	)

51 
	#CLONE_NEWNS
 0x00020000

	)

52 
	#CLONE_SYSVSEM
 0x00040000

	)

53 
	#CLONE_SETTLS
 0x00080000

	)

54 
	#CLONE_PARENT_SETTID
 0x00100000

	)

56 
	#CLONE_CHILD_CLEARTID
 0x00200000

	)

58 
	#CLONE_DETACHED
 0x00400000

	)

59 
	#CLONE_UNTRACED
 0x00800000

	)

61 
	#CLONE_CHILD_SETTID
 0x01000000

	)

63 
	#CLONE_NEWUTS
 0x04000000

	)

64 
	#CLONE_NEWIPC
 0x08000000

	)

65 
	#CLONE_NEWUSER
 0x10000000

	)

66 
	#CLONE_NEWPID
 0x20000000

	)

67 
	#CLONE_NEWNET
 0x40000000

	)

68 
	#CLONE_IO
 0x80000000

	)

72 
	ssched_m


74 
	m__sched_iܙy
;

77 
	g__BEGIN_DECLS


79 #ifde
__USE_GNU


81 
e
 ((*
__
(*
__g
), *
__chd_ack
,

82 
__ags
, *
__g
, ...
__THROW
;

85 
	$unshe
 (
__ags

__THROW
;

88 
	$sched_gu
 (
__THROW
;

91 
	$s
 (
__fd
, 
__ny

__THROW
;

95 
__END_DECLS


99 #i!
defed
 
__defed_schedm
 \

100 && (
defed
 
__ed_schedm
 || defed 
_SCHED_H
)

101 
	#__defed_schedm
 1

	)

103 
	s__sched_m


105 
__sched_iܙy
;

107 #unde
__ed_schedm


111 #i
defed
 
_SCHED_H
 && !defed 
__u_t_t_defed


112 
	#__u_t_t_defed


	)

114 
	#__CPU_SETSIZE
 1024

	)

115 
	#__NCPUBITS
 (8 *  (
__u_mask
))

	)

118 
	t__u_mask
;

121 
	#__CPUELT
(
u
((u/ 
__NCPUBITS
)

	)

122 
	#__CPUMASK
(
u
((
__u_mask
1 << ((u% 
__NCPUBITS
))

	)

127 
__u_mask
 
__bs
[
__CPU_SETSIZE
 / 
__NCPUBITS
];

128 } 
	tu_t_t
;

131 #i
	`__GNUC_PREREQ
 (2, 91)

132 
	#__CPU_ZERO_S
(
tsize
, 
u
) \

133 d
	`__but_memt
 (
u
, '\0', 
tsize
); 0)

	)

135 
	#__CPU_ZERO_S
(
tsize
, 
u
) \

137 
size_t
 
__i
; \

138 
size_t
 
__imax
 = (
tsize
/  (
__u_mask
); \

139 
__u_mask
 *
__bs
 = (
u
)->__bits; \

140 
__i
 = 0; __< 
__imax
; ++__i) \

141 
__bs
[
__i
] = 0; \

142 
	}
} 0)

	)

144 
	#__CPU_SET_S
(
u
, 
tsize
, 
u
) \

145 (
__exnsi__
 \

146 ({ 
size_t
 
__u
 = (
u
); \

147 
__u
 / 8 < (
tsize
) \

148 ? (((
__u_mask
 *((
u
)->
__bs
))[
	`__CPUELT
 (
__u
)] \

149 |
	`__CPUMASK
 (
__u
)) \

150 : 0; }))

	)

151 
	#__CPU_CLR_S
(
u
, 
tsize
, 
u
) \

152 (
__exnsi__
 \

153 ({ 
size_t
 
__u
 = (
u
); \

154 
__u
 / 8 < (
tsize
) \

155 ? (((
__u_mask
 *((
u
)->
__bs
))[
	`__CPUELT
 (
__u
)] \

156 &~
	`__CPUMASK
 (
__u
)) \

157 : 0; }))

	)

158 
	#__CPU_ISSET_S
(
u
, 
tsize
, 
u
) \

159 (
__exnsi__
 \

160 ({ 
size_t
 
__u
 = (
u
); \

161 
__u
 / 8 < (
tsize
) \

162 ? ((((cڡ 
__u_mask
 *((
u
)->
__bs
))[
	`__CPUELT
 (
__u
)] \

163 & 
	`__CPUMASK
 (
__u
))) != 0 \

164 : 0; }))

	)

166 
	#__CPU_COUNT_S
(
tsize
, 
u
) \

167 
	`__sched_ucou
 (
tsize
, 
u
)

	)

169 #i
__GNUC_PREREQ
 (2, 91)

170 
	#__CPU_EQUAL_S
(
tsize
, 
u1
, 
u2
) \

171 (
	`__but_memcmp
 (
u1
, 
u2
, 
tsize
=0)

	)

173 
	#__CPU_EQUAL_S
(
tsize
, 
u1
, 
u2
) \

174 (
__exnsi__
 \

175 ({ cڡ 
__u_mask
 *
__r1
 = (
u1
)->
__bs
; \

176 cڡ 
__u_mask
 *
__r2
 = (
u2
)->
__bs
; \

177 
size_t
 
__imax
 = (
tsize
/  (
__u_mask
); \

178 
size_t
 
__i
; \

179 
__i
 = 0; __< 
__imax
; ++__i) \

180 i(
__r1
[
__i
] !
__r2
[__i]) \

182 
__i
 =
__imax
; }))

	)

185 
	#__CPU_OP_S
(
tsize
, 
det
, 
ct1
, 
ct2
, 

) \

186 (
__exnsi__
 \

187 ({ 
u_t_t
 *
__de
 = (
det
); \

188 cڡ 
__u_mask
 *
__r1
 = (
ct1
)->
__bs
; \

189 cڡ 
__u_mask
 *
__r2
 = (
ct2
)->
__bs
; \

190 
size_t
 
__imax
 = (
tsize
/  (
__u_mask
); \

191 
size_t
 
__i
; \

192 
__i
 = 0; __< 
__imax
; ++__i) \

193 ((
__u_mask
 *
__de
->
__bs
)[
__i
] = 
__r1
[__i] 

 
__r2
[__i]; \

194 
__de
; }))

	)

196 
	#__CPU_ALLOC_SIZE
(
cou
) \

197 ((((
cou
+ 
__NCPUBITS
 - 1/ __NCPUBITS*  (
__u_mask
))

	)

198 
	#__CPU_ALLOC
(
cou

	`__sched_uloc
 (cou)

	)

199 
	#__CPU_FREE
(
ut

	`__sched_u
 (ut)

	)

201 
__BEGIN_DECLS


203 
	$__sched_ucou
 (
size_t
 
__tsize
, cڡ 
u_t_t
 *
__
)

204 
__THROW
;

205 
u_t_t
 *
	$__sched_uloc
 (
size_t
 
__cou

__THROW
 
__wur
;

206 
	$__sched_u
 (
u_t_t
 *
__t

__THROW
;

208 
__END_DECLS


	@/usr/include/bits/setjmp.h

19 #ide
_BITS_SETJMP_H


20 
	#_BITS_SETJMP_H
 1

	)

22 #i!
defed
 
_SETJMP_H
 && !defed 
_PTHREAD_H


26 
	~<bs/wdsize.h
>

28 #ide
_ASM


30 #i
__WORDSIZE
 == 64

31 
	t__jmp_buf
[8];

32 #i
defed
 
__x86_64__


33 
__exnsi__
 
	t__jmp_buf
[8];

35 
	t__jmp_buf
[6];

	@/usr/include/bits/sigaction.h

19 #ide
_SIGNAL_H


24 
	ssigai


27 #ifde
__USE_POSIX199309


31 
__sighdr_t
 
	m_hdr
;

33 (*
	m_sigai
(, 
	msigfo_t
 *, *);

35 
	m__sigai_hdr
;

36 
	#_hdr
 
__sigai_hdr
.
_hdr


	)

37 
	#_sigai
 
__sigai_hdr
.
_sigai


	)

39 
__sighdr_t
 
	m_hdr
;

43 
__sigt_t
 
	m_mask
;

46 
	m_ags
;

49 (*
	m_ܔ
) ();

53 
	#SA_NOCLDSTOP
 1

	)

54 
	#SA_NOCLDWAIT
 2

	)

55 
	#SA_SIGINFO
 4

	)

57 #i
defed
 
__USE_UNIX98
 || defed 
__USE_MISC


58 
	#SA_ONSTACK
 0x08000000

	)

60 #i
defed
 
__USE_UNIX98
 || defed 
__USE_MISC
 || defed 
__USE_XOPEN2K8


61 
	#SA_RESTART
 0x10000000

	)

62 
	#SA_NODEFER
 0x40000000

	)

64 
	#SA_RESETHAND
 0x80000000

	)

66 #ifde
__USE_MISC


67 
	#SA_INTERRUPT
 0x20000000

	)

70 
	#SA_NOMASK
 
SA_NODEFER


	)

71 
	#SA_ONESHOT
 
SA_RESETHAND


	)

72 
	#SA_STACK
 
SA_ONSTACK


	)

76 
	#SIG_BLOCK
 0

	)

77 
	#SIG_UNBLOCK
 1

	)

78 
	#SIG_SETMASK
 2

	)

	@/usr/include/bits/sigcontext.h

18 #ide
_BITS_SIGCONTEXT_H


19 
	#_BITS_SIGCONTEXT_H
 1

	)

21 #i!
defed
 
_SIGNAL_H
 && !defed 
_SYS_UCONTEXT_H


25 
	#FP_XSTATE_MAGIC1
 0x46505853U

	)

26 
	#FP_XSTATE_MAGIC2
 0x46505845U

	)

27 
	#FP_XSTATE_MAGIC2_SIZE
 (
FP_XSTATE_MAGIC2
)

	)

29 
	s_x_sw_bys


31 
__ut32_t
 
	mmagic1
;

32 
__ut32_t
 
	mexnded_size
;

33 
__ut64_t
 
	mxe_bv
;

34 
__ut32_t
 
	mxe_size
;

35 
__ut32_t
 
	mddg
[7];

38 
	s_g


40 
	msignifind
[4];

41 
	mexpڒt
;

44 
	s_xg


46 
	msignifind
[4];

47 
	mexpڒt
;

48 
	mddg
[3];

51 
	s_xmmg


53 
__ut32_t
 
	memt
[4];

58 #ide
__x86_64__


60 
	s_塩e


63 
__ut32_t
 
	mcw
;

64 
__ut32_t
 
	msw
;

65 
__ut32_t
 
	mg
;

66 
__ut32_t
 
	moff
;

67 
__ut32_t
 
	mcsl
;

68 
__ut32_t
 
	mdaoff
;

69 
__ut32_t
 
	mdal
;

70 
_g
 
	m_
[8];

71 
	mus
;

72 
	mmagic
;

75 
__ut32_t
 
	m_fx_v
[6];

76 
__ut32_t
 
	mmxc
;

77 
__ut32_t
 
	mrved
;

78 
_xg
 
	m_fx_
[8];

79 
_xmmg
 
	m_xmm
[8];

80 
__ut32_t
 
	mddg
[56];

83 #ide
sigcڋxt_ru


88 
	#sigcڋxt_ru
 
sigcڋxt


	)

91 
	#X86_FXSR_MAGIC
 0x0000

	)

93 
	ssigcڋxt


95 
	mgs
, 
	m__gsh
;

96 
	mfs
, 
	m__fsh
;

97 
	mes
, 
	m__esh
;

98 
	mds
, 
	m__dsh
;

99 
	medi
;

100 
	mesi
;

101 
	mebp
;

102 
	me
;

103 
	mebx
;

104 
	medx
;

105 
	mecx
;

106 
	mx
;

107 
	mno
;

108 
	mr
;

109 
	me
;

110 
	mcs
, 
	m__csh
;

111 
	meags
;

112 
	me__sigl
;

113 
	mss
, 
	m__ssh
;

114 
_塩e
 * 
	m塩e
;

115 
	mdmask
;

116 
	m2
;

121 
	s_塩e


124 
__ut16_t
 
	mcwd
;

125 
__ut16_t
 
	mswd
;

126 
__ut16_t
 
	mw
;

127 
__ut16_t
 
	mf
;

128 
__ut64_t
 
	mr
;

129 
__ut64_t
 
	mrdp
;

130 
__ut32_t
 
	mmxc
;

131 
__ut32_t
 
	mmx_mask
;

132 
_xg
 
	m_
[8];

133 
_xmmg
 
	m_xmm
[16];

134 
__ut32_t
 
	mddg
[24];

137 
	ssigcڋxt


139 
__ut64_t
 
	mr8
;

140 
__ut64_t
 
	mr9
;

141 
__ut64_t
 
	mr10
;

142 
__ut64_t
 
	mr11
;

143 
__ut64_t
 
	mr12
;

144 
__ut64_t
 
	mr13
;

145 
__ut64_t
 
	mr14
;

146 
__ut64_t
 
	mr15
;

147 
__ut64_t
 
	mrdi
;

148 
__ut64_t
 
	mrsi
;

149 
__ut64_t
 
	mrbp
;

150 
__ut64_t
 
	mrbx
;

151 
__ut64_t
 
	mrdx
;

152 
__ut64_t
 
	mx
;

153 
__ut64_t
 
	mrcx
;

154 
__ut64_t
 
	mr
;

155 
__ut64_t
 
	mr
;

156 
__ut64_t
 
	meags
;

157 
	mcs
;

158 
	mgs
;

159 
	mfs
;

160 
	m__d0
;

161 
__ut64_t
 
	mr
;

162 
__ut64_t
 
	mno
;

163 
__ut64_t
 
	mdmask
;

164 
__ut64_t
 
	m2
;

165 
__exnsi__
 union

167 
_塩e
 * 
	m塩e
;

168 
__ut64_t
 
	m__塩e_wd
;

170 
__ut64_t
 
	m__rved1
 [8];

175 
	s_xve_hdr


177 
__ut64_t
 
	mxe_bv
;

178 
__ut64_t
 
	mrved1
[2];

179 
__ut64_t
 
	mrved2
[5];

182 
	s_ymmh_e


184 
__ut32_t
 
	mymmh_a
[64];

187 
	s_xe


189 
_塩e
 
	m塩e
;

190 
_xve_hdr
 
	mxe_hdr
;

191 
_ymmh_e
 
	mymmh
;

	@/usr/include/bits/siginfo.h

19 #i!
defed
 
_SIGNAL_H
 && !defed 
__ed_sigfo_t
 \

20 && !
defed
 
	g__ed_sigevt_t


24 
	~<bs/wdsize.h
>

26 #i(!
defed
 
__have_sigv_t
 \

27 && (
defed
 
	g_SIGNAL_H
 || defed 
	g__ed_sigfo_t
 \

28 || 
defed
 
	g__ed_sigevt_t
))

29 
	#__have_sigv_t
 1

	)

32 
	usigv


34 
	msiv_t
;

35 *
	msiv_r
;

36 } 
	tsigv_t
;

39 #i(!
defed
 
__have_sigfo_t
 \

40 && (
defed
 
	g_SIGNAL_H
 || defed 
	g__ed_sigfo_t
))

41 
	#__have_sigfo_t
 1

	)

43 
	#__SI_MAX_SIZE
 128

	)

44 #i
__WORDSIZE
 == 64

45 
	#__SI_PAD_SIZE
 ((
__SI_MAX_SIZE
 /  ()- 4)

	)

47 
	#__SI_PAD_SIZE
 ((
__SI_MAX_SIZE
 /  ()- 3)

	)

50 #i
defed
 
__x86_64__
 && 
__WORDSIZE
 == 32

55 
__ock_t
 
	t__ibu__
 ((
	t__igd__
 (4))
	t__sigchld_ock_t
;

56 
	#__SI_ALIGNMENT
 
	`__ibu__
 ((
	`__igd__
 (8)))

	)

58 
__ock_t
 
	t__sigchld_ock_t
;

59 
	#__SI_ALIGNMENT


	)

64 
si_signo
;

65 
si_o
;

67 
si_code
;

71 
_d
[
__SI_PAD_SIZE
];

76 
__pid_t
 
si_pid
;

77 
__uid_t
 
si_uid
;

78 } 
_kl
;

83 
si_tid
;

84 
si_ovrun
;

85 
sigv_t
 
si_sigv
;

86 } 
_tim
;

91 
__pid_t
 
si_pid
;

92 
__uid_t
 
si_uid
;

93 
sigv_t
 
si_sigv
;

94 } 
_
;

99 
__pid_t
 
si_pid
;

100 
__uid_t
 
si_uid
;

101 
si_us
;

102 
__sigchld_ock_t
 
si_utime
;

103 
__sigchld_ock_t
 
si_ime
;

104 } 
_sigchld
;

109 *
si_addr
;

110 
si_addr_lsb
;

111 } 
_sigu
;

116 
si_bd
;

117 
si_fd
;

118 } 
_sigpl
;

123 *
__addr
;

124 
_sys
;

125 
_ch
;

126 } 
_sigsys
;

127 } 
_siflds
;

128 } 
	tsigfo_t
 
	t__SI_ALIGNMENT
;

132 
	#si_pid
 
_siflds
.
_kl
.
si_pid


	)

133 
	#si_uid
 
_siflds
.
_kl
.
si_uid


	)

134 
	#si_timid
 
_siflds
.
_tim
.
si_tid


	)

135 
	#si_ovrun
 
_siflds
.
_tim
.
si_ovrun


	)

136 
	#si_us
 
_siflds
.
_sigchld
.
si_us


	)

137 
	#si_utime
 
_siflds
.
_sigchld
.
si_utime


	)

138 
	#si_ime
 
_siflds
.
_sigchld
.
si_ime


	)

139 
	#si_vue
 
_siflds
.
_
.
si_sigv


	)

140 
	#si_t
 
_siflds
.
_
.
si_sigv
.
siv_t


	)

141 
	#si_r
 
_siflds
.
_
.
si_sigv
.
siv_r


	)

142 
	#si_addr
 
_siflds
.
_sigu
.
si_addr


	)

143 
	#si_addr_lsb
 
_siflds
.
_sigu
.
si_addr_lsb


	)

144 
	#si_bd
 
_siflds
.
_sigpl
.
si_bd


	)

145 
	#si_fd
 
_siflds
.
_sigpl
.
si_fd


	)

146 
	#si__addr
 
_siflds
.
_sigsys
.
__addr


	)

147 
	#si_sys
 
_siflds
.
_sigsys
.
_sys


	)

148 
	#si_ch
 
_siflds
.
_sigsys
.
_ch


	)

155 
SI_ASYNCNL
 = -60,

156 
	#SI_ASYNCNL
 
SI_ASYNCNL


	)

157 
SI_TKILL
 = -6,

158 
	#SI_TKILL
 
SI_TKILL


	)

159 
SI_SIGIO
,

160 
	#SI_SIGIO
 
SI_SIGIO


	)

161 
SI_ASYNCIO
,

162 
	#SI_ASYNCIO
 
SI_ASYNCIO


	)

163 
SI_MESGQ
,

164 
	#SI_MESGQ
 
SI_MESGQ


	)

165 
SI_TIMER
,

166 
	#SI_TIMER
 
SI_TIMER


	)

167 
SI_QUEUE
,

168 
	#SI_QUEUE
 
SI_QUEUE


	)

169 
SI_USER
,

170 
	#SI_USER
 
SI_USER


	)

171 
SI_KERNEL
 = 0x80

172 
	#SI_KERNEL
 
SI_KERNEL


	)

179 
ILL_ILLOPC
 = 1,

180 
	#ILL_ILLOPC
 
ILL_ILLOPC


	)

181 
ILL_ILLOPN
,

182 
	#ILL_ILLOPN
 
ILL_ILLOPN


	)

183 
ILL_ILLADR
,

184 
	#ILL_ILLADR
 
ILL_ILLADR


	)

185 
ILL_ILLTRP
,

186 
	#ILL_ILLTRP
 
ILL_ILLTRP


	)

187 
ILL_PRVOPC
,

188 
	#ILL_PRVOPC
 
ILL_PRVOPC


	)

189 
ILL_PRVREG
,

190 
	#ILL_PRVREG
 
ILL_PRVREG


	)

191 
ILL_COPROC
,

192 
	#ILL_COPROC
 
ILL_COPROC


	)

193 
ILL_BADSTK


194 
	#ILL_BADSTK
 
ILL_BADSTK


	)

200 
FPE_INTDIV
 = 1,

201 
	#FPE_INTDIV
 
FPE_INTDIV


	)

202 
FPE_INTOVF
,

203 
	#FPE_INTOVF
 
FPE_INTOVF


	)

204 
FPE_FLTDIV
,

205 
	#FPE_FLTDIV
 
FPE_FLTDIV


	)

206 
FPE_FLTOVF
,

207 
	#FPE_FLTOVF
 
FPE_FLTOVF


	)

208 
FPE_FLTUND
,

209 
	#FPE_FLTUND
 
FPE_FLTUND


	)

210 
FPE_FLTRES
,

211 
	#FPE_FLTRES
 
FPE_FLTRES


	)

212 
FPE_FLTINV
,

213 
	#FPE_FLTINV
 
FPE_FLTINV


	)

214 
FPE_FLTSUB


215 
	#FPE_FLTSUB
 
FPE_FLTSUB


	)

221 
SEGV_MAPERR
 = 1,

222 
	#SEGV_MAPERR
 
SEGV_MAPERR


	)

223 
SEGV_ACCERR


224 
	#SEGV_ACCERR
 
SEGV_ACCERR


	)

230 
BUS_ADRALN
 = 1,

231 
	#BUS_ADRALN
 
BUS_ADRALN


	)

232 
BUS_ADRERR
,

233 
	#BUS_ADRERR
 
BUS_ADRERR


	)

234 
BUS_OBJERR
,

235 
	#BUS_OBJERR
 
BUS_OBJERR


	)

236 
BUS_MCEERR_AR
,

237 
	#BUS_MCEERR_AR
 
BUS_MCEERR_AR


	)

238 
BUS_MCEERR_AO


239 
	#BUS_MCEERR_AO
 
BUS_MCEERR_AO


	)

245 
TRAP_BRKPT
 = 1,

246 
	#TRAP_BRKPT
 
TRAP_BRKPT


	)

247 
TRAP_TRACE


248 
	#TRAP_TRACE
 
TRAP_TRACE


	)

254 
CLD_EXITED
 = 1,

255 
	#CLD_EXITED
 
CLD_EXITED


	)

256 
CLD_KILLED
,

257 
	#CLD_KILLED
 
CLD_KILLED


	)

258 
CLD_DUMPED
,

259 
	#CLD_DUMPED
 
CLD_DUMPED


	)

260 
CLD_TRAPPED
,

261 
	#CLD_TRAPPED
 
CLD_TRAPPED


	)

262 
CLD_STOPPED
,

263 
	#CLD_STOPPED
 
CLD_STOPPED


	)

264 
CLD_CONTINUED


265 
	#CLD_CONTINUED
 
CLD_CONTINUED


	)

271 
POLL_IN
 = 1,

272 
	#POLL_IN
 
POLL_IN


	)

273 
POLL_OUT
,

274 
	#POLL_OUT
 
POLL_OUT


	)

275 
POLL_MSG
,

276 
	#POLL_MSG
 
POLL_MSG


	)

277 
POLL_ERR
,

278 
	#POLL_ERR
 
POLL_ERR


	)

279 
POLL_PRI
,

280 
	#POLL_PRI
 
POLL_PRI


	)

281 
POLL_HUP


282 
	#POLL_HUP
 
POLL_HUP


	)

285 #unde
__ed_sigfo_t


289 #i(
defed
 
_SIGNAL_H
 || defed 
__ed_sigevt_t
) \

290 && !
defed
 
__have_sigevt_t


291 
	#__have_sigevt_t
 1

	)

294 
	#__SIGEV_MAX_SIZE
 64

	)

295 #i
__WORDSIZE
 == 64

296 
	#__SIGEV_PAD_SIZE
 ((
__SIGEV_MAX_SIZE
 /  ()- 4)

	)

298 
	#__SIGEV_PAD_SIZE
 ((
__SIGEV_MAX_SIZE
 /  ()- 3)

	)

302 #ide
__have_had__t


303 
had__t
 
	thad__t
;

304 
	#__have_had__t
 1

	)

307 
	ssigevt


309 
sigv_t
 
sigev_vue
;

310 
sigev_signo
;

311 
sigev_nify
;

315 
_d
[
__SIGEV_PAD_SIZE
];

319 
__pid_t
 
_tid
;

323 (*
_funi
(
sigv_t
);

324 
had__t
 *
_ibu
;

325 } 
_sigev_thad
;

326 } 
_sigev_un
;

327 } 
	tsigevt_t
;

330 
	#sigev_nify_funi
 
_sigev_un
.
_sigev_thad
.
_funi


	)

331 
	#sigev_nify_ibus
 
_sigev_un
.
_sigev_thad
.
_ibu


	)

336 
SIGEV_SIGNAL
 = 0,

337 
	#SIGEV_SIGNAL
 
SIGEV_SIGNAL


	)

338 
SIGEV_NONE
,

339 
	#SIGEV_NONE
 
SIGEV_NONE


	)

340 
SIGEV_THREAD
,

341 
	#SIGEV_THREAD
 
SIGEV_THREAD


	)

343 
SIGEV_THREAD_ID
 = 4

344 
	#SIGEV_THREAD_ID
 
SIGEV_THREAD_ID


	)

	@/usr/include/bits/signum.h

19 #ifdef 
_SIGNAL_H


22 
	#SIG_ERR
 ((
__sighdr_t
-1

	)

23 
	#SIG_DFL
 ((
__sighdr_t
0

	)

24 
	#SIG_IGN
 ((
__sighdr_t
1

	)

26 #ifde
__USE_UNIX98


27 
	#SIG_HOLD
 ((
__sighdr_t
2

	)

32 
	#SIGHUP
 1

	)

33 
	#SIGINT
 2

	)

34 
	#SIGQUIT
 3

	)

35 
	#SIGILL
 4

	)

36 
	#SIGTRAP
 5

	)

37 
	#SIGABRT
 6

	)

38 
	#SIGIOT
 6

	)

39 
	#SIGBUS
 7

	)

40 
	#SIGFPE
 8

	)

41 
	#SIGKILL
 9

	)

42 
	#SIGUSR1
 10

	)

43 
	#SIGSEGV
 11

	)

44 
	#SIGUSR2
 12

	)

45 
	#SIGPIPE
 13

	)

46 
	#SIGALRM
 14

	)

47 
	#SIGTERM
 15

	)

48 
	#SIGSTKFLT
 16

	)

49 
	#SIGCLD
 
SIGCHLD


	)

50 
	#SIGCHLD
 17

	)

51 
	#SIGCONT
 18

	)

52 
	#SIGSTOP
 19

	)

53 
	#SIGTSTP
 20

	)

54 
	#SIGTTIN
 21

	)

55 
	#SIGTTOU
 22

	)

56 
	#SIGURG
 23

	)

57 
	#SIGXCPU
 24

	)

58 
	#SIGXFSZ
 25

	)

59 
	#SIGVTALRM
 26

	)

60 
	#SIGPROF
 27

	)

61 
	#SIGWINCH
 28

	)

62 
	#SIGPOLL
 
SIGIO


	)

63 
	#SIGIO
 29

	)

64 
	#SIGPWR
 30

	)

65 
	#SIGSYS
 31

	)

66 
	#SIGUNUSED
 31

	)

68 
	#_NSIG
 65

	)

71 
	#SIGRTMIN
 (
	`__libc_cut_sigm
 ())

	)

72 
	#SIGRTMAX
 (
	`__libc_cut_sigmax
 ())

	)

76 
	#__SIGRTMIN
 32

	)

77 
	#__SIGRTMAX
 (
_NSIG
 - 1)

	)

	@/usr/include/bits/sigset.h

19 #idef 
_SIGSET_H_tys


20 
	#_SIGSET_H_tys
 1

	)

22 
	t__sig_omic_t
;

26 
	#_SIGSET_NWORDS
 (1024 / (8 *  ()))

	)

29 
	m__v
[
_SIGSET_NWORDS
];

30 } 
	t__sigt_t
;

41 #i!
defed
 
_SIGSET_H_s
 && defed 
_SIGNAL_H


42 
	#_SIGSET_H_s
 1

	)

44 #ide
_EXTERN_INLINE


45 
	#_EXTERN_INLINE
 
__ex_le


	)

49 
	#__sigmask
(
sig
) \

50 (((1<< (((
sig
- 1% (8 *  ())))

	)

53 
	#__sigwd
(
sig
(((sig- 1/ (8 *  ()))

	)

55 #i
defed
 
__GNUC__
 && __GNUC__ >= 2

56 
	#__sigemyt
(
t
) \

57 (
	`__exnsi__
 ({ 
__t
 = 
_SIGSET_NWORDS
; \

58 
sigt_t
 *
__t
 = (
t
); \

59 --
__t
 >0
__t
->
__v
[__cnt] = 0; \

60 0; }))

	)

61 
	#__sigflt
(
t
) \

62 (
	`__exnsi__
 ({ 
__t
 = 
_SIGSET_NWORDS
; \

63 
sigt_t
 *
__t
 = (
t
); \

64 --
__t
 >0
__t
->
__v
[__cnt] = ~0UL; \

65 0; }))

	)

67 #ifde
__USE_GNU


71 
	#__sigimyt
(
t
) \

72 (
	`__exnsi__
 ({ 
__t
 = 
_SIGSET_NWORDS
; \

73 cڡ 
sigt_t
 *
__t
 = (
t
); \

74 
__t
 = 
__t
->
__v
[--
__t
]; \

75 !
__t
 && --
__t
 >= 0) \

76 
__t
 = 
__t
->
__v
[
__t
]; \

77 
__t
 =0; }))

	)

78 
	#__sigdt
(
de
, 

, 
right
) \

79 (
	`__exnsi__
 ({ 
__t
 = 
_SIGSET_NWORDS
; \

80 
sigt_t
 *
__de
 = (
de
); \

81 cڡ 
sigt_t
 *
__
 = (

); \

82 cڡ 
sigt_t
 *
__right
 = (
right
); \

83 --
__t
 >= 0) \

84 
__de
->
__v
[
__t
] = (
__
->__val[__cnt] \

85 & 
__right
->
__v
[
__t
]); \

86 0; }))

	)

87 
	#__sigܣt
(
de
, 

, 
right
) \

88 (
	`__exnsi__
 ({ 
__t
 = 
_SIGSET_NWORDS
; \

89 
sigt_t
 *
__de
 = (
de
); \

90 cڡ 
sigt_t
 *
__
 = (

); \

91 cڡ 
sigt_t
 *
__right
 = (
right
); \

92 --
__t
 >= 0) \

93 
__de
->
__v
[
__t
] = (
__
->__val[__cnt] \

94 | 
__right
->
__v
[
__t
]); \

95 0; }))

	)

102 
__sigismemb
 (cڡ 
__sigt_t
 *, );

103 
__sigaddt
 (
__sigt_t
 *, );

104 
__sigdt
 (
__sigt_t
 *, );

106 #ifde
__USE_EXTERN_INLINES


107 
	#__SIGSETFN
(
NAME
, 
BODY
, 
CONST
) \

108 
_EXTERN_INLINE
 \

109 
	`NAME
 (
CONST
 
__sigt_t
 *
__t
, 
__sig
) \

111 
__mask
 = 
	`__sigmask
 (
__sig
); \

112 
__wd
 = 
	`__sigwd
 (
__sig
); \

113  
BODY
; \

114 }

	)

116 
__SIGSETFN
 (
__sigismemb
, (
__t
->
__v
[
__wd
] & 
__mask
) ? 1 : 0, const)

117 
__SIGSETFN
 (
__sigaddt
, ((
__t
->
__v
[
__wd
] |
__mask
), 0), )

118 
__SIGSETFN
 (
__sigdt
, ((
__t
->
__v
[
__wd
] &~
__mask
), 0), )

120 #unde
__SIGSETFN


	@/usr/include/bits/sigstack.h

19 #ide
_SIGNAL_H


25 
	ssigack


27 *
	mss_
;

28 
	mss_ڡack
;

35 
	mSS_ONSTACK
 = 1,

36 
	#SS_ONSTACK
 
SS_ONSTACK


	)

37 
	mSS_DISABLE


38 
	#SS_DISABLE
 
SS_DISABLE


	)

42 
	#MINSIGSTKSZ
 2048

	)

45 
	#SIGSTKSZ
 8192

	)

49 
	ssigtack


51 *
	mss_
;

52 
	mss_ags
;

53 
size_t
 
	mss_size
;

54 } 
	tack_t
;

	@/usr/include/bits/sigthread.h

19 #ide
_BITS_SIGTHREAD_H


20 
	#_BITS_SIGTHREAD_H
 1

	)

22 #i!
defed
 
_SIGNAL_H
 && !defed 
_PTHREAD_H


30 
	$had_sigmask
 (
__how
,

31 cڡ 
__sigt_t
 *
__ri
 
__wmask
,

32 
__sigt_t
 *
__ri
 
__dmask
)
__THROW
;

35 
	$had_kl
 (
had_t
 
__thadid
, 
__signo

__THROW
;

37 #ifde
__USE_GNU


39 
	$had_sigqueue
 (
had_t
 
__thadid
, 
__signo
,

40 cڡ 
sigv
 
__vue

__THROW
;

	@/usr/include/bits/stat.h

18 #i!
defed
 
_SYS_STAT_H
 && !defed 
_FCNTL_H


22 #ide
_BITS_STAT_H


23 
	#_BITS_STAT_H
 1

	)

26 #ide
__x86_64__


27 
	#_STAT_VER_LINUX_OLD
 1

	)

28 
	#_STAT_VER_KERNEL
 1

	)

29 
	#_STAT_VER_SVR4
 2

	)

30 
	#_STAT_VER_LINUX
 3

	)

33 
	#_MKNOD_VER_LINUX
 1

	)

34 
	#_MKNOD_VER_SVR4
 2

	)

35 
	#_MKNOD_VER
 
_MKNOD_VER_LINUX


	)

37 
	#_STAT_VER_KERNEL
 0

	)

38 
	#_STAT_VER_LINUX
 1

	)

41 
	#_MKNOD_VER_LINUX
 0

	)

44 
	#_STAT_VER
 
_STAT_VER_LINUX


	)

46 
	s


48 
__dev_t
 
	m_dev
;

49 #ide
__x86_64__


50 
	m__d1
;

52 #i
defed
 
__x86_64__
 || !defed 
__USE_FILE_OFFSET64


53 
__o_t
 
	m_o
;

55 
__o_t
 
	m___o
;

57 #ide
__x86_64__


58 
__mode_t
 
	m_mode
;

59 
__ƚk_t
 
	m_ƚk
;

61 
__ƚk_t
 
	m_ƚk
;

62 
__mode_t
 
	m_mode
;

64 
__uid_t
 
	m_uid
;

65 
__gid_t
 
	m_gid
;

66 #ifde
__x86_64__


67 
	m__d0
;

69 
__dev_t
 
	m_rdev
;

70 #ide
__x86_64__


71 
	m__d2
;

73 #i
defed
 
__x86_64__
 || !defed 
__USE_FILE_OFFSET64


74 
__off_t
 
	m_size
;

76 
__off64_t
 
	m_size
;

78 
__blksize_t
 
	m_blksize
;

79 #i
defed
 
__x86_64__
 || !defed 
__USE_FILE_OFFSET64


80 
__blkt_t
 
	m_blocks
;

82 
__blkt64_t
 
	m_blocks
;

84 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN2K8


91 
timeec
 
	m_im
;

92 
timeec
 
	m_mtim
;

93 
timeec
 
	m_im
;

94 
	#_ime
 
_im
.
tv_c


	)

95 
	#_mtime
 
_mtim
.
tv_c


	)

96 
	#_ime
 
_im
.
tv_c


	)

98 
__time_t
 
	m_ime
;

99 
__sys_ulg_t
 
	m_imc
;

100 
__time_t
 
	m_mtime
;

101 
__sys_ulg_t
 
	m_mtimc
;

102 
__time_t
 
	m_ime
;

103 
__sys_ulg_t
 
	m_imc
;

105 #ifde
__x86_64__


106 
__sys_g_t
 
	m__glibc_rved
[3];

108 #ide
__USE_FILE_OFFSET64


109 
	m__glibc_rved4
;

110 
	m__glibc_rved5
;

112 
__o64_t
 
	m_o
;

117 #ifde
__USE_LARGEFILE64


119 
	s64


121 
__dev_t
 
	m_dev
;

122 #ifde
__x86_64__


123 
__o64_t
 
	m_o
;

124 
__ƚk_t
 
	m_ƚk
;

125 
__mode_t
 
	m_mode
;

127 
	m__d1
;

128 
__o_t
 
	m___o
;

129 
__mode_t
 
	m_mode
;

130 
__ƚk_t
 
	m_ƚk
;

132 
__uid_t
 
	m_uid
;

133 
__gid_t
 
	m_gid
;

134 #ifde
__x86_64__


135 
	m__d0
;

136 
__dev_t
 
	m_rdev
;

137 
__off_t
 
	m_size
;

139 
__dev_t
 
	m_rdev
;

140 
	m__d2
;

141 
__off64_t
 
	m_size
;

143 
__blksize_t
 
	m_blksize
;

144 
__blkt64_t
 
	m_blocks
;

145 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN2K8


152 
timeec
 
	m_im
;

153 
timeec
 
	m_mtim
;

154 
timeec
 
	m_im
;

156 
__time_t
 
	m_ime
;

157 
__sys_ulg_t
 
	m_imc
;

158 
__time_t
 
	m_mtime
;

159 
__sys_ulg_t
 
	m_mtimc
;

160 
__time_t
 
	m_ime
;

161 
__sys_ulg_t
 
	m_imc
;

163 #ifde
__x86_64__


164 
__sys_g_t
 
	m__glibc_rved
[3];

166 
__o64_t
 
	m_o
;

172 
	#_STATBUF_ST_BLKSIZE


	)

173 
	#_STATBUF_ST_RDEV


	)

175 
	#_STATBUF_ST_NSEC


	)

179 
	#__S_IFMT
 0170000

	)

182 
	#__S_IFDIR
 0040000

	)

183 
	#__S_IFCHR
 0020000

	)

184 
	#__S_IFBLK
 0060000

	)

185 
	#__S_IFREG
 0100000

	)

186 
	#__S_IFIFO
 0010000

	)

187 
	#__S_IFLNK
 0120000

	)

188 
	#__S_IFSOCK
 0140000

	)

192 
	#__S_TYPEISMQ
(
buf
((buf)->
_mode
 - (buf)->_mode)

	)

193 
	#__S_TYPEISSEM
(
buf
((buf)->
_mode
 - (buf)->_mode)

	)

194 
	#__S_TYPEISSHM
(
buf
((buf)->
_mode
 - (buf)->_mode)

	)

198 
	#__S_ISUID
 04000

	)

199 
	#__S_ISGID
 02000

	)

200 
	#__S_ISVTX
 01000

	)

201 
	#__S_IREAD
 0400

	)

202 
	#__S_IWRITE
 0200

	)

203 
	#__S_IEXEC
 0100

	)

205 #ifde
__USE_ATFILE


206 
	#UTIME_NOW
 ((1<< 30- 1l)

	)

207 
	#UTIME_OMIT
 ((1<< 30- 2l)

	)

	@/usr/include/bits/stdio-ldbl.h

19 #ide
_STDIO_H


23 
__BEGIN_NAMESPACE_STD


24 
	$__LDBL_REDIR_DECL
 (
rtf
)

25 
	$__LDBL_REDIR_DECL
 (
tf
)

26 
	$__LDBL_REDIR_DECL
 (
rtf
)

27 
	$__LDBL_REDIR_DECL
 (
vrtf
)

28 
	$__LDBL_REDIR_DECL
 (
vtf
)

29 
	$__LDBL_REDIR_DECL
 (
vrtf
)

30 #i
defed
 
__USE_ISOC99
 && !defed 
__USE_GNU
 \

31 && !
defed
 
__REDIRECT
 \

32 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

33 
	$__LDBL_REDIR1_DECL
 (
fsnf
, 
__dbl___isoc99_fsnf
)

34 
	$__LDBL_REDIR1_DECL
 (
snf
, 
__dbl___isoc99_snf
)

35 
	$__LDBL_REDIR1_DECL
 (
ssnf
, 
__dbl___isoc99_ssnf
)

37 
	$__LDBL_REDIR_DECL
 (
fsnf
)

38 
	$__LDBL_REDIR_DECL
 (
snf
)

39 
	$__LDBL_REDIR_DECL
 (
ssnf
)

41 
__END_NAMESPACE_STD


43 #i
defed
 
__USE_BSD
 || defed 
__USE_ISOC99
 || defed 
__USE_UNIX98


44 
__BEGIN_NAMESPACE_C99


45 
	$__LDBL_REDIR_DECL
 (
tf
)

46 
	$__LDBL_REDIR_DECL
 (
vtf
)

47 
__END_NAMESPACE_C99


50 #ifdef 
__USE_ISOC99


51 
__BEGIN_NAMESPACE_C99


52 #i!
defed
 
__USE_GNU
 && !defed 
__REDIRECT
 \

53 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

54 
	$__LDBL_REDIR1_DECL
 (
vfsnf
, 
__dbl___isoc99_vfsnf
)

55 
	$__LDBL_REDIR1_DECL
 (
vsnf
, 
__dbl___isoc99_vsnf
)

56 
	$__LDBL_REDIR1_DECL
 (
vssnf
, 
__dbl___isoc99_vssnf
)

58 
	$__LDBL_REDIR_DECL
 (
vfsnf
)

59 
	$__LDBL_REDIR_DECL
 (
vssnf
)

60 
	$__LDBL_REDIR_DECL
 (
vsnf
)

62 
__END_NAMESPACE_C99


65 #ifde
__USE_XOPEN2K8


66 
	$__LDBL_REDIR_DECL
 (
vdtf
)

67 
	$__LDBL_REDIR_DECL
 (
dtf
)

70 #ifde
__USE_GNU


71 
	$__LDBL_REDIR_DECL
 (
vartf
)

72 
	$__LDBL_REDIR_DECL
 (
__artf
)

73 
	$__LDBL_REDIR_DECL
 (
artf
)

74 
	$__LDBL_REDIR_DECL
 (
oback_tf
)

75 
	$__LDBL_REDIR_DECL
 (
oback_vtf
)

78 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


79 
	$__LDBL_REDIR_DECL
 (
__rtf_chk
)

80 
	$__LDBL_REDIR_DECL
 (
__vrtf_chk
)

81 #i
defed
 
__USE_BSD
 || defed 
__USE_ISOC99
 || defed 
__USE_UNIX98


82 
	$__LDBL_REDIR_DECL
 (
__tf_chk
)

83 
	$__LDBL_REDIR_DECL
 (
__vtf_chk
)

85 #i
__USE_FORTIFY_LEVEL
 > 1

86 
	$__LDBL_REDIR_DECL
 (
__rtf_chk
)

87 
	$__LDBL_REDIR_DECL
 (
__tf_chk
)

88 
	$__LDBL_REDIR_DECL
 (
__vrtf_chk
)

89 
	$__LDBL_REDIR_DECL
 (
__vtf_chk
)

90 #ifde
__USE_XOPEN2K8


91 
	$__LDBL_REDIR_DECL
 (
__dtf_chk
)

92 
	$__LDBL_REDIR_DECL
 (
__vdtf_chk
)

94 #ifde
__USE_GNU


95 
	$__LDBL_REDIR_DECL
 (
__artf_chk
)

96 
	$__LDBL_REDIR_DECL
 (
__vartf_chk
)

97 
	$__LDBL_REDIR_DECL
 (
__oback_tf_chk
)

98 
	$__LDBL_REDIR_DECL
 (
__oback_vtf_chk
)

	@/usr/include/bits/stdio.h

19 #ide
_STDIO_H


23 #ide
__ex_le


24 
	#__STDIO_INLINE
 
le


	)

26 
	#__STDIO_INLINE
 
__ex_le


	)

30 #ifde
__USE_EXTERN_INLINES


33 #i!(
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi
)

35 
__STDIO_INLINE
 

36 
	$vtf
 (cڡ *
__ri
 
__fmt
, 
_G_va_li
 
__g
)

38  
	`vrtf
 (
dout
, 
__fmt
, 
__g
);

39 
	}
}

43 
__STDIO_INLINE
 

44 
	$gch
 ()

46  
	`_IO_gc
 (
d
);

47 
	}
}

50 #ifde
__USE_MISC


52 
__STDIO_INLINE
 

53 
	$fgc_uocked
 (
FILE
 *
__
)

55  
	`_IO_gc_uocked
 (
__
);

56 
	}
}

60 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


62 
__STDIO_INLINE
 

63 
	$gc_uocked
 (
FILE
 *
__
)

65  
	`_IO_gc_uocked
 (
__
);

66 
	}
}

69 
__STDIO_INLINE
 

70 
	$gch_uocked
 ()

72  
	`_IO_gc_uocked
 (
d
);

73 
	}
}

78 
__STDIO_INLINE
 

79 
	$putch
 (
__c
)

81  
	`_IO_putc
 (
__c
, 
dout
);

82 
	}
}

85 #ifde
__USE_MISC


87 
__STDIO_INLINE
 

88 
	$utc_uocked
 (
__c
, 
FILE
 *
__am
)

90  
	`_IO_putc_uocked
 (
__c
, 
__am
);

91 
	}
}

95 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


97 
__STDIO_INLINE
 

98 
	$putc_uocked
 (
__c
, 
FILE
 *
__am
)

100  
	`_IO_putc_uocked
 (
__c
, 
__am
);

101 
	}
}

104 
__STDIO_INLINE
 

105 
	$putch_uocked
 (
__c
)

107  
	`_IO_putc_uocked
 (
__c
, 
dout
);

108 
	}
}

112 #ifdef 
__USE_GNU


114 
__STDIO_INLINE
 
_IO_ssize_t


115 
	$gle
 (**
__l
, 
size_t
 *
__n
, 
FILE
 *
__am
)

117  
	`__gdim
 (
__l
, 
__n
, '\n', 
__am
);

118 
	}
}

122 #ifde
__USE_MISC


124 
__STDIO_INLINE
 

125 
__NTH
 (
	$of_uocked
 (
FILE
 *
__am
))

127  
	`_IO_of_uocked
 (
__am
);

128 
	}
}

131 
__STDIO_INLINE
 

132 
__NTH
 (
	$_uocked
 (
FILE
 *
__am
))

134  
	`_IO__uocked
 (
__am
);

135 
	}
}

141 #i
defed
 
__USE_MISC
 && defed 
__GNUC__
 && defed 
__OPTIMIZE__
 \

142 && !
defed
 
	g__lulus


144 
	#d_uocked
(
r
, 
size
, 
n
, 
am
) \

145 (
	`__exnsi__
 ((
	`__but_cڡt_p
 (
size
&& __but_cڡt_(
n
) \

146 && (
size_t
(
size
* (size_t(
n
) <= 8 \

147 && (
size_t
(
size
) != 0) \

148 ? ({ *
__r
 = (*(
r
); \

149 
FILE
 *
__am
 = (
am
); \

150 
size_t
 
__t
; \

151 
__t
 = (
size_t
(
size
* (size_t(
n
); \

152 
__t
 > 0; --__cnt) \

154 
__c
 = 
	`_IO_gc_uocked
 (
__am
); \

155 i(
__c
 =
EOF
) \

157 *
__r
++ = 
__c
; \

159 ((
size_t
(
size
* (size_t(
n
- 
__t
) \

160 / (
size_t
(
size
); }) \

161 : (((
	`__but_cڡt_p
 (
size
&& (
size_t
) (size) == 0) \

162 || (
	`__but_cڡt_p
 (
n
&& (
size_t
) (n) == 0)) \

164 ? (((
r
), ((
am
), ((
size
), \

165 ((
n
), (
size_t
) 0) \

166 : 
	`d_uocked
 (
r
, 
size
, 
n
, 
am
))))

	)

168 
	#fwre_uocked
(
r
, 
size
, 
n
, 
am
) \

169 (
	`__exnsi__
 ((
	`__but_cڡt_p
 (
size
&& __but_cڡt_(
n
) \

170 && (
size_t
(
size
* (size_t(
n
) <= 8 \

171 && (
size_t
(
size
) != 0) \

172 ? ({ cڡ *
__r
 = (cڡ *(
r
); \

173 
FILE
 *
__am
 = (
am
); \

174 
size_t
 
__t
; \

175 
__t
 = (
size_t
(
size
* (size_t(
n
); \

176 
__t
 > 0; --__cnt) \

177 i(
	`_IO_putc_uocked
 (*
__r
++, 
__am
=
EOF
) \

179 ((
size_t
(
size
* (size_t(
n
- 
__t
) \

180 / (
size_t
(
size
); }) \

181 : (((
	`__but_cڡt_p
 (
size
&& (
size_t
) (size) == 0) \

182 || (
	`__but_cڡt_p
 (
n
&& (
size_t
) (n) == 0)) \

184 ? (((
r
), ((
am
), ((
size
), \

185 ((
n
), (
size_t
) 0) \

186 : 
	`fwre_uocked
 (
r
, 
size
, 
n
, 
am
))))

	)

190 #unde
__STDIO_INLINE


	@/usr/include/bits/stdio2.h

19 #ide
_STDIO_H


23 
	$__rtf_chk
 (*
__ri
 
__s
, 
__ag
, 
size_t
 
__
,

24 cڡ *
__ri
 
__fm
, ...
__THROW
;

25 
	$__vrtf_chk
 (*
__ri
 
__s
, 
__ag
, 
size_t
 
__
,

26 cڡ *
__ri
 
__fm
,

27 
_G_va_li
 
__

__THROW
;

29 #ifde
__va_g_ck


30 
__ftify_funi
 

31 
	`__NTH
 (
	$rtf
 (*
__ri
 
__s
, cڡ *__ri 
__fmt
, ...))

33  
	`__but___rtf_chk
 (
__s
, 
__USE_FORTIFY_LEVEL
 - 1,

34 
	`__bos
 (
__s
), 
__fmt
, 
	`__va_g_ck
 ());

35 
	}
}

36 #i!
defed
 
__lulus


37 
	#rtf
(
r
, ...) \

38 
	`__but___rtf_chk
 (
r
, 
__USE_FORTIFY_LEVEL
 - 1, 
	`__bos
 (str), \

39 
__VA_ARGS__
)

	)

42 
__ftify_funi
 

43 
__NTH
 (
	$vrtf
 (*
__ri
 
__s
, cڡ *__ri 
__fmt
,

44 
_G_va_li
 
__
))

46  
	`__but___vrtf_chk
 (
__s
, 
__USE_FORTIFY_LEVEL
 - 1,

47 
	`__bos
 (
__s
), 
__fmt
, 
__
);

48 
	}
}

50 #i
defed
 
__USE_BSD
 || defed 
__USE_ISOC99
 || defed 
__USE_UNIX98


52 
	$__tf_chk
 (*
__ri
 
__s
, 
size_t
 
__n
, 
__ag
,

53 
size_t
 
__
, cڡ *
__ri
 
__fm
,

54 ...
__THROW
;

55 
	$__vtf_chk
 (*
__ri
 
__s
, 
size_t
 
__n
, 
__ag
,

56 
size_t
 
__
, cڡ *
__ri
 
__fm
,

57 
_G_va_li
 
__

__THROW
;

59 #ifde
__va_g_ck


60 
__ftify_funi
 

61 
	`__NTH
 (
	$tf
 (*
__ri
 
__s
, 
size_t
 
__n
,

62 cڡ *
__ri
 
__fmt
, ...))

64  
	`__but___tf_chk
 (
__s
, 
__n
, 
__USE_FORTIFY_LEVEL
 - 1,

65 
	`__bos
 (
__s
), 
__fmt
, 
	`__va_g_ck
 ());

66 
	}
}

67 #i!
defed
 
__lulus


68 
	#tf
(
r
, 
n
, ...) \

69 
	`__but___tf_chk
 (
r
, 
n
, 
__USE_FORTIFY_LEVEL
 - 1, 
	`__bos
 (str), \

70 
__VA_ARGS__
)

	)

73 
__ftify_funi
 

74 
__NTH
 (
	$vtf
 (*
__ri
 
__s
, 
size_t
 
__n
,

75 cڡ *
__ri
 
__fmt
, 
_G_va_li
 
__
))

77  
	`__but___vtf_chk
 (
__s
, 
__n
, 
__USE_FORTIFY_LEVEL
 - 1,

78 
	`__bos
 (
__s
), 
__fmt
, 
__
);

79 
	}
}

83 #i
__USE_FORTIFY_LEVEL
 > 1

85 
__rtf_chk
 (
FILE
 *
__ri
 
__am
, 
__ag
,

86 cڡ *
__ri
 
__fm
, ...);

87 
__tf_chk
 (
__ag
, cڡ *
__ri
 
__fm
, ...);

88 
__vrtf_chk
 (
FILE
 *
__ri
 
__am
, 
__ag
,

89 cڡ *
__ri
 
__fm
, 
_G_va_li
 
__
);

90 
__vtf_chk
 (
__ag
, cڡ *
__ri
 
__fm
,

91 
_G_va_li
 
__
);

93 #ifde
__va_g_ck


94 
__ftify_funi
 

95 
	$rtf
 (
FILE
 *
__ri
 
__am
, cڡ *__ri 
__fmt
, ...)

97  
	`__rtf_chk
 (
__am
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

98 
	`__va_g_ck
 ());

99 
	}
}

101 
__ftify_funi
 

102 
	$tf
 (cڡ *
__ri
 
__fmt
, ...)

104  
	`__tf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
	`__va_g_ck
 ());

105 
	}
}

106 #i!
defed
 
__lulus


107 
	#tf
(...) \

108 
	`__tf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

109 
	#rtf
(
am
, ...) \

110 
	`__rtf_chk
 (
am
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

113 
__ftify_funi
 

114 
	$vtf
 (cڡ *
__ri
 
__fmt
, 
_G_va_li
 
__
)

116 #ifde
__USE_EXTERN_INLINES


117  
	`__vrtf_chk
 (
dout
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__
);

119  
	`__vtf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__
);

121 
	}
}

123 
__ftify_funi
 

124 
	$vrtf
 (
FILE
 *
__ri
 
__am
,

125 cڡ *
__ri
 
__fmt
, 
_G_va_li
 
__
)

127  
	`__vrtf_chk
 (
__am
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__
);

128 
	}
}

130 #ifde
__USE_XOPEN2K8


131 
	$__dtf_chk
 (
__fd
, 
__ag
, cڡ *
__ri
 
__fmt
,

132 ...
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 4)));

133 
	$__vdtf_chk
 (
__fd
, 
__ag
,

134 cڡ *
__ri
 
__fmt
, 
_G_va_li
 
__g
)

135 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 0)));

137 #ifde
__va_g_ck


138 
__ftify_funi
 

139 
	$dtf
 (
__fd
, cڡ *
__ri
 
__fmt
, ...)

141  
	`__dtf_chk
 (
__fd
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

142 
	`__va_g_ck
 ());

143 
	}
}

144 #i!
defed
 
__lulus


145 
	#dtf
(
fd
, ...) \

146 
	`__dtf_chk
 (
fd
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

149 
__ftify_funi
 

150 
	$vdtf
 (
__fd
, cڡ *
__ri
 
__fmt
, 
_G_va_li
 
__
)

152  
	`__vdtf_chk
 (
__fd
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__
);

153 
	}
}

156 #ifde
__USE_GNU


158 
	$__artf_chk
 (**
__ri
 
__r
, 
__ag
,

159 cڡ *
__ri
 
__fmt
, ...)

160 
__THROW
 
	`__ibu__
 ((
	$__fm__
 (
__tf__
, 3, 4))
__wur
;

161 
	$__vartf_chk
 (**
__ri
 
__r
, 
__ag
,

162 cڡ *
__ri
 
__fmt
, 
_G_va_li
 
__g
)

163 
__THROW
 
	`__ibu__
 ((
	$__fm__
 (
__tf__
, 3, 0))
__wur
;

164 
	$__oback_tf_chk
 (
oback
 *
__ri
 
__oback
,

165 
__ag
, cڡ *
__ri
 
__fm
,

167 
__THROW
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 4)));

168 
	$__oback_vtf_chk
 (
oback
 *
__ri
 
__oback
,

169 
__ag
,

170 cڡ *
__ri
 
__fm
,

171 
_G_va_li
 
__gs
)

172 
__THROW
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 0)));

174 #ifde
__va_g_ck


175 
__ftify_funi
 

176 
	`__NTH
 (
	$artf
 (**
__ri
 
__r
, cڡ *__ri 
__fmt
, ...))

178  
	`__artf_chk
 (
__r
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

179 
	`__va_g_ck
 ());

180 
	}
}

182 
__ftify_funi
 

183 
__NTH
 (
	$__artf
 (**
__ri
 
__r
, cڡ *__ri 
__fmt
,

186  
	`__artf_chk
 (
__r
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

187 
	`__va_g_ck
 ());

188 
	}
}

190 
__ftify_funi
 

191 
__NTH
 (
	$oback_tf
 (
oback
 *
__ri
 
__oback
,

192 cڡ *
__ri
 
__fmt
, ...))

194  
	`__oback_tf_chk
 (
__oback
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

195 
	`__va_g_ck
 ());

196 
	}
}

197 #i!
defed
 
__lulus


198 
	#artf
(
r
, ...) \

199 
	`__artf_chk
 (
r
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

200 
	#__artf
(
r
, ...) \

201 
	`__artf_chk
 (
r
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

202 
	#oback_tf
(
oback
, ...) \

203 
	`__oback_tf_chk
 (
oback
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

206 
__ftify_funi
 

207 
__NTH
 (
	$vartf
 (**
__ri
 
__r
, cڡ *__ri 
__fmt
,

208 
_G_va_li
 
__
))

210  
	`__vartf_chk
 (
__r
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__
);

211 
	}
}

213 
__ftify_funi
 

214 
__NTH
 (
	$oback_vtf
 (
oback
 *
__ri
 
__oback
,

215 cڡ *
__ri
 
__fmt
, 
_G_va_li
 
__
))

217  
	`__oback_vtf_chk
 (
__oback
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

218 
__
);

219 
	}
}

225 #i!
defed
 
__USE_ISOC11
 \

226 || (
defed
 
	g__lulus
 && __lulu<201103L && !defed 
__USE_GNU
)

227 *
	$__gs_chk
 (*
__r
, 
size_t

__wur
;

228 *
	`__REDIRECT
 (
__gs_wn
, (*
__r
), 
gs
)

229 
__wur
 
	`__wǉr
 ("please use fgets or getline instead, gets can't "

232 
__ftify_funi
 
__wur
 *

233 
	$gs
 (*
__r
)

235 i(
	`__bos
 (
__r
!(
size_t
) -1)

236  
	`__gs_chk
 (
__r
, 
	`__bos
 (__str));

237  
	`__gs_wn
 (
__r
);

238 
	}
}

241 *
	$__fgs_chk
 (*
__ri
 
__s
, 
size_t
 
__size
, 
__n
,

242 
FILE
 *
__ri
 
__am

__wur
;

243 *
	`__REDIRECT
 (
__fgs_s
,

244 (*
__ri
 
__s
, 
__n
,

245 
FILE
 *
__ri
 
__am
), 
fgs

__wur
;

246 *
	`__REDIRECT
 (
__fgs_chk_wn
,

247 (*
__ri
 
__s
, 
size_t
 
__size
, 
__n
,

248 
FILE
 *
__ri
 
__am
), 
__fgs_chk
)

249 
__wur
 
	`__wǉr
 ("fgets called with bigger sizehanength "

252 
__ftify_funi
 
__wur
 *

253 
	$fgs
 (*
__ri
 
__s
, 
__n
, 
FILE
 *__ri 
__am
)

255 i(
	`__bos
 (
__s
!(
size_t
) -1)

257 i(!
	`__but_cڡt_p
 (
__n
) || __n <= 0)

258  
	`__fgs_chk
 (
__s
, 
	`__bos
 (__s), 
__n
, 
__am
);

260 i((
size_t

__n
 > 
	`__bos
 (
__s
))

261  
	`__fgs_chk_wn
 (
__s
, 
	`__bos
 (__s), 
__n
, 
__am
);

263  
	`__fgs_s
 (
__s
, 
__n
, 
__am
);

264 
	}
}

266 
size_t
 
	$__d_chk
 (*
__ri
 
__r
, 
size_t
 
__
,

267 
size_t
 
__size
, size_
__n
,

268 
FILE
 *
__ri
 
__am

__wur
;

269 
size_t
 
	`__REDIRECT
 (
__d_s
,

270 (*
__ri
 
__r
, 
size_t
 
__size
,

271 
size_t
 
__n
, 
FILE
 *
__ri
 
__am
),

272 
d

__wur
;

273 
size_t
 
	`__REDIRECT
 (
__d_chk_wn
,

274 (*
__ri
 
__r
, 
size_t
 
__
,

275 
size_t
 
__size
, size_
__n
,

276 
FILE
 *
__ri
 
__am
),

277 
__d_chk
)

278 
__wur
 
	`__wǉr
 ("fread called with bigger size *membhanength "

281 
__ftify_funi
 
__wur
 
size_t


282 
	$d
 (*
__ri
 
__r
, 
size_t
 
__size
, size_
__n
,

283 
FILE
 *
__ri
 
__am
)

285 i(
	`__bos0
 (
__r
!(
size_t
) -1)

287 i(!
	`__but_cڡt_p
 (
__size
)

288 || !
	`__but_cڡt_p
 (
__n
)

289 || (
__size
 | 
__n
>(((
size_t
) 1) << (8 *  (size_t) / 2)))

290  
	`__d_chk
 (
__r
, 
	`__bos0
 (__r), 
__size
, 
__n
, 
__am
);

292 i(
__size
 * 
__n
 > 
	`__bos0
 (
__r
))

293  
	`__d_chk_wn
 (
__r
, 
	`__bos0
 (__r), 
__size
, 
__n
, 
__am
);

295  
	`__d_s
 (
__r
, 
__size
, 
__n
, 
__am
);

296 
	}
}

298 #ifde
__USE_GNU


299 *
	$__fgs_uocked_chk
 (*
__ri
 
__s
, 
size_t
 
__size
,

300 
__n
, 
FILE
 *
__ri
 
__am

__wur
;

301 *
	`__REDIRECT
 (
__fgs_uocked_s
,

302 (*
__ri
 
__s
, 
__n
,

303 
FILE
 *
__ri
 
__am
), 
fgs_uocked

__wur
;

304 *
	`__REDIRECT
 (
__fgs_uocked_chk_wn
,

305 (*
__ri
 
__s
, 
size_t
 
__size
, 
__n
,

306 
FILE
 *
__ri
 
__am
), 
__fgs_uocked_chk
)

307 
__wur
 
	`__wǉr
 ("fgets_unlocked called with bigger sizehanength "

310 
__ftify_funi
 
__wur
 *

311 
	$fgs_uocked
 (*
__ri
 
__s
, 
__n
, 
FILE
 *__ri 
__am
)

313 i(
	`__bos
 (
__s
!(
size_t
) -1)

315 i(!
	`__but_cڡt_p
 (
__n
) || __n <= 0)

316  
	`__fgs_uocked_chk
 (
__s
, 
	`__bos
 (__s), 
__n
, 
__am
);

318 i((
size_t

__n
 > 
	`__bos
 (
__s
))

319  
	`__fgs_uocked_chk_wn
 (
__s
, 
	`__bos
 (__s), 
__n
, 
__am
);

321  
	`__fgs_uocked_s
 (
__s
, 
__n
, 
__am
);

322 
	}
}

325 #ifde
__USE_MISC


326 #unde
d_uocked


327 
size_t
 
	$__d_uocked_chk
 (*
__ri
 
__r
, 
size_t
 
__
,

328 
size_t
 
__size
, size_
__n
,

329 
FILE
 *
__ri
 
__am

__wur
;

330 
size_t
 
	`__REDIRECT
 (
__d_uocked_s
,

331 (*
__ri
 
__r
, 
size_t
 
__size
,

332 
size_t
 
__n
, 
FILE
 *
__ri
 
__am
),

333 
d_uocked

__wur
;

334 
size_t
 
	`__REDIRECT
 (
__d_uocked_chk_wn
,

335 (*
__ri
 
__r
, 
size_t
 
__
,

336 
size_t
 
__size
, size_
__n
,

337 
FILE
 *
__ri
 
__am
),

338 
__d_uocked_chk
)

339 
__wur
 
	`__wǉr
 ("fread_unlocked called with bigger size *membhan "

342 
__ftify_funi
 
__wur
 
size_t


343 
	$d_uocked
 (*
__ri
 
__r
, 
size_t
 
__size
, size_
__n
,

344 
FILE
 *
__ri
 
__am
)

346 i(
	`__bos0
 (
__r
!(
size_t
) -1)

348 i(!
	`__but_cڡt_p
 (
__size
)

349 || !
	`__but_cڡt_p
 (
__n
)

350 || (
__size
 | 
__n
>(((
size_t
) 1) << (8 *  (size_t) / 2)))

351  
	`__d_uocked_chk
 (
__r
, 
	`__bos0
 (__r), 
__size
, 
__n
,

352 
__am
);

354 i(
__size
 * 
__n
 > 
	`__bos0
 (
__r
))

355  
	`__d_uocked_chk_wn
 (
__r
, 
	`__bos0
 (__r), 
__size
, 
__n
,

356 
__am
);

359 #ifde
__USE_EXTERN_INLINES


360 i(
	`__but_cڡt_p
 (
__size
)

361 && 
	`__but_cڡt_p
 (
__n
)

362 && (
__size
 | 
__n
< (((
size_t
) 1) << (8 *  (size_t) / 2))

363 && 
__size
 * 
__n
 <= 8)

365 
size_t
 
__t
 = 
__size
 * 
__n
;

366 *
__
 = (*
__r
;

367 i(
__t
 == 0)

370 ; 
__t
 > 0; --__cnt)

372 
__c
 = 
	`_IO_gc_uocked
 (
__am
);

373 i(
__c
 =
EOF
)

375 *
__
++ = 
__c
;

377  (
__
 - (*
__r
/ 
__size
;

380  
	`__d_uocked_s
 (
__r
, 
__size
, 
__n
, 
__am
);

381 
	}
}

	@/usr/include/bits/stdio_lim.h

18 #i!
defed
 
_STDIO_H
 && !defed 
__ed_FOPEN_MAX
 && !defed 
__ed_IOV_MAX


22 #ifde
_STDIO_H


23 
	#L_tmam
 20

	)

24 
	#TMP_MAX
 238328

	)

25 
	#FILENAME_MAX
 4096

	)

27 #ifde
__USE_POSIX


28 
	#L_mid
 9

	)

29 #i!
defed
 
__USE_XOPEN2K
 || defed 
__USE_GNU


30 
	#L_curid
 9

	)

35 #i
defed
 
__ed_FOPEN_MAX
 || defed 
_STDIO_H


36 #unde
FOPEN_MAX


37 
	#FOPEN_MAX
 16

	)

40 #i
defed
 
__ed_IOV_MAX
 && !defed 
IOV_MAX


41 
	#IOV_MAX
 1024

	)

	@/usr/include/bits/stdlib-bsearch.h

19 
__ex_le
 *

20 
	$bch
 (cڡ *
__key
, cڡ *
__ba
, 
size_t
 
__nmemb
, size_
__size
,

21 
__comr__t
 
__comr
)

23 
size_t
 
__l
, 
__u
, 
__idx
;

24 cڡ *
__p
;

25 
__comris
;

27 
__l
 = 0;

28 
__u
 = 
__nmemb
;

29 
__l
 < 
__u
)

31 
__idx
 = (
__l
 + 
__u
) / 2;

32 
__p
 = (*(((cڡ *
__ba
+ (
__idx
 * 
__size
));

33 
__comris
 = (*
__comr
(
__key
, 
__p
);

34 i(
__comris
 < 0)

35 
__u
 = 
__idx
;

36 i(
__comris
 > 0)

37 
__l
 = 
__idx
 + 1;

39  (*
__p
;

42  
NULL
;

43 
	}
}

	@/usr/include/bits/stdlib-float.h

19 #ide
_STDLIB_H


23 #ifde
__USE_EXTERN_INLINES


24 
__BEGIN_NAMESPACE_STD


25 
__ex_le
 

26 
__NTH
 (
	$of
 (cڡ *
__Ō
))

28  
	`od
 (
__Ō
, (**
NULL
);

29 
	}
}

30 
	g__END_NAMESPACE_STD


	@/usr/include/bits/stdlib-ldbl.h

19 #ide
_STDLIB_H


23 #ifdef 
__USE_ISOC99


24 
__BEGIN_NAMESPACE_C99


25 
	$__LDBL_REDIR1_DECL
 (
d
, 
od
)

26 
__END_NAMESPACE_C99


29 #ifde
__USE_GNU


30 
	$__LDBL_REDIR1_DECL
 (
d_l
, 
od_l
)

33 #ifde
__USE_MISC


34 
	$__LDBL_REDIR1_DECL
 (
qecvt
, 
ecvt
)

35 
	$__LDBL_REDIR1_DECL
 (
qfcvt
, 
fcvt
)

36 
	$__LDBL_REDIR1_DECL
 (
qgcvt
, 
gcvt
)

37 
	$__LDBL_REDIR1_DECL
 (
qecvt_r
, 
ecvt_r
)

38 
	$__LDBL_REDIR1_DECL
 (
qfcvt_r
, 
fcvt_r
)

	@/usr/include/bits/stdlib.h

19 #ide
_STDLIB_H


23 *
	$__th_chk
 (cڡ *
__ri
 
__me
,

24 *
__ri
 
__sved
,

25 
size_t
 
__svedn

__THROW
 
__wur
;

26 *
	`__REDIRECT_NTH
 (
__th_s
,

27 (cڡ *
__ri
 
__me
,

28 *
__ri
 
__sved
), 
th

__wur
;

29 *
	`__REDIRECT_NTH
 (
__th_chk_wn
,

30 (cڡ *
__ri
 
__me
,

31 *
__ri
 
__sved
,

32 
size_t
 
__svedn
), 
__th_chk

__wur


33 
	`__wǉr
 ("secondrgument ofealpath must beither NULL ort "

36 
__ftify_funi
 
__wur
 *

37 
	`__NTH
 (
	$th
 (cڡ *
__ri
 
__me
, *__ri 
__sved
))

39 i(
	`__bos
 (
__sved
!(
size_t
) -1)

41 #i
defed
 
_LIBC_LIMITS_H_
 && defed 
PATH_MAX


42 i(
	`__bos
 (
__sved
< 
PATH_MAX
)

43  
	`__th_chk_wn
 (
__me
, 
__sved
, 
	`__bos
 (__resolved));

45  
	`__th_chk
 (
__me
, 
__sved
, 
	`__bos
 (__resolved));

48  
	`__th_s
 (
__me
, 
__sved
);

49 
	}
}

52 
	$__ame_r_chk
 (
__fd
, *
__buf
, 
size_t
 
__bu
,

53 
size_t
 
__ėl

__THROW
 
	`__nnu
 ((2));

54 
	`__REDIRECT_NTH
 (
__ame_r_s
, (
__fd
, *
__buf
,

55 
size_t
 
__bu
), 
ame_r
)

56 
	`__nnu
 ((2));

57 
	`__REDIRECT_NTH
 (
__ame_r_chk_wn
,

58 (
__fd
, *
__buf
, 
size_t
 
__bu
,

59 
size_t
 
__ėl
), 
__ame_r_chk
)

60 
	`__nnu
 ((2)
	`__wǉr
 ("ptsname_r called with buflen biggerhan "

63 
__ftify_funi
 

64 
	`__NTH
 (
	$ame_r
 (
__fd
, *
__buf
, 
size_t
 
__bu
))

66 i(
	`__bos
 (
__buf
!(
size_t
) -1)

68 i(!
	`__but_cڡt_p
 (
__bu
))

69  
	`__ame_r_chk
 (
__fd
, 
__buf
, 
__bu
, 
	`__bos
 (__buf));

70 i(
__bu
 > 
	`__bos
 (
__buf
))

71  
	`__ame_r_chk_wn
 (
__fd
, 
__buf
, 
__bu
, 
	`__bos
 (__buf));

73  
	`__ame_r_s
 (
__fd
, 
__buf
, 
__bu
);

74 
	}
}

77 
	$__womb_chk
 (*
__s
, 
wch_t
 
__wch
, 
size_t
 
__bu
)

78 
__THROW
 
__wur
;

79 
	`__REDIRECT_NTH
 (
__womb_s
, (*
__s
, 
wch_t
 
__wch
),

80 
womb

__wur
;

82 
__ftify_funi
 
__wur
 

83 
	`__NTH
 (
	$womb
 (*
__s
, 
wch_t
 
__wch
))

88 
	#__STDLIB_MB_LEN_MAX
 16

	)

89 #i
defed
 
MB_LEN_MAX
 && MB_LEN_MAX !
__STDLIB_MB_LEN_MAX


92 i(
	`__bos
 (
__s
!(
size_t
-1 && 
__STDLIB_MB_LEN_MAX
 > __bos (__s))

93  
	`__womb_chk
 (
__s
, 
__wch
, 
	`__bos
 (__s));

94  
	`__womb_s
 (
__s
, 
__wch
);

95 
	}
}

98 
size_t
 
	$__mbowcs_chk
 (
wch_t
 *
__ri
 
__d
,

99 cڡ *
__ri
 
__c
,

100 
size_t
 
__n
, size_
__dn

__THROW
;

101 
size_t
 
	`__REDIRECT_NTH
 (
__mbowcs_s
,

102 (
wch_t
 *
__ri
 
__d
,

103 cڡ *
__ri
 
__c
,

104 
size_t
 
__n
), 
mbowcs
);

105 
size_t
 
	`__REDIRECT_NTH
 (
__mbowcs_chk_wn
,

106 (
wch_t
 *
__ri
 
__d
,

107 cڡ *
__ri
 
__c
,

108 
size_t
 
__n
, size_
__dn
), 
__mbowcs_chk
)

109 
	`__wǉr
 ("mbstowcs called with dst buffer smallerhanen "

112 
__ftify_funi
 
size_t


113 
	`__NTH
 (
	$mbowcs
 (
wch_t
 *
__ri
 
__d
, cڡ *__ri 
__c
,

114 
size_t
 
__n
))

116 i(
	`__bos
 (
__d
!(
size_t
) -1)

118 i(!
	`__but_cڡt_p
 (
__n
))

119  
	`__mbowcs_chk
 (
__d
, 
__c
, 
__n
,

120 
	`__bos
 (
__d
/  (
wch_t
));

122 i(
__n
 > 
	`__bos
 (
__d
/  (
wch_t
))

123  
	`__mbowcs_chk_wn
 (
__d
, 
__c
, 
__n
,

124 
	`__bos
 (
__d
/  (
wch_t
));

126  
	`__mbowcs_s
 (
__d
, 
__c
, 
__n
);

127 
	}
}

130 
size_t
 
	$__wcombs_chk
 (*
__ri
 
__d
,

131 cڡ 
wch_t
 *
__ri
 
__c
,

132 
size_t
 
__n
, size_
__dn

__THROW
;

133 
size_t
 
	`__REDIRECT_NTH
 (
__wcombs_s
,

134 (*
__ri
 
__d
,

135 cڡ 
wch_t
 *
__ri
 
__c
,

136 
size_t
 
__n
), 
wcombs
);

137 
size_t
 
	`__REDIRECT_NTH
 (
__wcombs_chk_wn
,

138 (*
__ri
 
__d
,

139 cڡ 
wch_t
 *
__ri
 
__c
,

140 
size_t
 
__n
, size_
__dn
), 
__wcombs_chk
)

141 
	`__wǉr
 ("wcstombs called with dst buffer smallerhanen");

143 
__ftify_funi
 
size_t


144 
	`__NTH
 (
	$wcombs
 (*
__ri
 
__d
, cڡ 
wch_t
 *__ri 
__c
,

145 
size_t
 
__n
))

147 i(
	`__bos
 (
__d
!(
size_t
) -1)

149 i(!
	`__but_cڡt_p
 (
__n
))

150  
	`__wcombs_chk
 (
__d
, 
__c
, 
__n
, 
	`__bos
 (__dst));

151 i(
__n
 > 
	`__bos
 (
__d
))

152  
	`__wcombs_chk_wn
 (
__d
, 
__c
, 
__n
, 
	`__bos
 (__dst));

154  
	`__wcombs_s
 (
__d
, 
__c
, 
__n
);

155 
	}
}

	@/usr/include/bits/string.h

19 #ide
_STRING_H


24 
	#_STRING_ARCH_uligd
 1

	)

28 #i!
defed
 
__x86_64__
 && (defed 
__i486__
 || defed 
__ium__
 \

29 || 
defed
 
	g__iumo__
 || defed 
	g__ium4__
 \

30 || 
defed
 
	g__noca__
 || defed 
	g__om__
 \

31 || 
defed
 
	g__ce2__
 || defed 
	g__cei7__
 \

32 || 
defed
 
	g__k6__
 || defed 
	g__geode__
 \

33 || 
defed
 
	g__k8__
 || defed 
	g__hl__
 \

34 || 
defed
 
	g__amdm10__
)

38 #i!
defed
 
__NO_STRING_INLINES
 && defed 
__USE_STRING_INLINES
 \

39 && 
defed
 
	g__GNUC__
 && __GNUC__ >= 2

41 #ide
__STRING_INLINE


42 #ide
__ex_le


43 
	#__STRING_INLINE
 
le


	)

45 
	#__STRING_INLINE
 
__ex_le


	)

50 
	#__STRING_SMALL_GET16
(
c
, 
idx
) \

51 ((((cڡ *(
c
))[
idx
 + 1] << 8) \

52 | ((cڡ *(
c
))[
idx
])

	)

53 
	#__STRING_SMALL_GET32
(
c
, 
idx
) \

54 (((((cڡ *(
c
))[
idx
 + 3] << 8 \

55 | ((cڡ *(
c
))[
idx
 + 2]) << 8 \

56 | ((cڡ *(
c
))[
idx
 + 1]) << 8 \

57 | ((cڡ *(
c
))[
idx
])

	)

61 
	#_HAVE_STRING_ARCH_memy
 1

	)

62 
	#memy
(
de
, 
c
, 
n
) \

63 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
n
) \

64 ? 
	`__memy_c
 ((
de
), (
c
), (
n
)) \

65 : 
	`__memy_g
 ((
de
), (
c
), (
n
))))

	)

66 
	#__memy_c
(
de
, 
c
, 
n
) \

67 ((
n
) == 0 \

68 ? (
de
) \

69 : (((
n
) % 4 == 0) \

70 ? 
	`__memy_by4
 (
de
, 
c
, 
n
) \

71 : (((
n
) % 2 == 0) \

72 ? 
	`__memy_by2
 (
de
, 
c
, 
n
) \

73 : 
	`__memy_g
 (
de
, 
c
, 
n
))))

	)

75 
__STRING_INLINE
 *
__memy_by4
 (*
__de
, cڡ *
__c
,

76 
size_t
 
__n
);

78 
__STRING_INLINE
 *

79 
	$__memy_by4
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
)

81 
__d0
, 
__d1
;

82 *
__tmp
 = 
__de
;

83 
__asm__
 
__vީe__


91 : "=&r" (
__d0
), "=&r" (
__tmp
), "=&r" (
__c
), "=&r" (
__d1
)

92 : "1" (
__tmp
), "2" (
__c
), "3" (
__n
 / 4)

94  
__de
;

95 
	}
}

97 
__STRING_INLINE
 *
__memy_by2
 (*
__de
, cڡ *
__c
,

98 
size_t
 
__n
);

100 
__STRING_INLINE
 *

101 
	$__memy_by2
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
)

103 
__d0
, 
__d1
;

104 *
__tmp
 = 
__de
;

105 
__asm__
 
__vީe__


118 : "=&q" (
__d0
), "=&r" (
__tmp
), "=&r" (
__c
), "=&r" (
__d1
)

119 : "1" (
__tmp
), "2" (
__c
), "3" (
__n
 / 2)

121  
__de
;

122 
	}
}

124 
__STRING_INLINE
 *
__memy_g
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
);

126 
__STRING_INLINE
 *

127 
	$__memy_g
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
)

129 
__d0
, 
__d1
, 
__d2
;

130 *
__tmp
 = 
__de
;

131 
__asm__
 
__vީe__


142 : "=&c" (
__d0
), "=&D" (
__d1
), "=&S" (
__d2
),

143 "=m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__de
)

144 : "0" (
__n
), "1" (
__tmp
), "2" (
__c
),

145 "m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__c
)

147  
__de
;

148 
	}
}

150 
	#_HAVE_STRING_ARCH_memmove
 1

	)

151 #ide
_FORCE_INLINES


154 
	#memmove
(
de
, 
c
, 
n

	`__memmove_g
 (de, src,)

	)

156 
__STRING_INLINE
 *
	$__memmove_g
 (*, cڡ *, 
size_t
)

157 
	`__asm__
 ("memmove");

159 
__STRING_INLINE
 *

160 
	$__memmove_g
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
)

162 
__d0
, 
__d1
, 
__d2
;

163 *
__tmp
 = 
__de
;

164 i(
__de
 < 
__c
)

165 
__asm__
 
__vީe__


168 : "=&c" (
__d0
), "=&S" (
__d1
), "=&D" (
__d2
),

169 "=m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__de
)

170 : "0" (
__n
), "1" (
__c
), "2" (
__tmp
),

171 "m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__c
));

173 
__asm__
 
__vީe__


177 : "=&c" (
__d0
), "=&S" (
__d1
), "=&D" (
__d2
),

178 "=m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__de
)

179 : "0" (
__n
), "1" (__- 1 + (cڡ *
__c
),

180 "2" (
__n
 - 1 + (*
__tmp
),

181 "m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__c
));

182  
__de
;

183 
	}
}

187 
	#_HAVE_STRING_ARCH_memcmp
 1

	)

188 #ide
_FORCE_INLINES


189 #ide
__PIC__


191 
__STRING_INLINE
 

192 
	$memcmp
 (cڡ *
__s1
, cڡ *
__s2
, 
size_t
 
__n
)

194 
__d0
, 
__d1
, 
__d2
;

195 
__s
;

196 
__asm__
 
__vީe__


204 : "=&a" (
__s
), "=&S" (
__d0
), "=&D" (
__d1
), "=&c" (
__d2
)

205 : "0" (0), "1" (
__s1
), "2" (
__s2
), "3" (
__n
),

206 "m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s1
),

207 "m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s2
)

209  
__s
;

210 
	}
}

215 
	#_HAVE_STRING_ARCH_memt
 1

	)

216 
	#_USE_STRING_ARCH_memt
 1

	)

217 
	#memt
(
s
, 
c
, 
n
) \

218 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
n
) && (n) <= 16 \

219 ? ((
n
) == 1 \

220 ? 
	`__memt_c1
 ((
s
), (
c
)) \

221 : 
	`__memt_gc
 ((
s
), (
c
), (
n
))) \

222 : (
	`__but_cڡt_p
 (
c
) \

223 ? (
	`__but_cڡt_p
 (
n
) \

224 ? 
	`__memt_c
 ((
s
), (
c
), (
n
)) \

225 : 
	`memt
 ((
s
), (
c
), (
n
))) \

226 : (
	`__but_cڡt_p
 (
n
) \

227 ? 
	`__memt_g
 ((
s
), (
c
), (
n
)) \

228 : 
	`memt
 ((
s
), (
c
), (
n
))))))

	)

230 
	#__memt_c1
(
s
, 
c
({ *
__s
 = (s); \

231 *((*
__s
((
c
); \

232 
__s
; })

	)

234 
	#__memt_gc
(
s
, 
c
, 
n
) \

235 ({ *
__s
 = (
s
); \

237 
__ui
; \

238 
__usi
; \

239 
__uc
; \

240 } *
__u
 = 
__s
; \

241 
__c
 = (((((
c
))) * 0x01010101; \

247 i((
n
) == 3 || (n) >= 5) \

248 
__asm__
 
	`__vީe__
 ("" : "" (
__c
) : "0" (__c)); \

251 
n
) \

254 
__u
->
__ui
 = 
__c
; \

255 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

257 
__u
->
__ui
 = 
__c
; \

258 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

260 
__u
->
__ui
 = 
__c
; \

261 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

263 
__u
->
__usi
 = (
__c
; \

264 
__u
 = 
	`__exnsi__
 ((*) __u + 2); \

265 
__u
->
__uc
 = (
__c
; \

269 
__u
->
__ui
 = 
__c
; \

270 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

272 
__u
->
__ui
 = 
__c
; \

273 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

275 
__u
->
__ui
 = 
__c
; \

276 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

278 
__u
->
__usi
 = (
__c
; \

282 
__u
->
__ui
 = 
__c
; \

283 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

285 
__u
->
__ui
 = 
__c
; \

286 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

288 
__u
->
__ui
 = 
__c
; \

289 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

291 
__u
->
__uc
 = (
__c
; \

295 
__u
->
__ui
 = 
__c
; \

296 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

298 
__u
->
__ui
 = 
__c
; \

299 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

301 
__u
->
__ui
 = 
__c
; \

302 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

304 
__u
->
__ui
 = 
__c
; \

309 
__s
; })

	)

311 
	#__memt_c
(
s
, 
c
, 
n
) \

312 (((
n
) % 4 == 0) \

313 ? 
	`__memt_c_by4
 (
s
, (((((
c
))) * 0x01010101,\

314 
n
) \

315 : (((
n
) % 2 == 0) \

316 ? 
	`__memt_c_by2
 (
s
, \

317 (((((
c
))) * 0x01010101,\

318 
n
) \

319 : 
	`memt
 (
s
, 
c
, 
n
)))

	)

321 
__STRING_INLINE
 *
__memt_c_by4
 (*
__s
, 
__c
,

322 
size_t
 
__n
);

324 
__STRING_INLINE
 *

325 
	$__memt_c_by4
 (*
__s
, 
__c
, 
size_t
 
__n
)

327 *
__tmp
 = 
__s
;

328 
__d0
;

329 #ifde
__i686__


330 
__asm__
 
__vީe__


333 : "=&a" (
__c
), "=&D" (
__tmp
), "=&c" (
__d0
),

334 "=m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s
)

335 : "0" ((
__c
), "1" (
__tmp
), "2" (
__n
 / 4)

338 
__asm__
 
__vީe__


344 : "=&r" (
__c
), "=&r" (
__tmp
), "=&r" (
__d0
),

345 "=m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s
)

346 : "0" ((
__c
), "1" (
__tmp
), "2" (
__n
 / 4)

349  
__s
;

350 
	}
}

352 
__STRING_INLINE
 *
__memt_c_by2
 (*
__s
, 
__c
,

353 
size_t
 
__n
);

355 
__STRING_INLINE
 *

356 
	$__memt_c_by2
 (*
__s
, 
__c
, 
size_t
 
__n
)

358 
__d0
, 
__d1
;

359 *
__tmp
 = 
__s
;

360 #ifde
__i686__


361 
__asm__
 
__vީe__


365 : "=&a" (
__d0
), "=&D" (
__tmp
), "=&c" (
__d1
),

366 "=m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s
)

367 : "0" ((
__c
), "1" (
__tmp
), "2" (
__n
 / 4)

370 
__asm__
 
__vީe__


376 : "=&q" (
__d0
), "=&r" (
__tmp
), "=&r" (
__d1
),

377 "=m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s
)

378 : "0" ((
__c
), "1" (
__tmp
), "2" (
__n
 / 4)

381  
__s
;

382 
	}
}

384 
	#__memt_g
(
s
, 
c
, 
n
) \

385 (((
n
) % 4 == 0) \

386 ? 
	`__memt_g_by4
 (
s
, 
c
, 
n
) \

387 : (((
n
) % 2 == 0) \

388 ? 
	`__memt_g_by2
 (
s
, 
c
, 
n
) \

389 : 
	`memt
 (
s
, 
c
, 
n
)))

	)

391 
__STRING_INLINE
 *
__memt_g_by4
 (*
__s
, 
__c
, 
size_t
 
__n
);

393 
__STRING_INLINE
 *

394 
	$__memt_g_by4
 (*
__s
, 
__c
, 
size_t
 
__n
)

396 *
__tmp
 = 
__s
;

397 
__d0
;

398 
__asm__
 
__vީe__


408 : "=&q" (
__c
), "=&r" (
__tmp
), "=&r" (
__d0
),

409 "=m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s
)

410 : "0" ((
__c
), "1" (
__tmp
), "2" (
__n
 / 4)

412  
__s
;

413 
	}
}

415 
__STRING_INLINE
 *
__memt_g_by2
 (*
__s
, 
__c
, 
size_t
 
__n
);

417 
__STRING_INLINE
 *

418 
	$__memt_g_by2
 (*
__s
, 
__c
, 
size_t
 
__n
)

420 
__d0
, 
__d1
;

421 *
__tmp
 = 
__s
;

422 
__asm__
 
__vީe__


433 : "=&q" (
__d0
), "=&r" (
__tmp
), "=&r" (
__d1
),

434 "=m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s
)

435 : "0" ((
__c
), "1" (
__tmp
), "2" (
__n
 / 4)

437  
__s
;

438 
	}
}

442 
	#_HAVE_STRING_ARCH_memchr
 1

	)

443 #ide
_FORCE_INLINES


444 
__STRING_INLINE
 *

445 
	$memchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n
)

447 
__d0
;

448 #ifde
__i686__


449 
__d1
;

451 *
__s
;

452 i(
__n
 == 0)

453  
NULL
;

454 #ifde
__i686__


455 
__asm__
 
__vީe__


459 : "=D" (
__s
), "=&c" (
__d0
), "=&r" (
__d1
)

460 : "a" (
__c
), "0" (
__s
), "1" (
__n
), "2" (1),

461 "m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s
)

464 
__asm__
 
__vީe__


470 : "=D" (
__s
), "=&c" (
__d0
)

471 : "a" (
__c
), "0" (
__s
), "1" (
__n
),

472 "m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s
)

475  
__s
 - 1;

476 
	}
}

479 
	#_HAVE_STRING_ARCH_memrchr
 1

	)

480 #ide
_FORCE_INLINES


481 
__STRING_INLINE
 *
__memrchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n
);

483 
__STRING_INLINE
 *

484 
	$__memrchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n
)

486 
__d0
;

487 #ifde
__i686__


488 
__d1
;

490 *
__s
;

491 i(
__n
 == 0)

492  
NULL
;

493 #ifde
__i686__


494 
__asm__
 
__vީe__


500 : "=D" (
__s
), "=&c" (
__d0
), "=&r" (
__d1
)

501 : "a" (
__c
), "0" (
__s
 + 
__n
 - 1), "1" (__n), "2" (-1),

502 "m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s
)

505 
__asm__
 
__vީe__


512 : "=D" (
__s
), "=&c" (
__d0
)

513 : "a" (
__c
), "0" (
__s
 + 
__n
 - 1), "1" (__n),

514 "m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s
)

517  
__s
;

518 
	}
}

519 #ifde
__USE_GNU


520 
	#memrchr
(
s
, 
c
, 
n

	`__memrchr
 ((s), (c), (n))

	)

525 
	#_HAVE_STRING_ARCH_wmemchr
 1

	)

526 
__STRING_INLINE
 *
__wmemchr
 (cڡ *
__s
, 
__c
);

528 #ide
_FORCE_INLINES


529 
__STRING_INLINE
 *

530 
	$__wmemchr
 (cڡ *
__s
, 
__c
)

532 
__d0
;

533 *
__s
;

534 
__asm__
 
__vީe__


537 : "=D" (
__s
), "=&c" (
__d0
)

538 : "a" (
__c
), "0" (
__s
), "1" (0xffffffff),

539 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s
)

541  
__s
 - 1;

542 
	}
}

543 #ifde
__USE_GNU


544 
__STRING_INLINE
 *

545 
	$wmemchr
 (cڡ *
__s
, 
__c
)

547  
	`__wmemchr
 (
__s
, 
__c
);

548 
	}
}

554 
	#_HAVE_STRING_ARCH_
 1

	)

555 
	#
(
r
) \

556 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
r
) \

557 ? 
	`__but_
 (
r
) \

558 : 
	`___g
 (
r
)))

	)

559 
__STRING_INLINE
 
size_t
 
___g
 (cڡ *
__r
);

561 
__STRING_INLINE
 
size_t


562 
	$___g
 (cڡ *
__r
)

564 
__dummy
;

565 cڡ *
__tmp
 = 
__r
;

566 
__asm__
 
__vީe__


572 : "" (
__tmp
), "=&q" (
__dummy
)

573 : "0" (
__r
),

574 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__r
)

576  
__tmp
 - 
__r
 - 1;

577 
	}
}

581 
	#_HAVE_STRING_ARCH_ry
 1

	)

582 
	#ry
(
de
, 
c
) \

583 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) \

584 ? ( ((
c
)[0]=1 && 
	`
 (src) + 1 <= 8 \

585 ? 
	`__ry_a_sml
 ((
de
), (
c
), 
	`
 (src) + 1) \

586 : (*
	`memy
 ((*(
de
), \

587 (cڡ *(
c
), \

588 
	`
 (
c
) + 1)) \

589 : 
	`__ry_g
 ((
de
), (
c
))))

	)

591 
	#__ry_a_sml
(
de
, 
c
, 

) \

592 (
	`__exnsi__
 ({ *
__de
 = (
de
); \

594 
__ui
; \

595 
__usi
; \

596 
__uc
; \

597 
__c
; \

598 } *
__u
 = (*
__de
; \

599 

) \

602 
__u
->
__uc
 = '\0'; \

605 
__u
->
__usi
 = 
	`__STRING_SMALL_GET16
 (
c
, 0); \

608 
__u
->
__usi
 = 
	`__STRING_SMALL_GET16
 (
c
, 0); \

609 
__u
 = 
	`__exnsi__
 ((*) __u + 2); \

610 
__u
->
__uc
 = '\0'; \

613 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
c
, 0); \

616 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
c
, 0); \

617 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

618 
__u
->
__uc
 = '\0'; \

621 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
c
, 0); \

622 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

623 
__u
->
__usi
 = 
	`__STRING_SMALL_GET16
 (
c
, 4); \

626 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
c
, 0); \

627 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

628 
__u
->
__usi
 = 
	`__STRING_SMALL_GET16
 (
c
, 4); \

629 
__u
 = 
	`__exnsi__
 ((*) __u + 2); \

630 
__u
->
__uc
 = '\0'; \

633 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
c
, 0); \

634 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

635 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
c
, 4); \

638 (*
__de
; }))

	)

640 
__STRING_INLINE
 *
__ry_g
 (*
__de
, cڡ *
__c
);

642 
__STRING_INLINE
 *

643 
	$__ry_g
 (*
__de
, cڡ *
__c
)

645 *
__tmp
 = 
__de
;

646 
__dummy
;

647 
__asm__
 
__vީe__


656 : "=&r" (
__c
), "=&r" (
__tmp
), "=&q" (
__dummy
),

657 "=m" ( *(ru { 
__x
[0xfffffff]; } *)
__de
)

658 : "0" (
__c
), "1" (
__tmp
),

659 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__c
)

661  
__de
;

662 
	}
}

665 #ifde
__USE_GNU


666 
	#_HAVE_STRING_ARCH_py
 1

	)

668 
	#__py
(
de
, 
c
) \

669 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) \

670 ? (
	`
 (
c
) + 1 <= 8 \

671 ? 
	`__py_a_sml
 ((
de
), (
c
), 
	`
 (src) + 1) \

672 : 
	`__py_c
 ((
de
), (
c
), 
	`
 (src) + 1)) \

673 : 
	`__py_g
 ((
de
), (
c
))))

	)

674 
	#__py_c
(
de
, 
c
, 

) \

675 ((

) % 4 == 0 \

676 ? 
	`__mempy_by4
 (
de
, 
c
, 

) - 1 \

677 : ((

) % 2 == 0 \

678 ? 
	`__mempy_by2
 (
de
, 
c
, 

) - 1 \

679 : 
	`__mempy_byn
 (
de
, 
c
, 

- 1))

	)

682 
	#py
(
de
, 
c

	`__py
 ((de), (c))

	)

684 
	#__py_a_sml
(
de
, 
c
, 

) \

685 (
	`__exnsi__
 ({ union { \

686 
__ui
; \

687 
__usi
; \

688 
__uc
; \

689 
__c
; \

690 } *
__u
 = (*(
de
); \

691 

) \

694 
__u
->
__uc
 = '\0'; \

697 
__u
->
__usi
 = 
	`__STRING_SMALL_GET16
 (
c
, 0); \

698 
__u
 = 
	`__exnsi__
 ((*) __u + 1); \

701 
__u
->
__usi
 = 
	`__STRING_SMALL_GET16
 (
c
, 0); \

702 
__u
 = 
	`__exnsi__
 ((*) __u + 2); \

703 
__u
->
__uc
 = '\0'; \

706 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
c
, 0); \

707 
__u
 = 
	`__exnsi__
 ((*) __u + 3); \

710 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
c
, 0); \

711 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

712 
__u
->
__uc
 = '\0'; \

715 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
c
, 0); \

716 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

717 
__u
->
__usi
 = 
	`__STRING_SMALL_GET16
 (
c
, 4); \

718 
__u
 = 
	`__exnsi__
 ((*) __u + 1); \

721 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
c
, 0); \

722 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

723 
__u
->
__usi
 = 
	`__STRING_SMALL_GET16
 (
c
, 4); \

724 
__u
 = 
	`__exnsi__
 ((*) __u + 2); \

725 
__u
->
__uc
 = '\0'; \

728 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
c
, 0); \

729 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

730 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
c
, 4); \

731 
__u
 = 
	`__exnsi__
 ((*) __u + 3); \

734 (*
__u
; }))

	)

736 
__STRING_INLINE
 *
__mempy_by4
 (*
__de
, cڡ *
__c
,

737 
size_t
 
__
);

739 
__STRING_INLINE
 *

740 
	$__mempy_by4
 (*
__de
, cڡ *
__c
, 
size_t
 
__
)

742 *
__tmp
 = 
__de
;

743 
__d0
, 
__d1
;

744 
__asm__
 
__vީe__


752 : "=&r" (
__d0
), "" (
__tmp
), "=&r" (
__c
), "=&r" (
__d1
)

753 : "1" (
__tmp
), "2" (
__c
), "3" (
__
 / 4)

755  
__tmp
;

756 
	}
}

758 
__STRING_INLINE
 *
__mempy_by2
 (*
__de
, cڡ *
__c
,

759 
size_t
 
__
);

761 
__STRING_INLINE
 *

762 
	$__mempy_by2
 (*
__de
, cڡ *
__c
, 
size_t
 
__
)

764 *
__tmp
 = 
__de
;

765 
__d0
, 
__d1
;

766 
__asm__
 
__vީe__


779 : "=&q" (
__d0
), "" (
__tmp
), "=&r" (
__c
), "=&r" (
__d1
),

780 "=m" ( *(ru { 
__exnsi__
 
__x
[
__
]; } *)
__de
)

781 : "1" (
__tmp
), "2" (
__c
), "3" (
__
 / 2),

782 "m" ( *(ru { 
__exnsi__
 
__x
[
__
]; } *)
__c
)

784  
__tmp
 + 2;

785 
	}
}

787 
__STRING_INLINE
 *
__mempy_byn
 (*
__de
, cڡ *
__c
,

788 
size_t
 
__
);

790 
__STRING_INLINE
 *

791 
	$__mempy_byn
 (*
__de
, cڡ *
__c
, 
size_t
 
__
)

793 
__d0
, 
__d1
;

794 *
__tmp
 = 
__de
;

795 
__asm__
 
__vީe__


806 : "=D" (
__tmp
), "=&c" (
__d0
), "=&S" (
__d1
),

807 "=m" ( *(ru { 
__exnsi__
 
__x
[
__
]; } *)
__de
)

808 : "0" (
__tmp
), "1" (
__
), "2" (
__c
),

809 "m" ( *(ru { 
__exnsi__
 
__x
[
__
]; } *)
__c
)

811  
__tmp
;

812 
	}
}

814 
__STRING_INLINE
 *
__py_g
 (*
__de
, cڡ *
__c
);

816 
__STRING_INLINE
 *

817 
	$__py_g
 (*
__de
, cڡ *
__c
)

819 *
__tmp
 = 
__de
;

820 
__dummy
;

821 
__asm__
 
__vީe__


830 : "=&r" (
__c
), "" (
__tmp
), "=&q" (
__dummy
),

831 "=m" ( *(ru { 
__x
[0xfffffff]; } *)
__de
)

832 : "0" (
__c
), "1" (
__tmp
),

833 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__c
)

835  
__tmp
 - 1;

836 
	}
}

841 
	#_HAVE_STRING_ARCH_y
 1

	)

842 
	#y
(
de
, 
c
, 
n
) \

843 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) \

844 ? ((
	`
 (
c
+ 1 >((
size_t
(
n
)) \

845 ? (*
	`memy
 ((*(
de
), \

846 (cڡ *(
c
), 
n
) \

847 : 
	`__y_cg
 ((
de
), (
c
), 
	`
 (c+ 1, 
n
))) \

848 : 
	`__y_gg
 ((
de
), (
c
), 
n
)))

	)

849 
	#__y_cg
(
de
, 
c
, 

, 
n
) \

850 (((

) % 4 == 0) \

851 ? 
	`__y_by4
 (
de
, 
c
, 

, 
n
) \

852 : (((

) % 2 == 0) \

853 ? 
	`__y_by2
 (
de
, 
c
, 

, 
n
) \

854 : 
	`__y_byn
 (
de
, 
c
, 

, 
n
)))

	)

856 
__STRING_INLINE
 *
__y_by4
 (*
__de
, cڡ 
__c
[],

857 
size_t
 
__
, size_
__n
);

859 
__STRING_INLINE
 *

860 
	$__y_by4
 (*
__de
, cڡ 
__c
[], 
size_t
 
__
, size_
__n
)

862 *
__tmp
 = 
__de
;

863 
__dummy1
, 
__dummy2
;

864 
__asm__
 
__vީe__


872 : "=&r" (
__dummy1
), "" (
__tmp
), "=&r" (
__c
), "=&r" (
__dummy2
),

873 "=m" ( *(ru { 
__exnsi__
 
__x
[
__
]; } *)
__de
)

874 : "1" (
__tmp
), "2" (
__c
), "3" (
__
 / 4),

875 "m" ( *(ru { 
__exnsi__
 
__x
[
__
]; } *)
__c
)

877 (
	`memt
 (
__tmp
, '\0', 
__n
 - 
__
);

878  
__de
;

879 
	}
}

881 
__STRING_INLINE
 *
__y_by2
 (*
__de
, cڡ 
__c
[],

882 
size_t
 
__
, size_
__n
);

884 
__STRING_INLINE
 *

885 
	$__y_by2
 (*
__de
, cڡ 
__c
[], 
size_t
 
__
, size_
__n
)

887 *
__tmp
 = 
__de
;

888 
__dummy1
, 
__dummy2
;

889 
__asm__
 
__vީe__


902 : "=&q" (
__dummy1
), "" (
__tmp
), "=&r" (
__c
), "=&r" (
__dummy2
),

903 "=m" ( *(ru { 
__exnsi__
 
__x
[
__
]; } *)
__de
)

904 : "1" (
__tmp
), "2" (
__c
), "3" (
__
 / 2),

905 "m" ( *(ru { 
__exnsi__
 
__x
[
__
]; } *)
__c
)

907 (
	`memt
 (
__tmp
 + 2, '\0', 
__n
 - 
__
);

908  
__de
;

909 
	}
}

911 
__STRING_INLINE
 *
__y_byn
 (*
__de
, cڡ 
__c
[],

912 
size_t
 
__
, size_
__n
);

914 
__STRING_INLINE
 *

915 
	$__y_byn
 (*
__de
, cڡ 
__c
[], 
size_t
 
__
, size_
__n
)

917 
__d0
, 
__d1
;

918 *
__tmp
 = 
__de
;

919 
__asm__
 
__vީe__


930 : "=D" (
__tmp
), "=&c" (
__d0
), "=&S" (
__d1
),

931 "=m" ( *(ru { 
__exnsi__
 
__x
[
__
]; } *)
__de
)

932 : "1" (
__
), "0" (
__tmp
),"2" (
__c
),

933 "m" ( *(ru { 
__exnsi__
 
__x
[
__
]; } *)
__c
)

935 (
	`memt
 (
__tmp
, '\0', 
__n
 - 
__
);

936  
__de
;

937 
	}
}

939 
__STRING_INLINE
 *
__y_gg
 (*
__de
, cڡ *
__c
,

940 
size_t
 
__n
);

942 
__STRING_INLINE
 *

943 
	$__y_gg
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
)

945 *
__tmp
 = 
__de
;

946 
__dummy
;

947 i(
__n
 > 0)

948 
__asm__
 
__vީe__


964 : "=&r" (
__c
), "=&r" (
__tmp
), "=&q" (
__dummy
), "=&r" (
__n
)

965 : "0" (
__c
), "1" (
__tmp
), "3" (
__n
)

968  
__de
;

969 
	}
}

973 
	#_HAVE_STRING_ARCH_rt
 1

	)

974 
	#rt
(
de
, 
c
) \

975 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) \

976 ? 
	`__rt_c
 ((
de
), (
c
), 
	`
 (src) + 1) \

977 : 
	`__rt_g
 ((
de
), (
c
))))

	)

979 
__STRING_INLINE
 *
__rt_c
 (*
__de
, cڡ 
__c
[],

980 
size_t
 
__
);

982 
__STRING_INLINE
 *

983 
	$__rt_c
 (*
__de
, cڡ 
__c
[], 
size_t
 
__
)

985 #ifde
__i686__


986 
__d0
;

987 *
__tmp
;

988 
__asm__
 
__vީe__


990 : "=D" (
__tmp
), "=&c" (
__d0
),

991 "=m" ( *(ru { 
__x
[0xfffffff]; } *)
__de
)

992 : "0" (
__de
), "1" (0xffffffff), "a" (0),

993 "m" ( *(ru { 
__exnsi__
 
__x
[
__
]; } *)
__c
)

995 --
__tmp
;

997 *
__tmp
 = 
__de
 - 1;

998 
__asm__
 
__vީe__


1003 : "" (
__tmp
),

1004 "=m" ( *(ru { 
__x
[0xfffffff]; } *)
__de
)

1005 : "0" (
__tmp
),

1006 "m" ( *(ru { 
__exnsi__
 
__x
[
__
]; } *)
__c
)

1009 (
	`memy
 (
__tmp
, 
__c
, 
__
);

1010  
__de
;

1011 
	}
}

1013 
__STRING_INLINE
 *
__rt_g
 (*
__de
, cڡ *
__c
);

1015 
__STRING_INLINE
 *

1016 
	$__rt_g
 (*
__de
, cڡ *
__c
)

1018 *
__tmp
 = 
__de
 - 1;

1019 
__dummy
;

1020 
__asm__
 
__vީe__


1032 : "=&q" (
__dummy
), "=&r" (
__tmp
), "=&r" (
__c
),

1033 "=m" ( *(ru { 
__x
[0xfffffff]; } *)
__de
)

1034 : "1" (
__tmp
), "2" (
__c
),

1035 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__c
)

1037  
__de
;

1038 
	}
}

1042 
	#_HAVE_STRING_ARCH_t
 1

	)

1043 
	#t
(
de
, 
c
, 
n
) \

1044 (
	`__exnsi__
 ({ *
__de
 = (
de
); \

1045 
	`__but_cڡt_p
 (
c
&& __but_cڡt_(
n
) \

1046 ? (
	`
 (
c
< ((
size_t
(
n
)) \

1047 ? 
	`rt
 (
__de
, (
c
)) \

1048 : (*(*)
	`__mempy
 (
	`rchr
 (
__de
, '\0'), \

1049 (cڡ *(
c
), \

1050 (
n
)0, 
__de
)) \

1051 : 
	`__t_g
 (
__de
, (
c
), (
n
)); }))

	)

1053 
__STRING_INLINE
 *
__t_g
 (*
__de
, cڡ 
__c
[],

1054 
size_t
 
__n
);

1056 
__STRING_INLINE
 *

1057 
	$__t_g
 (*
__de
, cڡ 
__c
[], 
size_t
 
__n
)

1059 *
__tmp
 = 
__de
;

1060 
__dummy
;

1061 #ifde
__i686__


1062 
__asm__
 
__vީe__


1076 : "=&a" (
__dummy
), "=&D" (
__tmp
), "=&S" (
__c
), "=&c" (
__n
)

1077 : "g" (
__n
), "0" (0), "1" (
__tmp
), "2" (
__c
), "3" (0xffffffff)

1080 --
__tmp
;

1081 
__asm__
 
__vީe__


1098 : "=&q" (
__dummy
), "=&r" (
__tmp
), "=&r" (
__c
), "=&r" (
__n
)

1099 : "1" (
__tmp
), "2" (
__c
), "3" (
__n
)

1102  
__de
;

1103 
	}
}

1107 
	#_HAVE_STRING_ARCH_rcmp
 1

	)

1108 
	#rcmp
(
s1
, 
s2
) \

1109 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
s1
&& __but_cڡt_(
s2
) \

1110 && ( ((
s1
)[0]!1 || 
	`
 (s1) >= 4) \

1111 && ( ((
s2
)[0]!1 || 
	`
 (s2) >= 4) \

1112 ? 
	`memcmp
 ((cڡ *(
s1
), (cڡ *(
s2
), \

1113 (
	`
 (
s1
< s(
s2
) \

1114 ? 
	`
 (
s1
: s(
s2
)) + 1) \

1115 : (
	`__but_cڡt_p
 (
s1
) &&  ((s1)[0]) == 1 \

1116 &&  ((
s2
)[0]=1 && 
	`
 (
s1
) < 4 \

1117 ? (
	`__but_cڡt_p
 (
s2
) &&  ((s2)[0]) == 1 \

1118 ? 
	`__rcmp_cc
 ((cڡ *(
s1
), \

1119 (cڡ *(
s2
), \

1120 
	`
 (
s1
)) \

1121 : 
	`__rcmp_cg
 ((cڡ *(
s1
), \

1122 (cڡ *(
s2
), \

1123 
	`
 (
s1
))) \

1124 : (
	`__but_cڡt_p
 (
s2
&&  ((
s1
)[0]) == 1 \

1125 &&  ((
s2
)[0]=1 && 
	`
 (s2) < 4 \

1126 ? (
	`__but_cڡt_p
 (
s1
) \

1127 ? 
	`__rcmp_cc
 ((cڡ *(
s1
), \

1128 (cڡ *(
s2
), \

1129 
	`
 (
s2
)) \

1130 : 
	`__rcmp_gc
 ((cڡ *(
s1
), \

1131 (cڡ *(
s2
), \

1132 
	`
 (
s2
))) \

1133 : 
	`__rcmp_gg
 ((
s1
), (
s2
))))))

	)

1135 
	#__rcmp_cc
(
s1
, 
s2
, 
l
) \

1136 (
	`__exnsi__
 ({ 
__su
 = (
s1
)[0] - (
s2
)[0]; \

1137 i(
l
 > 0 && 
__su
 == 0) \

1139 
__su
 = (
s1
)[1] - (
s2
)[1]; \

1140 i(
l
 > 1 && 
__su
 == 0) \

1142 
__su
 = (
s1
)[2] - (
s2
)[2]; \

1143 i(
l
 > 2 && 
__su
 == 0) \

1144 
__su
 = (
s1
)[3] - (
s2
)[3]; \

1147 
__su
; }))

	)

1149 
	#__rcmp_cg
(
s1
, 
s2
, 
l1
) \

1150 (
	`__exnsi__
 ({ cڡ *
__s2
 = (
s2
); \

1151 
__su
 = (
s1
)[0] - 
__s2
[0]; \

1152 i(
l1
 > 0 && 
__su
 == 0) \

1154 
__su
 = (
s1
)[1] - 
__s2
[1]; \

1155 i(
l1
 > 1 && 
__su
 == 0) \

1157 
__su
 = (
s1
)[2] - 
__s2
[2]; \

1158 i(
l1
 > 2 && 
__su
 == 0) \

1159 
__su
 = (
s1
)[3] - 
__s2
[3]; \

1162 
__su
; }))

	)

1164 
	#__rcmp_gc
(
s1
, 
s2
, 
l2
) \

1165 (
	`__exnsi__
 ({ cڡ *
__s1
 = (
s1
); \

1166 
__su
 = 
__s1
[0] - (
s2
)[0]; \

1167 i(
l2
 > 0 && 
__su
 == 0) \

1169 
__su
 = 
__s1
[1] - (
s2
)[1]; \

1170 i(
l2
 > 1 && 
__su
 == 0) \

1172 
__su
 = 
__s1
[2] - (
s2
)[2]; \

1173 i(
l2
 > 2 && 
__su
 == 0) \

1174 
__su
 = 
__s1
[3] - (
s2
)[3]; \

1177 
__su
; }))

	)

1179 
__STRING_INLINE
 
__rcmp_gg
 (cڡ *
__s1
, cڡ *
__s2
);

1181 
__STRING_INLINE
 

1182 
	$__rcmp_gg
 (cڡ *
__s1
, cڡ *
__s2
)

1184 
__s
;

1185 
__asm__
 
__vީe__


1201 : "=q" (
__s
), "=&r" (
__s1
), "=&r" (
__s2
)

1202 : "1" (
__s1
), "2" (
__s2
),

1203 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s1
),

1204 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s2
)

1206  
__s
;

1207 
	}
}

1211 
	#_HAVE_STRING_ARCH_cmp
 1

	)

1212 
	#cmp
(
s1
, 
s2
, 
n
) \

1213 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
s1
&& 
	`
 (s1< ((
size_t
(
n
)) \

1214 ? 
	`rcmp
 ((
s1
), (
s2
)) \

1215 : (
	`__but_cڡt_p
 (
s2
&& 
	`
 (s2< ((
size_t
(
n
))\

1216 ? 
	`rcmp
 ((
s1
), (
s2
)) \

1217 : 
	`__cmp_g
 ((
s1
), (
s2
), (
n
)))))

	)

1219 
__STRING_INLINE
 
__cmp_g
 (cڡ *
__s1
, cڡ *
__s2
,

1220 
size_t
 
__n
);

1222 
__STRING_INLINE
 

1223 
	$__cmp_g
 (cڡ *
__s1
, cڡ *
__s2
, 
size_t
 
__n
)

1225 
__s
;

1226 
__asm__
 
__vީe__


1245 : "=q" (
__s
), "=&r" (
__s1
), "=&r" (
__s2
), "=&r" (
__n
)

1246 : "1" (
__s1
), "2" (
__s2
), "3" (
__n
),

1247 "m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s1
),

1248 "m" ( *(ru { 
__exnsi__
 
__x
[
__n
]; } *)
__s2
)

1250  
__s
;

1251 
	}
}

1255 
	#_HAVE_STRING_ARCH_rchr
 1

	)

1256 
	#_USE_STRING_ARCH_rchr
 1

	)

1257 
	#rchr
(
s
, 
c
) \

1258 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) \

1259 ? ((
c
) == '\0' \

1260 ? (*
	`__wmemchr
 ((
s
), (
c
)) \

1261 : 
	`__rchr_c
 ((
s
), ((
c
) & 0xff) << 8)) \

1262 : 
	`__rchr_g
 ((
s
), (
c
))))

	)

1264 
__STRING_INLINE
 *
__rchr_c
 (cڡ *
__s
, 
__c
);

1266 
__STRING_INLINE
 *

1267 
	$__rchr_c
 (cڡ *
__s
, 
__c
)

1269 
__d0
;

1270 *
__s
;

1271 
__asm__
 
__vީe__


1281 : "" (
__s
), "=&a" (
__d0
)

1282 : "0" (
__s
), "1" (
__c
),

1283 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s
)

1285  
__s
;

1286 
	}
}

1288 
__STRING_INLINE
 *
__rchr_g
 (cڡ *
__s
, 
__c
);

1290 
__STRING_INLINE
 *

1291 
	$__rchr_g
 (cڡ *
__s
, 
__c
)

1293 
__d0
;

1294 *
__s
;

1295 
__asm__
 
__vީe__


1306 : "" (
__s
), "=&a" (
__d0
)

1307 : "0" (
__s
), "1" (
__c
),

1308 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s
)

1310  
__s
;

1311 
	}
}

1315 
	#_HAVE_STRING_ARCH_rchul
 1

	)

1316 
	#__rchul
(
s
, 
c
) \

1317 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) \

1318 ? ((
c
) == '\0' \

1319 ? (*
	`__wmemchr
 ((
s
), 
c
) \

1320 : 
	`__rchul_c
 ((
s
), ((
c
) & 0xff) << 8)) \

1321 : 
	`__rchul_g
 ((
s
), 
c
)))

	)

1323 
__STRING_INLINE
 *
__rchul_c
 (cڡ *
__s
, 
__c
);

1325 
__STRING_INLINE
 *

1326 
	$__rchul_c
 (cڡ *
__s
, 
__c
)

1328 
__d0
;

1329 *
__s
;

1330 
__asm__
 
__vީe__


1340 : "" (
__s
), "=&a" (
__d0
)

1341 : "0" (
__s
), "1" (
__c
),

1342 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s
)

1344  
__s
;

1345 
	}
}

1347 
__STRING_INLINE
 *
__rchul_g
 (cڡ *
__s
, 
__c
);

1349 
__STRING_INLINE
 *

1350 
	$__rchul_g
 (cڡ *
__s
, 
__c
)

1352 
__d0
;

1353 *
__s
;

1354 
__asm__
 
__vީe__


1365 : "" (
__s
), "=&a" (
__d0
)

1366 : "0" (
__s
), "1" (
__c
),

1367 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s
)

1369  
__s
;

1370 
	}
}

1371 #ifde
__USE_GNU


1372 
	#rchul
(
s
, 
c

	`__rchul
 ((s), (c))

	)

1376 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


1378 
	#_HAVE_STRING_ARCH_dex
 1

	)

1379 
	#dex
(
s
, 
c
) \

1380 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) \

1381 ? 
	`__rchr_c
 ((
s
), ((
c
) & 0xff) << 8) \

1382 : 
	`__rchr_g
 ((
s
), (
c
))))

	)

1387 
	#_HAVE_STRING_ARCH_chr
 1

	)

1388 
	#chr
(
s
, 
c
) \

1389 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) \

1390 ? 
	`__chr_c
 ((
s
), ((
c
) & 0xff) << 8) \

1391 : 
	`__chr_g
 ((
s
), (
c
))))

	)

1393 #ifde
__i686__


1394 
__STRING_INLINE
 *
__chr_c
 (cڡ *
__s
, 
__c
);

1396 
__STRING_INLINE
 *

1397 
	$__chr_c
 (cڡ *
__s
, 
__c
)

1399 
__d0
, 
__d1
;

1400 *
__s
;

1401 
__asm__
 
__vީe__


1409 : "=d" (
__s
), "=&S" (
__d0
), "=&a" (
__d1
)

1410 : "0" (1), "1" (
__s
), "2" (
__c
),

1411 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s
)

1413  
__s
 - 1;

1414 
	}
}

1416 
__STRING_INLINE
 *
__chr_g
 (cڡ *
__s
, 
__c
);

1418 
__STRING_INLINE
 *

1419 
	$__chr_g
 (cڡ *
__s
, 
__c
)

1421 
__d0
, 
__d1
;

1422 *
__s
;

1423 
__asm__
 
__vީe__


1432 : "=d" (
__s
), "=&S" (
__d0
), "=&a" (
__d1
)

1433 : "0" (1), "1" (
__s
), "2" (
__c
),

1434 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s
)

1436  
__s
 - 1;

1437 
	}
}

1439 
__STRING_INLINE
 *
__chr_c
 (cڡ *
__s
, 
__c
);

1441 
__STRING_INLINE
 *

1442 
	$__chr_c
 (cڡ *
__s
, 
__c
)

1444 
__d0
, 
__d1
;

1445 *
__s
;

1446 
__asm__
 
__vީe__


1456 : "=d" (
__s
), "=&S" (
__d0
), "=&a" (
__d1
)

1457 : "0" (0), "1" (
__s
), "2" (
__c
),

1458 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s
)

1460  
__s
;

1461 
	}
}

1463 
__STRING_INLINE
 *
__chr_g
 (cڡ *
__s
, 
__c
);

1465 
__STRING_INLINE
 *

1466 
	$__chr_g
 (cڡ *
__s
, 
__c
)

1468 
__d0
, 
__d1
;

1469 *
__s
;

1470 
__asm__
 
__vީe__


1481 : "" (
__s
), "=&S" (
__d0
), "=&a" (
__d1
)

1482 : "0" (0), "1" (
__s
), "2" (
__c
),

1483 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s
)

1485  
__s
;

1486 
	}
}

1490 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


1492 
	#_HAVE_STRING_ARCH_rdex
 1

	)

1493 
	#rdex
(
s
, 
c
) \

1494 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) \

1495 ? 
	`__chr_c
 ((
s
), ((
c
) & 0xff) << 8) \

1496 : 
	`__chr_g
 ((
s
), (
c
))))

	)

1502 
	#_HAVE_STRING_ARCH_rcn
 1

	)

1503 
	#rcn
(
s
, 
je
) \

1504 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
je
) &&  ((reject)[0]) == 1 \

1505 ? ((
je
)[0] == '\0' \

1506 ? 
	`
 (
s
) \

1507 : ((
je
)[1] == '\0' \

1508 ? 
	`__rcn_c1
 ((
s
), (((
je
)[0] << 8) & 0xff00)) \

1509 : 
	`__rcn_cg
 ((
s
), (
je
), 
	`
 (reject)))) \

1510 : 
	`__rcn_g
 ((
s
), (
je
))))

	)

1512 
__STRING_INLINE
 
size_t
 
__rcn_c1
 (cڡ *
__s
, 
__je
);

1514 #ide
_FORCE_INLINES


1515 
__STRING_INLINE
 
size_t


1516 
	$__rcn_c1
 (cڡ *
__s
, 
__je
)

1518 
__d0
;

1519 *
__s
;

1520 
__asm__
 
__vީe__


1529 : "" (
__s
), "=&a" (
__d0
)

1530 : "0" (
__s
), "1" (
__je
),

1531 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s
)

1533  (
__s
 - 1- 
__s
;

1534 
	}
}

1537 
__STRING_INLINE
 
size_t
 
__rcn_cg
 (cڡ *
__s
, cڡ 
__je
[],

1538 
size_t
 
__je_n
);

1540 
__STRING_INLINE
 
size_t


1541 
	$__rcn_cg
 (cڡ *
__s
, cڡ 
__je
[], 
size_t
 
__je_n
)

1543 
__d0
, 
__d1
, 
__d2
;

1544 cڡ *
__s
;

1545 
__asm__
 
__vީe__


1556 : "=S" (
__s
), "=&a" (
__d0
), "=&c" (
__d1
), "=&D" (
__d2
)

1557 : "0" (
__s
), "d" (
__je
), "g" (
__je_n
)

1559  (
__s
 - 1- 
__s
;

1560 
	}
}

1562 
__STRING_INLINE
 
size_t
 
__rcn_g
 (cڡ *
__s
, cڡ *
__je
);

1563 #ifde
__PIC__


1565 
__STRING_INLINE
 
size_t


1566 
	$__rcn_g
 (cڡ *
__s
, cڡ *
__je
)

1568 
__d0
, 
__d1
, 
__d2
;

1569 cڡ *
__s
;

1570 
__asm__
 
__vީe__


1587 : "=S" (
__s
), "=&a" (
__d0
), "=&c" (
__d1
), "=&D" (
__d2
)

1588 : "r" (
__je
), "0" (
__s
), "1" (0), "2" (0xffffffff)

1590  (
__s
 - 1- 
__s
;

1591 
	}
}

1593 
__STRING_INLINE
 
size_t


1594 
	$__rcn_g
 (cڡ *
__s
, cڡ *
__je
)

1596 
__d0
, 
__d1
, 
__d2
, 
__d3
;

1597 cڡ *
__s
;

1598 
__asm__
 
__vީe__


1612 : "=S" (
__s
), "=&a" (
__d0
), "=&c" (
__d1
), "=&D" (
__d2
), "=&d" (
__d3
)

1613 : "0" (
__s
), "1" (0), "2" (0xffffffff), "3" (
__je
), "b" (__reject)

1616  (
__s
 - 1- 
__s
;

1617 
	}
}

1623 
	#_HAVE_STRING_ARCH_rn
 1

	)

1624 
	#rn
(
s
, 
ac
) \

1625 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
ac
) &&  ((accept)[0]) == 1 \

1626 ? ((
ac
)[0] == '\0' \

1627 ? (((
s
), 0) \

1628 : ((
ac
)[1] == '\0' \

1629 ? 
	`__rn_c1
 ((
s
), (((
ac
)[0] << 8 ) & 0xff00)) \

1630 : 
	`__rn_cg
 ((
s
), (
ac
), 
	`
 (accept)))) \

1631 : 
	`__rn_g
 ((
s
), (
ac
))))

	)

1633 #ide
_FORCE_INLINES


1634 
__STRING_INLINE
 
size_t
 
__rn_c1
 (cڡ *
__s
, 
__ac
);

1636 
__STRING_INLINE
 
size_t


1637 
	$__rn_c1
 (cڡ *
__s
, 
__ac
)

1639 
__d0
;

1640 *
__s
;

1642 
__asm__
 
__vީe__


1648 : "" (
__s
), "=&q" (
__d0
)

1649 : "0" (
__s
), "1" (
__ac
),

1650 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s
)

1652  (
__s
 - 1- 
__s
;

1653 
	}
}

1656 
__STRING_INLINE
 
size_t
 
__rn_cg
 (cڡ *
__s
, cڡ 
__ac
[],

1657 
size_t
 
__ac_n
);

1659 
__STRING_INLINE
 
size_t


1660 
	$__rn_cg
 (cڡ *
__s
, cڡ 
__ac
[], 
size_t
 
__ac_n
)

1662 
__d0
, 
__d1
, 
__d2
;

1663 cڡ *
__s
;

1664 
__asm__
 
__vީe__


1675 : "=S" (
__s
), "=&a" (
__d0
), "=&c" (
__d1
), "=&D" (
__d2
)

1676 : "0" (
__s
), "g" (
__ac
), "g" (
__ac_n
),

1679 "m" ( *(ru { 
__x
[0xfffffff]; } *)
__s
),

1680 "m" ( *(ru { 
__exnsi__
 
__x
[
__ac_n
]; } *)
__ac
)

1682  (
__s
 - 1- 
__s
;

1683 
	}
}

1685 
__STRING_INLINE
 
size_t
 
__rn_g
 (cڡ *
__s
, cڡ *
__ac
);

1686 #ifde
__PIC__


1688 
__STRING_INLINE
 
size_t


1689 
	$__rn_g
 (cڡ *
__s
, cڡ *
__ac
)

1691 
__d0
, 
__d1
, 
__d2
;

1692 cڡ *
__s
;

1693 
__asm__
 
__vީe__


1709 : "=S" (
__s
), "=&a" (
__d0
), "=&c" (
__d1
), "=&D" (
__d2
)

1710 : "d" (
__ac
), "0" (
__s
), "1" (0), "2" (0xffffffff), "3" (__accept)

1712  (
__s
 - 1- 
__s
;

1713 
	}
}

1715 
__STRING_INLINE
 
size_t


1716 
	$__rn_g
 (cڡ *
__s
, cڡ *
__ac
)

1718 
__d0
, 
__d1
, 
__d2
, 
__d3
;

1719 cڡ *
__s
;

1720 
__asm__
 
__vީe__


1734 : "=S" (
__s
), "=&a" (
__d0
), "=&c" (
__d1
), "=&D" (
__d2
), "=&d" (
__d3
)

1735 : "0" (
__s
), "1" (0), "2" (0xffffffff), "3" (
__ac
), "b" (__accept)

1737  (
__s
 - 1- 
__s
;

1738 
	}
}

1743 
	#_HAVE_STRING_ARCH_brk
 1

	)

1744 
	#brk
(
s
, 
ac
) \

1745 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
ac
) &&  ((accept)[0]) == 1 \

1746 ? ((
ac
)[0] == '\0' \

1747 ? (((
s
), (*) 0) \

1748 : ((
ac
)[1] == '\0' \

1749 ? 
	`rchr
 ((
s
), (
ac
)[0]) \

1750 : 
	`__brk_cg
 ((
s
), (
ac
), 
	`
 (accept)))) \

1751 : 
	`__brk_g
 ((
s
), (
ac
))))

	)

1753 
__STRING_INLINE
 *
__brk_cg
 (cڡ *
__s
, cڡ 
__ac
[],

1754 
size_t
 
__ac_n
);

1756 
__STRING_INLINE
 *

1757 
	$__brk_cg
 (cڡ *
__s
, cڡ 
__ac
[], 
size_t
 
__ac_n
)

1759 
__d0
, 
__d1
, 
__d2
;

1760 *
__s
;

1761 
__asm__
 
__vީe__


1776 : "=S" (
__s
), "=&a" (
__d0
), "=&c" (
__d1
), "=&D" (
__d2
)

1777 : "0" (
__s
), "d" (
__ac
), "g" (
__ac_n
)

1779  
__s
;

1780 
	}
}

1782 
__STRING_INLINE
 *
__brk_g
 (cڡ *
__s
, cڡ *
__ac
);

1783 #ifde
__PIC__


1785 
__STRING_INLINE
 *

1786 
	$__brk_g
 (cڡ *
__s
, cڡ *
__ac
)

1788 
__d0
, 
__d1
, 
__d2
;

1789 *
__s
;

1790 
__asm__
 
__vީe__


1811 : "=S" (
__s
), "=&a" (
__d0
), "=&c" (
__d1
), "=&D" (
__d2
)

1812 : "d" (
__ac
), "0" (
__s
), "1" (0), "2" (0xffffffff)

1814  
__s
;

1815 
	}
}

1817 
__STRING_INLINE
 *

1818 
	$__brk_g
 (cڡ *
__s
, cڡ *
__ac
)

1820 
__d0
, 
__d1
, 
__d2
, 
__d3
;

1821 *
__s
;

1822 
__asm__
 
__vީe__


1841 : "=S" (
__s
), "=&a" (
__d0
), "=&c" (
__d1
), "=&d" (
__d2
), "=&D" (
__d3
)

1842 : "0" (
__s
), "1" (0), "2" (0xffffffff), "b" (
__ac
)

1844  
__s
;

1845 
	}
}

1850 
	#_HAVE_STRING_ARCH_rr
 1

	)

1851 
	#rr
(
hayack
, 
ed
) \

1852 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
ed
) &&  ((needle)[0]) == 1 \

1853 ? ((
ed
)[0] == '\0' \

1854 ? (
hayack
) \

1855 : ((
ed
)[1] == '\0' \

1856 ? 
	`rchr
 ((
hayack
), (
ed
)[0]) \

1857 : 
	`__rr_cg
 ((
hayack
), (
ed
), \

1858 
	`
 (
ed
)))) \

1859 : 
	`__rr_g
 ((
hayack
), (
ed
))))

	)

1863 
__STRING_INLINE
 *
__rr_cg
 (cڡ *
__hayack
,

1864 cڡ 
__ed
[],

1865 
size_t
 
__ed_n
);

1867 
__STRING_INLINE
 *

1868 
	$__rr_cg
 (cڡ *
__hayack
, cڡ 
__ed
[],

1869 
size_t
 
__ed_n
)

1871 
__d0
, 
__d1
, 
__d2
;

1872 *
__s
;

1873 
__asm__
 
__vީe__


1886 : "=&a" (
__s
), "=&S" (
__d0
), "=&D" (
__d1
), "=&c" (
__d2
)

1887 : "g" (
__ed_n
), "1" (
__hayack
), "d" (
__ed
)

1889  
__s
;

1890 
	}
}

1892 
__STRING_INLINE
 *
__rr_g
 (cڡ *
__hayack
,

1893 cڡ *
__ed
);

1894 #ifde
__PIC__


1896 
__STRING_INLINE
 *

1897 
	$__rr_g
 (cڡ *
__hayack
, cڡ *
__ed
)

1899 
__d0
, 
__d1
, 
__d2
;

1900 *
__s
;

1901 
__asm__
 
__vީe__


1920 : "=&a" (
__s
), "=&c" (
__d0
), "=&S" (
__d1
), "=&D" (
__d2
)

1921 : "0" (0), "1" (0xffffffff), "2" (
__hayack
), "3" (
__ed
),

1922 "d" (
__ed
)

1924  
__s
;

1925 
	}
}

1927 
__STRING_INLINE
 *

1928 
	$__rr_g
 (cڡ *
__hayack
, cڡ *
__ed
)

1930 
__d0
, 
__d1
, 
__d2
, 
__d3
;

1931 *
__s
;

1932 
__asm__
 
__vީe__


1949 : "=&a" (
__s
), "=&c" (
__d0
), "=&S" (
__d1
), "=&D" (
__d2
), "=&d" (
__d3
)

1950 : "0" (0), "1" (0xffffffff), "2" (
__hayack
), "3" (
__ed
),

1951 "b" (
__ed
)

1953  
__s
;

1954 
	}
}

1960 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


1961 #ifde
__i686__


1962 
	#_HAVE_STRING_ARCH_ffs
 1

	)

1963 
	#ffs
(
wd
(
	`__but_cڡt_p
 (word) \

1964 ? 
	`__but_ffs
 (
wd
) \

1965 : ({ 
__t
, 
__tmp
; \

1966 
__asm__
 
__vީe__
 \

1969 : "=&r" (
__t
), "" (
__tmp
) \

1970 : "rm" (
wd
), "1" (-1)); \

1971 
__t
 + 1; }))

	)

1973 #ide
ff


1974 
	#ff
(
wd

	`ffs
(wd)

	)

1979 #ide
_FORCE_INLINES


1980 #unde
__STRING_INLINE


	@/usr/include/bits/string2.h

20 #ide
_STRING_H


24 #ide
__NO_STRING_INLINES


41 #ide
__STRING_INLINE


42 #ifde
__lulus


43 
	#__STRING_INLINE
 
le


	)

45 
	#__STRING_INLINE
 
__ex_le


	)

49 #i
_STRING_ARCH_uligd


51 
	~<dn.h
>

52 
	~<bs/tys.h
>

54 #i
__BYTE_ORDER
 =
__LITTLE_ENDIAN


55 
	#__STRING2_SMALL_GET16
(
c
, 
idx
) \

56 (((cڡ *(cڡ *(
c
))[
idx
 + 1] << 8 \

57 | ((cڡ *(cڡ *(
c
))[
idx
])

	)

58 
	#__STRING2_SMALL_GET32
(
c
, 
idx
) \

59 (((((cڡ *(cڡ *(
c
))[
idx
 + 3] << 8 \

60 | ((cڡ *(cڡ *(
c
))[
idx
 + 2]) << 8 \

61 | ((cڡ *(cڡ *(
c
))[
idx
 + 1]) << 8 \

62 | ((cڡ *(cڡ *(
c
))[
idx
])

	)

64 
	#__STRING2_SMALL_GET16
(
c
, 
idx
) \

65 (((cڡ *(cڡ *(
c
))[
idx
] << 8 \

66 | ((cڡ *(cڡ *(
c
))[
idx
 + 1])

	)

67 
	#__STRING2_SMALL_GET32
(
c
, 
idx
) \

68 (((((cڡ *(cڡ *(
c
))[
idx
] << 8 \

69 | ((cڡ *(cڡ *(
c
))[
idx
 + 1]) << 8 \

70 | ((cڡ *(cڡ *(
c
))[
idx
 + 2]) << 8 \

71 | ((cڡ *(cڡ *(
c
))[
idx
 + 3])

	)

76 
	#__STRING2_COPY_TYPE
(
N
) \

77 ru { 
__r
[
N
]; } \

78 
	t__ibu__
 ((
	t__cked__
)
	t__STRING2_COPY_ARR
##
	tN


	)

79 
	t__STRING2_COPY_TYPE
 (2);

80 
__STRING2_COPY_TYPE
 (3);

81 
__STRING2_COPY_TYPE
 (4);

82 
__STRING2_COPY_TYPE
 (5);

83 
__STRING2_COPY_TYPE
 (6);

84 
__STRING2_COPY_TYPE
 (7);

85 
__STRING2_COPY_TYPE
 (8);

86 #unde
__STRING2_COPY_TYPE


92 
	#__rg2_1br_p
(
__x
) \

93 ((
size_t
)(cڡ *)((
__x
+ 1- (size_t)(cڡ *)(__x=1)

	)

96 #i!
defed
 
_HAVE_STRING_ARCH_memt


97 #i!
__GNUC_PREREQ
 (3, 0)

98 #i
_STRING_ARCH_uligd


99 
	#memt
(
s
, 
c
, 
n
) \

100 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
n
) && (n) <= 16 \

101 ? ((
n
) == 1 \

102 ? 
	`__memt_1
 (
s
, 
c
) \

103 : 
	`__memt_gc
 (
s
, 
c
, 
n
)) \

104 : (
	`__but_cڡt_p
 (
c
) && (c) == '\0' \

105 ? ({ *
__s
 = (
s
); 
	`__bzo
 (__s, 
n
); __s; }) \

106 : 
	`memt
 (
s
, 
c
, 
n
))))

	)

108 
	#__memt_1
(
s
, 
c
({ *
__s
 = (s); \

109 *((
__ut8_t
 *
__s
(__ut8_t
c
; __s; })

	)

111 
	#__memt_gc
(
s
, 
c
, 
n
) \

112 ({ *
__s
 = (
s
); \

114 
__ui
; \

115 
__usi
; \

116 
__uc
; \

117 } *
__u
 = 
__s
; \

118 
__ut8_t
 
__c
 = (__ut8_t(
c
); \

121 ((
n
)) \

124 
__u
->
__ui
 = 
__c
 * 0x01010101; \

125 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

127 
__u
->
__ui
 = 
__c
 * 0x01010101; \

128 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

130 
__u
->
__ui
 = 
__c
 * 0x01010101; \

131 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

133 
__u
->
__usi
 = (
__c
 * 0x0101; \

134 
__u
 = 
	`__exnsi__
 ((*) __u + 2); \

135 
__u
->
__uc
 = (
__c
; \

139 
__u
->
__ui
 = 
__c
 * 0x01010101; \

140 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

142 
__u
->
__ui
 = 
__c
 * 0x01010101; \

143 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

145 
__u
->
__ui
 = 
__c
 * 0x01010101; \

146 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

148 
__u
->
__usi
 = (
__c
 * 0x0101; \

152 
__u
->
__ui
 = 
__c
 * 0x01010101; \

153 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

155 
__u
->
__ui
 = 
__c
 * 0x01010101; \

156 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

158 
__u
->
__ui
 = 
__c
 * 0x01010101; \

159 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

161 
__u
->
__uc
 = (
__c
; \

165 
__u
->
__ui
 = 
__c
 * 0x01010101; \

166 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

168 
__u
->
__ui
 = 
__c
 * 0x01010101; \

169 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

171 
__u
->
__ui
 = 
__c
 * 0x01010101; \

172 
__u
 = 
	`__exnsi__
 ((*) __u + 4); \

174 
__u
->
__ui
 = 
__c
 * 0x01010101; \

179 
__s
; })

	)

181 
	#memt
(
s
, 
c
, 
n
) \

182 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) && (c) == '\0' \

183 ? ({ *
__s
 = (
s
); 
	`__bzo
 (__s, 
n
); __s; }) \

184 : 
	`memt
 (
s
, 
c
, 
n
)))

	)

193 #i
__GNUC_PREREQ
 (2, 91)

194 
	#__bzo
(
s
, 
n

	`__but_memt
 (s, '\0',)

	)

202 #ifde
__USE_GNU


203 #i!
defed
 
_HAVE_STRING_ARCH_mempy
 || defed 
_FORCE_INLINES


204 #ide
_HAVE_STRING_ARCH_mempy


205 #i
__GNUC_PREREQ
 (3, 4)

206 
	#__mempy
(
de
, 
c
, 
n

	`__but_mempy
 (de, src,)

	)

207 #i
__GNUC_PREREQ
 (3, 0)

208 
	#__mempy
(
de
, 
c
, 
n
) \

209 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
&& __but_cڡt_(
n
) \

210 && 
	`__rg2_1br_p
 (
c
&& 
n
 <= 8 \

211 ? 
	`__but_memy
 (
de
, 
c
, 
n
) + (n) \

212 : 
	`__mempy
 (
de
, 
c
, 
n
)))

	)

214 
	#__mempy
(
de
, 
c
, 
n
) \

215 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
&& __but_cڡt_(
n
) \

216 && 
	`__rg2_1br_p
 (
c
&& 
n
 <= 8 \

217 ? 
	`__mempy_sml
 (
de
, 
	`__mempy_gs
 (
c
), 
n
) \

218 : 
	`__mempy
 (
de
, 
c
, 
n
)))

	)

222 
	#mempy
(
de
, 
c
, 
n

	`__mempy
 (de, src,)

	)

225 #i!
__GNUC_PREREQ
 (3, 0|| 
defed
 
_FORCE_INLINES


226 #i
_STRING_ARCH_uligd


227 #ide
_FORCE_INLINES


228 
	#__mempy_gs
(
c
) \

229 ((cڡ *(
c
))[0], ((const *) (src))[2], \

230 ((cڡ *(
c
))[4], ((const *) (src))[6], \

231 
__exnsi__
 
	`__STRING2_SMALL_GET16
 (
c
, 0), \

232 
__exnsi__
 
	`__STRING2_SMALL_GET16
 (
c
, 4), \

233 
__exnsi__
 
	`__STRING2_SMALL_GET32
 (
c
, 0), \

234 
__exnsi__
 
	`__STRING2_SMALL_GET32
 (
c
, 4)

	)

236 
__STRING_INLINE
 *
__mempy_sml
 (*, , , , ,

237 
__ut16_t
, __ut16_t, 
__ut32_t
,

238 
__ut32_t
, 
size_t
);

239 
__STRING_INLINE
 *

240 
	$__mempy_sml
 (*
__de1
,

241 
__c0_1
, 
__c2_1
, 
__c4_1
, 
__c6_1
,

242 
__ut16_t
 
__c0_2
, __ut16_
__c4_2
,

243 
__ut32_t
 
__c0_4
, __ut32_
__c4_4
,

244 
size_t
 
__
)

247 
__ut32_t
 
__ui
;

248 
__ut16_t
 
__usi
;

249 
__uc
;

250 
__c
;

251 } *
__u
 = 
__de1
;

252 (
__
)

255 
__u
->
__c
 = 
__c0_1
;

256 
__u
 = 
	`__exnsi__
 ((*) __u + 1);

259 
__u
->
__usi
 = 
__c0_2
;

260 
__u
 = 
	`__exnsi__
 ((*) __u + 2);

263 
__u
->
__usi
 = 
__c0_2
;

264 
__u
 = 
	`__exnsi__
 ((*) __u + 2);

265 
__u
->
__c
 = 
__c2_1
;

266 
__u
 = 
	`__exnsi__
 ((*) __u + 1);

269 
__u
->
__ui
 = 
__c0_4
;

270 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

273 
__u
->
__ui
 = 
__c0_4
;

274 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

275 
__u
->
__c
 = 
__c4_1
;

276 
__u
 = 
	`__exnsi__
 ((*) __u + 1);

279 
__u
->
__ui
 = 
__c0_4
;

280 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

281 
__u
->
__usi
 = 
__c4_2
;

282 
__u
 = 
	`__exnsi__
 ((*) __u + 2);

285 
__u
->
__ui
 = 
__c0_4
;

286 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

287 
__u
->
__usi
 = 
__c4_2
;

288 
__u
 = 
	`__exnsi__
 ((*) __u + 2);

289 
__u
->
__c
 = 
__c6_1
;

290 
__u
 = 
	`__exnsi__
 ((*) __u + 1);

293 
__u
->
__ui
 = 
__c0_4
;

294 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

295 
__u
->
__ui
 = 
__c4_4
;

296 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

299  (*
__u
;

300 
	}
}

302 #ide
_FORCE_INLINES


303 
	#__mempy_gs
(
c
) \

304 ((cڡ *(
c
))[0], \

305 
	`__exnsi__
 ((
__STRING2_COPY_ARR2
) \

306 { { ((cڡ *(
c
))[0], ((const *) (src))[1] } }), \

307 
	`__exnsi__
 ((
__STRING2_COPY_ARR3
) \

308 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

309 ((cڡ *(
c
))[2] } }), \

310 
	`__exnsi__
 ((
__STRING2_COPY_ARR4
) \

311 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

312 ((cڡ *(
c
))[2], ((const *) (src))[3] } }), \

313 
	`__exnsi__
 ((
__STRING2_COPY_ARR5
) \

314 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

315 ((cڡ *(
c
))[2], ((const *) (src))[3], \

316 ((cڡ *(
c
))[4] } }), \

317 
	`__exnsi__
 ((
__STRING2_COPY_ARR6
) \

318 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

319 ((cڡ *(
c
))[2], ((const *) (src))[3], \

320 ((cڡ *(
c
))[4], ((const *) (src))[5] } }), \

321 
	`__exnsi__
 ((
__STRING2_COPY_ARR7
) \

322 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

323 ((cڡ *(
c
))[2], ((const *) (src))[3], \

324 ((cڡ *(
c
))[4], ((const *) (src))[5], \

325 ((cڡ *(
c
))[6] } }), \

326 
	`__exnsi__
 ((
__STRING2_COPY_ARR8
) \

327 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

328 ((cڡ *(
c
))[2], ((const *) (src))[3], \

329 ((cڡ *(
c
))[4], ((const *) (src))[5], \

330 ((cڡ *(
c
))[6], ((cڡ *(c))[7] } })

	)

332 
__STRING_INLINE
 *
__mempy_sml
 (*, , 
__STRING2_COPY_ARR2
,

333 
__STRING2_COPY_ARR3
,

334 
__STRING2_COPY_ARR4
,

335 
__STRING2_COPY_ARR5
,

336 
__STRING2_COPY_ARR6
,

337 
__STRING2_COPY_ARR7
,

338 
__STRING2_COPY_ARR8
, 
size_t
);

339 
__STRING_INLINE
 *

340 
	$__mempy_sml
 (*
__de
, 
__c1
,

341 
__STRING2_COPY_ARR2
 
__c2
, 
__STRING2_COPY_ARR3
 
__c3
,

342 
__STRING2_COPY_ARR4
 
__c4
, 
__STRING2_COPY_ARR5
 
__c5
,

343 
__STRING2_COPY_ARR6
 
__c6
, 
__STRING2_COPY_ARR7
 
__c7
,

344 
__STRING2_COPY_ARR8
 
__c8
, 
size_t
 
__
)

347 
__c
;

348 
__STRING2_COPY_ARR2
 
__s2
;

349 
__STRING2_COPY_ARR3
 
__s3
;

350 
__STRING2_COPY_ARR4
 
__s4
;

351 
__STRING2_COPY_ARR5
 
__s5
;

352 
__STRING2_COPY_ARR6
 
__s6
;

353 
__STRING2_COPY_ARR7
 
__s7
;

354 
__STRING2_COPY_ARR8
 
__s8
;

355 } *
__u
 = 
__de
;

356 (
__
)

359 
__u
->
__c
 = 
__c1
;

362 
__exnsi__
 
__u
->
__s2
 = 
__c2
;

365 
__exnsi__
 
__u
->
__s3
 = 
__c3
;

368 
__exnsi__
 
__u
->
__s4
 = 
__c4
;

371 
__exnsi__
 
__u
->
__s5
 = 
__c5
;

374 
__exnsi__
 
__u
->
__s6
 = 
__c6
;

377 
__exnsi__
 
__u
->
__s7
 = 
__c7
;

380 
__exnsi__
 
__u
->
__s8
 = 
__c8
;

383  
	`__exnsi__
 ((*
__u
 + 
__
);

384 
	}
}

392 #ide
_HAVE_STRING_ARCH_rchr


393 *
__wmemchr
 (cڡ *
__s
, 
__c
);

394 #i
__GNUC_PREREQ
 (3, 2)

395 
	#rchr
(
s
, 
c
) \

396 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
&& !__but_cڡt_(
s
) \

397 && (
c
) == '\0' \

398 ? (*
	`__wmemchr
 (
s
, 
c
) \

399 : 
	`__but_rchr
 (
s
, 
c
)))

	)

401 
	#rchr
(
s
, 
c
) \

402 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) && (c) == '\0' \

403 ? (*
	`__wmemchr
 (
s
, 
c
) \

404 : 
	`rchr
 (
s
, 
c
)))

	)

410 #i(!
defed
 
_HAVE_STRING_ARCH_ry
 && !
__GNUC_PREREQ
 (3, 0)) \

411 || 
defed
 
	g_FORCE_INLINES


412 #i!
defed
 
_HAVE_STRING_ARCH_ry
 && !
__GNUC_PREREQ
 (3, 0)

413 
	#ry
(
de
, 
c
) \

414 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) \

415 ? (
	`__rg2_1br_p
 (
c
&& 
	`
 (src) + 1 <= 8 \

416 ? 
	`__ry_sml
 (
de
, 
	`__ry_gs
 (
c
), \

417 
	`
 (
c
) + 1) \

418 : (*
	`memy
 (
de
, 
c
, 
	`
 (src) + 1)) \

419 : 
	`ry
 (
de
, 
c
)))

	)

422 #i
_STRING_ARCH_uligd


423 #ide
_FORCE_INLINES


424 
	#__ry_gs
(
c
) \

425 
__exnsi__
 
	`__STRING2_SMALL_GET16
 (
c
, 0), \

426 
__exnsi__
 
	`__STRING2_SMALL_GET16
 (
c
, 4), \

427 
__exnsi__
 
	`__STRING2_SMALL_GET32
 (
c
, 0), \

428 
__exnsi__
 
	`__STRING2_SMALL_GET32
 (
c
, 4)

	)

430 
__STRING_INLINE
 *
__ry_sml
 (*, 
__ut16_t
, __uint16_t,

431 
__ut32_t
, __ut32_t, 
size_t
);

432 
__STRING_INLINE
 *

433 
	$__ry_sml
 (*
__de
,

434 
__ut16_t
 
__c0_2
, __ut16_
__c4_2
,

435 
__ut32_t
 
__c0_4
, __ut32_
__c4_4
,

436 
size_t
 
__
)

439 
__ut32_t
 
__ui
;

440 
__ut16_t
 
__usi
;

441 
__uc
;

442 } *
__u
 = (*
__de
;

443 (
__
)

446 
__u
->
__uc
 = '\0';

449 
__u
->
__usi
 = 
__c0_2
;

452 
__u
->
__usi
 = 
__c0_2
;

453 
__u
 = 
	`__exnsi__
 ((*) __u + 2);

454 
__u
->
__uc
 = '\0';

457 
__u
->
__ui
 = 
__c0_4
;

460 
__u
->
__ui
 = 
__c0_4
;

461 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

462 
__u
->
__uc
 = '\0';

465 
__u
->
__ui
 = 
__c0_4
;

466 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

467 
__u
->
__usi
 = 
__c4_2
;

470 
__u
->
__ui
 = 
__c0_4
;

471 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

472 
__u
->
__usi
 = 
__c4_2
;

473 
__u
 = 
	`__exnsi__
 ((*) __u + 2);

474 
__u
->
__uc
 = '\0';

477 
__u
->
__ui
 = 
__c0_4
;

478 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

479 
__u
->
__ui
 = 
__c4_4
;

482  
__de
;

483 
	}
}

485 #ide
_FORCE_INLINES


486 
	#__ry_gs
(
c
) \

487 
	`__exnsi__
 ((
__STRING2_COPY_ARR2
) \

488 { { ((cڡ *(
c
))[0], '\0' } }), \

489 
	`__exnsi__
 ((
__STRING2_COPY_ARR3
) \

490 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

492 
	`__exnsi__
 ((
__STRING2_COPY_ARR4
) \

493 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

494 ((cڡ *(
c
))[2], '\0' } }), \

495 
	`__exnsi__
 ((
__STRING2_COPY_ARR5
) \

496 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

497 ((cڡ *(
c
))[2], ((const *) (src))[3], \

499 
	`__exnsi__
 ((
__STRING2_COPY_ARR6
) \

500 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

501 ((cڡ *(
c
))[2], ((const *) (src))[3], \

502 ((cڡ *(
c
))[4], '\0' } }), \

503 
	`__exnsi__
 ((
__STRING2_COPY_ARR7
) \

504 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

505 ((cڡ *(
c
))[2], ((const *) (src))[3], \

506 ((cڡ *(
c
))[4], ((const *) (src))[5], \

508 
	`__exnsi__
 ((
__STRING2_COPY_ARR8
) \

509 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

510 ((cڡ *(
c
))[2], ((const *) (src))[3], \

511 ((cڡ *(
c
))[4], ((const *) (src))[5], \

512 ((cڡ *(
c
))[6], '\0' } })

	)

514 
__STRING_INLINE
 *
__ry_sml
 (*, 
__STRING2_COPY_ARR2
,

515 
__STRING2_COPY_ARR3
,

516 
__STRING2_COPY_ARR4
,

517 
__STRING2_COPY_ARR5
,

518 
__STRING2_COPY_ARR6
,

519 
__STRING2_COPY_ARR7
,

520 
__STRING2_COPY_ARR8
, 
size_t
);

521 
__STRING_INLINE
 *

522 
	$__ry_sml
 (*
__de
,

523 
__STRING2_COPY_ARR2
 
__c2
, 
__STRING2_COPY_ARR3
 
__c3
,

524 
__STRING2_COPY_ARR4
 
__c4
, 
__STRING2_COPY_ARR5
 
__c5
,

525 
__STRING2_COPY_ARR6
 
__c6
, 
__STRING2_COPY_ARR7
 
__c7
,

526 
__STRING2_COPY_ARR8
 
__c8
, 
size_t
 
__
)

529 
__c
;

530 
__STRING2_COPY_ARR2
 
__s2
;

531 
__STRING2_COPY_ARR3
 
__s3
;

532 
__STRING2_COPY_ARR4
 
__s4
;

533 
__STRING2_COPY_ARR5
 
__s5
;

534 
__STRING2_COPY_ARR6
 
__s6
;

535 
__STRING2_COPY_ARR7
 
__s7
;

536 
__STRING2_COPY_ARR8
 
__s8
;

537 } *
__u
 = (*
__de
;

538 (
__
)

541 
__u
->
__c
 = '\0';

544 
__exnsi__
 
__u
->
__s2
 = 
__c2
;

547 
__exnsi__
 
__u
->
__s3
 = 
__c3
;

550 
__exnsi__
 
__u
->
__s4
 = 
__c4
;

553 
__exnsi__
 
__u
->
__s5
 = 
__c5
;

556 
__exnsi__
 
__u
->
__s6
 = 
__c6
;

559 
__exnsi__
 
__u
->
__s7
 = 
__c7
;

562 
__exnsi__
 
__u
->
__s8
 = 
__c8
;

565  
__de
;

566 
	}
}

572 #ifde
__USE_GNU


573 #i!
defed
 
_HAVE_STRING_ARCH_py
 || defed 
_FORCE_INLINES


574 #ide
_HAVE_STRING_ARCH_py


575 #i
__GNUC_PREREQ
 (3, 4)

576 
	#__py
(
de
, 
c

	`__but_py
 (de, src)

	)

577 #i
__GNUC_PREREQ
 (3, 0)

578 
	#__py
(
de
, 
c
) \

579 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) \

580 ? (
	`__rg2_1br_p
 (
c
&& 
	`
 (src) + 1 <= 8 \

581 ? 
	`__but_ry
 (
de
, 
c
+ 
	`
 (src) \

582 : ((*(
__mempy
(
de
, 
c
, 
	`
 (src) + 1) \

584 : 
	`__py
 (
de
, 
c
)))

	)

586 
	#__py
(
de
, 
c
) \

587 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
) \

588 ? (
	`__rg2_1br_p
 (
c
&& 
	`
 (src) + 1 <= 8 \

589 ? 
	`__py_sml
 (
de
, 
	`__py_gs
 (
c
), \

590 
	`
 (
c
) + 1) \

591 : ((*(
__mempy
(
de
, 
c
, 
	`
 (src) + 1) \

593 : 
	`__py
 (
de
, 
c
)))

	)

597 
	#py
(
de
, 
c

	`__py
 (de, src)

	)

600 #i!
__GNUC_PREREQ
 (3, 0|| 
defed
 
_FORCE_INLINES


601 #i
_STRING_ARCH_uligd


602 #ide
_FORCE_INLINES


603 
	#__py_gs
(
c
) \

604 
__exnsi__
 
	`__STRING2_SMALL_GET16
 (
c
, 0), \

605 
__exnsi__
 
	`__STRING2_SMALL_GET16
 (
c
, 4), \

606 
__exnsi__
 
	`__STRING2_SMALL_GET32
 (
c
, 0), \

607 
__exnsi__
 
	`__STRING2_SMALL_GET32
 (
c
, 4)

	)

609 
__STRING_INLINE
 *
__py_sml
 (*, 
__ut16_t
, __uint16_t,

610 
__ut32_t
, __ut32_t, 
size_t
);

611 
__STRING_INLINE
 *

612 
	$__py_sml
 (*
__de
,

613 
__ut16_t
 
__c0_2
, __ut16_
__c4_2
,

614 
__ut32_t
 
__c0_4
, __ut32_
__c4_4
,

615 
size_t
 
__
)

618 
__ui
;

619 
__usi
;

620 
__uc
;

621 
__c
;

622 } *
__u
 = (*
__de
;

623 (
__
)

626 
__u
->
__uc
 = '\0';

629 
__u
->
__usi
 = 
__c0_2
;

630 
__u
 = 
	`__exnsi__
 ((*) __u + 1);

633 
__u
->
__usi
 = 
__c0_2
;

634 
__u
 = 
	`__exnsi__
 ((*) __u + 2);

635 
__u
->
__uc
 = '\0';

638 
__u
->
__ui
 = 
__c0_4
;

639 
__u
 = 
	`__exnsi__
 ((*) __u + 3);

642 
__u
->
__ui
 = 
__c0_4
;

643 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

644 
__u
->
__uc
 = '\0';

647 
__u
->
__ui
 = 
__c0_4
;

648 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

649 
__u
->
__usi
 = 
__c4_2
;

650 
__u
 = 
	`__exnsi__
 ((*) __u + 1);

653 
__u
->
__ui
 = 
__c0_4
;

654 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

655 
__u
->
__usi
 = 
__c4_2
;

656 
__u
 = 
	`__exnsi__
 ((*) __u + 2);

657 
__u
->
__uc
 = '\0';

660 
__u
->
__ui
 = 
__c0_4
;

661 
__u
 = 
	`__exnsi__
 ((*) __u + 4);

662 
__u
->
__ui
 = 
__c4_4
;

663 
__u
 = 
	`__exnsi__
 ((*) __u + 3);

666  &
__u
->
__c
;

667 
	}
}

669 #ide
_FORCE_INLINES


670 
	#__py_gs
(
c
) \

671 
	`__exnsi__
 ((
__STRING2_COPY_ARR2
) \

672 { { ((cڡ *(
c
))[0], '\0' } }), \

673 
	`__exnsi__
 ((
__STRING2_COPY_ARR3
) \

674 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

676 
	`__exnsi__
 ((
__STRING2_COPY_ARR4
) \

677 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

678 ((cڡ *(
c
))[2], '\0' } }), \

679 
	`__exnsi__
 ((
__STRING2_COPY_ARR5
) \

680 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

681 ((cڡ *(
c
))[2], ((const *) (src))[3], \

683 
	`__exnsi__
 ((
__STRING2_COPY_ARR6
) \

684 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

685 ((cڡ *(
c
))[2], ((const *) (src))[3], \

686 ((cڡ *(
c
))[4], '\0' } }), \

687 
	`__exnsi__
 ((
__STRING2_COPY_ARR7
) \

688 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

689 ((cڡ *(
c
))[2], ((const *) (src))[3], \

690 ((cڡ *(
c
))[4], ((const *) (src))[5], \

692 
	`__exnsi__
 ((
__STRING2_COPY_ARR8
) \

693 { { ((cڡ *(
c
))[0], ((const *) (src))[1], \

694 ((cڡ *(
c
))[2], ((const *) (src))[3], \

695 ((cڡ *(
c
))[4], ((const *) (src))[5], \

696 ((cڡ *(
c
))[6], '\0' } })

	)

698 
__STRING_INLINE
 *
__py_sml
 (*, 
__STRING2_COPY_ARR2
,

699 
__STRING2_COPY_ARR3
,

700 
__STRING2_COPY_ARR4
,

701 
__STRING2_COPY_ARR5
,

702 
__STRING2_COPY_ARR6
,

703 
__STRING2_COPY_ARR7
,

704 
__STRING2_COPY_ARR8
, 
size_t
);

705 
__STRING_INLINE
 *

706 
	$__py_sml
 (*
__de
,

707 
__STRING2_COPY_ARR2
 
__c2
, 
__STRING2_COPY_ARR3
 
__c3
,

708 
__STRING2_COPY_ARR4
 
__c4
, 
__STRING2_COPY_ARR5
 
__c5
,

709 
__STRING2_COPY_ARR6
 
__c6
, 
__STRING2_COPY_ARR7
 
__c7
,

710 
__STRING2_COPY_ARR8
 
__c8
, 
size_t
 
__
)

713 
__c
;

714 
__STRING2_COPY_ARR2
 
__s2
;

715 
__STRING2_COPY_ARR3
 
__s3
;

716 
__STRING2_COPY_ARR4
 
__s4
;

717 
__STRING2_COPY_ARR5
 
__s5
;

718 
__STRING2_COPY_ARR6
 
__s6
;

719 
__STRING2_COPY_ARR7
 
__s7
;

720 
__STRING2_COPY_ARR8
 
__s8
;

721 } *
__u
 = (*
__de
;

722 (
__
)

725 
__u
->
__c
 = '\0';

728 
__exnsi__
 
__u
->
__s2
 = 
__c2
;

731 
__exnsi__
 
__u
->
__s3
 = 
__c3
;

734 
__exnsi__
 
__u
->
__s4
 = 
__c4
;

737 
__exnsi__
 
__u
->
__s5
 = 
__c5
;

740 
__exnsi__
 
__u
->
__s6
 = 
__c6
;

743 
__exnsi__
 
__u
->
__s7
 = 
__c7
;

746 
__exnsi__
 
__u
->
__s8
 = 
__c8
;

749  
__de
 + 
__
 - 1;

750 
	}
}

758 #ide
_HAVE_STRING_ARCH_y


759 #i
__GNUC_PREREQ
 (3, 2)

760 
	#y
(
de
, 
c
, 
n

	`__but_y
 (de, src,)

	)

762 
	#y
(
de
, 
c
, 
n
) \

763 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
&& __but_cڡt_(
n
) \

764 ? (
	`
 (
c
+ 1 >((
size_t
(
n
)) \

765 ? (*
	`memy
 (
de
, 
c
, 
n
) \

766 : 
	`y
 (
de
, 
c
, 
n
)) \

767 : 
	`y
 (
de
, 
c
, 
n
)))

	)

773 #ide
_HAVE_STRING_ARCH_t


774 #ifde
_USE_STRING_ARCH_rchr


775 
	#t
(
de
, 
c
, 
n
) \

776 (
	`__exnsi__
 ({ *
__de
 = (
de
); \

777 
	`__but_cڡt_p
 (
c
&& __but_cڡt_(
n
) \

778 ? (
	`
 (
c
< ((
size_t
(
n
)) \

779 ? 
	`rt
 (
__de
, 
c
) \

780 : (*((*
	`__mempy
 (
	`rchr
 (
__de
, '\0'), \

781 
c
, 
n
)'\0', 
__de
)) \

782 : 
	`t
 (
de
, 
c
, 
n
); }))

	)

783 #i
__GNUC_PREREQ
 (3, 2)

784 
	#t
(
de
, 
c
, 
n

	`__but_t
 (de, src,)

	)

786 
	#t
(
de
, 
c
, 
n
) \

787 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
c
&& __but_cڡt_(
n
) \

788 ? (
	`
 (
c
< ((
size_t
(
n
)) \

789 ? 
	`rt
 (
de
, 
c
) \

790 : 
	`t
 (
de
, 
c
, 
n
)) \

791 : 
	`t
 (
de
, 
c
, 
n
)))

	)

797 #ide
_HAVE_STRING_ARCH_rcmp


798 #i
__GNUC_PREREQ
 (3, 2)

799 
	#rcmp
(
s1
, 
s2
) \

800 
__exnsi__
 \

801 ({ 
size_t
 
__s1_n
, 
__s2_n
; \

802 (
	`__but_cڡt_p
 (
s1
&& __but_cڡt_(
s2
) \

803 && (
__s1_n
 = 
	`__but_
 (
s1
), 
__s2_n
 = __but_ (
s2
), \

804 (!
	`__rg2_1br_p
 (
s1
|| 
__s1_n
 >= 4) \

805 && (!
	`__rg2_1br_p
 (
s2
|| 
__s2_n
 >= 4)) \

806 ? 
	`__but_rcmp
 (
s1
, 
s2
) \

807 : (
	`__but_cڡt_p
 (
s1
&& 
	`__rg2_1br_p
 (s1) \

808 && (
__s1_n
 = 
	`__but_
 (
s1
), __s1_len < 4) \

809 ? (
	`__but_cڡt_p
 (
s2
&& 
	`__rg2_1br_p
 (s2) \

810 ? 
	`__but_rcmp
 (
s1
, 
s2
) \

811 : 
	`__rcmp_cg
 (
s1
, 
s2
, 
__s1_n
)) \

812 : (
	`__but_cڡt_p
 (
s2
&& 
	`__rg2_1br_p
 (s2) \

813 && (
__s2_n
 = 
	`__but_
 (
s2
), __s2_len < 4) \

814 ? (
	`__but_cڡt_p
 (
s1
&& 
	`__rg2_1br_p
 (s1) \

815 ? 
	`__but_rcmp
 (
s1
, 
s2
) \

816 : 
	`__rcmp_gc
 (
s1
, 
s2
, 
__s2_n
)) \

817 : 
	`__but_rcmp
 (
s1
, 
s2
)))); })

	)

819 
	#rcmp
(
s1
, 
s2
) \

820 
__exnsi__
 \

821 ({ 
size_t
 
__s1_n
, 
__s2_n
; \

822 (
	`__but_cڡt_p
 (
s1
&& __but_cڡt_(
s2
) \

823 && (
__s1_n
 = 
	`
 (
s1
), 
__s2_n
 = s(
s2
), \

824 (!
	`__rg2_1br_p
 (
s1
|| 
__s1_n
 >= 4) \

825 && (!
	`__rg2_1br_p
 (
s2
|| 
__s2_n
 >= 4)) \

826 ? 
	`memcmp
 ((cڡ *(
s1
), (cڡ *(
s2
), \

827 (
__s1_n
 < 
__s2_n
 ? __s1_len : __s2_len) + 1) \

828 : (
	`__but_cڡt_p
 (
s1
&& 
	`__rg2_1br_p
 (s1) \

829 && (
__s1_n
 = 
	`
 (
s1
), __s1_len < 4) \

830 ? (
	`__but_cڡt_p
 (
s2
&& 
	`__rg2_1br_p
 (s2) \

831 ? 
	`__rcmp_cc
 (
s1
, 
s2
, 
__s1_n
) \

832 : 
	`__rcmp_cg
 (
s1
, 
s2
, 
__s1_n
)) \

833 : (
	`__but_cڡt_p
 (
s2
&& 
	`__rg2_1br_p
 (s2) \

834 && (
__s2_n
 = 
	`
 (
s2
), __s2_len < 4) \

835 ? (
	`__but_cڡt_p
 (
s1
&& 
	`__rg2_1br_p
 (s1) \

836 ? 
	`__rcmp_cc
 (
s1
, 
s2
, 
__s2_n
) \

837 : 
	`__rcmp_gc
 (
s1
, 
s2
, 
__s2_n
)) \

838 : 
	`rcmp
 (
s1
, 
s2
)))); })

	)

841 
	#__rcmp_cc
(
s1
, 
s2
, 
l
) \

842 (
	`__exnsi__
 ({ 
__su
 = \

843 (((cڡ *(cڡ *(
s1
))[0] \

844 - ((cڡ *(cڡ *)(
s2
))[0]); \

845 i(
l
 > 0 && 
__su
 == 0) \

847 
__su
 = (((const *) \

848 (cڡ *(
s1
))[1] \

850 (cڡ *(
s2
))[1]); \

851 i(
l
 > 1 && 
__su
 == 0) \

853 
__su
 = \

855 (cڡ *(
s1
))[2] \

857 (cڡ *(
s2
))[2]); \

858 i(
l
 > 2 && 
__su
 == 0) \

859 
__su
 = \

861 (cڡ *(
s1
))[3] \

863 (cڡ *(
s2
))[3]); \

866 
__su
; }))

	)

868 
	#__rcmp_cg
(
s1
, 
s2
, 
l1
) \

869 (
	`__exnsi__
 ({ cڡ *
__s2
 = \

870 (cڡ *(cڡ *(
s2
); \

871 
__su
 = \

872 (((cڡ *(cڡ *(
s1
))[0] \

873 - 
__s2
[0]); \

874 i(
l1
 > 0 && 
__su
 == 0) \

876 
__su
 = (((const *) \

877 (cڡ *(
s1
))[1] - 
__s2
[1]); \

878 i(
l1
 > 1 && 
__su
 == 0) \

880 
__su
 = (((const *) \

881 (cڡ *(
s1
))[2] - 
__s2
[2]); \

882 i(
l1
 > 2 && 
__su
 == 0) \

883 
__su
 = (((const *) \

884 (cڡ *(
s1
))[3] \

885 - 
__s2
[3]); \

888 
__su
; }))

	)

890 
	#__rcmp_gc
(
s1
, 
s2
, 
l2
(- 
	`__rcmp_cg
 (s2, s1,2))

	)

895 #ide
_HAVE_STRING_ARCH_cmp


896 
	#cmp
(
s1
, 
s2
, 
n
) \

897 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
n
) \

898 && ((
	`__but_cڡt_p
 (
s1
) \

899 && 
	`
 (
s1
< ((
size_t
(
n
))) \

900 || (
	`__but_cڡt_p
 (
s2
) \

901 && 
	`
 (
s2
< ((
size_t
(
n
)))) \

902 ? 
	`rcmp
 (
s1
, 
s2
: 
	`cmp
 (s1, s2, 
n
)))

	)

908 #i!
defed
 
_HAVE_STRING_ARCH_rcn
 || defed 
_FORCE_INLINES


909 #ide
_HAVE_STRING_ARCH_rcn


910 #i
__GNUC_PREREQ
 (3, 2)

911 
	#rcn
(
s
, 
je
) \

912 
__exnsi__
 \

913 ({ 
__r0
, 
__r1
, 
__r2
; \

914 (
	`__but_cڡt_p
 (
je
&& 
	`__rg2_1br_p
 (reject) \

915 ? ((
	`__but_cڡt_p
 (
s
&& 
	`__rg2_1br_p
 (s)) \

916 ? 
	`__but_rcn
 (
s
, 
je
) \

917 : ((
__r0
 = ((cڡ *(
je
))[0], __r0 == '\0') \

918 ? 
	`
 (
s
) \

919 : ((
__r1
 = ((cڡ *(
je
))[1], __r1 == '\0') \

920 ? 
	`__rcn_c1
 (
s
, 
__r0
) \

921 : ((
__r2
 = ((cڡ *(
je
))[2], __r2 == '\0') \

922 ? 
	`__rcn_c2
 (
s
, 
__r0
, 
__r1
) \

923 : (((cڡ *(
je
))[3] == '\0' \

924 ? 
	`__rcn_c3
 (
s
, 
__r0
, 
__r1
, 
__r2
) \

925 : 
	`__but_rcn
 (
s
, 
je
)))))) \

926 : 
	`__but_rcn
 (
s
, 
je
)); })

	)

928 
	#rcn
(
s
, 
je
) \

929 
__exnsi__
 \

930 ({ 
__r0
, 
__r1
, 
__r2
; \

931 (
	`__but_cڡt_p
 (
je
&& 
	`__rg2_1br_p
 (reject) \

932 ? ((
__r0
 = ((cڡ *(
je
))[0], __r0 == '\0') \

933 ? 
	`
 (
s
) \

934 : ((
__r1
 = ((cڡ *(
je
))[1], __r1 == '\0') \

935 ? 
	`__rcn_c1
 (
s
, 
__r0
) \

936 : ((
__r2
 = ((cڡ *(
je
))[2], __r2 == '\0') \

937 ? 
	`__rcn_c2
 (
s
, 
__r0
, 
__r1
) \

938 : (((cڡ *(
je
))[3] == '\0' \

939 ? 
	`__rcn_c3
 (
s
, 
__r0
, 
__r1
, 
__r2
) \

940 : 
	`rcn
 (
s
, 
je
))))) \

941 : 
	`rcn
 (
s
, 
je
)); })

	)

945 
__STRING_INLINE
 
size_t
 
__rcn_c1
 (cڡ *
__s
, 
__je
);

946 
__STRING_INLINE
 
size_t


947 
	$__rcn_c1
 (cڡ *
__s
, 
__je
)

949 
size_t
 
__su
 = 0;

950 
__s
[
__su
] !'\0' && __s[__su] !
__je
)

951 ++
__su
;

952  
__su
;

953 
	}
}

955 
__STRING_INLINE
 
size_t
 
__rcn_c2
 (cڡ *
__s
, 
__je1
,

956 
__je2
);

957 
__STRING_INLINE
 
size_t


958 
	$__rcn_c2
 (cڡ *
__s
, 
__je1
, 
__je2
)

960 
size_t
 
__su
 = 0;

961 
__s
[
__su
] !'\0' && __s[__su] !
__je1


962 && 
__s
[
__su
] !
__je2
)

963 ++
__su
;

964  
__su
;

965 
	}
}

967 
__STRING_INLINE
 
size_t
 
__rcn_c3
 (cڡ *
__s
, 
__je1
,

968 
__je2
, 
__je3
);

969 
__STRING_INLINE
 
size_t


970 
	$__rcn_c3
 (cڡ *
__s
, 
__je1
, 
__je2
,

971 
__je3
)

973 
size_t
 
__su
 = 0;

974 
__s
[
__su
] !'\0' && __s[__su] !
__je1


975 && 
__s
[
__su
] !
__je2
 && __s[__su] !
__je3
)

976 ++
__su
;

977  
__su
;

978 
	}
}

984 #i!
defed
 
_HAVE_STRING_ARCH_rn
 || defed 
_FORCE_INLINES


985 #ide
_HAVE_STRING_ARCH_rn


986 #i
__GNUC_PREREQ
 (3, 2)

987 
	#rn
(
s
, 
ac
) \

988 
__exnsi__
 \

989 ({ 
__a0
, 
__a1
, 
__a2
; \

990 (
	`__but_cڡt_p
 (
ac
&& 
	`__rg2_1br_p
 (accept) \

991 ? ((
	`__but_cڡt_p
 (
s
&& 
	`__rg2_1br_p
 (s)) \

992 ? 
	`__but_rn
 (
s
, 
ac
) \

993 : ((
__a0
 = ((cڡ *(
ac
))[0], __a0 == '\0') \

994 ? (((
s
), (
size_t
) 0) \

995 : ((
__a1
 = ((cڡ *(
ac
))[1], __a1 == '\0') \

996 ? 
	`__rn_c1
 (
s
, 
__a0
) \

997 : ((
__a2
 = ((cڡ *(
ac
))[2], __a2 == '\0') \

998 ? 
	`__rn_c2
 (
s
, 
__a0
, 
__a1
) \

999 : (((cڡ *(
ac
))[3] == '\0' \

1000 ? 
	`__rn_c3
 (
s
, 
__a0
, 
__a1
, 
__a2
) \

1001 : 
	`__but_rn
 (
s
, 
ac
)))))) \

1002 : 
	`__but_rn
 (
s
, 
ac
)); })

	)

1004 
	#rn
(
s
, 
ac
) \

1005 
__exnsi__
 \

1006 ({ 
__a0
, 
__a1
, 
__a2
; \

1007 (
	`__but_cڡt_p
 (
ac
&& 
	`__rg2_1br_p
 (accept) \

1008 ? ((
__a0
 = ((cڡ *(
ac
))[0], __a0 == '\0') \

1009 ? (((
s
), (
size_t
) 0) \

1010 : ((
__a1
 = ((cڡ *(
ac
))[1], __a1 == '\0') \

1011 ? 
	`__rn_c1
 (
s
, 
__a0
) \

1012 : ((
__a2
 = ((cڡ *(
ac
))[2], __a2 == '\0') \

1013 ? 
	`__rn_c2
 (
s
, 
__a0
, 
__a1
) \

1014 : (((cڡ *(
ac
))[3] == '\0' \

1015 ? 
	`__rn_c3
 (
s
, 
__a0
, 
__a1
, 
__a2
) \

1016 : 
	`rn
 (
s
, 
ac
))))) \

1017 : 
	`rn
 (
s
, 
ac
)); })

	)

1021 
__STRING_INLINE
 
size_t
 
__rn_c1
 (cڡ *
__s
, 
__ac
);

1022 
__STRING_INLINE
 
size_t


1023 
	$__rn_c1
 (cڡ *
__s
, 
__ac
)

1025 
size_t
 
__su
 = 0;

1027 
__s
[
__su
] =
__ac
)

1028 ++
__su
;

1029  
__su
;

1030 
	}
}

1032 
__STRING_INLINE
 
size_t
 
__rn_c2
 (cڡ *
__s
, 
__ac1
,

1033 
__ac2
);

1034 
__STRING_INLINE
 
size_t


1035 
	$__rn_c2
 (cڡ *
__s
, 
__ac1
, 
__ac2
)

1037 
size_t
 
__su
 = 0;

1039 
__s
[
__su
] =
__ac1
 || __s[__su] =
__ac2
)

1040 ++
__su
;

1041  
__su
;

1042 
	}
}

1044 
__STRING_INLINE
 
size_t
 
__rn_c3
 (cڡ *
__s
, 
__ac1
,

1045 
__ac2
, 
__ac3
);

1046 
__STRING_INLINE
 
size_t


1047 
	$__rn_c3
 (cڡ *
__s
, 
__ac1
, 
__ac2
, 
__ac3
)

1049 
size_t
 
__su
 = 0;

1051 
__s
[
__su
] =
__ac1
 || __s[__su] =
__ac2


1052 || 
__s
[
__su
] =
__ac3
)

1053 ++
__su
;

1054  
__su
;

1055 
	}
}

1060 #i!
defed
 
_HAVE_STRING_ARCH_brk
 || defed 
_FORCE_INLINES


1061 #ide
_HAVE_STRING_ARCH_brk


1062 #i
__GNUC_PREREQ
 (3, 2)

1063 
	#brk
(
s
, 
ac
) \

1064 
__exnsi__
 \

1065 ({ 
__a0
, 
__a1
, 
__a2
; \

1066 (
	`__but_cڡt_p
 (
ac
&& 
	`__rg2_1br_p
 (accept) \

1067 ? ((
	`__but_cڡt_p
 (
s
&& 
	`__rg2_1br_p
 (s)) \

1068 ? 
	`__but_brk
 (
s
, 
ac
) \

1069 : ((
__a0
 = ((cڡ *(
ac
))[0], __a0 == '\0') \

1070 ? (((
s
), (*
NULL
) \

1071 : ((
__a1
 = ((cڡ *(
ac
))[1], __a1 == '\0') \

1072 ? 
	`__but_rchr
 (
s
, 
__a0
) \

1073 : ((
__a2
 = ((cڡ *(
ac
))[2], __a2 == '\0') \

1074 ? 
	`__brk_c2
 (
s
, 
__a0
, 
__a1
) \

1075 : (((cڡ *(
ac
))[3] == '\0' \

1076 ? 
	`__brk_c3
 (
s
, 
__a0
, 
__a1
, 
__a2
) \

1077 : 
	`__but_brk
 (
s
, 
ac
)))))) \

1078 : 
	`__but_brk
 (
s
, 
ac
)); })

	)

1080 
	#brk
(
s
, 
ac
) \

1081 
__exnsi__
 \

1082 ({ 
__a0
, 
__a1
, 
__a2
; \

1083 (
	`__but_cڡt_p
 (
ac
&& 
	`__rg2_1br_p
 (accept) \

1084 ? ((
__a0
 = ((cڡ *(
ac
))[0], __a0 == '\0') \

1085 ? (((
s
), (*
NULL
) \

1086 : ((
__a1
 = ((cڡ *(
ac
))[1], __a1 == '\0') \

1087 ? 
	`rchr
 (
s
, 
__a0
) \

1088 : ((
__a2
 = ((cڡ *(
ac
))[2], __a2 == '\0') \

1089 ? 
	`__brk_c2
 (
s
, 
__a0
, 
__a1
) \

1090 : (((cڡ *(
ac
))[3] == '\0' \

1091 ? 
	`__brk_c3
 (
s
, 
__a0
, 
__a1
, 
__a2
) \

1092 : 
	`brk
 (
s
, 
ac
))))) \

1093 : 
	`brk
 (
s
, 
ac
)); })

	)

1097 
__STRING_INLINE
 *
__brk_c2
 (cڡ *
__s
, 
__ac1
,

1098 
__ac2
);

1099 
__STRING_INLINE
 *

1100 
	$__brk_c2
 (cڡ *
__s
, 
__ac1
, 
__ac2
)

1103 *
__s
 !'\0' && *__!
__ac1
 && *__!
__ac2
)

1104 ++
__s
;

1105  *
__s
 ='\0' ? 
NULL
 : (*(
size_t
) __s;

1106 
	}
}

1108 
__STRING_INLINE
 *
__brk_c3
 (cڡ *
__s
, 
__ac1
,

1109 
__ac2
, 
__ac3
);

1110 
__STRING_INLINE
 *

1111 
	$__brk_c3
 (cڡ *
__s
, 
__ac1
, 
__ac2
, 
__ac3
)

1114 *
__s
 !'\0' && *__!
__ac1
 && *__!
__ac2


1115 && *
__s
 !
__ac3
)

1116 ++
__s
;

1117  *
__s
 ='\0' ? 
NULL
 : (*(
size_t
) __s;

1118 
	}
}

1124 #i!
defed
 
_HAVE_STRING_ARCH_rr
 && !
__GNUC_PREREQ
 (2, 97)

1125 
	#rr
(
hayack
, 
ed
) \

1126 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
ed
&& 
	`__rg2_1br_p
 (needle) \

1127 ? (((cڡ *(
ed
))[0] == '\0' \

1128 ? (*(
size_t
(
hayack
) \

1129 : (((cڡ *(
ed
))[1] == '\0' \

1130 ? 
	`rchr
 (
hayack
, \

1131 ((cڡ *(
ed
))[0]) \

1132 : 
	`rr
 (
hayack
, 
ed
))) \

1133 : 
	`rr
 (
hayack
, 
ed
)))

	)

1137 #i!
defed
 
_HAVE_STRING_ARCH_ok_r
 || defed 
_FORCE_INLINES


1138 #ide
_HAVE_STRING_ARCH_ok_r


1139 
	#__ok_r
(
s
, 
p
, 
x
) \

1140 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
p
&& 
	`__rg2_1br_p
 (sep) \

1141 && ((cڡ *(
p
))[0] != '\0' \

1142 && ((cڡ *(
p
))[1] == '\0' \

1143 ? 
	`__ok_r_1c
 (
s
, ((cڡ *(
p
))[0], 
x
) \

1144 : 
	`__ok_r
 (
s
, 
p
, 
x
)))

	)

1147 
__STRING_INLINE
 *
__ok_r_1c
 (*
__s
, 
__p
, **
__x
);

1148 
__STRING_INLINE
 *

1149 
	$__ok_r_1c
 (*
__s
, 
__p
, **
__x
)

1151 *
__su
;

1152 i(
__s
 =
NULL
)

1153 
__s
 = *
__x
;

1154 *
__s
 =
__p
)

1155 ++
__s
;

1156 
__su
 = 
NULL
;

1157 i(*
__s
 != '\0')

1159 
__su
 = 
__s
++;

1160 *
__s
 != '\0')

1161 i(*
__s
++ =
__p
)

1163 
__s
[-1] = '\0';

1167 *
__x
 = 
__s
;

1168  
__su
;

1169 
	}
}

1170 #i
defed
 
__USE_POSIX
 || defed 
__USE_MISC


1171 
	#ok_r
(
s
, 
p
, 
x

	`__ok_r
 (s, s,ex)

	)

1176 #i!
defed
 
_HAVE_STRING_ARCH_rp
 || defed 
_FORCE_INLINES


1177 #ide
_HAVE_STRING_ARCH_rp


1179 *
__rp_g
 (**
__rgp
, cڡ *
__dim
);

1180 
	#__rp
(
s
, 
je
) \

1181 
__exnsi__
 \

1182 ({ 
__r0
, 
__r1
, 
__r2
; \

1183 (
	`__but_cڡt_p
 (
je
&& 
	`__rg2_1br_p
 (reject) \

1184 && (
__r0
 = ((cڡ *(
je
))[0], \

1185 ((cڡ *(
je
))[0] != '\0') \

1186 ? ((
__r1
 = ((cڡ *(
je
))[1], \

1187 ((cڡ *(
je
))[1] == '\0') \

1188 ? 
	`__rp_1c
 (
s
, 
__r0
) \

1189 : ((
__r2
 = ((cڡ *(
je
))[2], __r2 == '\0') \

1190 ? 
	`__rp_2c
 (
s
, 
__r0
, 
__r1
) \

1191 : (((cڡ *(
je
))[3] == '\0' \

1192 ? 
	`__rp_3c
 (
s
, 
__r0
, 
__r1
, 
__r2
) \

1193 : 
	`__rp_g
 (
s
, 
je
)))) \

1194 : 
	`__rp_g
 (
s
, 
je
)); })

	)

1197 
__STRING_INLINE
 *
__rp_1c
 (**
__s
, 
__je
);

1198 
__STRING_INLINE
 *

1199 
	$__rp_1c
 (**
__s
, 
__je
)

1201 *
__tv
 = *
__s
;

1202 i(
__tv
 !
NULL
 && (*
__s
 = 
	`rchr
 (__tv, 
__je
)) != NULL)

1203 *(*
__s
)++ = '\0';

1204  
__tv
;

1205 
	}
}

1207 
__STRING_INLINE
 *
__rp_2c
 (**
__s
, 
__je1
, 
__je2
);

1208 
__STRING_INLINE
 *

1209 
	$__rp_2c
 (**
__s
, 
__je1
, 
__je2
)

1211 *
__tv
 = *
__s
;

1212 i(
__tv
 !
NULL
)

1214 *
__
 = 
__tv
;

1217 i(*
__
 == '\0')

1219 
__
 = 
NULL
;

1222 i(*
__
 =
__je1
 || *__ =
__je2
)

1224 *
__
++ = '\0';

1227 ++
__
;

1229 *
__s
 = 
__
;

1231  
__tv
;

1232 
	}
}

1234 
__STRING_INLINE
 *
__rp_3c
 (**
__s
, 
__je1
, 
__je2
,

1235 
__je3
);

1236 
__STRING_INLINE
 *

1237 
	$__rp_3c
 (**
__s
, 
__je1
, 
__je2
, 
__je3
)

1239 *
__tv
 = *
__s
;

1240 i(
__tv
 !
NULL
)

1242 *
__
 = 
__tv
;

1245 i(*
__
 == '\0')

1247 
__
 = 
NULL
;

1250 i(*
__
 =
__je1
 || *__ =
__je2
 || *__ =
__je3
)

1252 *
__
++ = '\0';

1255 ++
__
;

1257 *
__s
 = 
__
;

1259  
__tv
;

1260 
	}
}

1261 #ifde
__USE_BSD


1262 
	#rp
(
s
, 
je

	`__rp
 (s,eje)

	)

1269 #ifde
__USE_MISC


1271 #i!
defed
 
_HAVE_STRING_ARCH_rdup
 || !defed 
_HAVE_STRING_ARCH_dup


1272 
	#__ed_mloc_d_oc


	)

1273 
	~<dlib.h
>

1276 #ide
_HAVE_STRING_ARCH_rdup


1278 *
	$__rdup
 (cڡ *
__rg

__THROW
 
__ibu_mloc__
;

1279 
	#__rdup
(
s
) \

1280 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
s
&& 
	`__rg2_1br_p
 (s) \

1281 ? (((cڡ *(
s
))[0] == '\0' \

1282 ? (*
	`oc
 ((
size_t
) 1, (size_t) 1) \

1283 : ({ 
size_t
 
__n
 = 
	`
 (
s
) + 1; \

1284 *
__tv
 = (*
	`mloc
 (
__n
); \

1285 i(
__tv
 !
NULL
) \

1286 
__tv
 = (*
	`memy
 (__tv, 
s
, 
__n
); \

1287 
__tv
; 
	}
})) \

1288 : 
	`__rdup
 (
s
)))

	)

1290 #i
defed
 
__USE_SVID
 || defed 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


1291 
	#rdup
(
s

	`__rdup
 (s)

	)

1295 #ide
_HAVE_STRING_ARCH_dup


1297 *
	$__dup
 (cڡ *
__rg
, 
size_t
 
__n
)

1298 
__THROW
 
__ibu_mloc__
;

1299 
	#__dup
(
s
, 
n
) \

1300 (
	`__exnsi__
 (
	`__but_cڡt_p
 (
s
&& 
	`__rg2_1br_p
 (s) \

1301 ? (((cڡ *(
s
))[0] == '\0' \

1302 ? (*
	`oc
 ((
size_t
) 1, (size_t) 1) \

1303 : ({ 
size_t
 
__n
 = 
	`
 (
s
) + 1; \

1304 
size_t
 
__n
 = (
n
); \

1305 *
__tv
; \

1306 i(
__n
 < 
__n
) \

1307 
__n
 = 
__n
 + 1; \

1308 
__tv
 = (*
	`mloc
 (
__n
); \

1309 i(
__tv
 !
NULL
) \

1311 
__tv
[
__n
 - 1] = '\0'; \

1312 
__tv
 = (*
	`memy
 (__tv, 
s
, \

1313 
__n
 - 1); \

1315 
__tv
; 
	}
})) \

1316 : 
	`__dup
 (
s
, 
n
)))

	)

1318 #ifde
__USE_GNU


1319 
	#dup
(
s
, 
n

	`__dup
 (s,)

	)

1325 #ide
_FORCE_INLINES


1326 #unde
__STRING_INLINE


	@/usr/include/bits/string3.h

18 #ide
_STRING_H


22 
__wnde
 (
__wn_memt_zo_n
,

25 #ide
__lulus


29 #unde
memy


30 #unde
memmove


31 #unde
memt


32 #unde
rt


33 #unde
ry


34 #unde
t


35 #unde
y


36 #ifde
__USE_GNU


37 #unde
mempy


38 #unde
py


40 #ifde
__USE_BSD


41 #unde
bcy


42 #unde
bzo


47 
__ftify_funi
 *

48 
__NTH
 (
	$memy
 (*
__ri
 
__de
, cڡ *__ri 
__c
,

49 
size_t
 
__n
))

51  
	`__but___memy_chk
 (
__de
, 
__c
, 
__n
, 
	`__bos0
 (__dest));

52 
	}
}

54 
__ftify_funi
 *

55 
__NTH
 (
	$memmove
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
))

57  
	`__but___memmove_chk
 (
__de
, 
__c
, 
__n
, 
	`__bos0
 (__dest));

58 
	}
}

60 #ifde
__USE_GNU


61 
__ftify_funi
 *

62 
__NTH
 (
	$mempy
 (*
__ri
 
__de
, cڡ *__ri 
__c
,

63 
size_t
 
__n
))

65  
	`__but___mempy_chk
 (
__de
, 
__c
, 
__n
, 
	`__bos0
 (__dest));

66 
	}
}

75 
__ftify_funi
 *

76 
__NTH
 (
	$memt
 (*
__de
, 
__ch
, 
size_t
 
__n
))

78 i(
	`__but_cڡt_p
 (
__n
) && __len == 0

79 && (!
	`__but_cڡt_p
 (
__ch
) || __ch != 0))

81 
	`__wn_memt_zo_n
 ();

82  
__de
;

84  
	`__but___memt_chk
 (
__de
, 
__ch
, 
__n
, 
	`__bos0
 (__dest));

85 
	}
}

87 #ifde
__USE_BSD


88 
__ftify_funi
 

89 
__NTH
 (
	$bcy
 (cڡ *
__c
, *
__de
, 
size_t
 
__n
))

91 (
	`__but___memmove_chk
 (
__de
, 
__c
, 
__n
, 
	`__bos0
 (__dest));

92 
	}
}

94 
__ftify_funi
 

95 
__NTH
 (
	$bzo
 (*
__de
, 
size_t
 
__n
))

97 (
	`__but___memt_chk
 (
__de
, '\0', 
__n
, 
	`__bos0
 (__dest));

98 
	}
}

101 
__ftify_funi
 *

102 
__NTH
 (
	$ry
 (*
__ri
 
__de
, cڡ *__ri 
__c
))

104  
	`__but___ry_chk
 (
__de
, 
__c
, 
	`__bos
 (__dest));

105 
	}
}

107 #ifde
__USE_GNU


108 
__ftify_funi
 *

109 
__NTH
 (
	$py
 (*
__ri
 
__de
, cڡ *__ri 
__c
))

111  
	`__but___py_chk
 (
__de
, 
__c
, 
	`__bos
 (__dest));

112 
	}
}

116 
__ftify_funi
 *

117 
__NTH
 (
	$y
 (*
__ri
 
__de
, cڡ *__ri 
__c
,

118 
size_t
 
__n
))

120  
	`__but___y_chk
 (
__de
, 
__c
, 
__n
, 
	`__bos
 (__dest));

121 
	}
}

124 *
	$__y_chk
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
,

125 
size_t
 
__den

__THROW
;

126 *
	`__REDIRECT_NTH
 (
__y_s
, (*
__de
, cڡ *
__c
,

127 
size_t
 
__n
), 
y
);

129 
__ftify_funi
 *

130 
	`__NTH
 (
	$y
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
))

132 i(
	`__bos
 (
__de
!(
size_t
) -1

133 && (!
	`__but_cڡt_p
 (
__n
|| __<
	`__bos
 (
__de
)))

134  
	`__y_chk
 (
__de
, 
__c
, 
__n
, 
	`__bos
 (__dest));

135  
	`__y_s
 (
__de
, 
__c
, 
__n
);

136 
	}
}

139 
__ftify_funi
 *

140 
__NTH
 (
	$rt
 (*
__ri
 
__de
, cڡ *__ri 
__c
))

142  
	`__but___rt_chk
 (
__de
, 
__c
, 
	`__bos
 (__dest));

143 
	}
}

146 
__ftify_funi
 *

147 
__NTH
 (
	$t
 (*
__ri
 
__de
, cڡ *__ri 
__c
,

148 
size_t
 
__n
))

150  
	`__but___t_chk
 (
__de
, 
__c
, 
__n
, 
	`__bos
 (__dest));

151 
	}
}

	@/usr/include/bits/sys_errlist.h

19 #ide
_STDIO_H


25 #ifde 
__USE_BSD


26 
sys_ü
;

27 cڡ *cڡ 
sys_i
[];

29 #ifde 
__USE_GNU


30 
_sys_ü
;

31 cڡ *cڡ 
_sys_i
[];

	@/usr/include/bits/sysctl.h

18 #i
defed
 
__x86_64__
 && defed 
__ILP32__


	@/usr/include/bits/time.h

23 #i
defed
 
__ed_timev
 || defed 
__USE_GNU


24 #ide
_STRUCT_TIMEVAL


25 
	#_STRUCT_TIMEVAL
 1

	)

26 
	~<bs/tys.h
>

30 
	stimev


32 
__time_t
 
	mtv_c
;

33 
__sucds_t
 
	mtv_uc
;

38 #ide
__ed_timev


39 #ide
_BITS_TIME_H


40 
	#_BITS_TIME_H
 1

	)

48 
	#CLOCKS_PER_SEC
 1000000l

	)

50 #i(!
defed
 
__STRICT_ANSI__
 || defed 
__USE_POSIX
) \

51 && !
defed
 
	g__USE_XOPEN2K


54 
	~<bs/tys.h
>

55 
__syscf
 ();

56 
	#CLK_TCK
 ((
__ock_t

	`__syscf
 (2)

	)

59 #ifde
__USE_POSIX199309


61 
	#CLOCK_REALTIME
 0

	)

63 
	#CLOCK_MONOTONIC
 1

	)

65 
	#CLOCK_PROCESS_CPUTIME_ID
 2

	)

67 
	#CLOCK_THREAD_CPUTIME_ID
 3

	)

69 
	#CLOCK_MONOTONIC_RAW
 4

	)

71 
	#CLOCK_REALTIME_COARSE
 5

	)

73 
	#CLOCK_MONOTONIC_COARSE
 6

	)

75 
	#CLOCK_BOOTTIME
 7

	)

77 
	#CLOCK_REALTIME_ALARM
 8

	)

79 
	#CLOCK_BOOTTIME_ALARM
 9

	)

82 
	#TIMER_ABSTIME
 1

	)

85 #ifde
__USE_GNU


86 
	~<bs/timex.h
>

88 
__BEGIN_DECLS


91 
	$ock_adjtime
 (
__ockid_t
 
__ock_id
, 
timex
 *
__utx

__THROW
;

93 
__END_DECLS


99 #unde
__ed_timev


	@/usr/include/bits/types.h

23 #idef 
_BITS_TYPES_H


24 
	#_BITS_TYPES_H
 1

	)

26 
	~<us.h
>

27 
	~<bs/wdsize.h
>

30 
	t__u_ch
;

31 
	t__u_sht
;

32 
	t__u_t
;

33 
	t__u_lg
;

36 sigd 
	t__t8_t
;

37 
	t__ut8_t
;

38 sigd 
	t__t16_t
;

39 
	t__ut16_t
;

40 sigd 
	t__t32_t
;

41 
	t__ut32_t
;

42 #i
__WORDSIZE
 == 64

43 sigd 
	t__t64_t
;

44 
	t__ut64_t
;

46 
__exnsi__
 sigd 
	t__t64_t
;

47 
__exnsi__
 
	t__ut64_t
;

51 #i
__WORDSIZE
 == 64

52 
	t__quad_t
;

53 
	t__u_quad_t
;

55 
__exnsi__
 
	t__quad_t
;

56 
__exnsi__
 
	t__u_quad_t
;

89 
	#__S16_TYPE
 

	)

90 
	#__U16_TYPE
 

	)

91 
	#__S32_TYPE
 

	)

92 
	#__U32_TYPE
 

	)

93 
	#__SLONGWORD_TYPE
 

	)

94 
	#__ULONGWORD_TYPE
 

	)

95 #i
__WORDSIZE
 == 32

96 
	#__SQUAD_TYPE
 
__quad_t


	)

97 
	#__UQUAD_TYPE
 
__u_quad_t


	)

98 
	#__SWORD_TYPE
 

	)

99 
	#__UWORD_TYPE
 

	)

100 
	#__SLONG32_TYPE
 

	)

101 
	#__ULONG32_TYPE
 

	)

102 
	#__S64_TYPE
 
__quad_t


	)

103 
	#__U64_TYPE
 
__u_quad_t


	)

106 
	#__STD_TYPE
 
__exnsi__
 

	)

107 #i
__WORDSIZE
 == 64

108 
	t__SQUAD_TYPE
 

	)

109 
	t__UQUAD_TYPE
 

	)

110 
	t__SWORD_TYPE
 

	)

111 
	t__UWORD_TYPE
 

	)

112 
	t__SLONG32_TYPE
 

	)

113 
	t__ULONG32_TYPE
 

	)

114 
	t__S64_TYPE
 

	)

115 
	t__U64_TYPE
 

	)

117 
	t__STD_TYPE
 

	)

121 
	~<bs/tysizes.h
>

124 
__STD_TYPE
 
	t__DEV_T_TYPE
 
	t__dev_t
;

125 
__STD_TYPE
 
__UID_T_TYPE
 
	g__uid_t
;

126 
__STD_TYPE
 
__GID_T_TYPE
 
	g__gid_t
;

127 
__STD_TYPE
 
__INO_T_TYPE
 
	g__o_t
;

128 
__STD_TYPE
 
__INO64_T_TYPE
 
	g__o64_t
;

129 
__STD_TYPE
 
__MODE_T_TYPE
 
	g__mode_t
;

130 
__STD_TYPE
 
__NLINK_T_TYPE
 
	g__ƚk_t
;

131 
__STD_TYPE
 
__OFF_T_TYPE
 
	g__off_t
;

132 
__STD_TYPE
 
__OFF64_T_TYPE
 
	g__off64_t
;

133 
__STD_TYPE
 
__PID_T_TYPE
 
	g__pid_t
;

134 
__STD_TYPE
 
__FSID_T_TYPE
 
	g__fsid_t
;

135 
__STD_TYPE
 
__CLOCK_T_TYPE
 
	g__ock_t
;

136 
__STD_TYPE
 
__RLIM_T_TYPE
 
	g__im_t
;

137 
__STD_TYPE
 
__RLIM64_T_TYPE
 
	g__im64_t
;

138 
__STD_TYPE
 
__ID_T_TYPE
 
	g__id_t
;

139 
__STD_TYPE
 
__TIME_T_TYPE
 
	g__time_t
;

140 
__STD_TYPE
 
__USECONDS_T_TYPE
 
	g__ucds_t
;

141 
__STD_TYPE
 
__SUSECONDS_T_TYPE
 
	g__sucds_t
;

143 
__STD_TYPE
 
__DADDR_T_TYPE
 
	g__daddr_t
;

144 
__STD_TYPE
 
__KEY_T_TYPE
 
	g__key_t
;

147 
__STD_TYPE
 
__CLOCKID_T_TYPE
 
	g__ockid_t
;

150 
__STD_TYPE
 
__TIMER_T_TYPE
 
	g__tim_t
;

153 
__STD_TYPE
 
__BLKSIZE_T_TYPE
 
	g__blksize_t
;

158 
__STD_TYPE
 
__BLKCNT_T_TYPE
 
	g__blkt_t
;

159 
__STD_TYPE
 
__BLKCNT64_T_TYPE
 
	g__blkt64_t
;

162 
__STD_TYPE
 
__FSBLKCNT_T_TYPE
 
	g__fsblkt_t
;

163 
__STD_TYPE
 
__FSBLKCNT64_T_TYPE
 
	g__fsblkt64_t
;

166 
__STD_TYPE
 
__FSFILCNT_T_TYPE
 
	g__fsft_t
;

167 
__STD_TYPE
 
__FSFILCNT64_T_TYPE
 
	g__fsft64_t
;

170 
__STD_TYPE
 
__FSWORD_T_TYPE
 
	g__fswd_t
;

172 
__STD_TYPE
 
__SSIZE_T_TYPE
 
	g__ssize_t
;

175 
__STD_TYPE
 
__SYSCALL_SLONG_TYPE
 
	g__sys_g_t
;

177 
__STD_TYPE
 
__SYSCALL_ULONG_TYPE
 
	g__sys_ulg_t
;

181 
__off64_t
 
	t__loff_t
;

182 
__quad_t
 *
	t__qaddr_t
;

183 *
	t__ddr_t
;

186 
__STD_TYPE
 
__SWORD_TYPE
 
	g___t
;

189 
__STD_TYPE
 
__U32_TYPE
 
	g__sockn_t
;

192 #unde
__STD_TYPE


	@/usr/include/bits/unistd.h

19 #ide
_UNISTD_H


23 
ssize_t
 
	$__ad_chk
 (
__fd
, *
__buf
, 
size_t
 
__nbys
,

24 
size_t
 
__bu

__wur
;

25 
ssize_t
 
	`__REDIRECT
 (
__ad_s
, (
__fd
, *
__buf
,

26 
size_t
 
__nbys
), 
ad

__wur
;

27 
ssize_t
 
	`__REDIRECT
 (
__ad_chk_wn
,

28 (
__fd
, *
__buf
, 
size_t
 
__nbys
,

29 
size_t
 
__bu
), 
__ad_chk
)

30 
__wur
 
	`__wǉr
 ("read called with biggerengthhan size of "

33 
__ftify_funi
 
__wur
 
ssize_t


34 
	$ad
 (
__fd
, *
__buf
, 
size_t
 
__nbys
)

36 i(
	`__bos0
 (
__buf
!(
size_t
) -1)

38 i(!
	`__but_cڡt_p
 (
__nbys
))

39  
	`__ad_chk
 (
__fd
, 
__buf
, 
__nbys
, 
	`__bos0
 (__buf));

41 i(
__nbys
 > 
	`__bos0
 (
__buf
))

42  
	`__ad_chk_wn
 (
__fd
, 
__buf
, 
__nbys
, 
	`__bos0
 (__buf));

44  
	`__ad_s
 (
__fd
, 
__buf
, 
__nbys
);

45 
	}
}

47 #ifde
__USE_UNIX98


48 
ssize_t
 
	$__d_chk
 (
__fd
, *
__buf
, 
size_t
 
__nbys
,

49 
__off_t
 
__offt
, 
size_t
 
__bufsize

__wur
;

50 
ssize_t
 
	$__d64_chk
 (
__fd
, *
__buf
, 
size_t
 
__nbys
,

51 
__off64_t
 
__offt
, 
size_t
 
__bufsize

__wur
;

52 
ssize_t
 
	`__REDIRECT
 (
__d_s
,

53 (
__fd
, *
__buf
, 
size_t
 
__nbys
,

54 
__off_t
 
__offt
), 
d

__wur
;

55 
ssize_t
 
	`__REDIRECT
 (
__d64_s
,

56 (
__fd
, *
__buf
, 
size_t
 
__nbys
,

57 
__off64_t
 
__offt
), 
d64

__wur
;

58 
ssize_t
 
	`__REDIRECT
 (
__d_chk_wn
,

59 (
__fd
, *
__buf
, 
size_t
 
__nbys
,

60 
__off_t
 
__offt
, 
size_t
 
__bufsize
), 
__d_chk
)

61 
__wur
 
	`__wǉr
 ("pread called with biggerengthhan size of "

63 
ssize_t
 
	`__REDIRECT
 (
__d64_chk_wn
,

64 (
__fd
, *
__buf
, 
size_t
 
__nbys
,

65 
__off64_t
 
__offt
, 
size_t
 
__bufsize
),

66 
__d64_chk
)

67 
__wur
 
	`__wǉr
 ("pread64 called with biggerengthhan size of "

70 #ide
__USE_FILE_OFFSET64


71 
__ftify_funi
 
__wur
 
ssize_t


72 
	$d
 (
__fd
, *
__buf
, 
size_t
 
__nbys
, 
__off_t
 
__offt
)

74 i(
	`__bos0
 (
__buf
!(
size_t
) -1)

76 i(!
	`__but_cڡt_p
 (
__nbys
))

77  
	`__d_chk
 (
__fd
, 
__buf
, 
__nbys
, 
__offt
, 
	`__bos0
 (__buf));

79 i
__nbys
 > 
	`__bos0
 (
__buf
))

80  
	`__d_chk_wn
 (
__fd
, 
__buf
, 
__nbys
, 
__offt
,

81 
	`__bos0
 (
__buf
));

83  
	`__d_s
 (
__fd
, 
__buf
, 
__nbys
, 
__offt
);

84 
	}
}

86 
__ftify_funi
 
__wur
 
ssize_t


87 
	$d
 (
__fd
, *
__buf
, 
size_t
 
__nbys
, 
__off64_t
 
__offt
)

89 i(
	`__bos0
 (
__buf
!(
size_t
) -1)

91 i(!
	`__but_cڡt_p
 (
__nbys
))

92  
	`__d64_chk
 (
__fd
, 
__buf
, 
__nbys
, 
__offt
, 
	`__bos0
 (__buf));

94 i
__nbys
 > 
	`__bos0
 (
__buf
))

95  
	`__d64_chk_wn
 (
__fd
, 
__buf
, 
__nbys
, 
__offt
,

96 
	`__bos0
 (
__buf
));

99  
	`__d64_s
 (
__fd
, 
__buf
, 
__nbys
, 
__offt
);

100 
	}
}

103 #ifde
__USE_LARGEFILE64


104 
__ftify_funi
 
__wur
 
ssize_t


105 
	$d64
 (
__fd
, *
__buf
, 
size_t
 
__nbys
, 
__off64_t
 
__offt
)

107 i(
	`__bos0
 (
__buf
!(
size_t
) -1)

109 i(!
	`__but_cڡt_p
 (
__nbys
))

110  
	`__d64_chk
 (
__fd
, 
__buf
, 
__nbys
, 
__offt
, 
	`__bos0
 (__buf));

112 i
__nbys
 > 
	`__bos0
 (
__buf
))

113  
	`__d64_chk_wn
 (
__fd
, 
__buf
, 
__nbys
, 
__offt
,

114 
	`__bos0
 (
__buf
));

117  
	`__d64_s
 (
__fd
, 
__buf
, 
__nbys
, 
__offt
);

118 
	}
}

122 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K


123 
ssize_t
 
	$__adlk_chk
 (cڡ *
__ri
 
__th
,

124 *
__ri
 
__buf
, 
size_t
 
__n
,

125 
size_t
 
__bu
)

126 
__THROW
 
	`__nnu
 ((1, 2)
__wur
;

127 
ssize_t
 
	`__REDIRECT_NTH
 (
__adlk_s
,

128 (cڡ *
__ri
 
__th
,

129 *
__ri
 
__buf
, 
size_t
 
__n
), 
adlk
)

130 
	`__nnu
 ((1, 2)
__wur
;

131 
ssize_t
 
	`__REDIRECT_NTH
 (
__adlk_chk_wn
,

132 (cڡ *
__ri
 
__th
,

133 *
__ri
 
__buf
, 
size_t
 
__n
,

134 
size_t
 
__bu
), 
__adlk_chk
)

135 
	`__nnu
 ((1, 2)
__wur
 
	`__wǉr
 ("readlink called with biggerength "

138 
__ftify_funi
 
	`__nnu
 ((1, 2)
__wur
 
ssize_t


139 
	`__NTH
 (
	$adlk
 (cڡ *
__ri
 
__th
, *__ri 
__buf
,

140 
size_t
 
__n
))

142 i(
	`__bos
 (
__buf
!(
size_t
) -1)

144 i(!
	`__but_cڡt_p
 (
__n
))

145  
	`__adlk_chk
 (
__th
, 
__buf
, 
__n
, 
	`__bos
 (__buf));

147 i
__n
 > 
	`__bos
 (
__buf
))

148  
	`__adlk_chk_wn
 (
__th
, 
__buf
, 
__n
, 
	`__bos
 (__buf));

150  
	`__adlk_s
 (
__th
, 
__buf
, 
__n
);

151 
	}
}

154 #ifde
__USE_ATFILE


155 
ssize_t
 
	$__adlk_chk
 (
__fd
, cڡ *
__ri
 
__th
,

156 *
__ri
 
__buf
, 
size_t
 
__n
,

157 
size_t
 
__bu
)

158 
__THROW
 
	`__nnu
 ((2, 3)
__wur
;

159 
ssize_t
 
	`__REDIRECT_NTH
 (
__adlk_s
,

160 (
__fd
, cڡ *
__ri
 
__th
,

161 *
__ri
 
__buf
, 
size_t
 
__n
),

162 
adlk
)

163 
	`__nnu
 ((2, 3)
__wur
;

164 
ssize_t
 
	`__REDIRECT_NTH
 (
__adlk_chk_wn
,

165 (
__fd
, cڡ *
__ri
 
__th
,

166 *
__ri
 
__buf
, 
size_t
 
__n
,

167 
size_t
 
__bu
), 
__adlk_chk
)

168 
	`__nnu
 ((2, 3)
__wur
 
	`__wǉr
 ("readlinkat called with bigger "

172 
__ftify_funi
 
	`__nnu
 ((2, 3)
__wur
 
ssize_t


173 
	`__NTH
 (
	$adlk
 (
__fd
, cڡ *
__ri
 
__th
,

174 *
__ri
 
__buf
, 
size_t
 
__n
))

176 i(
	`__bos
 (
__buf
!(
size_t
) -1)

178 i(!
	`__but_cڡt_p
 (
__n
))

179  
	`__adlk_chk
 (
__fd
, 
__th
, 
__buf
, 
__n
, 
	`__bos
 (__buf));

181 i(
__n
 > 
	`__bos
 (
__buf
))

182  
	`__adlk_chk_wn
 (
__fd
, 
__th
, 
__buf
, 
__n
,

183 
	`__bos
 (
__buf
));

185  
	`__adlk_s
 (
__fd
, 
__th
, 
__buf
, 
__n
);

186 
	}
}

189 *
	$__gcwd_chk
 (*
__buf
, 
size_t
 
__size
, size_
__bu
)

190 
__THROW
 
__wur
;

191 *
	`__REDIRECT_NTH
 (
__gcwd_s
,

192 (*
__buf
, 
size_t
 
__size
), 
gcwd

__wur
;

193 *
	`__REDIRECT_NTH
 (
__gcwd_chk_wn
,

194 (*
__buf
, 
size_t
 
__size
, size_
__bu
),

195 
__gcwd_chk
)

196 
__wur
 
	`__wǉr
 ("getcwd caller with biggerengthhan size of "

199 
__ftify_funi
 
__wur
 *

200 
	`__NTH
 (
	$gcwd
 (*
__buf
, 
size_t
 
__size
))

202 i(
	`__bos
 (
__buf
!(
size_t
) -1)

204 i(!
	`__but_cڡt_p
 (
__size
))

205  
	`__gcwd_chk
 (
__buf
, 
__size
, 
	`__bos
 (__buf));

207 i(
__size
 > 
	`__bos
 (
__buf
))

208  
	`__gcwd_chk_wn
 (
__buf
, 
__size
, 
	`__bos
 (__buf));

210  
	`__gcwd_s
 (
__buf
, 
__size
);

211 
	}
}

213 #i
defed
 
__USE_BSD
 || defed 
__USE_XOPEN_EXTENDED


214 *
	$__gwd_chk
 (*
__buf
, 
size_t
 
bu
)

215 
__THROW
 
	`__nnu
 ((1)
__wur
;

216 *
	`__REDIRECT_NTH
 (
__gwd_wn
, (*
__buf
), 
gwd
)

217 
	`__nnu
 ((1)
__wur
 
	`__wǉr
 ("please use getcwd instead,s getwd "

220 
__ftify_funi
 
	`__nnu
 ((1)
__ibu_dd__
 
__wur
 *

221 
	`__NTH
 (
	$gwd
 (*
__buf
))

223 i(
	`__bos
 (
__buf
!(
size_t
) -1)

224  
	`__gwd_chk
 (
__buf
, 
	`__bos
 (__buf));

225  
	`__gwd_wn
 (
__buf
);

226 
	}
}

229 
size_t
 
	$__cfr_chk
 (
__me
, *
__buf
, 
size_t
 
__n
,

230 
size_t
 
__bu

__THROW
;

231 
size_t
 
	`__REDIRECT_NTH
 (
__cfr_s
, (
__me
, *
__buf
,

232 
size_t
 
__n
), 
cfr
);

233 
size_t
 
	`__REDIRECT_NTH
 (
__cfr_chk_wn
,

234 (
__me
, *
__buf
, 
size_t
 
__n
,

235 
size_t
 
__bu
), 
__cfr_chk
)

236 
	`__wǉr
 ("confstr called with biggerengthhan size of destination "

239 
__ftify_funi
 
size_t


240 
	`__NTH
 (
	$cfr
 (
__me
, *
__buf
, 
size_t
 
__n
))

242 i(
	`__bos
 (
__buf
!(
size_t
) -1)

244 i(!
	`__but_cڡt_p
 (
__n
))

245  
	`__cfr_chk
 (
__me
, 
__buf
, 
__n
, 
	`__bos
 (__buf));

247 i(
	`__bos
 (
__buf
< 
__n
)

248  
	`__cfr_chk_wn
 (
__me
, 
__buf
, 
__n
, 
	`__bos
 (__buf));

250  
	`__cfr_s
 (
__me
, 
__buf
, 
__n
);

251 
	}
}

254 
	$__ggroups_chk
 (
__size
, 
__gid_t
 
__li
[], 
size_t
 
__lin
)

255 
__THROW
 
__wur
;

256 
	`__REDIRECT_NTH
 (
__ggroups_s
, (
__size
, 
__gid_t
 
__li
[]),

257 
ggroups

__wur
;

258 
	`__REDIRECT_NTH
 (
__ggroups_chk_wn
,

259 (
__size
, 
__gid_t
 
__li
[], 
size_t
 
__lin
),

260 
__ggroups_chk
)

261 
__wur
 
	`__wǉr
 ("getgroups called with bigger group counthan what "

264 
__ftify_funi
 

265 
	`__NTH
 (
	$ggroups
 (
__size
, 
__gid_t
 
__li
[]))

267 i(
	`__bos
 (
__li
!(
size_t
) -1)

269 i(!
	`__but_cڡt_p
 (
__size
) || __size < 0)

270  
	`__ggroups_chk
 (
__size
, 
__li
, 
	`__bos
 (__list));

272 i(
__size
 *  (
__gid_t
> 
	`__bos
 (
__li
))

273  
	`__ggroups_chk_wn
 (
__size
, 
__li
, 
	`__bos
 (__list));

275  
	`__ggroups_s
 (
__size
, 
__li
);

276 
	}
}

279 
	$__yme_r_chk
 (
__fd
, *
__buf
, 
size_t
 
__bu
,

280 
size_t
 
__ėl

__THROW
 
	`__nnu
 ((2));

281 
	`__REDIRECT_NTH
 (
__yme_r_s
, (
__fd
, *
__buf
,

282 
size_t
 
__bu
), 
yme_r
)

283 
	`__nnu
 ((2));

284 
	`__REDIRECT_NTH
 (
__yme_r_chk_wn
,

285 (
__fd
, *
__buf
, 
size_t
 
__bu
,

286 
size_t
 
__ėl
), 
__yme_r_chk
)

287 
	`__nnu
 ((2)
	`__wǉr
 ("ttyname_r called with bigger buflenhan "

290 
__ftify_funi
 

291 
	`__NTH
 (
	$yme_r
 (
__fd
, *
__buf
, 
size_t
 
__bu
))

293 i(
	`__bos
 (
__buf
!(
size_t
) -1)

295 i(!
	`__but_cڡt_p
 (
__bu
))

296  
	`__yme_r_chk
 (
__fd
, 
__buf
, 
__bu
, 
	`__bos
 (__buf));

298 i(
__bu
 > 
	`__bos
 (
__buf
))

299  
	`__yme_r_chk_wn
 (
__fd
, 
__buf
, 
__bu
, 
	`__bos
 (__buf));

301  
	`__yme_r_s
 (
__fd
, 
__buf
, 
__bu
);

302 
	}
}

305 #i
defed
 
__USE_REENTRANT
 || defed 
__USE_POSIX199506


306 
	$__glog_r_chk
 (*
__buf
, 
size_t
 
__bu
, size_
__ėl
)

307 
	`__nnu
 ((1));

308 
	`__REDIRECT
 (
__glog_r_s
, (*
__buf
, 
size_t
 
__bu
),

309 
glog_r

	`__nnu
 ((1));

310 
	`__REDIRECT
 (
__glog_r_chk_wn
,

311 (*
__buf
, 
size_t
 
__bu
, size_
__ėl
),

312 
__glog_r_chk
)

313 
	`__nnu
 ((1)
	`__wǉr
 ("getlogin_r called with bigger buflenhan "

316 
__ftify_funi
 

317 
	$glog_r
 (*
__buf
, 
size_t
 
__bu
)

319 i(
	`__bos
 (
__buf
!(
size_t
) -1)

321 i(!
	`__but_cڡt_p
 (
__bu
))

322  
	`__glog_r_chk
 (
__buf
, 
__bu
, 
	`__bos
 (__buf));

324 i(
__bu
 > 
	`__bos
 (
__buf
))

325  
	`__glog_r_chk_wn
 (
__buf
, 
__bu
, 
	`__bos
 (__buf));

327  
	`__glog_r_s
 (
__buf
, 
__bu
);

328 
	}
}

332 #i
defed
 
__USE_BSD
 || defed 
__USE_UNIX98


333 
	$__ghome_chk
 (*
__buf
, 
size_t
 
__bu
, size_
__ėl
)

334 
__THROW
 
	`__nnu
 ((1));

335 
	`__REDIRECT_NTH
 (
__ghome_s
, (*
__buf
, 
size_t
 
__bu
),

336 
ghome

	`__nnu
 ((1));

337 
	`__REDIRECT_NTH
 (
__ghome_chk_wn
,

338 (*
__buf
, 
size_t
 
__bu
, size_
__ėl
),

339 
__ghome_chk
)

340 
	`__nnu
 ((1)
	`__wǉr
 ("gethostname called with bigger buflenhan "

343 
__ftify_funi
 

344 
	`__NTH
 (
	$ghome
 (*
__buf
, 
size_t
 
__bu
))

346 i(
	`__bos
 (
__buf
!(
size_t
) -1)

348 i(!
	`__but_cڡt_p
 (
__bu
))

349  
	`__ghome_chk
 (
__buf
, 
__bu
, 
	`__bos
 (__buf));

351 i(
__bu
 > 
	`__bos
 (
__buf
))

352  
	`__ghome_chk_wn
 (
__buf
, 
__bu
, 
	`__bos
 (__buf));

354  
	`__ghome_s
 (
__buf
, 
__bu
);

355 
	}
}

359 #i
defed
 
__USE_BSD
 || (defed 
__USE_XOPEN
 && !defed 
__USE_UNIX98
)

360 
	$__gdomame_chk
 (*
__buf
, 
size_t
 
__bu
, size_
__ėl
)

361 
__THROW
 
	`__nnu
 ((1)
__wur
;

362 
	`__REDIRECT_NTH
 (
__gdomame_s
, (*
__buf
,

363 
size_t
 
__bu
),

364 
gdomame

	`__nnu
 ((1)
__wur
;

365 
	`__REDIRECT_NTH
 (
__gdomame_chk_wn
,

366 (*
__buf
, 
size_t
 
__bu
, size_
__ėl
),

367 
__gdomame_chk
)

368 
	`__nnu
 ((1)
__wur
 
	`__wǉr
 ("getdomainname called with bigger "

372 
__ftify_funi
 

373 
	`__NTH
 (
	$gdomame
 (*
__buf
, 
size_t
 
__bu
))

375 i(
	`__bos
 (
__buf
!(
size_t
) -1)

377 i(!
	`__but_cڡt_p
 (
__bu
))

378  
	`__gdomame_chk
 (
__buf
, 
__bu
, 
	`__bos
 (__buf));

380 i(
__bu
 > 
	`__bos
 (
__buf
))

381  
	`__gdomame_chk_wn
 (
__buf
, 
__bu
, 
	`__bos
 (__buf));

383  
	`__gdomame_s
 (
__buf
, 
__bu
);

384 
	}
}

	@/usr/include/bits/utsname.h

18 #ide
_SYS_UTSNAME_H


23 
	#_UTSNAME_LENGTH
 65

	)

28 
	#_UTSNAME_DOMAIN_LENGTH
 
_UTSNAME_LENGTH


	)

	@/usr/include/bits/waitflags.h

19 #i!
defed
 
_SYS_WAIT_H
 && !defed 
_STDLIB_H


25 
	#WNOHANG
 1

	)

26 
	#WUNTRACED
 2

	)

29 
	#WSTOPPED
 2

	)

30 
	#WEXITED
 4

	)

31 
	#WCONTINUED
 8

	)

32 
	#WNOWAIT
 0x01000000

	)

34 
	#__WNOTHREAD
 0x20000000

	)

36 
	#__WALL
 0x40000000

	)

37 
	#__WCLONE
 0x80000000

	)

40 #i
defed
 
__USE_SVID
 || defed 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8


41 #ide
__ENUM_IDTYPE_T


42 
	#__ENUM_IDTYPE_T
 1

	)

46 #unde
P_ALL


47 #unde
P_PID


48 #unde
P_PGID


52 
	mP_ALL
,

53 
	mP_PID
,

54 
	mP_PGID


55 } 
	tidty_t
;

	@/usr/include/bits/waitstatus.h

19 #i!
defed
 
_SYS_WAIT_H
 && !defed 
_STDLIB_H


28 
	#__WEXITSTATUS
(
us
(((us& 0xff00>> 8)

	)

31 
	#__WTERMSIG
(
us
((us& 0x7f)

	)

34 
	#__WSTOPSIG
(
us

	`__WEXITSTATUS
(us)

	)

37 
	#__WIFEXITED
(
us
(
	`__WTERMSIG
(us=0)

	)

40 
	#__WIFSIGNALED
(
us
) \

41 (((sigd (((
us
& 0x7f+ 1>> 1> 0)

	)

44 
	#__WIFSTOPPED
(
us
(((us& 0xff=0x7f)

	)

48 #ifde
WCONTINUED


49 
	#__WIFCONTINUED
(
us
((us=
__W_CONTINUED
)

	)

53 
	#__WCOREDUMP
(
us
((us& 
__WCOREFLAG
)

	)

56 
	#__W_EXITCODE
(
t
, 
sig
(ԑ<< 8 | (sig))

	)

57 
	#__W_STOPCODE
(
sig
((sig<< 8 | 0x7f)

	)

58 
	#__W_CONTINUED
 0xffff

	)

59 
	#__WCOREFLAG
 0x80

	)

62 #ifdef 
__USE_BSD


64 
	~<dn.h
>

66 
	uwa


68 
	mw_us
;

71 #if 
__BYTE_ORDER
 =
__LITTLE_ENDIAN


72 
	m__w_rmsig
:7;

73 
	m__w_cedump
:1;

74 
	m__w_tcode
:8;

77 #if 
__BYTE_ORDER
 =
__BIG_ENDIAN


79 
	m__w_tcode
:8;

80 
	m__w_cedump
:1;

81 
	m__w_rmsig
:7;

83 } 
	m__wa_rmed
;

86 #if 
__BYTE_ORDER
 =
__LITTLE_ENDIAN


87 
	m__w_v
:8;

88 
	m__w_sig
:8;

91 #if 
__BYTE_ORDER
 =
__BIG_ENDIAN


93 
	m__w_sig
:8;

94 
	m__w_v
:8;

96 } 
	m__wa_ݳd
;

99 
	#w_rmsig
 
__wa_rmed
.
__w_rmsig


	)

100 
	#w_cedump
 
__wa_rmed
.
__w_cedump


	)

101 
	#w_tcode
 
__wa_rmed
.
__w_tcode


	)

102 
	#w_sig
 
__wa_ݳd
.
__w_sig


	)

103 
	#w_v
 
__wa_ݳd
.
__w_v


	)

	@/usr/include/bits/wchar.h

19 #ide
_BITS_WCHAR_H


20 
	#_BITS_WCHAR_H
 1

	)

33 #ifde
__WCHAR_MAX__


34 
	#__WCHAR_MAX
 
__WCHAR_MAX__


	)

35 #i
L
'\0' - 1 > 0

36 
	#__WCHAR_MAX
 (0xffffffffu + 
L
'\0')

	)

38 
	#__WCHAR_MAX
 (0x7ffffff+ 
L
'\0')

	)

41 #ifde
__WCHAR_MIN__


42 
	#__WCHAR_MIN
 
__WCHAR_MIN__


	)

43 #i
L
'\0' - 1 > 0

44 
	#__WCHAR_MIN
 (
L
'\0' + 0)

	)

46 
	#__WCHAR_MIN
 (-
__WCHAR_MAX
 - 1)

	)

	@/usr/include/bits/wordsize.h

3 #i
defed
 
__x86_64__
 && !defed 
__ILP32__


4 
	#__WORDSIZE
 64

	)

6 
	#__WORDSIZE
 32

	)

9 #ifde
__x86_64__


10 
	#__WORDSIZE_TIME64_COMPAT32
 1

	)

12 
	#__SYSCALL_WORDSIZE
 64

	)

	@/usr/include/bits/xopen_lim.h

29 #ide
_XOPEN_LIM_H


30 
	#_XOPEN_LIM_H
 1

	)

32 
	#__ed_IOV_MAX


	)

33 
	~<bs/dio_lim.h
>

65 
	#_XOPEN_IOV_MAX
 
_POSIX_UIO_MAXIOV


	)

70 
	#NL_ARGMAX
 
_POSIX_ARG_MAX


	)

73 
	#NL_LANGMAX
 
_POSIX2_LINE_MAX


	)

76 
	#NL_MSGMAX
 
INT_MAX


	)

80 
	#NL_NMAX
 
INT_MAX


	)

83 
	#NL_SETMAX
 
INT_MAX


	)

86 
	#NL_TEXTMAX
 
INT_MAX


	)

89 
	#NZERO
 20

	)

93 #ifde
INT_MAX


94 #i
INT_MAX
 == 32767

95 
	#WORD_BIT
 16

	)

97 #i
INT_MAX
 == 2147483647

98 
	#WORD_BIT
 32

	)

101 
	#WORD_BIT
 64

	)

104 #i
defed
 
__INT_MAX__


105 #i
__INT_MAX__
 == 32767

106 
	#WORD_BIT
 16

	)

108 #i
__INT_MAX__
 == 2147483647

109 
	#WORD_BIT
 32

	)

112 
	#WORD_BIT
 64

	)

116 
	#WORD_BIT
 32

	)

120 #ifde
LONG_MAX


121 #i
LONG_MAX
 == 2147483647

122 
	#LONG_BIT
 32

	)

125 
	#LONG_BIT
 64

	)

127 #i
defed
 
__LONG_MAX__


128 #i
__LONG_MAX__
 == 2147483647

129 
	#LONG_BIT
 32

	)

132 
	#LONG_BIT
 64

	)

135 
	~<bs/wdsize.h
>

136 #i
__WORDSIZE
 == 64

137 
	#LONG_BIT
 64

	)

139 
	#LONG_BIT
 32

	)

	@/usr/include/endian.h

18 #idef 
_ENDIAN_H


19 
	#_ENDIAN_H
 1

	)

21 
	~<us.h
>

31 
	#__LITTLE_ENDIAN
 1234

	)

32 
	#__BIG_ENDIAN
 4321

	)

33 
	#__PDP_ENDIAN
 3412

	)

36 
	~<bs/dn.h
>

40 #ide
__FLOAT_WORD_ORDER


41 
	#__FLOAT_WORD_ORDER
 
__BYTE_ORDER


	)

44 #ifdef 
__USE_BSD


45 
	#LITTLE_ENDIAN
 
__LITTLE_ENDIAN


	)

46 
	#BIG_ENDIAN
 
__BIG_ENDIAN


	)

47 
	#PDP_ENDIAN
 
__PDP_ENDIAN


	)

48 
	#BYTE_ORDER
 
__BYTE_ORDER


	)

51 #i
__BYTE_ORDER
 =
__LITTLE_ENDIAN


52 
	#__LONG_LONG_PAIR
(
HI
, 
LO
LO, 
	)
HI

53 #i
__BYTE_ORDER
 =
__BIG_ENDIAN


54 
	#__LONG_LONG_PAIR
(
HI
, 
LO
HI, 
	)
LO

58 #i
defed
 
__USE_BSD
 && !defed 
__ASSEMBLER__


60 
	~<bs/bysw.h
>

62 #i
__BYTE_ORDER
 =
__LITTLE_ENDIAN


63 
	#htobe16
(
x

	`__bsw_16
 (x)

	)

64 
	#hte16
(
x
(x)

	)

65 
	#be16toh
(
x

	`__bsw_16
 (x)

	)

66 
	#16toh
(
x
(x)

	)

68 
	#htobe32
(
x

	`__bsw_32
 (x)

	)

69 
	#hte32
(
x
(x)

	)

70 
	#be32toh
(
x

	`__bsw_32
 (x)

	)

71 
	#32toh
(
x
(x)

	)

73 
	#htobe64
(
x

	`__bsw_64
 (x)

	)

74 
	#hte64
(
x
(x)

	)

75 
	#be64toh
(
x

	`__bsw_64
 (x)

	)

76 
	#64toh
(
x
(x)

	)

79 
	#htobe16
(
x
(x)

	)

80 
	#hte16
(
x

	`__bsw_16
 (x)

	)

81 
	#be16toh
(
x
(x)

	)

82 
	#16toh
(
x

	`__bsw_16
 (x)

	)

84 
	#htobe32
(
x
(x)

	)

85 
	#hte32
(
x

	`__bsw_32
 (x)

	)

86 
	#be32toh
(
x
(x)

	)

87 
	#32toh
(
x

	`__bsw_32
 (x)

	)

89 
	#htobe64
(
x
(x)

	)

90 
	#hte64
(
x

	`__bsw_64
 (x)

	)

91 
	#be64toh
(
x
(x)

	)

92 
	#64toh
(
x

	`__bsw_64
 (x)

	)

	@/usr/include/features.h

18 #idef 
_FEATURES_H


19 
	#_FEATURES_H
 1

	)

101 #unde
__USE_ISOC11


102 #unde
__USE_ISOC99


103 #unde
__USE_ISOC95


104 #unde
__USE_ISOCXX11


105 #unde
__USE_POSIX


106 #unde
__USE_POSIX2


107 #unde
__USE_POSIX199309


108 #unde
__USE_POSIX199506


109 #unde
__USE_XOPEN


110 #unde
__USE_XOPEN_EXTENDED


111 #unde
__USE_UNIX98


112 #unde
__USE_XOPEN2K


113 #unde
__USE_XOPEN2KXSI


114 #unde
__USE_XOPEN2K8


115 #unde
__USE_XOPEN2K8XSI


116 #unde
__USE_LARGEFILE


117 #unde
__USE_LARGEFILE64


118 #unde
__USE_FILE_OFFSET64


119 #unde
__USE_BSD


120 #unde
__USE_SVID


121 #unde
__USE_MISC


122 #unde
__USE_ATFILE


123 #unde
__USE_GNU


124 #unde
__USE_REENTRANT


125 #unde
__USE_FORTIFY_LEVEL


126 #unde
__KERNEL_STRICT_NAMES


130 #ide
_LOOSE_KERNEL_NAMES


131 
	#__KERNEL_STRICT_NAMES


	)

141 #i
defed
 
__GNUC__
 && defed 
__GNUC_MINOR__


142 
	#__GNUC_PREREQ
(
maj
, 
m
) \

143 ((
__GNUC__
 << 16+ 
__GNUC_MINOR__
 >((
maj
<< 16+ (
m
))

	)

145 
	#__GNUC_PREREQ
(
maj
, 
m
0

	)

150 #ifde
_GNU_SOURCE


151 #unde
_ISOC95_SOURCE


152 
	#_ISOC95_SOURCE
 1

	)

153 #unde
_ISOC99_SOURCE


154 
	#_ISOC99_SOURCE
 1

	)

155 #unde
_ISOC11_SOURCE


156 
	#_ISOC11_SOURCE
 1

	)

157 #unde
_POSIX_SOURCE


158 
	#_POSIX_SOURCE
 1

	)

159 #unde
_POSIX_C_SOURCE


160 
	#_POSIX_C_SOURCE
 200809L

	)

161 #unde
_XOPEN_SOURCE


162 
	#_XOPEN_SOURCE
 700

	)

163 #unde
_XOPEN_SOURCE_EXTENDED


164 
	#_XOPEN_SOURCE_EXTENDED
 1

	)

165 #unde
_LARGEFILE64_SOURCE


166 
	#_LARGEFILE64_SOURCE
 1

	)

167 #unde
_DEFAULT_SOURCE


168 
	#_DEFAULT_SOURCE
 1

	)

169 #unde
_BSD_SOURCE


170 
	#_BSD_SOURCE
 1

	)

171 #unde
_SVID_SOURCE


172 
	#_SVID_SOURCE
 1

	)

173 #unde
_ATFILE_SOURCE


174 
	#_ATFILE_SOURCE
 1

	)

179 #i(
defed
 
_DEFAULT_SOURCE
 \

180 || (!
defed
 
	g__STRICT_ANSI__
 \

181 && !
defed
 
	g_ISOC99_SOURCE
 \

182 && !
defed
 
	g_POSIX_SOURCE
 && !defed 
	g_POSIX_C_SOURCE
 \

183 && !
defed
 
	g_XOPEN_SOURCE
 \

184 && !
defed
 
	g_BSD_SOURCE
 && !defed 
	g_SVID_SOURCE
))

185 #unde
_DEFAULT_SOURCE


186 
	#_DEFAULT_SOURCE
 1

	)

187 #unde
_BSD_SOURCE


188 
	#_BSD_SOURCE
 1

	)

189 #unde
_SVID_SOURCE


190 
	#_SVID_SOURCE
 1

	)

194 #i(
defed
 
_ISOC11_SOURCE
 \

195 || (
defed
 
	g__STDC_VERSION__
 && __STDC_VERSION__ >= 201112L))

196 
	#__USE_ISOC11
 1

	)

200 #i(
defed
 
_ISOC99_SOURCE
 || defed 
_ISOC11_SOURCE
 \

201 || (
defed
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L))

202 
	#__USE_ISOC99
 1

	)

206 #i(
defed
 
_ISOC99_SOURCE
 || defed 
_ISOC11_SOURCE
 \

207 || (
defed
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199409L))

208 
	#__USE_ISOC95
 1

	)

215 #i((
defed
 
__lulus
 && __cplusplus >= 201103L) \

216 || 
defed
 
__GXX_EXPERIMENTAL_CXX0X__
)

217 
	#__USE_ISOCXX11
 1

	)

223 #ifde
_DEFAULT_SOURCE


224 #i!
defed
 
_POSIX_SOURCE
 && !defed 
_POSIX_C_SOURCE


225 
	#__USE_POSIX_IMPLICITLY
 1

	)

227 #unde
_POSIX_SOURCE


228 
	#_POSIX_SOURCE
 1

	)

229 #unde
_POSIX_C_SOURCE


230 
	#_POSIX_C_SOURCE
 200809L

	)

232 #i((!
defed
 
__STRICT_ANSI__
 || (
_XOPEN_SOURCE
 - 0) >= 500) && \

233 !
defed
 
_POSIX_SOURCE
 && !defed 
_POSIX_C_SOURCE
)

234 
	#_POSIX_SOURCE
 1

	)

235 #i
defed
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 500

236 
	#_POSIX_C_SOURCE
 2

	)

237 #i
defed
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 600

238 
	#_POSIX_C_SOURCE
 199506L

	)

239 #i
defed
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 700

240 
	#_POSIX_C_SOURCE
 200112L

	)

242 
	#_POSIX_C_SOURCE
 200809L

	)

244 
	#__USE_POSIX_IMPLICITLY
 1

	)

247 #i
defed
 
_POSIX_SOURCE
 || 
_POSIX_C_SOURCE
 >1 || defed 
_XOPEN_SOURCE


248 
	#__USE_POSIX
 1

	)

251 #i
defed
 
_POSIX_C_SOURCE
 && _POSIX_C_SOURCE >2 || defed 
_XOPEN_SOURCE


252 
	#__USE_POSIX2
 1

	)

255 #i(
_POSIX_C_SOURCE
 - 0) >= 199309L

256 
	#__USE_POSIX199309
 1

	)

259 #i(
_POSIX_C_SOURCE
 - 0) >= 199506L

260 
	#__USE_POSIX199506
 1

	)

263 #i(
_POSIX_C_SOURCE
 - 0) >= 200112L

264 
	#__USE_XOPEN2K
 1

	)

265 #unde
__USE_ISOC95


266 
	#__USE_ISOC95
 1

	)

267 #unde
__USE_ISOC99


268 
	#__USE_ISOC99
 1

	)

271 #i(
_POSIX_C_SOURCE
 - 0) >= 200809L

272 
	#__USE_XOPEN2K8
 1

	)

273 #unde
_ATFILE_SOURCE


274 
	#_ATFILE_SOURCE
 1

	)

277 #ifdef 
_XOPEN_SOURCE


278 
	#__USE_XOPEN
 1

	)

279 #i(
_XOPEN_SOURCE
 - 0) >= 500

280 
	#__USE_XOPEN_EXTENDED
 1

	)

281 
	#__USE_UNIX98
 1

	)

282 #unde
_LARGEFILE_SOURCE


283 
	#_LARGEFILE_SOURCE
 1

	)

284 #i(
_XOPEN_SOURCE
 - 0) >= 600

285 #i(
_XOPEN_SOURCE
 - 0) >= 700

286 
	#__USE_XOPEN2K8
 1

	)

287 
	#__USE_XOPEN2K8XSI
 1

	)

289 
	#__USE_XOPEN2K
 1

	)

290 
	#__USE_XOPEN2KXSI
 1

	)

291 #unde
__USE_ISOC95


292 
	#__USE_ISOC95
 1

	)

293 #unde
__USE_ISOC99


294 
	#__USE_ISOC99
 1

	)

297 #ifde
_XOPEN_SOURCE_EXTENDED


298 
	#__USE_XOPEN_EXTENDED
 1

	)

303 #ifde
_LARGEFILE_SOURCE


304 
	#__USE_LARGEFILE
 1

	)

307 #ifde
_LARGEFILE64_SOURCE


308 
	#__USE_LARGEFILE64
 1

	)

311 #i
defed
 
_FILE_OFFSET_BITS
 && _FILE_OFFSET_BITS == 64

312 
	#__USE_FILE_OFFSET64
 1

	)

315 #i
defed
 
_BSD_SOURCE
 || defed 
_SVID_SOURCE


316 
	#__USE_MISC
 1

	)

319 #ifdef 
_BSD_SOURCE


320 
	#__USE_BSD
 1

	)

323 #ifdef 
_SVID_SOURCE


324 
	#__USE_SVID
 1

	)

327 #ifdef 
_ATFILE_SOURCE


328 
	#__USE_ATFILE
 1

	)

331 #ifdef 
_GNU_SOURCE


332 
	#__USE_GNU
 1

	)

335 #i
defed
 
_REENTRANT
 || defed 
_THREAD_SAFE


336 
	#__USE_REENTRANT
 1

	)

339 #i
defed
 
_FORTIFY_SOURCE
 && _FORTIFY_SOURCE > 0 \

340 && 
__GNUC_PREREQ
 (4, 1&& 
defed
 
	g__OPTIMIZE__
 && __OPTIMIZE__ > 0

341 #i
_FORTIFY_SOURCE
 > 1

342 
	#__USE_FORTIFY_LEVEL
 2

	)

344 
	#__USE_FORTIFY_LEVEL
 1

	)

347 
	#__USE_FORTIFY_LEVEL
 0

	)

352 
	~<dc-edef.h
>

360 #unde
__GNU_LIBRARY__


361 
	#__GNU_LIBRARY__
 6

	)

365 
	#__GLIBC__
 2

	)

366 
	#__GLIBC_MINOR__
 19

	)

368 
	#__GLIBC_PREREQ
(
maj
, 
m
) \

369 ((
__GLIBC__
 << 16+ 
__GLIBC_MINOR__
 >((
maj
<< 16+ (
m
))

	)

372 #ide
__ASSEMBLER__


373 #ide
_SYS_CDEFS_H


374 
	~<sys/cdefs.h
>

379 #i
defed
 
__USE_FILE_OFFSET64
 && !defed 
__REDIRECT


380 
	#__USE_LARGEFILE
 1

	)

381 
	#__USE_LARGEFILE64
 1

	)

387 #i
__GNUC_PREREQ
 (2, 7&& 
defed
 
__OPTIMIZE__
 \

388 && !
defed
 
	g__OPTIMIZE_SIZE__
 && !defed 
	g__NO_INLINE__
 \

389 && 
defed
 
	g__ex_le


390 
	#__USE_EXTERN_INLINES
 1

	)

398 
	~<gnu/ubs.h
>

	@/usr/include/getopt.h

19 #ide
_GETOPT_H


21 #ide
__ed_gt


22 
	#_GETOPT_H
 1

	)

32 #i!
defed
 
__GNU_LIBRARY__


33 
	~<y.h
>

36 #ide
__THROW


37 #ide
__GNUC_PREREQ


38 
	#__GNUC_PREREQ
(
maj
, 
m
(0)

	)

40 #i
defed
 
__lulus
 && 
__GNUC_PREREQ
 (2,8)

41 
	#__THROW
 
	`throw
 ()

	)

43 
	#__THROW


	)

47 #ifdef 
__lulus


57 *
ݏrg
;

71 
td
;

76 
݋
;

80 
tt
;

82 #ide
__ed_gt


104 
	sti


106 cڡ *
	gme
;

109 
	ghas_g
;

110 *
	gag
;

111 
	gv
;

116 
	#no_gumt
 0

	)

117 
	#qued_gumt
 1

	)

118 
	#tiڮ_gumt
 2

	)

146 #ifde
__GNU_LIBRARY__


150 
gt
 (
___gc
, *cڡ *
___gv
, cڡ *
__shtts
)

151 
__THROW
;

153 #i
defed
 
__ed_gt
 && defed 
__USE_POSIX2
 \

154 && !
defed
 
	g__USE_POSIX_IMPLICITLY
 && !defed 
	g__USE_GNU


158 #ifde
__REDIRECT


159 
__REDIRECT_NTH
 (
gt
, (
___gc
, *cڡ *
___gv
,

160 cڡ *
__shtts
),

161 
__posix_gt
);

163 
__posix_gt
 (
___gc
, *cڡ *
___gv
,

164 cڡ *
__shtts

__THROW
;

165 
	#gt
 
__posix_gt


	)

169 
gt
 ();

172 #ide
__ed_gt


173 
gt_lg
 (
___gc
, *cڡ *
___gv
,

174 cڡ *
__shtts
,

175 cڡ 
ti
 *
__lgts
, *
__lgd
)

176 
__THROW
;

177 
gt_lg_ly
 (
___gc
, *cڡ *
___gv
,

178 cڡ *
__shtts
,

179 cڡ 
ti
 *
__lgts
, *
__lgd
)

180 
__THROW
;

184 #ifdef 
__lulus


189 #unde
__ed_gt


	@/usr/include/libio.h

28 #ide
_IO_STDIO_H


29 
	#_IO_STDIO_H


	)

31 
	~<_G_cfig.h
>

33 
	#_IO_os_t
 
_G_os_t


	)

34 
	#_IO_os64_t
 
_G_os64_t


	)

35 
	#_IO_size_t
 
size_t


	)

36 
	#_IO_ssize_t
 
__ssize_t


	)

37 
	#_IO_off_t
 
__off_t


	)

38 
	#_IO_off64_t
 
__off64_t


	)

39 
	#_IO_pid_t
 
__pid_t


	)

40 
	#_IO_uid_t
 
__uid_t


	)

41 
	#_IO_icv_t
 
_G_icv_t


	)

42 
	#_IO_HAVE_ST_BLKSIZE
 
_G_HAVE_ST_BLKSIZE


	)

43 
	#_IO_BUFSIZ
 
_G_BUFSIZ


	)

44 
	#_IO_va_li
 
_G_va_li


	)

45 
	#_IO_wt_t
 
wt_t


	)

48 
	#__ed___va_li


	)

49 
	~<dg.h
>

50 #ifde
__GNUC_VA_LIST


51 #unde
_IO_va_li


52 
	#_IO_va_li
 
__gnuc_va_li


	)

55 #ide
__P


56 
	~<sys/cdefs.h
>

59 
	#_IO_UNIFIED_JUMPTABLES
 1

	)

61 #ide
EOF


62 
	#EOF
 (-1)

	)

64 #ide
NULL


65 #i
defed
 
__GNUG__
 && \

66 (
	g__GNUC__
 > 2 || (__GNUC__ =2 && 
__GNUC_MINOR__
 >= 8))

67 
	#NULL
 (
__nu
)

	)

69 #i!
defed
(
__lulus
)

70 
	#NULL
 ((*)0)

	)

72 
	#NULL
 (0)

	)

77 
	#_IOS_INPUT
 1

	)

78 
	#_IOS_OUTPUT
 2

	)

79 
	#_IOS_ATEND
 4

	)

80 
	#_IOS_APPEND
 8

	)

81 
	#_IOS_TRUNC
 16

	)

82 
	#_IOS_NOCREATE
 32

	)

83 
	#_IOS_NOREPLACE
 64

	)

84 
	#_IOS_BIN
 128

	)

92 
	#_IO_MAGIC
 0xFBAD0000

	)

93 
	#_OLD_STDIO_MAGIC
 0xFABC0000

	)

94 
	#_IO_MAGIC_MASK
 0xFFFF0000

	)

95 
	#_IO_USER_BUF
 1

	)

96 
	#_IO_UNBUFFERED
 2

	)

97 
	#_IO_NO_READS
 4

	)

98 
	#_IO_NO_WRITES
 8

	)

99 
	#_IO_EOF_SEEN
 0x10

	)

100 
	#_IO_ERR_SEEN
 0x20

	)

101 
	#_IO_DELETE_DONT_CLOSE
 0x40

	)

102 
	#_IO_LINKED
 0x80

	)

103 
	#_IO_IN_BACKUP
 0x100

	)

104 
	#_IO_LINE_BUF
 0x200

	)

105 
	#_IO_TIED_PUT_GET
 0x400

	)

106 
	#_IO_CURRENTLY_PUTTING
 0x800

	)

107 
	#_IO_IS_APPENDING
 0x1000

	)

108 
	#_IO_IS_FILEBUF
 0x2000

	)

109 
	#_IO_BAD_SEEN
 0x4000

	)

110 
	#_IO_USER_LOCK
 0x8000

	)

112 
	#_IO_FLAGS2_MMAP
 1

	)

113 
	#_IO_FLAGS2_NOTCANCEL
 2

	)

114 #ifde
_LIBC


115 
	#_IO_FLAGS2_FORTIFY
 4

	)

117 
	#_IO_FLAGS2_USER_WBUF
 8

	)

118 #ifde
_LIBC


119 
	#_IO_FLAGS2_SCANF_STD
 16

	)

120 
	#_IO_FLAGS2_NOCLOSE
 32

	)

121 
	#_IO_FLAGS2_CLOEXEC
 64

	)

125 
	#_IO_SKIPWS
 01

	)

126 
	#_IO_LEFT
 02

	)

127 
	#_IO_RIGHT
 04

	)

128 
	#_IO_INTERNAL
 010

	)

129 
	#_IO_DEC
 020

	)

130 
	#_IO_OCT
 040

	)

131 
	#_IO_HEX
 0100

	)

132 
	#_IO_SHOWBASE
 0200

	)

133 
	#_IO_SHOWPOINT
 0400

	)

134 
	#_IO_UPPERCASE
 01000

	)

135 
	#_IO_SHOWPOS
 02000

	)

136 
	#_IO_SCIENTIFIC
 04000

	)

137 
	#_IO_FIXED
 010000

	)

138 
	#_IO_UNITBUF
 020000

	)

139 
	#_IO_STDIO
 040000

	)

140 
	#_IO_DONT_CLOSE
 0100000

	)

141 
	#_IO_BOOLALPHA
 0200000

	)

144 
_IO_jump_t
; 
	g_IO_FILE
;

147 #ifde
_IO_MTSAFE_IO


148 #i
defed
 
__GLIBC__
 && __GLIBC__ >= 2

149 
	~<bs/dio-lock.h
>

154 
	t_IO_lock_t
;

160 
	s_IO_mk
 {

161 
_IO_mk
 *
	m_xt
;

162 
_IO_FILE
 *
	m_sbuf
;

166 
	m_pos
;

168 
t_ampos
(
ampos
 

{ 
	m_os
 = sp; }

169 
t_offt
(
offt
{ 
	m_pos
 = offt; 
	m_os
 = (
ampos
)(-2); }

170 
	mpublic
:

171 
ammk
(
ambuf
 *
sb
);

172 ~
ammk
();

173 
vg
({  
	m_os
 == -2; }

174 
d
(
ammk
&);

175 
d
();

180 
	e__codecvt_su


182 
	m__codecvt_ok
,

183 
	m__codecvt_l
,

184 
	m__codecvt_r
,

185 
	m__codecvt_nocv


188 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


191 
	s_IO_codecvt


193 (*
	m__codecvt_der
(
	m_IO_codecvt
 *);

194 
__codecvt_su
 (*
__codecvt_do_out
(
	m_IO_codecvt
 *,

195 
	m__mbe_t
 *,

196 cڡ 
	mwch_t
 *,

197 cڡ 
	mwch_t
 *,

198 cڡ 
	mwch_t
 **, *,

200 
__codecvt_su
 (*
__codecvt_do_unshi
(
	m_IO_codecvt
 *,

201 
	m__mbe_t
 *, *,

203 
__codecvt_su
 (*
__codecvt_do_
(
	m_IO_codecvt
 *,

204 
	m__mbe_t
 *,

206 cڡ **, 
	mwch_t
 *,

207 
	mwch_t
 *, wchar_t **);

208 (*
	m__codecvt_do_codg
(
	m_IO_codecvt
 *);

209 (*
	m__codecvt_do_ways_nocv
(
	m_IO_codecvt
 *);

210 (*
	m__codecvt_do_ngth
(
	m_IO_codecvt
 *, 
	m__mbe_t
 *,

211 cڡ *, cڡ *, 
	m_IO_size_t
);

212 (*
	m__codecvt_do_max_ngth
(
	m_IO_codecvt
 *);

214 
_IO_icv_t
 
	m__cd_
;

215 
_IO_icv_t
 
	m__cd_out
;

219 
	s_IO_wide_da


221 
wch_t
 *
	m_IO_ad_r
;

222 
wch_t
 *
	m_IO_ad_d
;

223 
wch_t
 *
	m_IO_ad_ba
;

224 
wch_t
 *
	m_IO_wre_ba
;

225 
wch_t
 *
	m_IO_wre_r
;

226 
wch_t
 *
	m_IO_wre_d
;

227 
wch_t
 *
	m_IO_buf_ba
;

228 
wch_t
 *
	m_IO_buf_d
;

230 
wch_t
 *
	m_IO_ve_ba
;

231 
wch_t
 *
	m_IO_backup_ba
;

233 
wch_t
 *
	m_IO_ve_d
;

235 
__mbe_t
 
	m_IO_e
;

236 
__mbe_t
 
	m_IO_ϡ_e
;

237 
_IO_codecvt
 
	m_codecvt
;

239 
wch_t
 
	m_shtbuf
[1];

241 cڡ 
_IO_jump_t
 *
	m_wide_vb
;

245 
	s_IO_FILE
 {

246 
	m_ags
;

247 
	#_IO_fe_ags
 
_ags


	)

251 * 
	m_IO_ad_r
;

252 * 
	m_IO_ad_d
;

253 * 
	m_IO_ad_ba
;

254 * 
	m_IO_wre_ba
;

255 * 
	m_IO_wre_r
;

256 * 
	m_IO_wre_d
;

257 * 
	m_IO_buf_ba
;

258 * 
	m_IO_buf_d
;

260 *
	m_IO_ve_ba
;

261 *
	m_IO_backup_ba
;

262 *
	m_IO_ve_d
;

264 
_IO_mk
 *
	m_mks
;

266 
_IO_FILE
 *
	m_cha
;

268 
	m_fo
;

270 
	m_blksize
;

272 
	m_ags2
;

274 
_IO_off_t
 
	m_d_offt
;

276 
	#__HAVE_COLUMN


	)

278 
	m_cur_cumn
;

279 sigd 
	m_vb_offt
;

280 
	m_shtbuf
[1];

284 
_IO_lock_t
 *
	m_lock
;

285 #ifde
_IO_USE_OLD_IO_FILE


288 
	s_IO_FILE_come


290 
_IO_FILE
 
	m_fe
;

292 #i
defed
 
_G_IO_IO_FILE_VERSION
 && _G_IO_IO_FILE_VERSION == 0x20001

293 
_IO_off64_t
 
	m_offt
;

294 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


296 
_IO_codecvt
 *
	m_codecvt
;

297 
_IO_wide_da
 *
	m_wide_da
;

298 
_IO_FILE
 *
	m_䓻s_li
;

299 *
	m_䓻s_buf
;

300 
size_t
 
	m_䓻s_size
;

302 *
	m__d1
;

303 *
	m__d2
;

304 *
	m__d3
;

305 *
	m__d4
;

306 
size_t
 
	m__d5
;

308 
	m_mode
;

310 
	m_unud2
[15 *  (- 4 *  (*-  (
size_t
)];

314 #ide
__lulus


315 
_IO_FILE
 
	t_IO_FILE
;

318 
	g_IO_FILE_us
;

320 
_IO_FILE_us
 
_IO_2_1_d_
;

321 
_IO_FILE_us
 
_IO_2_1_dout_
;

322 
_IO_FILE_us
 
_IO_2_1_dr_
;

323 #ide
_LIBC


324 
	#_IO_d
 ((
_IO_FILE
*)(&
_IO_2_1_d_
))

	)

325 
	#_IO_dout
 ((
_IO_FILE
*)(&
_IO_2_1_dout_
))

	)

326 
	#_IO_dr
 ((
_IO_FILE
*)(&
_IO_2_1_dr_
))

	)

328 
_IO_FILE
 *
_IO_d
 
ibu_hidd
;

329 
_IO_FILE
 *
_IO_dout
 
ibu_hidd
;

330 
_IO_FILE
 *
_IO_dr
 
ibu_hidd
;

338 
__ssize_t
 
	t__io_ad_
 (*
	t__cook
, *
	t__buf
, 
	tsize_t
 
	t__nbys
);

346 
__ssize_t
 
	t__io_wre_
 (*
	t__cook
, cڡ *
	t__buf
,

347 
	tsize_t
 
	t__n
);

355 
	t__io_ek_
 (*
	t__cook
, 
	t_IO_off64_t
 *
	t__pos
, 
	t__w
);

358 
	t__io_o_
 (*
	t__cook
);

361 #ifde
_GNU_SOURCE


363 
__io_ad_
 
	tcook_ad_funi_t
;

364 
__io_wre_
 
	tcook_wre_funi_t
;

365 
__io_ek_
 
	tcook_ek_funi_t
;

366 
__io_o_
 
	tcook_o_funi_t
;

371 
__io_ad_
 *
	mad
;

372 
__io_wre_
 *
	mwre
;

373 
__io_ek_
 *
	mek
;

374 
__io_o_
 *
	mo
;

375 } 
	t_IO_cook_io_funis_t
;

376 
_IO_cook_io_funis_t
 
	tcook_io_funis_t
;

378 
	g_IO_cook_fe
;

381 
_IO_cook_
 (
_IO_cook_fe
 *
__cfe
, 
__ad_wre
,

382 *
__cook
, 
_IO_cook_io_funis_t
 
__s
);

386 #ifde
__lulus


390 
__undow
 (
_IO_FILE
 *);

391 
__uow
 (
_IO_FILE
 *);

392 
__ovow
 (
_IO_FILE
 *, );

393 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


394 
_IO_wt_t
 
__wundow
 (
_IO_FILE
 *);

395 
_IO_wt_t
 
__wuow
 (
_IO_FILE
 *);

396 
_IO_wt_t
 
__wovow
 (
_IO_FILE
 *, _IO_wint_t);

399 #i 
__GNUC__
 >= 3

400 
	#_IO_BE
(
ex
, 
s

	`__but_ex
 (x),es)

	)

402 
	#_IO_BE
(
ex
, 
s
x)

	)

405 
	#_IO_gc_uocked
(
_
) \

406 (
	`_IO_BE
 ((
_
)->
_IO_ad_r
 >(_)->
_IO_ad_d
, 0) \

407 ? 
	`__uow
 (
_
: *(*(_)->
_IO_ad_r
++)

	)

408 
	#_IO_ekc_uocked
(
_
) \

409 (
	`_IO_BE
 ((
_
)->
_IO_ad_r
 >(_)->
_IO_ad_d
, 0) \

410 && 
	`__undow
 (
_
=
EOF
 ? EOF \

411 : *(*(
_
)->
_IO_ad_r
)

	)

412 
	#_IO_putc_uocked
(
_ch
, 
_
) \

413 (
	`_IO_BE
 ((
_
)->
_IO_wre_r
 >(_)->
_IO_wre_d
, 0) \

414 ? 
	`__ovow
 (
_
, ((
_ch
)) \

415 : ((*(
_
)->
_IO_wre_r
++ = (
_ch
)))

	)

417 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


418 
	#_IO_gwc_uocked
(
_
) \

419 (
	`_IO_BE
 ((
_
)->
_wide_da
 =
NULL
 \

420 || ((
_
)->
_wide_da
->
_IO_ad_r
 \

421 >(
_
)->
_wide_da
->
_IO_ad_d
), 0) \

422 ? 
	`__wuow
 (
_
: (
_IO_wt_t
*(_)->
_wide_da
->
_IO_ad_r
++)

	)

423 
	#_IO_putwc_uocked
(
_wch
, 
_
) \

424 (
	`_IO_BE
 ((
_
)->
_wide_da
 =
NULL
 \

425 || ((
_
)->
_wide_da
->
_IO_wre_r
 \

426 >(
_
)->
_wide_da
->
_IO_wre_d
), 0) \

427 ? 
	`__wovow
 (
_
, 
_wch
) \

428 : (
_IO_wt_t
(*(
_
)->
_wide_da
->
_IO_wre_r
++ = (
_wch
)))

	)

431 
	#_IO_of_uocked
(
__
(((__)->
_ags
 & 
_IO_EOF_SEEN
!0)

	)

432 
	#_IO__uocked
(
__
(((__)->
_ags
 & 
_IO_ERR_SEEN
!0)

	)

434 
_IO_gc
 (
_IO_FILE
 *
__
);

435 
_IO_putc
 (
__c
, 
_IO_FILE
 *
__
);

436 
_IO_of
 (
_IO_FILE
 *
__

__THROW
;

437 
_IO_
 (
_IO_FILE
 *
__

__THROW
;

439 
_IO_ekc_locked
 (
_IO_FILE
 *
__
);

442 
	#_IO_PENDING_OUTPUT_COUNT
(
_
) \

443 ((
_
)->
_IO_wre_r
 - (_)->
_IO_wre_ba
)

	)

445 
_IO_ockfe
 (
_IO_FILE
 *
__THROW
;

446 
_IO_fuockfe
 (
_IO_FILE
 *
__THROW
;

447 
_IO_rylockfe
 (
_IO_FILE
 *
__THROW
;

449 #ifde
_IO_MTSAFE_IO


450 
	#_IO_ekc
(
_

	`_IO_ekc_locked
 (_)

	)

451 
	#_IO_ockfe
(
_
) \

452 i(((
_
)->
_ags
 & 
_IO_USER_LOCK
=0
	`_IO_ockfe
 (_)

	)

453 
	#_IO_fuockfe
(
_
) \

454 i(((
_
)->
_ags
 & 
_IO_USER_LOCK
=0
	`_IO_fuockfe
 (_)

	)

456 
	#_IO_ekc
(
_

	`_IO_ekc_uocked
 (_)

	)

457 
	#_IO_ockfe
(
_


	)

458 
	#_IO_fuockfe
(
_


	)

459 
	#_IO_rylockfe
(
_


	)

460 
	#_IO_nup_gi_t
(
_f
, 
_


	)

461 
	#_IO_nup_gi_d
(
_Do


	)

464 
_IO_vfsnf
 (
_IO_FILE
 * 
__ri
, const * __restrict,

465 
_IO_va_li
, *
__ri
);

466 
_IO_vrtf
 (
_IO_FILE
 *
__ri
, const *__restrict,

467 
_IO_va_li
);

468 
_IO_ssize_t
 
_IO_dn
 (
_IO_FILE
 *, , _IO_ssize_t);

469 
_IO_size_t
 
_IO_sgn
 (
_IO_FILE
 *, *, _IO_size_t);

471 
_IO_off64_t
 
_IO_ekoff
 (
_IO_FILE
 *, _IO_off64_t, , );

472 
_IO_off64_t
 
_IO_ekpos
 (
_IO_FILE
 *, _IO_off64_t, );

474 
_IO__backup_
 (
_IO_FILE
 *
__THROW
;

476 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


477 
_IO_wt_t
 
_IO_gwc
 (
_IO_FILE
 *
__
);

478 
_IO_wt_t
 
_IO_putwc
 (
wch_t
 
__wc
, 
_IO_FILE
 *
__
);

479 
_IO_fwide
 (
_IO_FILE
 *
__
, 
__mode

__THROW
;

480 #i
__GNUC__
 >= 2

483 #i
defed
 
_LIBC
 && defed 
SHARED


484 
	~<shlib-comt.h
>

485 #i
SHLIB_COMPAT
 (
libc
, 
GLIBC_2_0
, 
GLIBC_2_1
)

486 
	#_IO_fwide_maybe_comtib
 \

487 (
	`__but_ex
 (&
_IO_d_ud
 =
NULL
, 0))

	)

488 cڡ 
_IO_d_ud
;

489 
wk_ex
 (
_IO_d_ud
);

492 #ide
_IO_fwide_maybe_comtib


493 
	#_IO_fwide_maybe_comtib
 (0)

	)

497 
	#_IO_fwide
(
__
, 
__mode
) \

498 ({ 
__su
 = (
__mode
); \

499 i(
__su
 < 0 && ! 
_IO_fwide_maybe_comtib
) \

501 i((
__
)->
_mode
 == 0) \

503 (
__
)->
_mode
 = -1; \

504 
__su
 = (
__
)->
_mode
; \

506 i(
	`__but_cڡt_p
 (
__mode
) && (__mode) == 0) \

507 
__su
 = 
_IO_fwide_maybe_comtib
 ? -1 : (
__
)->
_mode
; \

509 
__su
 = 
	`_IO_fwide
 (
__
, __result); \

510 
__su
; })

	)

513 
_IO_vfwsnf
 (
_IO_FILE
 * 
__ri
, cڡ 
wch_t
 * __restrict,

514 
_IO_va_li
, *
__ri
);

515 
_IO_vfwtf
 (
_IO_FILE
 *
__ri
, cڡ 
wch_t
 *__restrict,

516 
_IO_va_li
);

517 
_IO_ssize_t
 
_IO_wdn
 (
_IO_FILE
 *, 
wt_t
, _IO_ssize_t);

518 
_IO__wbackup_
 (
_IO_FILE
 *
__THROW
;

521 #ifde
__LDBL_COMPAT


522 
	~<bs/libio-ldbl.h
>

525 #ifde
__lulus


	@/usr/include/linux/sysctl.h

22 #ide
_LINUX_SYSCTL_H


23 
	#_LINUX_SYSCTL_H


	)

25 
	~<lux/kl.h
>

26 
	~<lux/tys.h
>

29 
	gcomi
;

31 
	#CTL_MAXNAME
 10

	)

36 
	s__sysl_gs
 {

37 *
	mme
;

38 
	mƒ
;

39 *
	mdv
;

40 
size_t
 *
	md
;

41 *
	mwv
;

42 
size_t
 
	mwn
;

43 
	m__unud
[4];

52 
	mCTL_KERN
=1,

53 
	mCTL_VM
=2,

54 
	mCTL_NET
=3,

55 
	mCTL_PROC
=4,

56 
	mCTL_FS
=5,

57 
	mCTL_DEBUG
=6,

58 
	mCTL_DEV
=7,

59 
	mCTL_BUS
=8,

60 
	mCTL_ABI
=9,

61 
	mCTL_CPU
=10,

62 
	mCTL_ARLAN
=254,

63 
	mCTL_S390DBF
=5677,

64 
	mCTL_SUNRPC
=7249,

65 
	mCTL_PM
=9899,

66 
	mCTL_FRV
=9898,

72 
	mCTL_BUS_ISA
=1

78 
	mINOTIFY_MAX_USER_INSTANCES
=1,

79 
	mINOTIFY_MAX_USER_WATCHES
=2,

80 
	mINOTIFY_MAX_QUEUED_EVENTS
=3

86 
	mKERN_OSTYPE
=1,

87 
	mKERN_OSRELEASE
=2,

88 
	mKERN_OSREV
=3,

89 
	mKERN_VERSION
=4,

90 
	mKERN_SECUREMASK
=5,

91 
	mKERN_PROF
=6,

92 
	mKERN_NODENAME
=7,

93 
	mKERN_DOMAINNAME
=8,

95 
	mKERN_PANIC
=15,

96 
	mKERN_REALROOTDEV
=16,

98 
	mKERN_SPARC_REBOOT
=21,

99 
	mKERN_CTLALTDEL
=22,

100 
	mKERN_PRINTK
=23,

101 
	mKERN_NAMETRANS
=24,

102 
	mKERN_PPC_HTABRECLAIM
=25,

103 
	mKERN_PPC_ZEROPAGED
=26,

104 
	mKERN_PPC_POWERSAVE_NAP
=27,

105 
	mKERN_MODPROBE
=28,

106 
	mKERN_SG_BIG_BUFF
=29,

107 
	mKERN_ACCT
=30,

108 
	mKERN_PPC_L2CR
=31,

110 
	mKERN_RTSIGNR
=32,

111 
	mKERN_RTSIGMAX
=33,

113 
	mKERN_SHMMAX
=34,

114 
	mKERN_MSGMAX
=35,

115 
	mKERN_MSGMNB
=36,

116 
	mKERN_MSGPOOL
=37,

117 
	mKERN_SYSRQ
=38,

118 
	mKERN_MAX_THREADS
=39,

119 
	mKERN_RANDOM
=40,

120 
	mKERN_SHMALL
=41,

121 
	mKERN_MSGMNI
=42,

122 
	mKERN_SEM
=43,

123 
	mKERN_SPARC_STOP_A
=44,

124 
	mKERN_SHMMNI
=45,

125 
	mKERN_OVERFLOWUID
=46,

126 
	mKERN_OVERFLOWGID
=47,

127 
	mKERN_SHMPATH
=48,

128 
	mKERN_HOTPLUG
=49,

129 
	mKERN_IEEE_EMULATION_WARNINGS
=50,

130 
	mKERN_S390_USER_DEBUG_LOGGING
=51,

131 
	mKERN_CORE_USES_PID
=52,

132 
	mKERN_TAINTED
=53,

133 
	mKERN_CADPID
=54,

134 
	mKERN_PIDMAX
=55,

135 
	mKERN_CORE_PATTERN
=56,

136 
	mKERN_PANIC_ON_OOPS
=57,

137 
	mKERN_HPPA_PWRSW
=58,

138 
	mKERN_HPPA_UNALIGNED
=59,

139 
	mKERN_PRINTK_RATELIMIT
=60,

140 
	mKERN_PRINTK_RATELIMIT_BURST
=61,

141 
	mKERN_PTY
=62,

142 
	mKERN_NGROUPS_MAX
=63,

143 
	mKERN_SPARC_SCONS_PWROFF
=64,

144 
	mKERN_HZ_TIMER
=65,

145 
	mKERN_UNKNOWN_NMI_PANIC
=66,

146 
	mKERN_BOOTLOADER_TYPE
=67,

147 
	mKERN_RANDOMIZE
=68,

148 
	mKERN_SETUID_DUMPABLE
=69,

149 
	mKERN_SPIN_RETRY
=70,

150 
	mKERN_ACPI_VIDEO_FLAGS
=71,

151 
	mKERN_IA64_UNALIGNED
=72,

152 
	mKERN_COMPAT_LOG
=73,

153 
	mKERN_MAX_LOCK_DEPTH
=74,

154 
	mKERN_NMI_WATCHDOG
=75,

155 
	mKERN_PANIC_ON_NMI
=76,

163 
	mVM_UNUSED1
=1,

164 
	mVM_UNUSED2
=2,

165 
	mVM_UNUSED3
=3,

166 
	mVM_UNUSED4
=4,

167 
	mVM_OVERCOMMIT_MEMORY
=5,

168 
	mVM_UNUSED5
=6,

169 
	mVM_UNUSED7
=7,

170 
	mVM_UNUSED8
=8,

171 
	mVM_UNUSED9
=9,

172 
	mVM_PAGE_CLUSTER
=10,

173 
	mVM_DIRTY_BACKGROUND
=11,

174 
	mVM_DIRTY_RATIO
=12,

175 
	mVM_DIRTY_WB_CS
=13,

176 
	mVM_DIRTY_EXPIRE_CS
=14,

177 
	mVM_NR_PDFLUSH_THREADS
=15,

178 
	mVM_OVERCOMMIT_RATIO
=16,

179 
	mVM_PAGEBUF
=17,

180 
	mVM_HUGETLB_PAGES
=18,

181 
	mVM_SWAPPINESS
=19,

182 
	mVM_LOWMEM_RESERVE_RATIO
=20,

183 
	mVM_MIN_FREE_KBYTES
=21,

184 
	mVM_MAX_MAP_COUNT
=22,

185 
	mVM_LAPTOP_MODE
=23,

186 
	mVM_BLOCK_DUMP
=24,

187 
	mVM_HUGETLB_GROUP
=25,

188 
	mVM_VFS_CACHE_PRESSURE
=26,

189 
	mVM_LEGACY_VA_LAYOUT
=27,

190 
	mVM_SWAP_TOKEN_TIMEOUT
=28,

191 
	mVM_DROP_PAGECACHE
=29,

192 
	mVM_PERCPU_PAGELIST_FRACTION
=30,

193 
	mVM_ZONE_RECLAIM_MODE
=31,

194 
	mVM_MIN_UNMAPPED
=32,

195 
	mVM_PANIC_ON_OOM
=33,

196 
	mVM_VDSO_ENABLED
=34,

197 
	mVM_MIN_SLAB
=35,

204 
	mNET_CORE
=1,

205 
	mNET_ETHER
=2,

206 
	mNET_802
=3,

207 
	mNET_UNIX
=4,

208 
	mNET_IPV4
=5,

209 
	mNET_IPX
=6,

210 
	mNET_ATALK
=7,

211 
	mNET_NETROM
=8,

212 
	mNET_AX25
=9,

213 
	mNET_BRIDGE
=10,

214 
	mNET_ROSE
=11,

215 
	mNET_IPV6
=12,

216 
	mNET_X25
=13,

217 
	mNET_TR
=14,

218 
	mNET_DECNET
=15,

219 
	mNET_ECONET
=16,

220 
	mNET_SCTP
=17,

221 
	mNET_LLC
=18,

222 
	mNET_NETFILTER
=19,

223 
	mNET_DCCP
=20,

224 
	mNET_IRDA
=412,

230 
	mRANDOM_POOLSIZE
=1,

231 
	mRANDOM_ENTROPY_COUNT
=2,

232 
	mRANDOM_READ_THRESH
=3,

233 
	mRANDOM_WRITE_THRESH
=4,

234 
	mRANDOM_BOOT_ID
=5,

235 
	mRANDOM_UUID
=6

241 
	mPTY_MAX
=1,

242 
	mPTY_NR
=2

248 
	mBUS_ISA_MEM_BASE
=1,

249 
	mBUS_ISA_PORT_BASE
=2,

250 
	mBUS_ISA_PORT_SHIFT
=3

256 
	mNET_CORE_WMEM_MAX
=1,

257 
	mNET_CORE_RMEM_MAX
=2,

258 
	mNET_CORE_WMEM_DEFAULT
=3,

259 
	mNET_CORE_RMEM_DEFAULT
=4,

261 
	mNET_CORE_MAX_BACKLOG
=6,

262 
	mNET_CORE_FASTROUTE
=7,

263 
	mNET_CORE_MSG_COST
=8,

264 
	mNET_CORE_MSG_BURST
=9,

265 
	mNET_CORE_OPTMEM_MAX
=10,

266 
	mNET_CORE_HOT_LIST_LENGTH
=11,

267 
	mNET_CORE_DIVERT_VERSION
=12,

268 
	mNET_CORE_NO_CONG_THRESH
=13,

269 
	mNET_CORE_NO_CONG
=14,

270 
	mNET_CORE_LO_CONG
=15,

271 
	mNET_CORE_MOD_CONG
=16,

272 
	mNET_CORE_DEV_WEIGHT
=17,

273 
	mNET_CORE_SOMAXCONN
=18,

274 
	mNET_CORE_BUDGET
=19,

275 
	mNET_CORE_AEVENT_ETIME
=20,

276 
	mNET_CORE_AEVENT_RSEQTH
=21,

277 
	mNET_CORE_WARNINGS
=22,

288 
	mNET_UNIX_DESTROY_DELAY
=1,

289 
	mNET_UNIX_DELETE_DELAY
=2,

290 
	mNET_UNIX_MAX_DGRAM_QLEN
=3,

296 
	mNET_NF_CONNTRACK_MAX
=1,

297 
	mNET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT
=2,

298 
	mNET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV
=3,

299 
	mNET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED
=4,

300 
	mNET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT
=5,

301 
	mNET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT
=6,

302 
	mNET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK
=7,

303 
	mNET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT
=8,

304 
	mNET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE
=9,

305 
	mNET_NF_CONNTRACK_UDP_TIMEOUT
=10,

306 
	mNET_NF_CONNTRACK_UDP_TIMEOUT_STREAM
=11,

307 
	mNET_NF_CONNTRACK_ICMP_TIMEOUT
=12,

308 
	mNET_NF_CONNTRACK_GENERIC_TIMEOUT
=13,

309 
	mNET_NF_CONNTRACK_BUCKETS
=14,

310 
	mNET_NF_CONNTRACK_LOG_INVALID
=15,

311 
	mNET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS
=16,

312 
	mNET_NF_CONNTRACK_TCP_LOOSE
=17,

313 
	mNET_NF_CONNTRACK_TCP_BE_LIBERAL
=18,

314 
	mNET_NF_CONNTRACK_TCP_MAX_RETRANS
=19,

315 
	mNET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED
=20,

316 
	mNET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT
=21,

317 
	mNET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED
=22,

318 
	mNET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED
=23,

319 
	mNET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT
=24,

320 
	mNET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD
=25,

321 
	mNET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT
=26,

322 
	mNET_NF_CONNTRACK_COUNT
=27,

323 
	mNET_NF_CONNTRACK_ICMPV6_TIMEOUT
=28,

324 
	mNET_NF_CONNTRACK_FRAG6_TIMEOUT
=29,

325 
	mNET_NF_CONNTRACK_FRAG6_LOW_THRESH
=30,

326 
	mNET_NF_CONNTRACK_FRAG6_HIGH_THRESH
=31,

327 
	mNET_NF_CONNTRACK_CHECKSUM
=32,

334 
	mNET_IPV4_FORWARD
=8,

335 
	mNET_IPV4_DYNADDR
=9,

337 
	mNET_IPV4_CONF
=16,

338 
	mNET_IPV4_NEIGH
=17,

339 
	mNET_IPV4_ROUTE
=18,

340 
	mNET_IPV4_FIB_HASH
=19,

341 
	mNET_IPV4_NETFILTER
=20,

343 
	mNET_IPV4_TCP_TIMESTAMPS
=33,

344 
	mNET_IPV4_TCP_WINDOW_SCALING
=34,

345 
	mNET_IPV4_TCP_SACK
=35,

346 
	mNET_IPV4_TCP_RETRANS_COLLAPSE
=36,

347 
	mNET_IPV4_DEFAULT_TTL
=37,

348 
	mNET_IPV4_AUTOCONFIG
=38,

349 
	mNET_IPV4_NO_PMTU_DISC
=39,

350 
	mNET_IPV4_TCP_SYN_RETRIES
=40,

351 
	mNET_IPV4_IPFRAG_HIGH_THRESH
=41,

352 
	mNET_IPV4_IPFRAG_LOW_THRESH
=42,

353 
	mNET_IPV4_IPFRAG_TIME
=43,

354 
	mNET_IPV4_TCP_MAX_KA_PROBES
=44,

355 
	mNET_IPV4_TCP_KEEPALIVE_TIME
=45,

356 
	mNET_IPV4_TCP_KEEPALIVE_PROBES
=46,

357 
	mNET_IPV4_TCP_RETRIES1
=47,

358 
	mNET_IPV4_TCP_RETRIES2
=48,

359 
	mNET_IPV4_TCP_FIN_TIMEOUT
=49,

360 
	mNET_IPV4_IP_MASQ_DEBUG
=50,

361 
	mNET_TCP_SYNCOOKIES
=51,

362 
	mNET_TCP_STDURG
=52,

363 
	mNET_TCP_RFC1337
=53,

364 
	mNET_TCP_SYN_TAILDROP
=54,

365 
	mNET_TCP_MAX_SYN_BACKLOG
=55,

366 
	mNET_IPV4_LOCAL_PORT_RANGE
=56,

367 
	mNET_IPV4_ICMP_ECHO_IGNORE_ALL
=57,

368 
	mNET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS
=58,

369 
	mNET_IPV4_ICMP_SOURCEQUENCH_RATE
=59,

370 
	mNET_IPV4_ICMP_DESTUNREACH_RATE
=60,

371 
	mNET_IPV4_ICMP_TIMEEXCEED_RATE
=61,

372 
	mNET_IPV4_ICMP_PARAMPROB_RATE
=62,

373 
	mNET_IPV4_ICMP_ECHOREPLY_RATE
=63,

374 
	mNET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES
=64,

375 
	mNET_IPV4_IGMP_MAX_MEMBERSHIPS
=65,

376 
	mNET_TCP_TW_RECYCLE
=66,

377 
	mNET_IPV4_ALWAYS_DEFRAG
=67,

378 
	mNET_IPV4_TCP_KEEPALIVE_INTVL
=68,

379 
	mNET_IPV4_INET_PEER_THRESHOLD
=69,

380 
	mNET_IPV4_INET_PEER_MINTTL
=70,

381 
	mNET_IPV4_INET_PEER_MAXTTL
=71,

382 
	mNET_IPV4_INET_PEER_GC_MINTIME
=72,

383 
	mNET_IPV4_INET_PEER_GC_MAXTIME
=73,

384 
	mNET_TCP_ORPHAN_RETRIES
=74,

385 
	mNET_TCP_ABORT_ON_OVERFLOW
=75,

386 
	mNET_TCP_SYNACK_RETRIES
=76,

387 
	mNET_TCP_MAX_ORPHANS
=77,

388 
	mNET_TCP_MAX_TW_BUCKETS
=78,

389 
	mNET_TCP_FACK
=79,

390 
	mNET_TCP_REORDERING
=80,

391 
	mNET_TCP_ECN
=81,

392 
	mNET_TCP_DSACK
=82,

393 
	mNET_TCP_MEM
=83,

394 
	mNET_TCP_WMEM
=84,

395 
	mNET_TCP_RMEM
=85,

396 
	mNET_TCP_APP_WIN
=86,

397 
	mNET_TCP_ADV_WIN_SCALE
=87,

398 
	mNET_IPV4_NONLOCAL_BIND
=88,

399 
	mNET_IPV4_ICMP_RATELIMIT
=89,

400 
	mNET_IPV4_ICMP_RATEMASK
=90,

401 
	mNET_TCP_TW_REUSE
=91,

402 
	mNET_TCP_FRTO
=92,

403 
	mNET_TCP_LOW_LATENCY
=93,

404 
	mNET_IPV4_IPFRAG_SECRET_INTERVAL
=94,

405 
	mNET_IPV4_IGMP_MAX_MSF
=96,

406 
	mNET_TCP_NO_METRICS_SAVE
=97,

407 
	mNET_TCP_DEFAULT_WIN_SCALE
=105,

408 
	mNET_TCP_MODERATE_RCVBUF
=106,

409 
	mNET_TCP_TSO_WIN_DIVISOR
=107,

410 
	mNET_TCP_BIC_BETA
=108,

411 
	mNET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR
=109,

412 
	mNET_TCP_CONG_CONTROL
=110,

413 
	mNET_TCP_ABC
=111,

414 
	mNET_IPV4_IPFRAG_MAX_DIST
=112,

415 
	mNET_TCP_MTU_PROBING
=113,

416 
	mNET_TCP_BASE_MSS
=114,

417 
	mNET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS
=115,

418 
	mNET_TCP_DMA_COPYBREAK
=116,

419 
	mNET_TCP_SLOW_START_AFTER_IDLE
=117,

420 
	mNET_CIPSOV4_CACHE_ENABLE
=118,

421 
	mNET_CIPSOV4_CACHE_BUCKET_SIZE
=119,

422 
	mNET_CIPSOV4_RBM_OPTFMT
=120,

423 
	mNET_CIPSOV4_RBM_STRICTVALID
=121,

424 
	mNET_TCP_AVAIL_CONG_CONTROL
=122,

425 
	mNET_TCP_ALLOWED_CONG_CONTROL
=123,

426 
	mNET_TCP_MAX_SSTHRESH
=124,

427 
	mNET_TCP_FRTO_RESPONSE
=125,

431 
	mNET_IPV4_ROUTE_FLUSH
=1,

432 
	mNET_IPV4_ROUTE_MIN_DELAY
=2,

433 
	mNET_IPV4_ROUTE_MAX_DELAY
=3,

434 
	mNET_IPV4_ROUTE_GC_THRESH
=4,

435 
	mNET_IPV4_ROUTE_MAX_SIZE
=5,

436 
	mNET_IPV4_ROUTE_GC_MIN_INTERVAL
=6,

437 
	mNET_IPV4_ROUTE_GC_TIMEOUT
=7,

438 
	mNET_IPV4_ROUTE_GC_INTERVAL
=8,

439 
	mNET_IPV4_ROUTE_REDIRECT_LOAD
=9,

440 
	mNET_IPV4_ROUTE_REDIRECT_NUMBER
=10,

441 
	mNET_IPV4_ROUTE_REDIRECT_SILENCE
=11,

442 
	mNET_IPV4_ROUTE_ERROR_COST
=12,

443 
	mNET_IPV4_ROUTE_ERROR_BURST
=13,

444 
	mNET_IPV4_ROUTE_GC_ELASTICITY
=14,

445 
	mNET_IPV4_ROUTE_MTU_EXPIRES
=15,

446 
	mNET_IPV4_ROUTE_MIN_PMTU
=16,

447 
	mNET_IPV4_ROUTE_MIN_ADVMSS
=17,

448 
	mNET_IPV4_ROUTE_SECRET_INTERVAL
=18,

449 
	mNET_IPV4_ROUTE_GC_MIN_INTERVAL_MS
=19,

454 
	mNET_PROTO_CONF_ALL
=-2,

455 
	mNET_PROTO_CONF_DEFAULT
=-3

462 
	mNET_IPV4_CONF_FORWARDING
=1,

463 
	mNET_IPV4_CONF_MC_FORWARDING
=2,

464 
	mNET_IPV4_CONF_PROXY_ARP
=3,

465 
	mNET_IPV4_CONF_ACCEPT_REDIRECTS
=4,

466 
	mNET_IPV4_CONF_SECURE_REDIRECTS
=5,

467 
	mNET_IPV4_CONF_SEND_REDIRECTS
=6,

468 
	mNET_IPV4_CONF_SHARED_MEDIA
=7,

469 
	mNET_IPV4_CONF_RP_FILTER
=8,

470 
	mNET_IPV4_CONF_ACCEPT_SOURCE_ROUTE
=9,

471 
	mNET_IPV4_CONF_BOOTP_RELAY
=10,

472 
	mNET_IPV4_CONF_LOG_MARTIANS
=11,

473 
	mNET_IPV4_CONF_TAG
=12,

474 
	mNET_IPV4_CONF_ARPFILTER
=13,

475 
	mNET_IPV4_CONF_MEDIUM_ID
=14,

476 
	mNET_IPV4_CONF_NOXFRM
=15,

477 
	mNET_IPV4_CONF_NOPOLICY
=16,

478 
	mNET_IPV4_CONF_FORCE_IGMP_VERSION
=17,

479 
	mNET_IPV4_CONF_ARP_ANNOUNCE
=18,

480 
	mNET_IPV4_CONF_ARP_IGNORE
=19,

481 
	mNET_IPV4_CONF_PROMOTE_SECONDARIES
=20,

482 
	mNET_IPV4_CONF_ARP_ACCEPT
=21,

483 
	mNET_IPV4_CONF_ARP_NOTIFY
=22,

489 
	mNET_IPV4_NF_CONNTRACK_MAX
=1,

490 
	mNET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT
=2,

491 
	mNET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV
=3,

492 
	mNET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED
=4,

493 
	mNET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT
=5,

494 
	mNET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT
=6,

495 
	mNET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK
=7,

496 
	mNET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT
=8,

497 
	mNET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE
=9,

498 
	mNET_IPV4_NF_CONNTRACK_UDP_TIMEOUT
=10,

499 
	mNET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM
=11,

500 
	mNET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT
=12,

501 
	mNET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT
=13,

502 
	mNET_IPV4_NF_CONNTRACK_BUCKETS
=14,

503 
	mNET_IPV4_NF_CONNTRACK_LOG_INVALID
=15,

504 
	mNET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS
=16,

505 
	mNET_IPV4_NF_CONNTRACK_TCP_LOOSE
=17,

506 
	mNET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL
=18,

507 
	mNET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS
=19,

508 
	mNET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED
=20,

509 
	mNET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT
=21,

510 
	mNET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED
=22,

511 
	mNET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED
=23,

512 
	mNET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT
=24,

513 
	mNET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD
=25,

514 
	mNET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT
=26,

515 
	mNET_IPV4_NF_CONNTRACK_COUNT
=27,

516 
	mNET_IPV4_NF_CONNTRACK_CHECKSUM
=28,

521 
	mNET_IPV6_CONF
=16,

522 
	mNET_IPV6_NEIGH
=17,

523 
	mNET_IPV6_ROUTE
=18,

524 
	mNET_IPV6_ICMP
=19,

525 
	mNET_IPV6_BINDV6ONLY
=20,

526 
	mNET_IPV6_IP6FRAG_HIGH_THRESH
=21,

527 
	mNET_IPV6_IP6FRAG_LOW_THRESH
=22,

528 
	mNET_IPV6_IP6FRAG_TIME
=23,

529 
	mNET_IPV6_IP6FRAG_SECRET_INTERVAL
=24,

530 
	mNET_IPV6_MLD_MAX_MSF
=25,

534 
	mNET_IPV6_ROUTE_FLUSH
=1,

535 
	mNET_IPV6_ROUTE_GC_THRESH
=2,

536 
	mNET_IPV6_ROUTE_MAX_SIZE
=3,

537 
	mNET_IPV6_ROUTE_GC_MIN_INTERVAL
=4,

538 
	mNET_IPV6_ROUTE_GC_TIMEOUT
=5,

539 
	mNET_IPV6_ROUTE_GC_INTERVAL
=6,

540 
	mNET_IPV6_ROUTE_GC_ELASTICITY
=7,

541 
	mNET_IPV6_ROUTE_MTU_EXPIRES
=8,

542 
	mNET_IPV6_ROUTE_MIN_ADVMSS
=9,

543 
	mNET_IPV6_ROUTE_GC_MIN_INTERVAL_MS
=10

547 
	mNET_IPV6_FORWARDING
=1,

548 
	mNET_IPV6_HOP_LIMIT
=2,

549 
	mNET_IPV6_MTU
=3,

550 
	mNET_IPV6_ACCEPT_RA
=4,

551 
	mNET_IPV6_ACCEPT_REDIRECTS
=5,

552 
	mNET_IPV6_AUTOCONF
=6,

553 
	mNET_IPV6_DAD_TRANSMITS
=7,

554 
	mNET_IPV6_RTR_SOLICITS
=8,

555 
	mNET_IPV6_RTR_SOLICIT_INTERVAL
=9,

556 
	mNET_IPV6_RTR_SOLICIT_DELAY
=10,

557 
	mNET_IPV6_USE_TEMPADDR
=11,

558 
	mNET_IPV6_TEMP_VALID_LFT
=12,

559 
	mNET_IPV6_TEMP_PREFERED_LFT
=13,

560 
	mNET_IPV6_REGEN_MAX_RETRY
=14,

561 
	mNET_IPV6_MAX_DESYNC_FACTOR
=15,

562 
	mNET_IPV6_MAX_ADDRESSES
=16,

563 
	mNET_IPV6_FORCE_MLD_VERSION
=17,

564 
	mNET_IPV6_ACCEPT_RA_DEFRTR
=18,

565 
	mNET_IPV6_ACCEPT_RA_PINFO
=19,

566 
	mNET_IPV6_ACCEPT_RA_RTR_PREF
=20,

567 
	mNET_IPV6_RTR_PROBE_INTERVAL
=21,

568 
	mNET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN
=22,

569 
	mNET_IPV6_PROXY_NDP
=23,

570 
	mNET_IPV6_ACCEPT_SOURCE_ROUTE
=25,

571 
	m__NET_IPV6_MAX


576 
	mNET_IPV6_ICMP_RATELIMIT
=1

581 
	mNET_NEIGH_MCAST_SOLICIT
=1,

582 
	mNET_NEIGH_UCAST_SOLICIT
=2,

583 
	mNET_NEIGH_APP_SOLICIT
=3,

584 
	mNET_NEIGH_RETRANS_TIME
=4,

585 
	mNET_NEIGH_REACHABLE_TIME
=5,

586 
	mNET_NEIGH_DELAY_PROBE_TIME
=6,

587 
	mNET_NEIGH_GC_STALE_TIME
=7,

588 
	mNET_NEIGH_UNRES_QLEN
=8,

589 
	mNET_NEIGH_PROXY_QLEN
=9,

590 
	mNET_NEIGH_ANYCAST_DELAY
=10,

591 
	mNET_NEIGH_PROXY_DELAY
=11,

592 
	mNET_NEIGH_LOCKTIME
=12,

593 
	mNET_NEIGH_GC_INTERVAL
=13,

594 
	mNET_NEIGH_GC_THRESH1
=14,

595 
	mNET_NEIGH_GC_THRESH2
=15,

596 
	mNET_NEIGH_GC_THRESH3
=16,

597 
	mNET_NEIGH_RETRANS_TIME_MS
=17,

598 
	mNET_NEIGH_REACHABLE_TIME_MS
=18,

603 
	mNET_DCCP_DEFAULT
=1,

608 
	mNET_IPX_PPROP_BROADCASTING
=1,

609 
	mNET_IPX_FORWARDING
=2

614 
	mNET_LLC2
=1,

615 
	mNET_LLC_STATION
=2,

620 
	mNET_LLC2_TIMEOUT
=1,

625 
	mNET_LLC_STATION_ACK_TIMEOUT
=1,

630 
	mNET_LLC2_ACK_TIMEOUT
=1,

631 
	mNET_LLC2_P_TIMEOUT
=2,

632 
	mNET_LLC2_REJ_TIMEOUT
=3,

633 
	mNET_LLC2_BUSY_TIMEOUT
=4,

638 
	mNET_ATALK_AARP_EXPIRY_TIME
=1,

639 
	mNET_ATALK_AARP_TICK_TIME
=2,

640 
	mNET_ATALK_AARP_RETRANSMIT_LIMIT
=3,

641 
	mNET_ATALK_AARP_RESOLVE_TIME
=4

647 
	mNET_NETROM_DEFAULT_PATH_QUALITY
=1,

648 
	mNET_NETROM_OBSOLESCENCE_COUNT_INITIALISER
=2,

649 
	mNET_NETROM_NETWORK_TTL_INITIALISER
=3,

650 
	mNET_NETROM_TRANSPORT_TIMEOUT
=4,

651 
	mNET_NETROM_TRANSPORT_MAXIMUM_TRIES
=5,

652 
	mNET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY
=6,

653 
	mNET_NETROM_TRANSPORT_BUSY_DELAY
=7,

654 
	mNET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE
=8,

655 
	mNET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT
=9,

656 
	mNET_NETROM_ROUTING_CONTROL
=10,

657 
	mNET_NETROM_LINK_FAILS_COUNT
=11,

658 
	mNET_NETROM_RESET
=12

663 
	mNET_AX25_IP_DEFAULT_MODE
=1,

664 
	mNET_AX25_DEFAULT_MODE
=2,

665 
	mNET_AX25_BACKOFF_TYPE
=3,

666 
	mNET_AX25_CONNECT_MODE
=4,

667 
	mNET_AX25_STANDARD_WINDOW
=5,

668 
	mNET_AX25_EXTENDED_WINDOW
=6,

669 
	mNET_AX25_T1_TIMEOUT
=7,

670 
	mNET_AX25_T2_TIMEOUT
=8,

671 
	mNET_AX25_T3_TIMEOUT
=9,

672 
	mNET_AX25_IDLE_TIMEOUT
=10,

673 
	mNET_AX25_N2
=11,

674 
	mNET_AX25_PACLEN
=12,

675 
	mNET_AX25_PROTOCOL
=13,

676 
	mNET_AX25_DAMA_SLAVE_TIMEOUT
=14

681 
	mNET_ROSE_RESTART_REQUEST_TIMEOUT
=1,

682 
	mNET_ROSE_CALL_REQUEST_TIMEOUT
=2,

683 
	mNET_ROSE_RESET_REQUEST_TIMEOUT
=3,

684 
	mNET_ROSE_CLEAR_REQUEST_TIMEOUT
=4,

685 
	mNET_ROSE_ACK_HOLD_BACK_TIMEOUT
=5,

686 
	mNET_ROSE_ROUTING_CONTROL
=6,

687 
	mNET_ROSE_LINK_FAIL_TIMEOUT
=7,

688 
	mNET_ROSE_MAX_VCS
=8,

689 
	mNET_ROSE_WINDOW_SIZE
=9,

690 
	mNET_ROSE_NO_ACTIVITY_TIMEOUT
=10

695 
	mNET_X25_RESTART_REQUEST_TIMEOUT
=1,

696 
	mNET_X25_CALL_REQUEST_TIMEOUT
=2,

697 
	mNET_X25_RESET_REQUEST_TIMEOUT
=3,

698 
	mNET_X25_CLEAR_REQUEST_TIMEOUT
=4,

699 
	mNET_X25_ACK_HOLD_BACK_TIMEOUT
=5,

700 
	mNET_X25_FORWARD
=6

706 
	mNET_TR_RIF_TIMEOUT
=1

711 
	mNET_DECNET_NODE_TYPE
 = 1,

712 
	mNET_DECNET_NODE_ADDRESS
 = 2,

713 
	mNET_DECNET_NODE_NAME
 = 3,

714 
	mNET_DECNET_DEFAULT_DEVICE
 = 4,

715 
	mNET_DECNET_TIME_WAIT
 = 5,

716 
	mNET_DECNET_DN_COUNT
 = 6,

717 
	mNET_DECNET_DI_COUNT
 = 7,

718 
	mNET_DECNET_DR_COUNT
 = 8,

719 
	mNET_DECNET_DST_GC_INTERVAL
 = 9,

720 
	mNET_DECNET_CONF
 = 10,

721 
	mNET_DECNET_NO_FC_MAX_CWND
 = 11,

722 
	mNET_DECNET_MEM
 = 12,

723 
	mNET_DECNET_RMEM
 = 13,

724 
	mNET_DECNET_WMEM
 = 14,

725 
	mNET_DECNET_DEBUG_LEVEL
 = 255

730 
	mNET_DECNET_CONF_LOOPBACK
 = -2,

731 
	mNET_DECNET_CONF_DDCMP
 = -3,

732 
	mNET_DECNET_CONF_PPP
 = -4,

733 
	mNET_DECNET_CONF_X25
 = -5,

734 
	mNET_DECNET_CONF_GRE
 = -6,

735 
	mNET_DECNET_CONF_ETHER
 = -7

742 
	mNET_DECNET_CONF_DEV_PRIORITY
 = 1,

743 
	mNET_DECNET_CONF_DEV_T1
 = 2,

744 
	mNET_DECNET_CONF_DEV_T2
 = 3,

745 
	mNET_DECNET_CONF_DEV_T3
 = 4,

746 
	mNET_DECNET_CONF_DEV_FORWARDING
 = 5,

747 
	mNET_DECNET_CONF_DEV_BLKSIZE
 = 6,

748 
	mNET_DECNET_CONF_DEV_STATE
 = 7

753 
	mNET_SCTP_RTO_INITIAL
 = 1,

754 
	mNET_SCTP_RTO_MIN
 = 2,

755 
	mNET_SCTP_RTO_MAX
 = 3,

756 
	mNET_SCTP_RTO_ALPHA
 = 4,

757 
	mNET_SCTP_RTO_BETA
 = 5,

758 
	mNET_SCTP_VALID_COOKIE_LIFE
 = 6,

759 
	mNET_SCTP_ASSOCIATION_MAX_RETRANS
 = 7,

760 
	mNET_SCTP_PATH_MAX_RETRANS
 = 8,

761 
	mNET_SCTP_MAX_INIT_RETRANSMITS
 = 9,

762 
	mNET_SCTP_HB_INTERVAL
 = 10,

763 
	mNET_SCTP_PRESERVE_ENABLE
 = 11,

764 
	mNET_SCTP_MAX_BURST
 = 12,

765 
	mNET_SCTP_ADDIP_ENABLE
 = 13,

766 
	mNET_SCTP_PRSCTP_ENABLE
 = 14,

767 
	mNET_SCTP_SNDBUF_POLICY
 = 15,

768 
	mNET_SCTP_SACK_TIMEOUT
 = 16,

769 
	mNET_SCTP_RCVBUF_POLICY
 = 17,

774 
	mNET_BRIDGE_NF_CALL_ARPTABLES
 = 1,

775 
	mNET_BRIDGE_NF_CALL_IPTABLES
 = 2,

776 
	mNET_BRIDGE_NF_CALL_IP6TABLES
 = 3,

777 
	mNET_BRIDGE_NF_FILTER_VLAN_TAGGED
 = 4,

778 
	mNET_BRIDGE_NF_FILTER_PPPOE_TAGGED
 = 5,

783 
	mNET_IRDA_DISCOVERY
=1,

784 
	mNET_IRDA_DEVNAME
=2,

785 
	mNET_IRDA_DEBUG
=3,

786 
	mNET_IRDA_FAST_POLL
=4,

787 
	mNET_IRDA_DISCOVERY_SLOTS
=5,

788 
	mNET_IRDA_DISCOVERY_TIMEOUT
=6,

789 
	mNET_IRDA_SLOT_TIMEOUT
=7,

790 
	mNET_IRDA_MAX_BAUD_RATE
=8,

791 
	mNET_IRDA_MIN_TX_TURN_TIME
=9,

792 
	mNET_IRDA_MAX_TX_DATA_SIZE
=10,

793 
	mNET_IRDA_MAX_TX_WINDOW
=11,

794 
	mNET_IRDA_MAX_NOREPLY_TIME
=12,

795 
	mNET_IRDA_WARN_NOREPLY_TIME
=13,

796 
	mNET_IRDA_LAP_KEEPALIVE_TIME
=14,

803 
	mFS_NRINODE
=1,

804 
	mFS_STATINODE
=2,

805 
	mFS_MAXINODE
=3,

806 
	mFS_NRDQUOT
=4,

807 
	mFS_MAXDQUOT
=5,

808 
	mFS_NRFILE
=6,

809 
	mFS_MAXFILE
=7,

810 
	mFS_DENTRY
=8,

811 
	mFS_NRSUPER
=9,

812 
	mFS_MAXSUPER
=10,

813 
	mFS_OVERFLOWUID
=11,

814 
	mFS_OVERFLOWGID
=12,

815 
	mFS_LEASES
=13,

816 
	mFS_DIR_NOTIFY
=14,

817 
	mFS_LEASE_TIME
=15,

818 
	mFS_DQSTATS
=16,

819 
	mFS_XFS
=17,

820 
	mFS_AIO_NR
=18,

821 
	mFS_AIO_MAX_NR
=19,

822 
	mFS_INOTIFY
=20,

823 
	mFS_OCFS2
=988,

828 
	mFS_DQ_LOOKUPS
 = 1,

829 
	mFS_DQ_DROPS
 = 2,

830 
	mFS_DQ_READS
 = 3,

831 
	mFS_DQ_WRITES
 = 4,

832 
	mFS_DQ_CACHE_HITS
 = 5,

833 
	mFS_DQ_ALLOCATED
 = 6,

834 
	mFS_DQ_FREE
 = 7,

835 
	mFS_DQ_SYNCS
 = 8,

836 
	mFS_DQ_WARNINGS
 = 9,

843 
	mDEV_CDROM
=1,

844 
	mDEV_HWMON
=2,

845 
	mDEV_PARPORT
=3,

846 
	mDEV_RAID
=4,

847 
	mDEV_MAC_HID
=5,

848 
	mDEV_SCSI
=6,

849 
	mDEV_IPMI
=7,

854 
	mDEV_CDROM_INFO
=1,

855 
	mDEV_CDROM_AUTOCLOSE
=2,

856 
	mDEV_CDROM_AUTOEJECT
=3,

857 
	mDEV_CDROM_DEBUG
=4,

858 
	mDEV_CDROM_LOCK
=5,

859 
	mDEV_CDROM_CHECK_MEDIA
=6

864 
	mDEV_PARPORT_DEFAULT
=-3

869 
	mDEV_RAID_SPEED_LIMIT_MIN
=1,

870 
	mDEV_RAID_SPEED_LIMIT_MAX
=2

875 
	mDEV_PARPORT_DEFAULT_TIMESLICE
=1,

876 
	mDEV_PARPORT_DEFAULT_SPINTIME
=2

881 
	mDEV_PARPORT_SPINTIME
=1,

882 
	mDEV_PARPORT_BASE_ADDR
=2,

883 
	mDEV_PARPORT_IRQ
=3,

884 
	mDEV_PARPORT_DMA
=4,

885 
	mDEV_PARPORT_MODES
=5,

886 
	mDEV_PARPORT_DEVICES
=6,

887 
	mDEV_PARPORT_AUTOPROBE
=16

892 
	mDEV_PARPORT_DEVICES_ACTIVE
=-3,

897 
	mDEV_PARPORT_DEVICE_TIMESLICE
=1,

902 
	mDEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES
=1,

903 
	mDEV_MAC_HID_KEYBOARD_LOCK_KEYCODES
=2,

904 
	mDEV_MAC_HID_MOUSE_BUTTON_EMULATION
=3,

905 
	mDEV_MAC_HID_MOUSE_BUTTON2_KEYCODE
=4,

906 
	mDEV_MAC_HID_MOUSE_BUTTON3_KEYCODE
=5,

907 
	mDEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES
=6

912 
	mDEV_SCSI_LOGGING_LEVEL
=1,

917 
	mDEV_IPMI_POWEROFF_POWERCYCLE
=1,

923 
	mABI_DEFHANDLER_COFF
=1,

924 
	mABI_DEFHANDLER_ELF
=2,

925 
	mABI_DEFHANDLER_LCALL7
=3,

926 
	mABI_DEFHANDLER_LIBCSO
=4,

927 
	mABI_TRACE
=5,

928 
	mABI_FAKE_UTSNAME
=6,

	@/usr/include/netinet/in.h

18 #idef 
_NETINET_IN_H


19 
	#_NETINET_IN_H
 1

	)

21 
	~<us.h
>

22 
	~<dt.h
>

23 
	~<sys/sock.h
>

24 
	~<bs/tys.h
>

27 
__BEGIN_DECLS


30 
ut32_t
 
	t_addr_t
;

31 
	s_addr


33 
_addr_t
 
	ms_addr
;

37 
	~<bs/.h
>

42 
	mIPPROTO_IP
 = 0,

43 
	#IPPROTO_IP
 
IPPROTO_IP


	)

44 
	mIPPROTO_ICMP
 = 1,

45 
	#IPPROTO_ICMP
 
IPPROTO_ICMP


	)

46 
	mIPPROTO_IGMP
 = 2,

47 
	#IPPROTO_IGMP
 
IPPROTO_IGMP


	)

48 
	mIPPROTO_IPIP
 = 4,

49 
	#IPPROTO_IPIP
 
IPPROTO_IPIP


	)

50 
	mIPPROTO_TCP
 = 6,

51 
	#IPPROTO_TCP
 
IPPROTO_TCP


	)

52 
	mIPPROTO_EGP
 = 8,

53 
	#IPPROTO_EGP
 
IPPROTO_EGP


	)

54 
	mIPPROTO_PUP
 = 12,

55 
	#IPPROTO_PUP
 
IPPROTO_PUP


	)

56 
	mIPPROTO_UDP
 = 17,

57 
	#IPPROTO_UDP
 
IPPROTO_UDP


	)

58 
	mIPPROTO_IDP
 = 22,

59 
	#IPPROTO_IDP
 
IPPROTO_IDP


	)

60 
	mIPPROTO_TP
 = 29,

61 
	#IPPROTO_TP
 
IPPROTO_TP


	)

62 
	mIPPROTO_DCCP
 = 33,

63 
	#IPPROTO_DCCP
 
IPPROTO_DCCP


	)

64 
	mIPPROTO_IPV6
 = 41,

65 
	#IPPROTO_IPV6
 
IPPROTO_IPV6


	)

66 
	mIPPROTO_RSVP
 = 46,

67 
	#IPPROTO_RSVP
 
IPPROTO_RSVP


	)

68 
	mIPPROTO_GRE
 = 47,

69 
	#IPPROTO_GRE
 
IPPROTO_GRE


	)

70 
	mIPPROTO_ESP
 = 50,

71 
	#IPPROTO_ESP
 
IPPROTO_ESP


	)

72 
	mIPPROTO_AH
 = 51,

73 
	#IPPROTO_AH
 
IPPROTO_AH


	)

74 
	mIPPROTO_MTP
 = 92,

75 
	#IPPROTO_MTP
 
IPPROTO_MTP


	)

76 
	mIPPROTO_BEETPH
 = 94,

77 
	#IPPROTO_BEETPH
 
IPPROTO_BEETPH


	)

78 
	mIPPROTO_ENCAP
 = 98,

79 
	#IPPROTO_ENCAP
 
IPPROTO_ENCAP


	)

80 
	mIPPROTO_PIM
 = 103,

81 
	#IPPROTO_PIM
 
IPPROTO_PIM


	)

82 
	mIPPROTO_COMP
 = 108,

83 
	#IPPROTO_COMP
 
IPPROTO_COMP


	)

84 
	mIPPROTO_SCTP
 = 132,

85 
	#IPPROTO_SCTP
 
IPPROTO_SCTP


	)

86 
	mIPPROTO_UDPLITE
 = 136,

87 
	#IPPROTO_UDPLITE
 
IPPROTO_UDPLITE


	)

88 
	mIPPROTO_RAW
 = 255,

89 
	#IPPROTO_RAW
 
IPPROTO_RAW


	)

90 
	mIPPROTO_MAX


96 #ide
__USE_KERNEL_IPV6_DEFS


99 
	mIPPROTO_HOPOPTS
 = 0,

100 
	#IPPROTO_HOPOPTS
 
IPPROTO_HOPOPTS


	)

101 
	mIPPROTO_ROUTING
 = 43,

102 
	#IPPROTO_ROUTING
 
IPPROTO_ROUTING


	)

103 
	mIPPROTO_FRAGMENT
 = 44,

104 
	#IPPROTO_FRAGMENT
 
IPPROTO_FRAGMENT


	)

105 
	mIPPROTO_ICMPV6
 = 58,

106 
	#IPPROTO_ICMPV6
 
IPPROTO_ICMPV6


	)

107 
	mIPPROTO_NONE
 = 59,

108 
	#IPPROTO_NONE
 
IPPROTO_NONE


	)

109 
	mIPPROTO_DSTOPTS
 = 60,

110 
	#IPPROTO_DSTOPTS
 
IPPROTO_DSTOPTS


	)

111 
	mIPPROTO_MH
 = 135

112 
	#IPPROTO_MH
 
IPPROTO_MH


	)

117 
ut16_t
 
	t_pt_t
;

122 
	mIPPORT_ECHO
 = 7,

123 
	mIPPORT_DISCARD
 = 9,

124 
	mIPPORT_SYSTAT
 = 11,

125 
	mIPPORT_DAYTIME
 = 13,

126 
	mIPPORT_NETSTAT
 = 15,

127 
	mIPPORT_FTP
 = 21,

128 
	mIPPORT_TELNET
 = 23,

129 
	mIPPORT_SMTP
 = 25,

130 
	mIPPORT_TIMESERVER
 = 37,

131 
	mIPPORT_NAMESERVER
 = 42,

132 
	mIPPORT_WHOIS
 = 43,

133 
	mIPPORT_MTP
 = 57,

135 
	mIPPORT_TFTP
 = 69,

136 
	mIPPORT_RJE
 = 77,

137 
	mIPPORT_FINGER
 = 79,

138 
	mIPPORT_TTYLINK
 = 87,

139 
	mIPPORT_SUPDUP
 = 95,

142 
	mIPPORT_EXECSERVER
 = 512,

143 
	mIPPORT_LOGINSERVER
 = 513,

144 
	mIPPORT_CMDSERVER
 = 514,

145 
	mIPPORT_EFSSERVER
 = 520,

148 
	mIPPORT_BIFFUDP
 = 512,

149 
	mIPPORT_WHOSERVER
 = 513,

150 
	mIPPORT_ROUTESERVER
 = 520,

153 
	mIPPORT_RESERVED
 = 1024,

156 
	mIPPORT_USERRESERVED
 = 5000

164 
	#IN_CLASSA
(
a
((((
_addr_t
))& 0x80000000=0)

	)

165 
	#IN_CLASSA_NET
 0xff000000

	)

166 
	#IN_CLASSA_NSHIFT
 24

	)

167 
	#IN_CLASSA_HOST
 (0xfffffff& ~
IN_CLASSA_NET
)

	)

168 
	#IN_CLASSA_MAX
 128

	)

170 
	#IN_CLASSB
(
a
((((
_addr_t
))& 0xc0000000=0x80000000)

	)

171 
	#IN_CLASSB_NET
 0xffff0000

	)

172 
	#IN_CLASSB_NSHIFT
 16

	)

173 
	#IN_CLASSB_HOST
 (0xfffffff& ~
IN_CLASSB_NET
)

	)

174 
	#IN_CLASSB_MAX
 65536

	)

176 
	#IN_CLASSC
(
a
((((
_addr_t
))& 0xe0000000=0xc0000000)

	)

177 
	#IN_CLASSC_NET
 0xffffff00

	)

178 
	#IN_CLASSC_NSHIFT
 8

	)

179 
	#IN_CLASSC_HOST
 (0xfffffff& ~
IN_CLASSC_NET
)

	)

181 
	#IN_CLASSD
(
a
((((
_addr_t
))& 0xf0000000=0xe0000000)

	)

182 
	#IN_MULTICAST
(
a

	`IN_CLASSD
)

	)

184 
	#IN_EXPERIMENTAL
(
a
((((
_addr_t
))& 0xe0000000=0xe0000000)

	)

185 
	#IN_BADCLASS
(
a
((((
_addr_t
))& 0xf0000000=0xf0000000)

	)

188 
	#INADDR_ANY
 ((
_addr_t
0x00000000)

	)

190 
	#INADDR_BROADCAST
 ((
_addr_t
0xffffffff)

	)

192 
	#INADDR_NONE
 ((
_addr_t
0xffffffff)

	)

195 
	#IN_LOOPBACKNET
 127

	)

197 #ide
INADDR_LOOPBACK


198 
	#INADDR_LOOPBACK
 ((
_addr_t
0x7f000001

	)

202 
	#INADDR_UNSPEC_GROUP
 ((
_addr_t
0xe0000000

	)

203 
	#INADDR_ALLHOSTS_GROUP
 ((
_addr_t
0xe0000001

	)

204 
	#INADDR_ALLRTRS_GROUP
 ((
_addr_t
0xe0000002

	)

205 
	#INADDR_MAX_LOCAL_GROUP
 ((
_addr_t
0xe00000ff

	)

207 #ide
__USE_KERNEL_IPV6_DEFS


209 
	s6_addr


213 
ut8_t
 
	m__u6_addr8
[16];

214 #i
defed
 
__USE_MISC
 || defed 
__USE_GNU


215 
ut16_t
 
	m__u6_addr16
[8];

216 
ut32_t
 
	m__u6_addr32
[4];

218 } 
	m__6_u
;

219 
	#s6_addr
 
__6_u
.
__u6_addr8


	)

220 #i
defed
 
__USE_MISC
 || defed 
__USE_GNU


221 
	#s6_addr16
 
__6_u
.
__u6_addr16


	)

222 
	#s6_addr32
 
__6_u
.
__u6_addr32


	)

227 cڡ 
6_addr
 
6addr_y
;

228 cڡ 
6_addr
 
6addr_loback
;

229 
	#IN6ADDR_ANY_INIT
 { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } } }

	)

230 
	#IN6ADDR_LOOPBACK_INIT
 { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 } } }

	)

232 
	#INET_ADDRSTRLEN
 16

	)

233 
	#INET6_ADDRSTRLEN
 46

	)

237 
	ssockaddr_


239 
__SOCKADDR_COMMON
 (
s_
);

240 
_pt_t
 
	ms_pt
;

241 
_addr
 
	ms_addr
;

244 
	ms_zo
[ (
sockaddr
) -

245 
__SOCKADDR_COMMON_SIZE
 -

246  (
_pt_t
) -

247  (
_addr
)];

250 #ide
__USE_KERNEL_IPV6_DEFS


252 
	ssockaddr_6


254 
__SOCKADDR_COMMON
 (
s6_
);

255 
_pt_t
 
	ms6_pt
;

256 
ut32_t
 
	ms6_owfo
;

257 
6_addr
 
	ms6_addr
;

258 
ut32_t
 
	ms6_sce_id
;

262 #i
defed
 
__USE_MISC
 || defed 
__USE_GNU


264 
	s_mq


267 
_addr
 
	mimr_muɟddr
;

270 
_addr
 
	mimr_r
;

273 
	s_mq_sour


276 
_addr
 
	mimr_muɟddr
;

279 
_addr
 
	mimr_r
;

282 
_addr
 
	mimr_souraddr
;

286 #ide
__USE_KERNEL_IPV6_DEFS


288 
	sv6_mq


291 
6_addr
 
	mv6mr_muɟddr
;

294 
	mv6mr_r
;

298 #i
defed
 
__USE_MISC
 || defed 
__USE_GNU


300 
	sgroup_q


303 
ut32_t
 
	mgr_r
;

306 
sockaddr_age
 
	mgr_group
;

309 
	sgroup_sour_q


312 
ut32_t
 
	mg_r
;

315 
sockaddr_age
 
	mg_group
;

318 
sockaddr_age
 
	mg_sour
;

323 
	s_msfr


326 
_addr
 
	mimsf_muɟddr
;

329 
_addr
 
	mimsf_r
;

332 
ut32_t
 
	mimsf_fmode
;

335 
ut32_t
 
	mimsf_numc
;

337 
_addr
 
	mimsf_i
[1];

340 
	#IP_MSFILTER_SIZE
(
numc
( (
_msfr
) \

341 -  (
_addr
) \

342 + (
numc
*  (
_addr
))

	)

344 
	sgroup_fr


347 
ut32_t
 
	mgf_r
;

350 
sockaddr_age
 
	mgf_group
;

353 
ut32_t
 
	mgf_fmode
;

356 
ut32_t
 
	mgf_numc
;

358 
sockaddr_age
 
	mgf_i
[1];

361 
	#GROUP_FILTER_SIZE
(
numc
( (
group_fr
) \

362 -  (
sockaddr_age
) \

363 + ((
numc
) \

364 *  (
sockaddr_age
)))

	)

374 
ut32_t
 
	$ohl
 (
ut32_t
 
__Îg

__THROW
 
	`__ibu__
 ((
__cڡ__
));

375 
ut16_t
 
	$ohs
 (
ut16_t
 
__tsht
)

376 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

377 
ut32_t
 
	$htl
 (
ut32_t
 
__holg
)

378 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

379 
ut16_t
 
	$hts
 (
ut16_t
 
__hosht
)

380 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

382 
	~<dn.h
>

385 
	~<bs/bysw.h
>

387 #ifde
__OPTIMIZE__


391 #i
__BYTE_ORDER
 =
__BIG_ENDIAN


394 
	#ohl
(
x
(x)

	)

395 
	#ohs
(
x
(x)

	)

396 
	#htl
(
x
(x)

	)

397 
	#hts
(
x
(x)

	)

399 #i
__BYTE_ORDER
 =
__LITTLE_ENDIAN


400 
	#ohl
(
x

	`__bsw_32
 (x)

	)

401 
	#ohs
(
x

	`__bsw_16
 (x)

	)

402 
	#htl
(
x

	`__bsw_32
 (x)

	)

403 
	#hts
(
x

	`__bsw_16
 (x)

	)

408 #ifde
__GNUC__


409 
	#IN6_IS_ADDR_UNSPECIFIED
(
a
) \

410 (
__exnsi__
 \

411 ({ cڡ 
6_addr
 *
__a
 = (cڡ 6_add*(
a
); \

412 
__a
->
s6_addr32
[0] == 0 \

413 && 
__a
->
s6_addr32
[1] == 0 \

414 && 
__a
->
s6_addr32
[2] == 0 \

415 && 
__a
->
s6_addr32
[3] =0; 
	}
}))

	)

417 
	#IN6_IS_ADDR_LOOPBACK
(
a
) \

418 (
__exnsi__
 \

419 ({ cڡ 
6_addr
 *
__a
 = (cڡ 6_add*(
a
); \

420 
__a
->
s6_addr32
[0] == 0 \

421 && 
__a
->
s6_addr32
[1] == 0 \

422 && 
__a
->
s6_addr32
[2] == 0 \

423 && 
__a
->
s6_addr32
[3] =
	`htl
 (1); }))

	)

425 
	#IN6_IS_ADDR_LINKLOCAL
(
a
) \

426 (
__exnsi__
 \

427 ({ cڡ 
6_addr
 *
__a
 = (cڡ 6_add*(
a
); \

428 (
__a
->
s6_addr32
[0] & 
	`htl
 (0xffc00000)=ht(0x800000); }))

	)

430 
	#IN6_IS_ADDR_SITELOCAL
(
a
) \

431 (
__exnsi__
 \

432 ({ cڡ 
6_addr
 *
__a
 = (cڡ 6_add*(
a
); \

433 (
__a
->
s6_addr32
[0] & 
	`htl
 (0xffc00000)=ht(0xc00000); }))

	)

435 
	#IN6_IS_ADDR_V4MAPPED
(
a
) \

436 (
__exnsi__
 \

437 ({ cڡ 
6_addr
 *
__a
 = (cڡ 6_add*(
a
); \

438 
__a
->
s6_addr32
[0] == 0 \

439 && 
__a
->
s6_addr32
[1] == 0 \

440 && 
__a
->
s6_addr32
[2] =
	`htl
 (0xffff); }))

	)

442 
	#IN6_IS_ADDR_V4COMPAT
(
a
) \

443 (
__exnsi__
 \

444 ({ cڡ 
6_addr
 *
__a
 = (cڡ 6_add*(
a
); \

445 
__a
->
s6_addr32
[0] == 0 \

446 && 
__a
->
s6_addr32
[1] == 0 \

447 && 
__a
->
s6_addr32
[2] == 0 \

448 && 
	`ohl
 (
__a
->
s6_addr32
[3]> 1; }))

	)

450 
	#IN6_ARE_ADDR_EQUAL
(
a
,
b
) \

451 (
__exnsi__
 \

452 ({ cڡ 
6_addr
 *
__a
 = (cڡ 6_add*(
a
); \

453 cڡ 
6_addr
 *
__b
 = (cڡ 6_add*(
b
); \

454 
__a
->
s6_addr32
[0] =
__b
->s6_addr32[0] \

455 && 
__a
->
s6_addr32
[1] =
__b
->s6_addr32[1] \

456 && 
__a
->
s6_addr32
[2] =
__b
->s6_addr32[2] \

457 && 
__a
->
s6_addr32
[3] =
__b
->s6_addr32[3]; }))

	)

459 
	#IN6_IS_ADDR_UNSPECIFIED
(
a
) \

460 (((cڡ 
ut32_t
 *(
a
))[0] == 0 \

461 && ((cڡ 
ut32_t
 *(
a
))[1] == 0 \

462 && ((cڡ 
ut32_t
 *(
a
))[2] == 0 \

463 && ((cڡ 
ut32_t
 *(
a
))[3] =0)

	)

465 
	#IN6_IS_ADDR_LOOPBACK
(
a
) \

466 (((cڡ 
ut32_t
 *(
a
))[0] == 0 \

467 && ((cڡ 
ut32_t
 *(
a
))[1] == 0 \

468 && ((cڡ 
ut32_t
 *(
a
))[2] == 0 \

469 && ((cڡ 
ut32_t
 *(
a
))[3] =
	`htl
 (1))

	)

471 
	#IN6_IS_ADDR_LINKLOCAL
(
a
) \

472 ((((cڡ 
ut32_t
 *(
a
))[0] & 
	`htl
 (0xffc00000)) \

473 =
	`htl
 (0x800000))

	)

475 
	#IN6_IS_ADDR_SITELOCAL
(
a
) \

476 ((((cڡ 
ut32_t
 *(
a
))[0] & 
	`htl
 (0xffc00000)) \

477 =
	`htl
 (0xc00000))

	)

479 
	#IN6_IS_ADDR_V4MAPPED
(
a
) \

480 ((((cڡ 
ut32_t
 *(
a
))[0] == 0) \

481 && (((cڡ 
ut32_t
 *(
a
))[1] == 0) \

482 && (((cڡ 
ut32_t
 *(
a
))[2] =
	`htl
 (0xffff)))

	)

484 
	#IN6_IS_ADDR_V4COMPAT
(
a
) \

485 ((((cڡ 
ut32_t
 *(
a
))[0] == 0) \

486 && (((cڡ 
ut32_t
 *(
a
))[1] == 0) \

487 && (((cڡ 
ut32_t
 *(
a
))[2] == 0) \

488 && (
	`ohl
 (((cڡ 
ut32_t
 *(
a
))[3]> 1))

	)

490 
	#IN6_ARE_ADDR_EQUAL
(
a
,
b
) \

491 ((((cڡ 
ut32_t
 *(
a
))[0] =((cڡ ut32_*(
b
))[0]) \

492 && (((cڡ 
ut32_t
 *(
a
))[1] =((cڡ ut32_*(
b
))[1]) \

493 && (((cڡ 
ut32_t
 *(
a
))[2] =((cڡ ut32_*(
b
))[2]) \

494 && (((cڡ 
ut32_t
 *(
a
))[3] =((cڡ ut32_*(
b
))[3]))

	)

497 
	#IN6_IS_ADDR_MULTICAST
(
a
(((cڡ 
ut8_t
 *))[0] =0xff)

	)

499 #i
defed
 
__USE_MISC
 || defed 
__USE_GNU


501 
	$bdsvpt
 (
__sockfd
, 
sockaddr_
 *
__sock_

__THROW
;

504 
	$bdsvpt6
 (
__sockfd
, 
sockaddr_6
 *
__sock_
)

505 
__THROW
;

509 
	#IN6_IS_ADDR_MC_NODELOCAL
(
a
) \

510 (
	`IN6_IS_ADDR_MULTICAST
(
a
) \

511 && ((((cڡ 
ut8_t
 *(
a
))[1] & 0xf=0x1))

	)

513 
	#IN6_IS_ADDR_MC_LINKLOCAL
(
a
) \

514 (
	`IN6_IS_ADDR_MULTICAST
(
a
) \

515 && ((((cڡ 
ut8_t
 *(
a
))[1] & 0xf=0x2))

	)

517 
	#IN6_IS_ADDR_MC_SITELOCAL
(
a
) \

518 (
	`IN6_IS_ADDR_MULTICAST
(
a
) \

519 && ((((cڡ 
ut8_t
 *(
a
))[1] & 0xf=0x5))

	)

521 
	#IN6_IS_ADDR_MC_ORGLOCAL
(
a
) \

522 (
	`IN6_IS_ADDR_MULTICAST
(
a
) \

523 && ((((cڡ 
ut8_t
 *(
a
))[1] & 0xf=0x8))

	)

525 
	#IN6_IS_ADDR_MC_GLOBAL
(
a
) \

526 (
	`IN6_IS_ADDR_MULTICAST
(
a
) \

527 && ((((cڡ 
ut8_t
 *(
a
))[1] & 0xf=0xe))

	)

530 #ifde
__USE_GNU


531 
cmsghdr
;

534 
	s6_pktfo


536 
6_addr
 
i6_addr
;

537 
i6_ifdex
;

541 
	s6_mtufo


543 
sockaddr_6
 
6m_addr
;

544 
ut32_t
 
6m_mtu
;

549 
	$6_ti_a
 (
__nbys
)

550 
__THROW
 
__ibu_dd__
;

551 
	$6_ti_
 (*
__bp
, 
cmsghdr
 **
__cmsgp
,

552 
__ty

__THROW
 
__ibu_dd__
;

553 
	$6_ti_nd
 (
cmsghdr
 *
__cmsg
,

554 cڡ 
ut8_t
 *
__typ
, 
__mux
,

555 
__usy

__THROW
 
__ibu_dd__
;

556 
ut8_t
 *
	$6_ti_loc
 (
cmsghdr
 *
__cmsg
, 
__d
,

557 
__mux
, 
__usy
)

558 
__THROW
 
__ibu_dd__
;

559 
	$6_ti_xt
 (cڡ 
cmsghdr
 *
__cmsg
,

560 
ut8_t
 **
__p
)

561 
__THROW
 
__ibu_dd__
;

562 
	$6_ti_fd
 (cڡ 
cmsghdr
 *
__cmsg
,

563 
ut8_t
 **
__p
, 
__ty
)

564 
__THROW
 
__ibu_dd__
;

568 
	$6_t_
 (*
__extbuf
, 
sockn_t
 
__ex

__THROW
;

569 
	$6_t_nd
 (*
__extbuf
, 
sockn_t
 
__ex
, 
__offt
,

570 
ut8_t
 
__ty
, 
sockn_t
 
__n
, ut8_
__ign
,

571 **
__dabu

__THROW
;

572 
	$6_t_fish
 (*
__extbuf
, 
sockn_t
 
__ex
, 
__offt
)

573 
__THROW
;

574 
	$6_t_t_v
 (*
__dabuf
, 
__offt
, *
__v
,

575 
sockn_t
 
__vn

__THROW
;

576 
	$6_t_xt
 (*
__extbuf
, 
sockn_t
 
__ex
, 
__offt
,

577 
ut8_t
 *
__typ
, 
sockn_t
 *
__
,

578 **
__dabu

__THROW
;

579 
	$6_t_fd
 (*
__extbuf
, 
sockn_t
 
__ex
, 
__offt
,

580 
ut8_t
 
__ty
, 
sockn_t
 *
__
,

581 **
__dabu

__THROW
;

582 
	$6_t_g_v
 (*
__dabuf
, 
__offt
, *
__v
,

583 
sockn_t
 
__vn

__THROW
;

587 
sockn_t
 
	$6_h_a
 (
__ty
, 
__gmts

__THROW
;

588 *
	$6_h_
 (*
__bp
, 
sockn_t
 
__bp_n
, 
__ty
,

589 
__gmts

__THROW
;

590 
	$6_h_add
 (*
__bp
, cڡ 
6_addr
 *
__addr

__THROW
;

591 
	$6_h_v
 (cڡ *
__
, *
__out

__THROW
;

592 
	$6_h_gmts
 (cڡ *
__bp

__THROW
;

593 
6_addr
 *
	$6_h_gaddr
 (cڡ *
__bp
, 
__dex
)

594 
__THROW
;

600 
	$gv4sourfr
 (
__s
, 
_addr
 
__r_addr
,

601 
_addr
 
__group
, 
ut32_t
 *
__fmode
,

602 
ut32_t
 *
__numc
, 
_addr
 *
__i
)

603 
__THROW
;

606 
	$tv4sourfr
 (
__s
, 
_addr
 
__r_addr
,

607 
_addr
 
__group
, 
ut32_t
 
__fmode
,

608 
ut32_t
 
__numc
,

609 cڡ 
_addr
 *
__i
)

610 
__THROW
;

614 
	$gsourfr
 (
__s
, 
ut32_t
 
__r_addr
,

615 cڡ 
sockaddr
 *
__group
,

616 
sockn_t
 
__grou
, 
ut32_t
 *
__fmode
,

617 
ut32_t
 *
__numc
,

618 
sockaddr_age
 *
__i

__THROW
;

621 
	$tsourfr
 (
__s
, 
ut32_t
 
__r_addr
,

622 cڡ 
sockaddr
 *
__group
,

623 
sockn_t
 
__grou
, 
ut32_t
 
__fmode
,

624 
ut32_t
 
__numc
,

625 cڡ 
sockaddr_age
 *
__i

__THROW
;

628 
__END_DECLS


	@/usr/include/sys/select.h

21 #ide
_SYS_SELECT_H


22 
	#_SYS_SELECT_H
 1

	)

24 
	~<us.h
>

27 
	~<bs/tys.h
>

30 
	~<bs/.h
>

33 
	~<bs/sigt.h
>

35 #ide
__sigt_t_defed


36 
	#__sigt_t_defed


	)

37 
__sigt_t
 
	tsigt_t
;

41 
	#__ed_time_t


	)

42 
	#__ed_timeec


	)

43 
	~<time.h
>

44 
	#__ed_timev


	)

45 
	~<bs/time.h
>

47 #ide
__sucds_t_defed


48 
__sucds_t
 
	tsucds_t
;

49 
	#__sucds_t_defed


	)

54 
	t__fd_mask
;

57 #unde
__NFDBITS


59 
	#__NFDBITS
 (8 * ( (
__fd_mask
))

	)

60 
	#__FD_ELT
(
d
((d/ 
__NFDBITS
)

	)

61 
	#__FD_MASK
(
d
((
__fd_mask
1 << ((d% 
__NFDBITS
))

	)

68 #ifde
__USE_XOPEN


69 
__fd_mask
 
	mfds_bs
[
__FD_SETSIZE
 / 
__NFDBITS
];

70 
	#__FDS_BITS
(
t
((t)->
fds_bs
)

	)

72 
__fd_mask
 
	m__fds_bs
[
__FD_SETSIZE
 / 
__NFDBITS
];

73 
	#__FDS_BITS
(
t
((t)->
__fds_bs
)

	)

75 } 
	tfd_t
;

78 
	#FD_SETSIZE
 
__FD_SETSIZE


	)

80 #ifde
__USE_MISC


82 
__fd_mask
 
	tfd_mask
;

85 
	#NFDBITS
 
__NFDBITS


	)

90 
	#FD_SET
(
fd
, 
fd

	`__FD_SET
 (fd, fd)

	)

91 
	#FD_CLR
(
fd
, 
fd

	`__FD_CLR
 (fd, fd)

	)

92 
	#FD_ISSET
(
fd
, 
fd

	`__FD_ISSET
 (fd, fd)

	)

93 
	#FD_ZERO
(
fd

	`__FD_ZERO
 (fd)

	)

96 
__BEGIN_DECLS


106 

 (
__nfds
, 
fd_t
 *
__ri
 
__adfds
,

107 
fd_t
 *
__ri
 
__wrefds
,

108 
fd_t
 *
__ri
 
__exfds
,

109 
timev
 *
__ri
 
__timeout
);

111 #ifde
__USE_XOPEN2K


118 
p
 (
__nfds
, 
fd_t
 *
__ri
 
__adfds
,

119 
fd_t
 *
__ri
 
__wrefds
,

120 
fd_t
 *
__ri
 
__exfds
,

121 cڡ 
timeec
 *
__ri
 
__timeout
,

122 cڡ 
__sigt_t
 *
__ri
 
__sigmask
);

127 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__GNUC__


128 
	~<bs/2.h
>

131 
	g__END_DECLS


	@/usr/include/sys/sysmacros.h

19 #ide
_SYS_SYSMACROS_H


20 
	#_SYS_SYSMACROS_H
 1

	)

22 
	~<us.h
>

24 
__BEGIN_DECLS


26 
__exnsi__


27 
	$gnu_dev_maj
 (
__dev
)

28 
__THROW
 
__ibu_cڡ__
;

29 
__exnsi__


30 
	$gnu_dev_m
 (
__dev
)

31 
__THROW
 
__ibu_cڡ__
;

32 
__exnsi__


33 
	$gnu_dev_makedev
 (
__maj
,

34 
__m
)

35 
__THROW
 
__ibu_cڡ__
;

37 #ifde
__USE_EXTERN_INLINES


38 
__exnsi__
 
__ex_le
 
__ibu_cڡ__
 

39 
	`__NTH
 (
	$gnu_dev_maj
 (
__dev
))

41  ((
__dev
 >> 8) & 0xfff) | (() (__dev >> 32) & ~0xfff);

42 
	}
}

44 
__exnsi__
 
__ex_le
 
__ibu_cڡ__
 

45 
__NTH
 (
	$gnu_dev_m
 (
__dev
))

47  (
__dev
 & 0xff) | (() (__dev >> 12) & ~0xff);

48 
	}
}

50 
__exnsi__
 
__ex_le
 
__ibu_cڡ__
 

51 
__NTH
 (
	$gnu_dev_makedev
 (
__maj
, 
__m
))

53  ((
__m
 & 0xff| ((
__maj
 & 0xfff) << 8)

54 | ((((
__m
 & ~0xff)) << 12)

55 | ((((
__maj
 & ~0xfff)) << 32));

56 
	}
}

58 
	g__END_DECLS


61 
	#maj
(
dev

	`gnu_dev_maj
 (dev)

	)

62 
	#m
(
dev

	`gnu_dev_m
 (dev)

	)

63 
	#makedev
(
maj
, 
m

	`gnu_dev_makedev
 (maj, m)

	)

	@/usr/include/sys/ucontext.h

18 #ide
_SYS_UCONTEXT_H


19 
	#_SYS_UCONTEXT_H
 1

	)

21 
	~<us.h
>

22 
	~<sigl.h
>

26 
	~<bs/sigcڋxt.h
>

28 #ifde
__x86_64__


31 
__exnsi__
 
	tgg_t
;

34 
	#NGREG
 23

	)

37 
gg_t
 
	tggt_t
[
NGREG
];

39 #ifde
__USE_GNU


43 
	mREG_R8
 = 0,

44 
	#REG_R8
 
REG_R8


	)

45 
	mREG_R9
,

46 
	#REG_R9
 
REG_R9


	)

47 
	mREG_R10
,

48 
	#REG_R10
 
REG_R10


	)

49 
	mREG_R11
,

50 
	#REG_R11
 
REG_R11


	)

51 
	mREG_R12
,

52 
	#REG_R12
 
REG_R12


	)

53 
	mREG_R13
,

54 
	#REG_R13
 
REG_R13


	)

55 
	mREG_R14
,

56 
	#REG_R14
 
REG_R14


	)

57 
	mREG_R15
,

58 
	#REG_R15
 
REG_R15


	)

59 
	mREG_RDI
,

60 
	#REG_RDI
 
REG_RDI


	)

61 
	mREG_RSI
,

62 
	#REG_RSI
 
REG_RSI


	)

63 
	mREG_RBP
,

64 
	#REG_RBP
 
REG_RBP


	)

65 
	mREG_RBX
,

66 
	#REG_RBX
 
REG_RBX


	)

67 
	mREG_RDX
,

68 
	#REG_RDX
 
REG_RDX


	)

69 
	mREG_RAX
,

70 
	#REG_RAX
 
REG_RAX


	)

71 
	mREG_RCX
,

72 
	#REG_RCX
 
REG_RCX


	)

73 
	mREG_RSP
,

74 
	#REG_RSP
 
REG_RSP


	)

75 
	mREG_RIP
,

76 
	#REG_RIP
 
REG_RIP


	)

77 
	mREG_EFL
,

78 
	#REG_EFL
 
REG_EFL


	)

79 
	mREG_CSGSFS
,

80 
	#REG_CSGSFS
 
REG_CSGSFS


	)

81 
	mREG_ERR
,

82 
	#REG_ERR
 
REG_ERR


	)

83 
	mREG_TRAPNO
,

84 
	#REG_TRAPNO
 
REG_TRAPNO


	)

85 
	mREG_OLDMASK
,

86 
	#REG_OLDMASK
 
REG_OLDMASK


	)

87 
	mREG_CR2


88 
	#REG_CR2
 
REG_CR2


	)

92 
	s_libc_xg


94 
	msignifind
[4];

95 
	mexpڒt
;

96 
	mddg
[3];

99 
	s_libc_xmmg


101 
__ut32_t
 
	memt
[4];

104 
	s_libc_塩e


107 
__ut16_t
 
	mcwd
;

108 
__ut16_t
 
	mswd
;

109 
__ut16_t
 
	mw
;

110 
__ut16_t
 
	mf
;

111 
__ut64_t
 
	mr
;

112 
__ut64_t
 
	mrdp
;

113 
__ut32_t
 
	mmxc
;

114 
__ut32_t
 
	mmx_mask
;

115 
_libc_xg
 
	m_
[8];

116 
_libc_xmmg
 
	m_xmm
[16];

117 
__ut32_t
 
	mddg
[24];

121 
_libc_塩e
 *
	tgt_t
;

126 
ggt_t
 
	mggs
;

128 
gt_t
 
	mgs
;

129 
__exnsi__
 
	m__rved1
 [8];

130 } 
	tmcڋxt_t
;

133 
	sucڋxt


135 
	muc_ags
;

136 
ucڋxt
 *
	muc_lk
;

137 
ack_t
 
	muc_ack
;

138 
mcڋxt_t
 
	muc_mcڋxt
;

139 
__sigt_t
 
	muc_sigmask
;

140 
_libc_塩e
 
	m__gs_mem
;

141 } 
	tucڋxt_t
;

146 
	tgg_t
;

149 
	#NGREG
 19

	)

152 
gg_t
 
	tggt_t
[
NGREG
];

154 #ifde
__USE_GNU


158 
	mREG_GS
 = 0,

159 
	#REG_GS
 
REG_GS


	)

160 
	mREG_FS
,

161 
	#REG_FS
 
REG_FS


	)

162 
	mREG_ES
,

163 
	#REG_ES
 
REG_ES


	)

164 
	mREG_DS
,

165 
	#REG_DS
 
REG_DS


	)

166 
	mREG_EDI
,

167 
	#REG_EDI
 
REG_EDI


	)

168 
	mREG_ESI
,

169 
	#REG_ESI
 
REG_ESI


	)

170 
	mREG_EBP
,

171 
	#REG_EBP
 
REG_EBP


	)

172 
	mREG_ESP
,

173 
	#REG_ESP
 
REG_ESP


	)

174 
	mREG_EBX
,

175 
	#REG_EBX
 
REG_EBX


	)

176 
	mREG_EDX
,

177 
	#REG_EDX
 
REG_EDX


	)

178 
	mREG_ECX
,

179 
	#REG_ECX
 
REG_ECX


	)

180 
	mREG_EAX
,

181 
	#REG_EAX
 
REG_EAX


	)

182 
	mREG_TRAPNO
,

183 
	#REG_TRAPNO
 
REG_TRAPNO


	)

184 
	mREG_ERR
,

185 
	#REG_ERR
 
REG_ERR


	)

186 
	mREG_EIP
,

187 
	#REG_EIP
 
REG_EIP


	)

188 
	mREG_CS
,

189 
	#REG_CS
 
REG_CS


	)

190 
	mREG_EFL
,

191 
	#REG_EFL
 
REG_EFL


	)

192 
	mREG_UESP
,

193 
	#REG_UESP
 
REG_UESP


	)

194 
	mREG_SS


195 
	#REG_SS
 
REG_SS


	)

200 
	s_libc_g


202 
	msignifind
[4];

203 
	mexpڒt
;

206 
	s_libc_塩e


208 
	mcw
;

209 
	msw
;

210 
	mg
;

211 
	moff
;

212 
	mcsl
;

213 
	mdaoff
;

214 
	mdal
;

215 
_libc_g
 
	m_
[8];

216 
	mus
;

220 
_libc_塩e
 *
	tgt_t
;

225 
ggt_t
 
	mggs
;

228 
gt_t
 
	mgs
;

229 
	mdmask
;

230 
	m2
;

231 } 
	tmcڋxt_t
;

234 
	sucڋxt


236 
	muc_ags
;

237 
ucڋxt
 *
	muc_lk
;

238 
ack_t
 
	muc_ack
;

239 
mcڋxt_t
 
	muc_mcڋxt
;

240 
__sigt_t
 
	muc_sigmask
;

241 
_libc_塩e
 
	m__gs_mem
;

242 } 
	tucڋxt_t
;

	@/usr/include/xlocale.h

20 #ide
_XLOCALE_H


21 
	#_XLOCALE_H
 1

	)

27 
	s__lo_ru


30 
__lo_da
 *
	m__los
[13];

33 cڡ *
	m__y_b
;

34 cڡ *
	m__y_tow
;

35 cڡ *
	m__y_tou
;

38 cڡ *
	m__mes
[13];

39 } *
	t__lo_t
;

42 
__lo_t
 
	tlo_t
;

	@/usr/include/_G_config.h

4 #ide
_G_cfig_h


5 
	#_G_cfig_h
 1

	)

9 
	~<bs/tys.h
>

10 
	#__ed_size_t


	)

11 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


12 
	#__ed_wch_t


	)

14 
	#__ed_NULL


	)

15 
	~<ddef.h
>

16 
	#__ed_mbe_t


	)

17 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


18 
	#__ed_wt_t


	)

20 
	~<wch.h
>

23 
__off_t
 
	m__pos
;

24 
__mbe_t
 
	m__e
;

25 } 
	t_G_os_t
;

28 
__off64_t
 
	m__pos
;

29 
__mbe_t
 
	m__e
;

30 } 
	t_G_os64_t
;

31 #i
defed
 
_LIBC
 || defed 
_GLIBCPP_USE_WCHAR_T


32 
	~<gcv.h
>

35 
__gcv_fo
 
	m__cd
;

38 
__gcv_fo
 
	m__cd
;

39 
__gcv__da
 
	m__da
;

40 } 
	m__combed
;

41 } 
	t_G_icv_t
;

46 
	#_G_va_li
 
__gnuc_va_li


	)

48 
	#_G_HAVE_MMAP
 1

	)

49 
	#_G_HAVE_MREMAP
 1

	)

51 
	#_G_IO_IO_FILE_VERSION
 0x20001

	)

54 
	#_G_HAVE_ST_BLKSIZE
 
	`defed
 (
_STATBUF_ST_BLKSIZE
)

	)

56 
	#_G_BUFSIZ
 8192

	)

	@/usr/include/bits/byteswap.h

19 #i!
defed
 
_BYTESWAP_H
 && !defed 
_NETINET_IN_H
 && !defed 
_ENDIAN_H


23 #ide
_BITS_BYTESWAP_H


24 
	#_BITS_BYTESWAP_H
 1

	)

26 
	~<us.h
>

27 
	~<bs/tys.h
>

28 
	~<bs/wdsize.h
>

31 
	#__bsw_cڡt_16
(
x
) \

32 ((((((
x
>> 8& 0xff| (((x& 0xff<< 8)))

	)

35 
	~<bs/bysw-16.h
>

38 
	#__bsw_cڡt_32
(
x
) \

39 ((((
x
) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >> 8) | \

40 (((
x
& 0x0000ff00<< 8| (((x& 0x000000ff<< 24))

	)

42 #ifde
__GNUC__


43 #i
__GNUC_PREREQ
 (4, 3)

44 
__le
 

45 
	$__bsw_32
 (
__bsx
)

47  
	`__but_bsw32
 (
__bsx
);

48 
	}
}

49 #i
__GNUC__
 >= 2

50 #i
__WORDSIZE
 =64 || (
defed
 
__i486__
 || defed 
__ium__
 \

51 || 
defed
 
	g__iumo__
 || defed 
	g__ium4__
 \

52 || 
defed
 
	g__k8__
 || defed 
	g__hl__
 \

53 || 
defed
 
	g__k6__
 || defed 
	g__noca__
 \

54 || 
defed
 
	g__ce2__
 || defed 
	g__geode__
 \

55 || 
defed
 
	g__amdm10__
)

58 
	#__bsw_32
(
x
) \

59 (
__exnsi__
 \

60 ({ 
__v
, 
__x
 = (
x
); \

61 i(
	`__but_cڡt_p
 (
__x
)) \

62 
__v
 = 
	`__bsw_cڡt_32
 (
__x
); \

64 
	`__asm__
 ("bsw %0" : "" (
__v
: "0" (
__x
)); \

65 
__v
; }))

	)

67 
	#__bsw_32
(
x
) \

68 (
__exnsi__
 \

69 ({ 
__v
, 
__x
 = (
x
); \

70 i(
	`__but_cڡt_p
 (
__x
)) \

71 
__v
 = 
	`__bsw_cڡt_32
 (
__x
); \

73 
	`__asm__
 ("rorw $8, %w0;" \

76 : "" (
__v
) \

77 : "0" (
__x
) \

79 
__v
; }))

	)

82 
	#__bsw_32
(
x
) \

83 (
__exnsi__
 \

84 ({ 
__x
 = (
x
); 
	`__bsw_cڡt_32
 (__x); }))

	)

87 
__le
 

88 
	$__bsw_32
 (
__bsx
)

90  
	`__bsw_cڡt_32
 (
__bsx
);

91 
	}
}

95 #i
__GNUC_PREREQ
 (2, 0)

97 
	#__bsw_cڡt_64
(
x
) \

98 (
	`__exnsi__
 ((((
x
) & 0xff00000000000000ull) >> 56) \

99 | (((
x
) & 0x00ff000000000000ull) >> 40) \

100 | (((
x
) & 0x0000ff0000000000ull) >> 24) \

101 | (((
x
) & 0x000000ff00000000ull) >> 8) \

102 | (((
x
) & 0x00000000ff000000ull) << 8) \

103 | (((
x
) & 0x0000000000ff0000ull) << 24) \

104 | (((
x
) & 0x000000000000ff00ull) << 40) \

105 | (((
x
& 0x00000000000000ffu<< 56)))

	)

107 #i
__GNUC_PREREQ
 (4, 3)

108 
__le
 
__ut64_t


109 
	$__bsw_64
 (
__ut64_t
 
__bsx
)

111  
	`__but_bsw64
 (
__bsx
);

112 
	}
}

113 #i
__WORDSIZE
 == 64

114 
	#__bsw_64
(
x
) \

115 (
__exnsi__
 \

116 ({ 
__ut64_t
 
__v
, 
__x
 = (
x
); \

117 i(
	`__but_cڡt_p
 (
__x
)) \

118 
__v
 = 
	`__bsw_cڡt_64
 (
__x
); \

120 
	`__asm__
 ("bsw %q0" : "" (
__v
: "0" (
__x
)); \

121 
__v
; }))

	)

123 
	#__bsw_64
(
x
) \

124 (
__exnsi__
 \

125 ({ uni { 
__exnsi__
 
__ut64_t
 
__
; \

126 
__l
[2]; } 
__w
, 
__r
; \

127 i(
	`__but_cڡt_p
 (
x
)) \

128 
__r
.
__
 = 
	`__bsw_cڡt_64
 (
x
); \

131 
__w
.
__
 = (
x
); \

132 
__r
.
__l
[0] = 
	`__bsw_32
 (
__w
.__l[1]); \

133 
__r
.
__l
[1] = 
	`__bsw_32
 (
__w
.__l[0]); \

135 
__r
.
__
; }))

	)

138 
	#__bsw_cڡt_64
(
x
) \

139 ((((
x
) & 0xff00000000000000ull) >> 56) \

140 | (((
x
) & 0x00ff000000000000ull) >> 40) \

141 | (((
x
) & 0x0000ff0000000000ull) >> 24) \

142 | (((
x
) & 0x000000ff00000000ull) >> 8) \

143 | (((
x
) & 0x00000000ff000000ull) << 8) \

144 | (((
x
) & 0x0000000000ff0000ull) << 24) \

145 | (((
x
) & 0x000000000000ff00ull) << 40) \

146 | (((
x
& 0x00000000000000ffu<< 56))

	)

148 
__le
 
__ut64_t


149 
	$__bsw_64
 (
__ut64_t
 
__bsx
)

151  
	`__bsw_cڡt_64
 (
__bsx
);

152 
	}
}

	@/usr/include/bits/endian.h

3 #ide
_ENDIAN_H


7 
	#__BYTE_ORDER
 
__LITTLE_ENDIAN


	)

	@/usr/include/bits/fcntl-linux.h

19 #idef 
_FCNTL_H


37 #ifde
__USE_GNU


38 
	~<bs/uio.h
>

42 
	#O_ACCMODE
 0003

	)

43 
	#O_RDONLY
 00

	)

44 
	#O_WRONLY
 01

	)

45 
	#O_RDWR
 02

	)

46 #ide
O_CREAT


47 
	#O_CREAT
 0100

	)

49 #ide
O_EXCL


50 
	#O_EXCL
 0200

	)

52 #ide
O_NOCTTY


53 
	#O_NOCTTY
 0400

	)

55 #ide
O_TRUNC


56 
	#O_TRUNC
 01000

	)

58 #ide
O_APPEND


59 
	#O_APPEND
 02000

	)

61 #ide
O_NONBLOCK


62 
	#O_NONBLOCK
 04000

	)

64 #ide
O_NDELAY


65 
	#O_NDELAY
 
O_NONBLOCK


	)

67 #ide
O_SYNC


68 
	#O_SYNC
 04010000

	)

70 
	#O_FSYNC
 
O_SYNC


	)

71 #ide
O_ASYNC


72 
	#O_ASYNC
 020000

	)

74 #ide
__O_LARGEFILE


75 
	#__O_LARGEFILE
 0100000

	)

78 #ide
__O_DIRECTORY


79 
	#__O_DIRECTORY
 0200000

	)

81 #ide
__O_NOFOLLOW


82 
	#__O_NOFOLLOW
 0400000

	)

84 #ide
__O_CLOEXEC


85 
	#__O_CLOEXEC
 02000000

	)

87 #ide
__O_DIRECT


88 
	#__O_DIRECT
 040000

	)

90 #ide
__O_NOATIME


91 
	#__O_NOATIME
 01000000

	)

93 #ide
__O_PATH


94 
	#__O_PATH
 010000000

	)

96 #ide
__O_DSYNC


97 
	#__O_DSYNC
 010000

	)

99 #ide
__O_TMPFILE


100 
	#__O_TMPFILE
 020200000

	)

103 #ide
F_GETLK


104 #ide
__USE_FILE_OFFSET64


105 
	#F_GETLK
 5

	)

106 
	#F_SETLK
 6

	)

107 
	#F_SETLKW
 7

	)

109 
	#F_GETLK
 
F_GETLK64


	)

110 
	#F_SETLK
 
F_SETLK64


	)

111 
	#F_SETLKW
 
F_SETLKW64


	)

114 #ide
F_GETLK64


115 
	#F_GETLK64
 12

	)

116 
	#F_SETLK64
 13

	)

117 
	#F_SETLKW64
 14

	)

120 #ifde
__USE_LARGEFILE64


121 
	#O_LARGEFILE
 
__O_LARGEFILE


	)

124 #ifde
__USE_XOPEN2K8


125 
	#O_DIRECTORY
 
__O_DIRECTORY


	)

126 
	#O_NOFOLLOW
 
__O_NOFOLLOW


	)

127 
	#O_CLOEXEC
 
__O_CLOEXEC


	)

130 #ifde
__USE_GNU


131 
	#O_DIRECT
 
__O_DIRECT


	)

132 
	#O_NOATIME
 
__O_NOATIME


	)

133 
	#O_PATH
 
__O_PATH


	)

134 
	#O_TMPFILE
 
__O_TMPFILE


	)

140 #i
defed
 
__USE_POSIX199309
 || defed 
__USE_UNIX98


141 
	#O_DSYNC
 
__O_DSYNC


	)

142 #i
defed
 
__O_RSYNC


143 
	#O_RSYNC
 
__O_RSYNC


	)

145 
	#O_RSYNC
 
O_SYNC


	)

150 
	#F_DUPFD
 0

	)

151 
	#F_GETFD
 1

	)

152 
	#F_SETFD
 2

	)

153 
	#F_GETFL
 3

	)

154 
	#F_SETFL
 4

	)

156 #ide
__F_SETOWN


157 
	#__F_SETOWN
 8

	)

158 
	#__F_GETOWN
 9

	)

161 #i
defed
 
__USE_BSD
 || defed 
__USE_UNIX98
 || defed 
__USE_XOPEN2K8


162 
	#F_SETOWN
 
__F_SETOWN


	)

163 
	#F_GETOWN
 
__F_GETOWN


	)

166 #ide
__F_SETSIG


167 
	#__F_SETSIG
 10

	)

168 
	#__F_GETSIG
 11

	)

170 #ide
__F_SETOWN_EX


171 
	#__F_SETOWN_EX
 15

	)

172 
	#__F_GETOWN_EX
 16

	)

175 #ifde
__USE_GNU


176 
	#F_SETSIG
 
__F_SETSIG


	)

177 
	#F_GETSIG
 
__F_GETSIG


	)

178 
	#F_SETOWN_EX
 
__F_SETOWN_EX


	)

179 
	#F_GETOWN_EX
 
__F_GETOWN_EX


	)

182 #ifde
__USE_GNU


183 
	#F_SETLEASE
 1024

	)

184 
	#F_GETLEASE
 1025

	)

185 
	#F_NOTIFY
 1026

	)

186 
	#F_SETPIPE_SZ
 1031

	)

187 
	#F_GETPIPE_SZ
 1032

	)

189 #ifde
__USE_XOPEN2K8


190 
	#F_DUPFD_CLOEXEC
 1030

	)

195 
	#FD_CLOEXEC
 1

	)

197 #ide
F_RDLCK


199 
	#F_RDLCK
 0

	)

200 
	#F_WRLCK
 1

	)

201 
	#F_UNLCK
 2

	)

206 #ide
F_EXLCK


207 
	#F_EXLCK
 4

	)

208 
	#F_SHLCK
 8

	)

211 #ifde
__USE_BSD


213 
	#LOCK_SH
 1

	)

214 
	#LOCK_EX
 2

	)

215 
	#LOCK_NB
 4

	)

217 
	#LOCK_UN
 8

	)

220 #ifde
__USE_GNU


221 
	#LOCK_MAND
 32

	)

222 
	#LOCK_READ
 64

	)

223 
	#LOCK_WRITE
 128

	)

224 
	#LOCK_RW
 192

	)

227 #ifde
__USE_GNU


229 
	#DN_ACCESS
 0x00000001

	)

230 
	#DN_MODIFY
 0x00000002

	)

231 
	#DN_CREATE
 0x00000004

	)

232 
	#DN_DELETE
 0x00000008

	)

233 
	#DN_RENAME
 0x00000010

	)

234 
	#DN_ATTRIB
 0x00000020

	)

235 
	#DN_MULTISHOT
 0x80000000

	)

239 #ifde
__USE_GNU


241 
	e__pid_ty


243 
	mF_OWNER_TID
 = 0,

244 
	mF_OWNER_PID
,

245 
	mF_OWNER_PGRP
,

246 
	mF_OWNER_GID
 = 
F_OWNER_PGRP


250 
	sf_owr_ex


252 
__pid_ty
 
	mty
;

253 
__pid_t
 
	mpid
;

259 #ifdef 
__USE_BSD


260 
	#FAPPEND
 
O_APPEND


	)

261 
	#FFSYNC
 
O_FSYNC


	)

262 
	#FASYNC
 
O_ASYNC


	)

263 
	#FNONBLOCK
 
O_NONBLOCK


	)

264 
	#FNDELAY
 
O_NDELAY


	)

267 #ide
__POSIX_FADV_DONTNEED


268 
	#__POSIX_FADV_DONTNEED
 4

	)

269 
	#__POSIX_FADV_NOREUSE
 5

	)

272 #ifde
__USE_XOPEN2K


273 
	#POSIX_FADV_NORMAL
 0

	)

274 
	#POSIX_FADV_RANDOM
 1

	)

275 
	#POSIX_FADV_SEQUENTIAL
 2

	)

276 
	#POSIX_FADV_WILLNEED
 3

	)

277 
	#POSIX_FADV_DONTNEED
 
__POSIX_FADV_DONTNEED


	)

278 
	#POSIX_FADV_NOREUSE
 
__POSIX_FADV_NOREUSE


	)

282 #ifde
__USE_GNU


284 
	#SYNC_FILE_RANGE_WAIT_BEFORE
 1

	)

287 
	#SYNC_FILE_RANGE_WRITE
 2

	)

290 
	#SYNC_FILE_RANGE_WAIT_AFTER
 4

	)

295 
	#SPLICE_F_MOVE
 1

	)

296 
	#SPLICE_F_NONBLOCK
 2

	)

299 
	#SPLICE_F_MORE
 4

	)

300 
	#SPLICE_F_GIFT
 8

	)

304 
	#FALLOC_FL_KEEP_SIZE
 1

	)

307 
	#FALLOC_FL_PUNCH_HOLE
 2

	)

311 
	sfe_hd


313 
	mhd_bys
;

314 
	mhd_ty
;

316 
	mf_hd
[0];

320 
	#MAX_HANDLE_SZ
 128

	)

324 #ifde
__USE_ATFILE


325 
	#AT_FDCWD
 -100

	)

328 
	#AT_SYMLINK_NOFOLLOW
 0x100

	)

329 
	#AT_REMOVEDIR
 0x200

	)

331 
	#AT_SYMLINK_FOLLOW
 0x400

	)

332 #ifde
__USE_GNU


333 
	#AT_NO_AUTOMOUNT
 0x800

	)

335 
	#AT_EMPTY_PATH
 0x1000

	)

337 
	#AT_EACCESS
 0x200

	)

341 
	g__BEGIN_DECLS


343 #ifde
__USE_GNU


346 
ssize_t
 
	$adahd
 (
__fd
, 
__off64_t
 
__offt
, 
size_t
 
__cou
)

347 
__THROW
;

354 
	`sync_fe_nge
 (
__fd
, 
__off64_t
 
__offt
, __off64_
__cou
,

355 
__ags
);

362 
ssize_t
 
	`vmli
 (
__fdout
, cڡ 
iovec
 *
__iov
,

363 
size_t
 
__cou
, 
__ags
);

369 
ssize_t
 
	`li
 (
__fd
, 
__off64_t
 *
__off
, 
__fdout
,

370 
__off64_t
 *
__offout
, 
size_t
 
__n
,

371 
__ags
);

377 
ssize_t
 
	`e
 (
__fd
, 
__fdout
, 
size_t
 
__n
,

378 
__ags
);

384 #ide
__USE_FILE_OFFSET64


385 
	`o
 (
__fd
, 
__mode
, 
__off_t
 
__offt
, __off_
__n
);

387 #ifde
__REDIRECT


388 
	`__REDIRECT
 (
o
, (
__fd
, 
__mode
, 
__off64_t
 
__offt
,

389 
__off64_t
 
__n
),

390 
o64
);

392 
	#o
 
o64


	)

395 #ifde
__USE_LARGEFILE64


396 
	`o64
 (
__fd
, 
__mode
, 
__off64_t
 
__offt
,

397 
__off64_t
 
__n
);

402 
	$me_to_hd_
 (
__dfd
, cڡ *
__me
,

403 
fe_hd
 *
__hd
, *
__m_id
,

404 
__ags

__THROW
;

410 
	`ݒ_by_hd_
 (
__moudfd
, 
fe_hd
 *
__hd
,

411 
__ags
);

415 
__END_DECLS


	@/usr/include/bits/in.h

20 #ide
_NETINET_IN_H


29 #ifde
_UAPI_LINUX_IN6_H


33 
	#__USE_KERNEL_IPV6_DEFS


	)

39 
	#IP_OPTIONS
 4

	)

40 
	#IP_HDRINCL
 3

	)

41 
	#IP_TOS
 1

	)

42 
	#IP_TTL
 2

	)

43 
	#IP_RECVOPTS
 6

	)

45 
	#IP_RECVRETOPTS
 
IP_RETOPTS


	)

46 
	#IP_RETOPTS
 7

	)

47 
	#IP_MULTICAST_IF
 32

	)

48 
	#IP_MULTICAST_TTL
 33

	)

49 
	#IP_MULTICAST_LOOP
 34

	)

50 
	#IP_ADD_MEMBERSHIP
 35

	)

51 
	#IP_DROP_MEMBERSHIP
 36

	)

52 
	#IP_UNBLOCK_SOURCE
 37

	)

53 
	#IP_BLOCK_SOURCE
 38

	)

54 
	#IP_ADD_SOURCE_MEMBERSHIP
 39

	)

55 
	#IP_DROP_SOURCE_MEMBERSHIP
 40

	)

56 
	#IP_MSFILTER
 41

	)

57 #i
defed
 
__USE_MISC
 || defed 
__USE_GNU


58 
	#MCAST_JOIN_GROUP
 42

	)

59 
	#MCAST_BLOCK_SOURCE
 43

	)

60 
	#MCAST_UNBLOCK_SOURCE
 44

	)

61 
	#MCAST_LEAVE_GROUP
 45

	)

62 
	#MCAST_JOIN_SOURCE_GROUP
 46

	)

63 
	#MCAST_LEAVE_SOURCE_GROUP
 47

	)

64 
	#MCAST_MSFILTER
 48

	)

65 
	#IP_MULTICAST_ALL
 49

	)

66 
	#IP_UNICAST_IF
 50

	)

68 
	#MCAST_EXCLUDE
 0

	)

69 
	#MCAST_INCLUDE
 1

	)

72 
	#IP_ROUTER_ALERT
 5

	)

73 
	#IP_PKTINFO
 8

	)

74 
	#IP_PKTOPTIONS
 9

	)

75 
	#IP_PMTUDISC
 10

	)

76 
	#IP_MTU_DISCOVER
 10

	)

77 
	#IP_RECVERR
 11

	)

78 
	#IP_RECVTTL
 12

	)

79 
	#IP_RECVTOS
 13

	)

80 
	#IP_MTU
 14

	)

81 
	#IP_FREEBIND
 15

	)

82 
	#IP_IPSEC_POLICY
 16

	)

83 
	#IP_XFRM_POLICY
 17

	)

84 
	#IP_PASSSEC
 18

	)

85 
	#IP_TRANSPARENT
 19

	)

86 
	#IP_MULTICAST_ALL
 49

	)

89 
	#IP_ORIGDSTADDR
 20

	)

90 
	#IP_RECVORIGDSTADDR
 
IP_ORIGDSTADDR


	)

92 
	#IP_MINTTL
 21

	)

96 
	#IP_PMTUDISC_DONT
 0

	)

97 
	#IP_PMTUDISC_WANT
 1

	)

98 
	#IP_PMTUDISC_DO
 2

	)

99 
	#IP_PMTUDISC_PROBE
 3

	)

102 
	#SOL_IP
 0

	)

104 
	#IP_DEFAULT_MULTICAST_TTL
 1

	)

105 
	#IP_DEFAULT_MULTICAST_LOOP
 1

	)

106 
	#IP_MAX_MEMBERSHIPS
 20

	)

108 #i
defed
 
__USE_MISC
 || defed 
__USE_GNU


112 
	s_ts


114 
_addr
 
	m_d
;

115 
	m_ts
[40];

119 
	s_mqn


121 
_addr
 
	mimr_muɟddr
;

122 
_addr
 
	mimr_addss
;

123 
	mimr_ifdex
;

127 
	s_pktfo


129 
	mi_ifdex
;

130 
_addr
 
	mi_ec_d
;

131 
_addr
 
	mi_addr
;

138 
	#IPV6_ADDRFORM
 1

	)

139 
	#IPV6_2292PKTINFO
 2

	)

140 
	#IPV6_2292HOPOPTS
 3

	)

141 
	#IPV6_2292DSTOPTS
 4

	)

142 
	#IPV6_2292RTHDR
 5

	)

143 
	#IPV6_2292PKTOPTIONS
 6

	)

144 
	#IPV6_CHECKSUM
 7

	)

145 
	#IPV6_2292HOPLIMIT
 8

	)

147 
	#SCM_SRCRT
 
IPV6_RXSRCRT


	)

149 
	#IPV6_NEXTHOP
 9

	)

150 
	#IPV6_AUTHHDR
 10

	)

151 
	#IPV6_UNICAST_HOPS
 16

	)

152 
	#IPV6_MULTICAST_IF
 17

	)

153 
	#IPV6_MULTICAST_HOPS
 18

	)

154 
	#IPV6_MULTICAST_LOOP
 19

	)

155 
	#IPV6_JOIN_GROUP
 20

	)

156 
	#IPV6_LEAVE_GROUP
 21

	)

157 
	#IPV6_ROUTER_ALERT
 22

	)

158 
	#IPV6_MTU_DISCOVER
 23

	)

159 
	#IPV6_MTU
 24

	)

160 
	#IPV6_RECVERR
 25

	)

161 
	#IPV6_V6ONLY
 26

	)

162 
	#IPV6_JOIN_ANYCAST
 27

	)

163 
	#IPV6_LEAVE_ANYCAST
 28

	)

164 
	#IPV6_IPSEC_POLICY
 34

	)

165 
	#IPV6_XFRM_POLICY
 35

	)

167 
	#IPV6_RECVPKTINFO
 49

	)

168 
	#IPV6_PKTINFO
 50

	)

169 
	#IPV6_RECVHOPLIMIT
 51

	)

170 
	#IPV6_HOPLIMIT
 52

	)

171 
	#IPV6_RECVHOPOPTS
 53

	)

172 
	#IPV6_HOPOPTS
 54

	)

173 
	#IPV6_RTHDRDSTOPTS
 55

	)

174 
	#IPV6_RECVRTHDR
 56

	)

175 
	#IPV6_RTHDR
 57

	)

176 
	#IPV6_RECVDSTOPTS
 58

	)

177 
	#IPV6_DSTOPTS
 59

	)

179 
	#IPV6_RECVTCLASS
 66

	)

180 
	#IPV6_TCLASS
 67

	)

183 
	#IPV6_ADD_MEMBERSHIP
 
IPV6_JOIN_GROUP


	)

184 
	#IPV6_DROP_MEMBERSHIP
 
IPV6_LEAVE_GROUP


	)

185 
	#IPV6_RXHOPOPTS
 
IPV6_HOPOPTS


	)

186 
	#IPV6_RXDSTOPTS
 
IPV6_DSTOPTS


	)

189 
	#IPV6_PMTUDISC_DONT
 0

	)

190 
	#IPV6_PMTUDISC_WANT
 1

	)

191 
	#IPV6_PMTUDISC_DO
 2

	)

192 
	#IPV6_PMTUDISC_PROBE
 3

	)

195 
	#SOL_IPV6
 41

	)

196 
	#SOL_ICMPV6
 58

	)

199 
	#IPV6_RTHDR_LOOSE
 0

	)

200 
	#IPV6_RTHDR_STRICT
 1

	)

202 
	#IPV6_RTHDR_TYPE_0
 0

	)

	@/usr/include/bits/libio-ldbl.h

19 #ide
_IO_STDIO_H


23 
	$__LDBL_REDIR_DECL
 (
_IO_vfsnf
)

24 
	`__LDBL_REDIR_DECL
 (
_IO_vrtf
)

	@/usr/include/bits/local_lim.h

24 #ide
NR_OPEN


25 
	#__undef_NR_OPEN


	)

27 #ide
LINK_MAX


28 
	#__undef_LINK_MAX


	)

30 #ide
OPEN_MAX


31 
	#__undef_OPEN_MAX


	)

33 #ide
ARG_MAX


34 
	#__undef_ARG_MAX


	)

38 
	~<lux/lims.h
>

41 #ifde
__undef_NR_OPEN


42 #unde
NR_OPEN


43 #unde
__undef_NR_OPEN


46 #ifde
__undef_LINK_MAX


47 #unde
LINK_MAX


48 #unde
__undef_LINK_MAX


51 #ifde
__undef_OPEN_MAX


52 #unde
OPEN_MAX


53 #unde
__undef_OPEN_MAX


56 #ifde
__undef_ARG_MAX


57 #unde
ARG_MAX


58 #unde
__undef_ARG_MAX


62 
	#_POSIX_THREAD_KEYS_MAX
 128

	)

64 
	#PTHREAD_KEYS_MAX
 1024

	)

67 
	#_POSIX_THREAD_DESTRUCTOR_ITERATIONS
 4

	)

69 
	#PTHREAD_DESTRUCTOR_ITERATIONS
 
_POSIX_THREAD_DESTRUCTOR_ITERATIONS


	)

72 
	#_POSIX_THREAD_THREADS_MAX
 64

	)

74 #unde
PTHREAD_THREADS_MAX


78 
	#AIO_PRIO_DELTA_MAX
 20

	)

81 
	#PTHREAD_STACK_MIN
 16384

	)

84 
	#DELAYTIMER_MAX
 2147483647

	)

87 
	#TTY_NAME_MAX
 32

	)

90 
	#LOGIN_NAME_MAX
 256

	)

93 
	#HOST_NAME_MAX
 64

	)

96 
	#MQ_PRIO_MAX
 32768

	)

99 
	#SEM_VALUE_MAX
 (2147483647)

	)

	@/usr/include/bits/mman-linux.h

19 #ide
_SYS_MMAN_H


32 
	#PROT_READ
 0x1

	)

33 
	#PROT_WRITE
 0x2

	)

34 
	#PROT_EXEC
 0x4

	)

35 
	#PROT_NONE
 0x0

	)

36 
	#PROT_GROWSDOWN
 0x01000000

	)

38 
	#PROT_GROWSUP
 0x02000000

	)

42 
	#MAP_SHARED
 0x01

	)

43 
	#MAP_PRIVATE
 0x02

	)

44 #ifde
__USE_MISC


45 
	#MAP_TYPE
 0x0

	)

49 
	#MAP_FIXED
 0x10

	)

50 #ifde
__USE_MISC


51 
	#MAP_FILE
 0

	)

52 #ifde
__MAP_ANONYMOUS


53 
	#MAP_ANONYMOUS
 
__MAP_ANONYMOUS


	)

55 
	#MAP_ANONYMOUS
 0x20

	)

57 
	#MAP_ANON
 
MAP_ANONYMOUS


	)

59 
	#MAP_HUGE_SHIFT
 26

	)

60 
	#MAP_HUGE_MASK
 0x3f

	)

64 
	#MS_ASYNC
 1

	)

65 
	#MS_SYNC
 4

	)

66 
	#MS_INVALIDATE
 2

	)

69 #ifde
__USE_GNU


70 
	#MREMAP_MAYMOVE
 1

	)

71 
	#MREMAP_FIXED
 2

	)

75 #ifde
__USE_BSD


76 
	#MADV_NORMAL
 0

	)

77 
	#MADV_RANDOM
 1

	)

78 
	#MADV_SEQUENTIAL
 2

	)

79 
	#MADV_WILLNEED
 3

	)

80 
	#MADV_DONTNEED
 4

	)

81 
	#MADV_REMOVE
 9

	)

82 
	#MADV_DONTFORK
 10

	)

83 
	#MADV_DOFORK
 11

	)

84 
	#MADV_MERGEABLE
 12

	)

85 
	#MADV_UNMERGEABLE
 13

	)

86 
	#MADV_HUGEPAGE
 14

	)

87 
	#MADV_NOHUGEPAGE
 15

	)

88 
	#MADV_DONTDUMP
 16

	)

90 
	#MADV_DODUMP
 17

	)

91 
	#MADV_HWPOISON
 100

	)

95 #ifde
__USE_XOPEN2K


96 
	#POSIX_MADV_NORMAL
 0

	)

97 
	#POSIX_MADV_RANDOM
 1

	)

98 
	#POSIX_MADV_SEQUENTIAL
 2

	)

99 
	#POSIX_MADV_WILLNEED
 3

	)

100 
	#POSIX_MADV_DONTNEED
 4

	)

104 #ide
MCL_CURRENT


105 
	#MCL_CURRENT
 1

	)

106 
	#MCL_FUTURE
 2

	)

	@/usr/include/bits/select.h

18 #ide
_SYS_SELECT_H


22 
	~<bs/wdsize.h
>

25 #i
defed
 
__GNUC__
 && __GNUC__ >= 2

27 #i
__WORDSIZE
 == 64

28 
	#__FD_ZERO_STOS
 "osq"

	)

30 
	#__FD_ZERO_STOS
 "o"

	)

33 
	#__FD_ZERO
(
fd
) \

35 
__d0
, 
__d1
; \

36 
__asm__
 
	`__vީe__
 ("d;; " 
__FD_ZERO_STOS
 \

37 : "=c" (
__d0
), "=D" (
__d1
) \

38 : "a" (0), "0" ( (
fd_t
) \

39 /  (
__fd_mask
)), \

40 "1" (&
	`__FDS_BITS
 (
fd
)[0]) \

42 } 0)

	)

48 
	#__FD_ZERO
(
t
) \

50 
__i
; \

51 
fd_t
 *
__r
 = (
t
); \

52 
__i
 = 0; __<  (
fd_t
/  (
__fd_mask
); ++__i) \

53 
	`__FDS_BITS
 (
__r
)[
__i
] = 0; \

54 } 0)

	)

58 
	#__FD_SET
(
d
, 
t
) \

59 (((
	`__FDS_BITS
 (
t
)[
	`__FD_ELT
 (
d
)] |
	`__FD_MASK
 (d)))

	)

60 
	#__FD_CLR
(
d
, 
t
) \

61 (((
	`__FDS_BITS
 (
t
)[
	`__FD_ELT
 (
d
)] &~
	`__FD_MASK
 (d)))

	)

62 
	#__FD_ISSET
(
d
, 
t
) \

63 ((
	`__FDS_BITS
 (
t
)[
	`__FD_ELT
 (
d
)] & 
	`__FD_MASK
 (d)!0)

	)

	@/usr/include/bits/select2.h

19 #ide
_SYS_SELECT_H


24 
__fdt_chk
 (
__d
);

25 
	$__fdt_wn
 (
__d
)

26 
	`__wǉr
 ("bit outside of fd_set selected");

27 #unde
__FD_ELT


28 
	#__FD_ELT
(
d
) \

29 
__exnsi__
 \

30 ({ 
__d
 = (
d
); \

31 (
	`__but_cڡt_p
 (
__d
) \

32 ? (0 <
__d
 && __d < 
__FD_SETSIZE
 \

33 ? (
__d
 / 
__NFDBITS
) \

34 : 
	`__fdt_wn
 (
__d
)) \

35 : 
	`__fdt_chk
 (
__d
)); 
	}
})

	)

	@/usr/include/bits/stdio-lock.h

19 #ide
_BITS_STDIO_LOCK_H


20 
	#_BITS_STDIO_LOCK_H
 1

	)

22 
	~<bs/libc-lock.h
>

23 
	~<lowvlock.h
>

27 
	#_IO_lock_exnsive
 1

	)

29 ru { 
	mlock
; 
	mt
; *
	mowr
; } 
	t_IO_lock_t
;

31 
	#_IO_lock_liz
 { 
LLL_LOCK_INITIALIZER
, 0, 
NULL
 }

	)

33 
	#_IO_lock_
(
_me
) \

34 ((
_me
(
_IO_lock_t

_IO_lock_liz
 , 0)

	)

36 
	#_IO_lock_fi
(
_me
) \

37 ((0)

	)

39 
	#_IO_lock_lock
(
_me
) \

41 *
__lf
 = 
THREAD_SELF
; \

42 i((
_me
).
owr
 !
__lf
) \

44 
	`l_lock
 ((
_me
).
lock
, 
LLL_PRIVATE
); \

45 (
_me
).
owr
 = 
__lf
; \

47 ++(
_me
).
t
; \

48 } 0)

	)

50 
	#_IO_lock_ylock
(
_me
) \

52 
__su
 = 0; \

53 *
__lf
 = 
THREAD_SELF
; \

54 i((
_me
).
owr
 !
__lf
) \

56 i(
	`l_ylock
 ((
_me
).
lock
) == 0) \

58 (
_me
).
owr
 = 
__lf
; \

59 (
_me
).
t
 = 1; \

62 
__su
 = 
EBUSY
; \

65 ++(
_me
).
t
; \

66 
__su
; \

67 })

	)

69 
	#_IO_lock_uock
(
_me
) \

71 i(--(
_me
).
t
 == 0) \

73 (
_me
).
owr
 = 
NULL
; \

74 
	`l_uock
 ((
_me
).
lock
, 
LLL_PRIVATE
); \

76 } 0)

	)

80 
	#_IO_nup_gi_t
(
_f
, 
_
) \

81 
	`__libc_nup_gi_t
 (((
_
)->
_ags
 & 
_IO_USER_LOCK
=0, 
_f
, _)

	)

82 
	#_IO_nup_gi_t_nrg
(
_f
) \

83 
	`__libc_nup_gi_t
 (1, 
_f
, 
NULL
)

	)

84 
	#_IO_nup_gi_d
(
_do
) \

85 
	`__libc_nup_gi_d
 (
_do
)

	)

87 #i
defed
 
_LIBC
 && !defed 
NOT_IN_libc


89 #ifde
__EXCEPTIONS


90 
	#_IO_acque_lock
(
_
) \

92 
_IO_FILE
 *
_IO_acque_lock_fe
 \

93 
	`__ibu__
((
	`nup
 (
_IO_acque_lock_f
))) \

94 (
_
); \

95 
	`_IO_ockfe
 (
_IO_acque_lock_fe
);

	)

96 
	#_IO_acque_lock_r_ags2
(
_
) \

98 
_IO_FILE
 *
_IO_acque_lock_fe
 \

99 
	`__ibu__
((
	`nup
 (
_IO_acque_lock_r_ags2_f
))) \

100 (
_
); \

101 
	`_IO_ockfe
 (
_IO_acque_lock_fe
);

	)

103 
	#_IO_acque_lock
(
_

_IO_acque_lock_eds_exis_abd


	)

104 
	#_IO_acque_lock_r_ags2
(
_

	`_IO_acque_lock
 (_)

	)

106 
	#_IO_a_lock
(
_
; } 0)

	)

	@/usr/include/bits/timex.h

18 #idef 
_BITS_TIMEX_H


19 
	#_BITS_TIMEX_H
 1

	)

21 
	~<bs/tys.h
>

25 
	stimex


27 
	mmodes
;

28 
__sys_g_t
 
	mofft
;

29 
__sys_g_t
 
	meq
;

30 
__sys_g_t
 
	mmaxr
;

31 
__sys_g_t
 
	mer
;

32 
	mus
;

33 
__sys_g_t
 
	mcڡt
;

34 
__sys_g_t
 
	mecisi
;

35 
__sys_g_t
 
	mtޔ
;

36 
timev
 
	mtime
;

37 
__sys_g_t
 
	mtick
;

38 
__sys_g_t
 
	mseq
;

39 
__sys_g_t
 
	mjr
;

40 
	mshi
;

41 
__sys_g_t
 
	mab
;

42 
__sys_g_t
 
	mjt
;

43 
__sys_g_t
 
	mlt
;

44 
__sys_g_t
 
	mrt
;

45 
__sys_g_t
 
	mbt
;

47 
	mi
;

56 
	#ADJ_OFFSET
 0x0001

	)

57 
	#ADJ_FREQUENCY
 0x0002

	)

58 
	#ADJ_MAXERROR
 0x0004

	)

59 
	#ADJ_ESTERROR
 0x0008

	)

60 
	#ADJ_STATUS
 0x0010

	)

61 
	#ADJ_TIMECONST
 0x0020

	)

62 
	#ADJ_TAI
 0x0080

	)

63 
	#ADJ_MICRO
 0x1000

	)

64 
	#ADJ_NANO
 0x2000

	)

65 
	#ADJ_TICK
 0x4000

	)

66 
	#ADJ_OFFSET_SINGLESHOT
 0x8001

	)

67 
	#ADJ_OFFSET_SS_READ
 0xa001

	)

70 
	#MOD_OFFSET
 
ADJ_OFFSET


	)

71 
	#MOD_FREQUENCY
 
ADJ_FREQUENCY


	)

72 
	#MOD_MAXERROR
 
ADJ_MAXERROR


	)

73 
	#MOD_ESTERROR
 
ADJ_ESTERROR


	)

74 
	#MOD_STATUS
 
ADJ_STATUS


	)

75 
	#MOD_TIMECONST
 
ADJ_TIMECONST


	)

76 
	#MOD_CLKB
 
ADJ_TICK


	)

77 
	#MOD_CLKA
 
ADJ_OFFSET_SINGLESHOT


	)

78 
	#MOD_TAI
 
ADJ_TAI


	)

79 
	#MOD_MICRO
 
ADJ_MICRO


	)

80 
	#MOD_NANO
 
ADJ_NANO


	)

84 
	#STA_PLL
 0x0001

	)

85 
	#STA_PPSFREQ
 0x0002

	)

86 
	#STA_PPSTIME
 0x0004

	)

87 
	#STA_FLL
 0x0008

	)

89 
	#STA_INS
 0x0010

	)

90 
	#STA_DEL
 0x0020

	)

91 
	#STA_UNSYNC
 0x0040

	)

92 
	#STA_FREQHOLD
 0x0080

	)

94 
	#STA_PPSSIGNAL
 0x0100

	)

95 
	#STA_PPSJITTER
 0x0200

	)

96 
	#STA_PPSWANDER
 0x0400

	)

97 
	#STA_PPSERROR
 0x0800

	)

99 
	#STA_CLOCKERR
 0x1000

	)

100 
	#STA_NANO
 0x2000

	)

101 
	#STA_MODE
 0x4000

	)

102 
	#STA_CLK
 0x8000

	)

105 
	#STA_RONLY
 (
STA_PPSSIGNAL
 | 
STA_PPSJITTER
 | 
STA_PPSWANDER
 | \

106 
STA_PPSERROR
 | 
STA_CLOCKERR
 | 
STA_NANO
 | 
STA_MODE
 | 
STA_CLK
)

	)

	@/usr/include/bits/typesizes.h

19 #ide
_BITS_TYPES_H


23 #idef 
_BITS_TYPESIZES_H


24 
	#_BITS_TYPESIZES_H
 1

	)

30 #i
defed
 
__x86_64__
 && defed 
__ILP32__


31 
	#__SYSCALL_SLONG_TYPE
 
__SQUAD_TYPE


	)

32 
	#__SYSCALL_ULONG_TYPE
 
__UQUAD_TYPE


	)

34 
	#__SYSCALL_SLONG_TYPE
 
__SLONGWORD_TYPE


	)

35 
	#__SYSCALL_ULONG_TYPE
 
__ULONGWORD_TYPE


	)

38 
	#__DEV_T_TYPE
 
__UQUAD_TYPE


	)

39 
	#__UID_T_TYPE
 
__U32_TYPE


	)

40 
	#__GID_T_TYPE
 
__U32_TYPE


	)

41 
	#__INO_T_TYPE
 
__SYSCALL_ULONG_TYPE


	)

42 
	#__INO64_T_TYPE
 
__UQUAD_TYPE


	)

43 
	#__MODE_T_TYPE
 
__U32_TYPE


	)

44 #ifde
__x86_64__


45 
	#__NLINK_T_TYPE
 
__SYSCALL_ULONG_TYPE


	)

46 
	#__FSWORD_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

48 
	#__NLINK_T_TYPE
 
__UWORD_TYPE


	)

49 
	#__FSWORD_T_TYPE
 
__SWORD_TYPE


	)

51 
	#__OFF_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

52 
	#__OFF64_T_TYPE
 
__SQUAD_TYPE


	)

53 
	#__PID_T_TYPE
 
__S32_TYPE


	)

54 
	#__RLIM_T_TYPE
 
__SYSCALL_ULONG_TYPE


	)

55 
	#__RLIM64_T_TYPE
 
__UQUAD_TYPE


	)

56 
	#__BLKCNT_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

57 
	#__BLKCNT64_T_TYPE
 
__SQUAD_TYPE


	)

58 
	#__FSBLKCNT_T_TYPE
 
__SYSCALL_ULONG_TYPE


	)

59 
	#__FSBLKCNT64_T_TYPE
 
__UQUAD_TYPE


	)

60 
	#__FSFILCNT_T_TYPE
 
__SYSCALL_ULONG_TYPE


	)

61 
	#__FSFILCNT64_T_TYPE
 
__UQUAD_TYPE


	)

62 
	#__ID_T_TYPE
 
__U32_TYPE


	)

63 
	#__CLOCK_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

64 
	#__TIME_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

65 
	#__USECONDS_T_TYPE
 
__U32_TYPE


	)

66 
	#__SUSECONDS_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

67 
	#__DADDR_T_TYPE
 
__S32_TYPE


	)

68 
	#__KEY_T_TYPE
 
__S32_TYPE


	)

69 
	#__CLOCKID_T_TYPE
 
__S32_TYPE


	)

70 
	#__TIMER_T_TYPE
 *

	)

71 
	#__BLKSIZE_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

72 
	#__FSID_T_TYPE
 su { 
__v
[2]; }

	)

73 
	#__SSIZE_T_TYPE
 
__SWORD_TYPE


	)

75 #ifde
__x86_64__


79 
	#__OFF_T_MATCHES_OFF64_T
 1

	)

82 
	#__INO_T_MATCHES_INO64_T
 1

	)

86 
	#__FD_SETSIZE
 1024

	)

	@/usr/include/gnu/stubs.h

6 #i!
defed
 
__x86_64__


7 
	~<gnu/ubs-32.h
>

9 #i
defed
 
__x86_64__
 && defed 
__LP64__


10 
	~<gnu/ubs-64.h
>

12 #i
defed
 
__x86_64__
 && defed 
__ILP32__


13 
	~<gnu/ubs-x32.h
>

	@/usr/include/linux/errno.h

1 
	~<asm/o.h
>

	@/usr/include/linux/kernel.h

1 #ide
_LINUX_KERNEL_H


2 
	#_LINUX_KERNEL_H


	)

4 
	~<lux/sysfo.h
>

9 
	#__ALIGN_KERNEL
(
x
, 
a

	`__ALIGN_KERNEL_MASK
(x, (
	`tyof
(x))- 1)

	)

10 
	#__ALIGN_KERNEL_MASK
(
x
, 
mask
(((x+ (mask)& ~(mask))

	)

	@/usr/include/linux/limits.h

1 #ide
_LINUX_LIMITS_H


2 
	#_LINUX_LIMITS_H


	)

4 
	#NR_OPEN
 1024

	)

6 
	#NGROUPS_MAX
 65536

	)

7 
	#ARG_MAX
 131072

	)

8 
	#LINK_MAX
 127

	)

9 
	#MAX_CANON
 255

	)

10 
	#MAX_INPUT
 255

	)

11 
	#NAME_MAX
 255

	)

12 
	#PATH_MAX
 4096

	)

13 
	#PIPE_BUF
 4096

	)

14 
	#XATTR_NAME_MAX
 255

	)

15 
	#XATTR_SIZE_MAX
 65536

	)

16 
	#XATTR_LIST_MAX
 65536

	)

18 
	#RTSIG_MAX
 32

	)

	@/usr/include/linux/param.h

1 #ide
_LINUX_PARAM_H


2 
	#_LINUX_PARAM_H


	)

4 
	~<asm/m.h
>

	@/usr/include/linux/types.h

1 #ide
_LINUX_TYPES_H


2 
	#_LINUX_TYPES_H


	)

4 
	~<asm/tys.h
>

6 #ide
__ASSEMBLY__


8 
	~<lux/posix_tys.h
>

16 #ifde
__CHECKER__


17 
	#__bwi__
 
	`__ibu__
((
bwi
))

	)

19 
	#__bwi__


	)

21 #ifde
__CHECK_ENDIAN__


22 
	#__bwi
 
__bwi__


	)

24 
	#__bwi


	)

27 
__u16
 
	t__bwi
 
	t__16
;

28 
__u16
 
	t__bwi
 
	t__be16
;

29 
__u32
 
	t__bwi
 
	t__32
;

30 
__u32
 
	t__bwi
 
	t__be32
;

31 
__u64
 
	t__bwi
 
	t__64
;

32 
__u64
 
	t__bwi
 
	t__be64
;

34 
__u16
 
	t__bwi
 
	t__sum16
;

35 
__u32
 
	t__bwi
 
	t__wsum
;

46 
	#__igd_u64
 
__u64
 
	`__ibu__
((
	`igd
(8)))

	)

47 
	#__igd_be64
 
__be64
 
	`__ibu__
((
	`igd
(8)))

	)

48 
	#__igd_64
 
__64
 
	`__ibu__
((
	`igd
(8)))

	)

	@/usr/include/stdc-predef.h

18 #idef 
_STDC_PREDEF_H


19 
	#_STDC_PREDEF_H
 1

	)

36 #ifde
__GCC_IEC_559


37 #i
__GCC_IEC_559
 > 0

38 
	#__STDC_IEC_559__
 1

	)

41 
	#__STDC_IEC_559__
 1

	)

44 #ifde
__GCC_IEC_559_COMPLEX


45 #i
__GCC_IEC_559_COMPLEX
 > 0

46 
	#__STDC_IEC_559_COMPLEX__
 1

	)

49 
	#__STDC_IEC_559_COMPLEX__
 1

	)

54 
	#__STDC_ISO_10646__
 201103L

	)

57 
	#__STDC_NO_THREADS__
 1

	)

	@/usr/include/sys/cdefs.h

18 #idef 
_SYS_CDEFS_H


19 
	#_SYS_CDEFS_H
 1

	)

22 #ide
_FEATURES_H


23 
	~<us.h
>

29 #i
defed
 
__GNUC__
 && !defed 
__STDC__


34 #unde
__P


35 #unde
__PMT


37 #ifde
__GNUC__


41 #i
__GNUC_PREREQ
 (4, 6&& !
defed
 
_LIBC


42 
	#__LEAF
 , 
__af__


	)

43 
	#__LEAF_ATTR
 
	`__ibu__
 ((
__af__
))

	)

45 
	#__LEAF


	)

46 
	#__LEAF_ATTR


	)

54 #i!
defed
 
__lulus
 && 
__GNUC_PREREQ
 (3, 3)

55 
	#__THROW
 
	`__ibu__
 ((
__nhrow__
 
__LEAF
))

	)

56 
	#__THROWNL
 
	`__ibu__
 ((
__nhrow__
))

	)

57 
	#__NTH
(
f

	`__ibu__
 ((
__nhrow__
 
__LEAF
)
	)
fct

59 #i
defed
 
__lulus
 && 
__GNUC_PREREQ
 (2,8)

60 
	#__THROW
 
	`throw
 ()

	)

61 
	#__THROWNL
 
	`throw
 ()

	)

62 
	#__NTH
(
f

__LEAF_ATTR
 f 
	`throw
 ()

	)

64 
	#__THROW


	)

65 
	#__THROWNL


	)

66 
	#__NTH
(
f

	)
fct

72 
	#__le


	)

74 
	#__THROW


	)

75 
	#__THROWNL


	)

76 
	#__NTH
(
f

	)
fct

82 
	#__P
(
gs

	)
args

83 
	#__PMT
(
gs

	)
args

88 
	#__CONCAT
(
x
,
y
x ## 
	)
y

89 
	#__STRING
(
x
#x

	)

92 
	#__r_t
 *

	)

93 
	#__lg_doub_t
 

	)

97 #ifdef 
__lulus


98 
	#__BEGIN_DECLS
 "C" {

	)

99 
	#__END_DECLS
 }

	)

101 
	#__BEGIN_DECLS


	)

102 
	#__END_DECLS


	)

111 #i
defed
 
__lulus
 && defed 
_GLIBCPP_USE_NAMESPACES


112 
	#__BEGIN_NAMESPACE_STD
 
mea
 
d
 {

	)

113 
	#__END_NAMESPACE_STD
 }

	)

114 
	#__USING_NAMESPACE_STD
(
me

usg
 
d
::me;

	)

115 
	#__BEGIN_NAMESPACE_C99
 
mea
 
__c99
 {

	)

116 
	#__END_NAMESPACE_C99
 }

	)

117 
	#__USING_NAMESPACE_C99
(
me

usg
 
__c99
::me;

	)

122 
	#__BEGIN_NAMESPACE_STD


	)

123 
	#__END_NAMESPACE_STD


	)

124 
	#__USING_NAMESPACE_STD
(
me
)

	)

125 
	#__BEGIN_NAMESPACE_C99


	)

126 
	#__END_NAMESPACE_C99


	)

127 
	#__USING_NAMESPACE_C99
(
me
)

	)

132 
	#__bos
(
r

	`__but_obje_size
 (r, 
__USE_FORTIFY_LEVEL
 > 1)

	)

133 
	#__bos0
(
r

	`__but_obje_size
 (r, 0)

	)

134 
	#__ftify_funi
 
__ex_ways_le
 
__ibu_tificl__


	)

136 #i
__GNUC_PREREQ
 (4,3)

137 
	#__wnde
(
me
, 
msg
) \

138 
	`me
 (
	`__ibu__
((
	`__wng__
 (
msg
)))

	)

139 
	#__wǉr
(
msg

	`__ibu__
((
	`__wng__
 (msg)))

	)

140 
	#__rde
(
me
, 
msg
) \

141 
	`me
 (
	`__ibu__
((
	`__r__
 (
msg
)))

	)

143 
	#__wnde
(
me
, 
msg

	`me
 ()

	)

144 
	#__wǉr
(
msg
)

	)

145 
	#__rde
(
me
, 
msg

	`me
 ()

	)

149 #i
__GNUC_PREREQ
 (2,97)

151 
	#__exr
 []

	)

153 #ifde
__GNUC__


154 
	#__exr
 [0]

	)

156 #i
defed
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L

157 
	#__exr
 []

	)

160 
	#__exr
 [1]

	)

176 #i
defed
 
__GNUC__
 && __GNUC__ >= 2

178 
	#__REDIRECT
(
me
, 
o
, 
s
m
	`__asm__
 (
	`__ASMNAME
 (#s))

	)

179 #ifde
__lulus


180 
	#__REDIRECT_NTH
(
me
, 
o
, 
s
) \

181 
me
 
o
 
__THROW
 
	`__asm__
 (
	`__ASMNAME
 (#s))

	)

182 
	#__REDIRECT_NTHNL
(
me
, 
o
, 
s
) \

183 
me
 
o
 
__THROWNL
 
	`__asm__
 (
	`__ASMNAME
 (#s))

	)

185 
	#__REDIRECT_NTH
(
me
, 
o
, 
s
) \

186 
me
 
o
 
	`__asm__
 (
	`__ASMNAME
 (#s)
__THROW


	)

187 
	#__REDIRECT_NTHNL
(
me
, 
o
, 
s
) \

188 
me
 
o
 
	`__asm__
 (
	`__ASMNAME
 (#s)
__THROWNL


	)

190 
	#__ASMNAME
(
ame

	`__ASMNAME2
 (
__USER_LABEL_PREFIX__
, cme)

	)

191 
	#__ASMNAME2
(
efix
, 
ame

	`__STRING
 (efix
	)
cname

204 #i!
defed
 
__GNUC__
 || __GNUC__ < 2

205 
	#__ibu__
(
xyz


	)

211 #i
__GNUC_PREREQ
 (2,96)

212 
	#__ibu_mloc__
 
	`__ibu__
 ((
__mloc__
))

	)

214 
	#__ibu_mloc__


	)

219 #i
__GNUC_PREREQ
 (4, 3)

220 
	#__ibu_loc_size__
(
ms
) \

221 
	`__ibu__
 ((
__loc_size__
 
ms
))

	)

223 
	#__ibu_loc_size__
(
ms


	)

229 #i
__GNUC_PREREQ
 (2,96)

230 
	#__ibu_pu__
 
	`__ibu__
 ((
__pu__
))

	)

232 
	#__ibu_pu__


	)

236 #i
__GNUC_PREREQ
 (2,5)

237 
	#__ibu_cڡ__
 
	`__ibu__
 ((
__cڡ__
))

	)

239 
	#__ibu_cڡ__


	)

245 #i
__GNUC_PREREQ
 (3,1)

246 
	#__ibu_ud__
 
	`__ibu__
 ((
__ud__
))

	)

247 
	#__ibu_nole__
 
	`__ibu__
 ((
__nole__
))

	)

249 
	#__ibu_ud__
 
	`__ibu__
 ((
__unud__
))

	)

250 
	#__ibu_nole__


	)

254 #i
__GNUC_PREREQ
 (3,2)

255 
	#__ibu_dd__
 
	`__ibu__
 ((
__dd__
))

	)

257 
	#__ibu_dd__


	)

266 #i
__GNUC_PREREQ
 (2,8)

267 
	#__ibu_fm_g__
(
x

	`__ibu__
 ((
	`__fm_g__
 (x)))

	)

269 
	#__ibu_fm_g__
(
x


	)

276 #i
__GNUC_PREREQ
 (2,97)

277 
	#__ibu_fm_rfm__
(
a
,
b
) \

278 
	`__ibu__
 ((
	`__fm__
 (
__rfm__
, 
a
, 
b
)))

	)

280 
	#__ibu_fm_rfm__
(
a
,
b


	)

285 #i
__GNUC_PREREQ
 (3,3)

286 
	#__nnu
(
ms

	`__ibu__
 ((
__nnu__
ams))

	)

288 
	#__nnu
(
ms
)

	)

293 #i
__GNUC_PREREQ
 (3,4)

294 
	#__ibu_wn_unud_su__
 \

295 
	`__ibu__
 ((
__wn_unud_su__
))

	)

296 #i
__USE_FORTIFY_LEVEL
 > 0

297 
	#__wur
 
__ibu_wn_unud_su__


	)

300 
	#__ibu_wn_unud_su__


	)

302 #ide
__wur


303 
	#__wur


	)

307 #i
__GNUC_PREREQ
 (3,2)

308 
	#__ways_le
 
__le
 
	`__ibu__
 ((
__ways_le__
))

	)

310 
	#__ways_le
 
__le


	)

315 #i
__GNUC_PREREQ
 (4,3)

316 
	#__ibu_tificl__
 
	`__ibu__
 ((
__tificl__
))

	)

318 
	#__ibu_tificl__


	)

321 #ifde
__GNUC__


326 #i
defed
 
__GNUC_STDC_INLINE__
 || defed 
__GNUC_GNU_INLINE__


327 
	#__ex_le
 
__le
 
	`__ibu__
 ((
__gnu_le__
))

	)

328 
	#__ex_ways_le
 \

329 
__ways_le
 
	`__ibu__
 ((
__gnu_le__
))

	)

331 
	#__ex_le
 
__le


	)

332 
	#__ex_ways_le
 
__ways_le


	)

335 
	#__ex_le


	)

336 
	#__ex_ways_le


	)

341 #i
__GNUC_PREREQ
 (4,3)

342 
	#__va_g_ck
(
	`__but_va_g_ck
 ()

	)

343 
	#__va_g_ck_n
(
	`__but_va_g_ck_n
 ()

	)

350 #i!
__GNUC_PREREQ
 (2,8)

351 
	#__exnsi__


	)

355 #i!
__GNUC_PREREQ
 (2,92)

356 
	#__ri


	)

362 #i
__GNUC_PREREQ
 (3,1&& !
defed
 
__GNUG__


363 
	#__ri_r
 
__ri


	)

365 #ifde
__GNUC__


366 
	#__ri_r


	)

368 #i
defed
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L

369 
	#__ri_r
 
ri


	)

372 
	#__ri_r


	)

377 #i
__GNUC__
 >= 3

378 
	#__glibc_uiky
(
cd

	`__but_ex
 ((cd), 0)

	)

379 
	#__glibc_liky
(
cd

	`__but_ex
 ((cd), 1)

	)

381 
	#__glibc_uiky
(
cd
(cd)

	)

382 
	#__glibc_liky
(
cd
(cd)

	)

385 
	~<bs/wdsize.h
>

387 #i
defed
 
__LONG_DOUBLE_MATH_OPTIONAL
 && defed 
__NO_LONG_DOUBLE_MATH


388 
	#__LDBL_COMPAT
 1

	)

389 #ifde
__REDIRECT


390 
	#__LDBL_REDIR1
(
me
, 
o
, 
s

	`__REDIRECT
 (me,ro,ls)

	)

391 
	#__LDBL_REDIR
(
me
, 
o
) \

392 
	`__LDBL_REDIR1
 (
me
, 
o
, 
__dbl_
##me)

	)

393 
	#__LDBL_REDIR1_NTH
(
me
, 
o
, 
s

	`__REDIRECT_NTH
 (me,ro,ls)

	)

394 
	#__LDBL_REDIR_NTH
(
me
, 
o
) \

395 
	`__LDBL_REDIR1_NTH
 (
me
, 
o
, 
__dbl_
##me)

	)

396 
	#__LDBL_REDIR1_DECL
(
me
, 
s
) \

397 
	`__tyof
 (
me
m
	`__asm
 (
	`__ASMNAME
 (#s));

	)

398 
	#__LDBL_REDIR_DECL
(
me
) \

399 
	`__tyof
 (
me
m
	`__asm
 (
	`__ASMNAME
 ("__dbl_" #me));

	)

400 
	#__REDIRECT_LDBL
(
me
, 
o
, 
s
) \

401 
	`__LDBL_REDIR1
 (
me
, 
o
, 
__dbl_
##
s
)

	)

402 
	#__REDIRECT_NTH_LDBL
(
me
, 
o
, 
s
) \

403 
	`__LDBL_REDIR1_NTH
 (
me
, 
o
, 
__dbl_
##
s
)

	)

406 #i!
defed
 
__LDBL_COMPAT
 || !defed 
__REDIRECT


407 
	#__LDBL_REDIR1
(
me
, 
o
, 
s
m
	)
proto

408 
	#__LDBL_REDIR
(
me
, 
o
m
	)
proto

409 
	#__LDBL_REDIR1_NTH
(
me
, 
o
, 
s
m
__THROW


	)

410 
	#__LDBL_REDIR_NTH
(
me
, 
o
m
__THROW


	)

411 
	#__LDBL_REDIR_DECL
(
me
)

	)

412 #ifde
__REDIRECT


413 
	#__REDIRECT_LDBL
(
me
, 
o
, 
s

	`__REDIRECT
 (me,ro,ls)

	)

414 
	#__REDIRECT_NTH_LDBL
(
me
, 
o
, 
s
) \

415 
	`__REDIRECT_NTH
 (
me
, 
o
, 
s
)

	)

	@/usr/include/sys/socket.h

19 #idef 
_SYS_SOCKET_H


20 
	#_SYS_SOCKET_H
 1

	)

22 
	~<us.h
>

24 
	g__BEGIN_DECLS


26 
	~<sys/uio.h
>

27 
	#__ed_size_t


	)

28 
	~<ddef.h
>

29 #ifde
__USE_GNU


31 
	~<bs/sigt.h
>

38 
	~<bs/sock.h
>

40 #ifde
__USE_BSD


43 
	sosockaddr


45 
	m_my
;

46 
	m_da
[14];

54 
	mSHUT_RD
 = 0,

55 
	#SHUT_RD
 
SHUT_RD


	)

56 
	mSHUT_WR
,

57 
	#SHUT_WR
 
SHUT_WR


	)

58 
	mSHUT_RDWR


59 
	#SHUT_RDWR
 
SHUT_RDWR


	)

68 #i
defed
 
__lulus
 || !
__GNUC_PREREQ
 (2, 7|| !defed 
__USE_GNU


69 
	#__SOCKADDR_ARG
 
sockaddr
 *
__ri


	)

70 
	#__CONST_SOCKADDR_ARG
 cڡ 
sockaddr
 *

	)

74 
	#__SOCKADDR_ALLTYPES
 \

75 
	`__SOCKADDR_ONETYPE
 (
sockaddr
) \

76 
	`__SOCKADDR_ONETYPE
 (
sockaddr_
) \

77 
	`__SOCKADDR_ONETYPE
 (
sockaddr_ax25
) \

78 
	`__SOCKADDR_ONETYPE
 (
sockaddr_dl
) \

79 
	`__SOCKADDR_ONETYPE
 (
sockaddr_e
) \

80 
	`__SOCKADDR_ONETYPE
 (
sockaddr_
) \

81 
	`__SOCKADDR_ONETYPE
 (
sockaddr_6
) \

82 
	`__SOCKADDR_ONETYPE
 (
sockaddr_p
) \

83 
	`__SOCKADDR_ONETYPE
 (
sockaddr_x
) \

84 
	`__SOCKADDR_ONETYPE
 (
sockaddr_iso
) \

85 
	`__SOCKADDR_ONETYPE
 (
sockaddr_ns
) \

86 
	`__SOCKADDR_ONETYPE
 (
sockaddr_un
) \

87 
	`__SOCKADDR_ONETYPE
 (
sockaddr_x25
)

	)

89 
	#__SOCKADDR_ONETYPE
(
ty
ty *
__ri
 
__
##ty##__;

	)

90 uni { 
	m__SOCKADDR_ALLTYPES


91 } 
	t__SOCKADDR_ARG
 
	t__ibu__
 ((
	t__t_uni__
));

92 #unde
__SOCKADDR_ONETYPE


93 
	#__SOCKADDR_ONETYPE
(
ty
cڡ ty *
__ri
 
__
##ty##__;

	)

94 uni { 
	m__SOCKADDR_ALLTYPES


95 } 
	t__CONST_SOCKADDR_ARG
 
	t__ibu__
 ((
	t__t_uni__
));

96 #unde
__SOCKADDR_ONETYPE


99 #ifde
__USE_GNU


101 
	smmsghdr


103 
msghdr
 
	mmsg_hdr
;

104 
	mmsg_n
;

113 
	$sock
 (
__doma
, 
__ty
, 
__oc

__THROW
;

119 
	$sock
 (
__doma
, 
__ty
, 
__oc
,

120 
__fds
[2]
__THROW
;

123 
	$bd
 (
__fd
, 
__CONST_SOCKADDR_ARG
 
__addr
, 
sockn_t
 
__n
)

124 
__THROW
;

127 
	$gsockme
 (
__fd
, 
__SOCKADDR_ARG
 
__addr
,

128 
sockn_t
 *
__ri
 
__n

__THROW
;

137 
	`c
 (
__fd
, 
__CONST_SOCKADDR_ARG
 
__addr
, 
sockn_t
 
__n
);

141 
	$gme
 (
__fd
, 
__SOCKADDR_ARG
 
__addr
,

142 
sockn_t
 *
__ri
 
__n

__THROW
;

149 
ssize_t
 
	`nd
 (
__fd
, cڡ *
__buf
, 
size_t
 
__n
, 
__ags
);

156 
ssize_t
 
	`cv
 (
__fd
, *
__buf
, 
size_t
 
__n
, 
__ags
);

163 
ssize_t
 
	`ndto
 (
__fd
, cڡ *
__buf
, 
size_t
 
__n
,

164 
__ags
, 
__CONST_SOCKADDR_ARG
 
__addr
,

165 
sockn_t
 
__addr_n
);

174 
ssize_t
 
	`cvom
 (
__fd
, *
__ri
 
__buf
, 
size_t
 
__n
,

175 
__ags
, 
__SOCKADDR_ARG
 
__addr
,

176 
sockn_t
 *
__ri
 
__addr_n
);

184 
ssize_t
 
	`ndmsg
 (
__fd
, cڡ 
msghdr
 *
__mesge
,

185 
__ags
);

187 #ifde
__USE_GNU


193 
	`ndmmsg
 (
__fd
, 
mmsghdr
 *
__vmesges
,

194 
__vn
, 
__ags
);

202 
ssize_t
 
	`cvmsg
 (
__fd
, 
msghdr
 *
__mesge
, 
__ags
);

204 #ifde
__USE_GNU


210 
	`cvmmsg
 (
__fd
, 
mmsghdr
 *
__vmesges
,

211 
__vn
, 
__ags
,

212 cڡ 
timeec
 *
__tmo
);

219 
	$gsockt
 (
__fd
, 
__v
, 
__݊ame
,

220 *
__ri
 
__tv
,

221 
sockn_t
 *
__ri
 
__ݎ

__THROW
;

226 
	$tsockt
 (
__fd
, 
__v
, 
__݊ame
,

227 cڡ *
__tv
, 
sockn_t
 
__ݎ

__THROW
;

233 
	$li
 (
__fd
, 
__n

__THROW
;

243 
	`ac
 (
__fd
, 
__SOCKADDR_ARG
 
__addr
,

244 
sockn_t
 *
__ri
 
__addr_n
);

246 #ifde
__USE_GNU


251 
	`ac4
 (
__fd
, 
__SOCKADDR_ARG
 
__addr
,

252 
sockn_t
 *
__ri
 
__addr_n
, 
__ags
);

261 
	$shutdown
 (
__fd
, 
__how

__THROW
;

264 #ifde
__USE_XOPEN2K


266 
	$sockmk
 (
__fd

__THROW
;

270 #ifde
__USE_MISC


274 
	$isfdty
 (
__fd
, 
__fdty

__THROW
;

279 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


280 
	~<bs/sock2.h
>

283 
__END_DECLS


	@/usr/include/bits/byteswap-16.h

19 #ide
_BITS_BYTESWAP_H


23 #ifde
__GNUC__


24 #i
__GNUC__
 >= 2

25 
	#__bsw_16
(
x
) \

26 (
__exnsi__
 \

27 ({ 
__v
, 
__x
 = ((
x
); \

28 i(
	`__but_cڡt_p
 (
__x
)) \

29 
__v
 = 
	`__bsw_cڡt_16
 (
__x
); \

31 
	`__asm__
 ("rorw $8, %w0" \

32 : "" (
__v
) \

33 : "0" (
__x
) \

35 
__v
; }))

	)

38 
	#__bsw_16
(
x
) \

39 (
__exnsi__
 \

40 ({ 
__x
 = ((
x
); \

41 
	`__bsw_cڡt_16
 (
__x
); }))

	)

44 
__le
 

45 
	$__bsw_16
 (
__bsx
)

47  
	`__bsw_cڡt_16
 (
__bsx
);

48 
	}
}

	@/usr/include/bits/libc-lock.h

19 #ide
_BITS_LIBC_LOCK_H


20 
	#_BITS_LIBC_LOCK_H
 1

	)

22 
	~<had.h
>

23 
	#__ed_NULL


	)

24 
	~<ddef.h
>

27 #ifde
_LIBC


28 
	~<lowvlock.h
>

29 
	~<s.h
>

30 
	~<had-funis.h
>

31 
	~<o.h
>

32 
	~<gnu/ti-groups.h
>

36 #i
defed
 
_LIBC
 || defed 
_IO_MTSAFE_IO


37 #i(
defed
 
NOT_IN_libc
 && !defed 
IS_IN_libhad
|| !defed 
_LIBC


38 ru { 
had_mux_t
 
	mmux
; } 
	t__libc_lock_cursive_t
;

40 ru { 
	mlock
; 
	mt
; *
	mowr
; } 
	t__libc_lock_cursive_t
;

43 
__libc_lock_cursive_aque__
 
	t__libc_lock_cursive_t
;

53 
	#__libc_lock_defe_cursive
(
CLASS
,
NAME
) \

54 
CLASS
 
__libc_lock_cursive_t
 
NAME
;

	)

58 #i
defed
 
_LIBC
 && (!defed 
NOT_IN_libc
 || defed 
IS_IN_libhad
)

59 #i
LLL_LOCK_INITIALIZER
 == 0

60 
	#__libc_lock_defe_lized_cursive
(
CLASS
,
NAME
) \

61 
CLASS
 
__libc_lock_cursive_t
 
NAME
;

	)

63 
	#__libc_lock_defe_lized_cursive
(
CLASS
,
NAME
) \

64 
CLASS
 
__libc_lock_cursive_t
 
NAME
 = 
_LIBC_LOCK_RECURSIVE_INITIALIZER
;

	)

66 
	#_LIBC_LOCK_RECURSIVE_INITIALIZER
 \

67 { 
LLL_LOCK_INITIALIZER
, 0, 
NULL
 }

	)

69 
	#__libc_lock_defe_lized_cursive
(
CLASS
,
NAME
) \

70 
CLASS
 
__libc_lock_cursive_t
 
NAME
 = 
_LIBC_LOCK_RECURSIVE_INITIALIZER
;

	)

71 
	#_LIBC_LOCK_RECURSIVE_INITIALIZER
 \

72 {
PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
}

	)

76 #i
defed
 
_LIBC
 && (!defed 
NOT_IN_libc
 || defed 
IS_IN_libhad
)

77 
	#__libc_lock__cursive
(
NAME
) \

78 ((
NAME
(
__libc_lock_cursive_t

_LIBC_LOCK_RECURSIVE_INITIALIZER
, 0)

	)

80 
	#__libc_lock__cursive
(
NAME
) \

82 i(
__had_mux_
 !
NULL
) \

84 
had_mux_t
 
__
; \

85 
	`__had_mux_
 (&
__
); \

86 
	`__had_mux_y
 (&
__
, 
PTHREAD_MUTEX_RECURSIVE_NP
); \

87 
	`__had_mux_
 (&(
NAME
).
mux
, &
__
); \

88 
	`__had_mux_deroy
 (&
__
); \

90 } 0)

	)

94 #i
defed
 
_LIBC
 && (!defed 
NOT_IN_libc
 || defed 
IS_IN_libhad
)

95 
	#__libc_lock_fi_cursive
(
NAME
((0)

	)

97 
	#__libc_lock_fi_cursive
(
NAME
) \

98 
	`__libc_maybe_
 (
__had_mux_deroy
, (&(
NAME
).
mux
), 0)

	)

102 #i
defed
 
_LIBC
 && (!defed 
NOT_IN_libc
 || defed 
IS_IN_libhad
)

103 #i
__OPTION_EGLIBC_BIG_MACROS
 != 1

107 
__libc_lock_lock_cursive_
 (
__libc_lock_cursive_t
 *);

108 
libc_hidd_o
 (
__libc_lock_lock_cursive_
);

110 #i
__OPTION_EGLIBC_BIG_MACROS


111 
	#__libc_lock_lock_cursive
(
NAME
) \

113 *
lf
 = 
THREAD_SELF
; \

114 i((
NAME
).
owr
 !
lf
) \

116 
	`l_lock
 ((
NAME
).
lock
, 
LLL_PRIVATE
); \

117 (
NAME
).
owr
 = 
lf
; \

119 ++(
NAME
).
t
; \

120 } 0)

	)

122 
	#__libc_lock_lock_cursive
(
NAME
) \

123 
	`__libc_lock_lock_cursive_
 (&(
NAME
))

	)

126 
	#__libc_lock_lock_cursive
(
NAME
) \

127 
	`__libc_maybe_
 (
__had_mux_lock
, (&(
NAME
).
mux
), 0)

	)

131 #i
defed
 
_LIBC
 && (!defed 
NOT_IN_libc
 || defed 
IS_IN_libhad
)

132 #i
__OPTION_EGLIBC_BIG_MACROS
 != 1

136 
__libc_lock_ylock_cursive_
 (
__libc_lock_cursive_t
 *);

137 
libc_hidd_o
 (
__libc_lock_ylock_cursive_
);

139 #i
__OPTION_EGLIBC_BIG_MACROS


140 
	#__libc_lock_ylock_cursive
(
NAME
) \

142 
su
 = 0; \

143 *
lf
 = 
THREAD_SELF
; \

144 i((
NAME
).
owr
 !
lf
) \

146 i(
	`l_ylock
 ((
NAME
).
lock
) == 0) \

148 (
NAME
).
owr
 = 
lf
; \

149 (
NAME
).
t
 = 1; \

152 
su
 = 
EBUSY
; \

155 ++(
NAME
).
t
; \

156 
su
; \

157 })

	)

159 
	#__libc_lock_ylock_cursive
(
NAME
) \

160 
	`__libc_lock_ylock_cursive_
 (&(
NAME
))

	)

163 
	#__libc_lock_ylock_cursive
(
NAME
) \

164 
	`__libc_maybe_
 (
__had_mux_ylock
, (&(
NAME
).
mux
), 0)

	)

168 #i
defed
 
_LIBC
 && (!defed 
NOT_IN_libc
 || defed 
IS_IN_libhad
)

169 #i
__OPTION_EGLIBC_BIG_MACROS
 != 1

173 
__libc_lock_uock_cursive_
 (
__libc_lock_cursive_t
 *);

174 
libc_hidd_o
 (
__libc_lock_uock_cursive_
);

176 #i
__OPTION_EGLIBC_BIG_MACROS


178 
	#__libc_lock_uock_cursive
(
NAME
) \

180 i(--(
NAME
).
t
 == 0) \

182 (
NAME
).
owr
 = 
NULL
; \

183 
	`l_uock
 ((
NAME
).
lock
, 
LLL_PRIVATE
); \

185 } 0)

	)

187 
	#__libc_lock_uock_cursive
(
NAME
) \

188 
	`__libc_lock_uock_cursive_
 (&(
NAME
))

	)

191 
	#__libc_lock_uock_cursive
(
NAME
) \

192 
	`__libc_maybe_
 (
__had_mux_uock
, (&(
NAME
).
mux
), 0)

	)

199 
_had_nup_push_der
 (
_had_nup_bufr
 *
bufr
,

200 (*
route
(*), *
g
);

201 
	`_had_nup_p_e
 (
_had_nup_bufr
 *
bufr
,

202 
execu
);

205 
	#__libc_nup_gi_t
(
DOIT
, 
FCT
, 
ARG
) \

206 { 
_had_nup_bufr
 
_bufr
; \

207 
_ava
; \

208 i(
DOIT
) { \

209 
_ava
 = 
	`PTFAVAIL
 (
_had_nup_push_der
); \

210 i(
_ava
) { \

211 
	`__libc_f__ways
 (
_had_nup_push_der
, (&
_bufr
, 
FCT
, \

212 
ARG
)); \

214 
_bufr
.
__route
 = (
FCT
); \

215 
_bufr
.
__g
 = (
ARG
); \

218 
_ava
 = 0; \

219 }

	)

222 
	#__libc_nup_gi_d
(
DOIT
) \

223 i(
_ava
) { \

224 
	`__libc_f__ways
 (
_had_nup_p_e
, (&
_bufr
, 
DOIT
));\

225 } i(
DOIT
) \

226 
_bufr
.
	`__route
 (_bufr.
__g
); \

227 
	}

	)
}

232 #ifde
_LIBC


233 
	~"libc-lockP.h
"

	@/usr/include/bits/socket.h

19 #ide
__BITS_SOCKET_H


20 
	#__BITS_SOCKET_H


	)

22 #ide
_SYS_SOCKET_H


26 
	#__ed_size_t


	)

27 
	~<ddef.h
>

29 
	~<sys/tys.h
>

32 #ide
__sockn_t_defed


33 
__sockn_t
 
	tsockn_t
;

34 
	#__sockn_t_defed


	)

38 
	~<bs/sock_ty.h
>

41 
	#PF_UNSPEC
 0

	)

42 
	#PF_LOCAL
 1

	)

43 
	#PF_UNIX
 
PF_LOCAL


	)

44 
	#PF_FILE
 
PF_LOCAL


	)

45 
	#PF_INET
 2

	)

46 
	#PF_AX25
 3

	)

47 
	#PF_IPX
 4

	)

48 
	#PF_APPLETALK
 5

	)

49 
	#PF_NETROM
 6

	)

50 
	#PF_BRIDGE
 7

	)

51 
	#PF_ATMPVC
 8

	)

52 
	#PF_X25
 9

	)

53 
	#PF_INET6
 10

	)

54 
	#PF_ROSE
 11

	)

55 
	#PF_DECt
 12

	)

56 
	#PF_NETBEUI
 13

	)

57 
	#PF_SECURITY
 14

	)

58 
	#PF_KEY
 15

	)

59 
	#PF_NETLINK
 16

	)

60 
	#PF_ROUTE
 
PF_NETLINK


	)

61 
	#PF_PACKET
 17

	)

62 
	#PF_ASH
 18

	)

63 
	#PF_ECONET
 19

	)

64 
	#PF_ATMSVC
 20

	)

65 
	#PF_RDS
 21

	)

66 
	#PF_SNA
 22

	)

67 
	#PF_IRDA
 23

	)

68 
	#PF_PPPOX
 24

	)

69 
	#PF_WANPIPE
 25

	)

70 
	#PF_LLC
 26

	)

71 
	#PF_CAN
 29

	)

72 
	#PF_TIPC
 30

	)

73 
	#PF_BLUETOOTH
 31

	)

74 
	#PF_IUCV
 32

	)

75 
	#PF_RXRPC
 33

	)

76 
	#PF_ISDN
 34

	)

77 
	#PF_PHONET
 35

	)

78 
	#PF_IEEE802154
 36

	)

79 
	#PF_CAIF
 37

	)

80 
	#PF_ALG
 38

	)

81 
	#PF_NFC
 39

	)

82 
	#PF_VSOCK
 40

	)

83 
	#PF_MAX
 41

	)

86 
	#AF_UNSPEC
 
PF_UNSPEC


	)

87 
	#AF_LOCAL
 
PF_LOCAL


	)

88 
	#AF_UNIX
 
PF_UNIX


	)

89 
	#AF_FILE
 
PF_FILE


	)

90 
	#AF_INET
 
PF_INET


	)

91 
	#AF_AX25
 
PF_AX25


	)

92 
	#AF_IPX
 
PF_IPX


	)

93 
	#AF_APPLETALK
 
PF_APPLETALK


	)

94 
	#AF_NETROM
 
PF_NETROM


	)

95 
	#AF_BRIDGE
 
PF_BRIDGE


	)

96 
	#AF_ATMPVC
 
PF_ATMPVC


	)

97 
	#AF_X25
 
PF_X25


	)

98 
	#AF_INET6
 
PF_INET6


	)

99 
	#AF_ROSE
 
PF_ROSE


	)

100 
	#AF_DECt
 
PF_DECt


	)

101 
	#AF_NETBEUI
 
PF_NETBEUI


	)

102 
	#AF_SECURITY
 
PF_SECURITY


	)

103 
	#AF_KEY
 
PF_KEY


	)

104 
	#AF_NETLINK
 
PF_NETLINK


	)

105 
	#AF_ROUTE
 
PF_ROUTE


	)

106 
	#AF_PACKET
 
PF_PACKET


	)

107 
	#AF_ASH
 
PF_ASH


	)

108 
	#AF_ECONET
 
PF_ECONET


	)

109 
	#AF_ATMSVC
 
PF_ATMSVC


	)

110 
	#AF_RDS
 
PF_RDS


	)

111 
	#AF_SNA
 
PF_SNA


	)

112 
	#AF_IRDA
 
PF_IRDA


	)

113 
	#AF_PPPOX
 
PF_PPPOX


	)

114 
	#AF_WANPIPE
 
PF_WANPIPE


	)

115 
	#AF_LLC
 
PF_LLC


	)

116 
	#AF_CAN
 
PF_CAN


	)

117 
	#AF_TIPC
 
PF_TIPC


	)

118 
	#AF_BLUETOOTH
 
PF_BLUETOOTH


	)

119 
	#AF_IUCV
 
PF_IUCV


	)

120 
	#AF_RXRPC
 
PF_RXRPC


	)

121 
	#AF_ISDN
 
PF_ISDN


	)

122 
	#AF_PHONET
 
PF_PHONET


	)

123 
	#AF_IEEE802154
 
PF_IEEE802154


	)

124 
	#AF_CAIF
 
PF_CAIF


	)

125 
	#AF_ALG
 
PF_ALG


	)

126 
	#AF_NFC
 
PF_NFC


	)

127 
	#AF_VSOCK
 
PF_VSOCK


	)

128 
	#AF_MAX
 
PF_MAX


	)

134 
	#SOL_RAW
 255

	)

135 
	#SOL_DECNET
 261

	)

136 
	#SOL_X25
 262

	)

137 
	#SOL_PACKET
 263

	)

138 
	#SOL_ATM
 264

	)

139 
	#SOL_AAL
 265

	)

140 
	#SOL_IRDA
 266

	)

143 
	#SOMAXCONN
 128

	)

146 
	~<bs/sockaddr.h
>

149 
	ssockaddr


151 
__SOCKADDR_COMMON
 (
_
);

152 
	m_da
[14];

158 
	#__ss_igy
 

	)

159 
	#_SS_SIZE
 128

	)

160 
	#_SS_PADSIZE
 (
_SS_SIZE
 - (2 *  (
__ss_igy
)))

	)

162 
	ssockaddr_age


164 
__SOCKADDR_COMMON
 (
ss_
);

165 
__ss_igy
 
	m__ss_ign
;

166 
	m__ss_ddg
[
_SS_PADSIZE
];

173 
	mMSG_OOB
 = 0x01,

174 
	#MSG_OOB
 
MSG_OOB


	)

175 
	mMSG_PEEK
 = 0x02,

176 
	#MSG_PEEK
 
MSG_PEEK


	)

177 
	mMSG_DONTROUTE
 = 0x04,

178 
	#MSG_DONTROUTE
 
MSG_DONTROUTE


	)

179 #ifde
__USE_GNU


181 
	mMSG_TRYHARD
 = 
MSG_DONTROUTE
,

182 
	#MSG_TRYHARD
 
MSG_DONTROUTE


	)

184 
	mMSG_CTRUNC
 = 0x08,

185 
	#MSG_CTRUNC
 
MSG_CTRUNC


	)

186 
	mMSG_PROXY
 = 0x10,

187 
	#MSG_PROXY
 
MSG_PROXY


	)

188 
	mMSG_TRUNC
 = 0x20,

189 
	#MSG_TRUNC
 
MSG_TRUNC


	)

190 
	mMSG_DONTWAIT
 = 0x40,

191 
	#MSG_DONTWAIT
 
MSG_DONTWAIT


	)

192 
	mMSG_EOR
 = 0x80,

193 
	#MSG_EOR
 
MSG_EOR


	)

194 
	mMSG_WAITALL
 = 0x100,

195 
	#MSG_WAITALL
 
MSG_WAITALL


	)

196 
	mMSG_FIN
 = 0x200,

197 
	#MSG_FIN
 
MSG_FIN


	)

198 
	mMSG_SYN
 = 0x400,

199 
	#MSG_SYN
 
MSG_SYN


	)

200 
	mMSG_CONFIRM
 = 0x800,

201 
	#MSG_CONFIRM
 
MSG_CONFIRM


	)

202 
	mMSG_RST
 = 0x1000,

203 
	#MSG_RST
 
MSG_RST


	)

204 
	mMSG_ERRQUEUE
 = 0x2000,

205 
	#MSG_ERRQUEUE
 
MSG_ERRQUEUE


	)

206 
	mMSG_NOSIGNAL
 = 0x4000,

207 
	#MSG_NOSIGNAL
 
MSG_NOSIGNAL


	)

208 
	mMSG_MORE
 = 0x8000,

209 
	#MSG_MORE
 
MSG_MORE


	)

210 
	mMSG_WAITFORONE
 = 0x10000,

211 
	#MSG_WAITFORONE
 
MSG_WAITFORONE


	)

212 
	mMSG_FASTOPEN
 = 0x20000000,

213 
	#MSG_FASTOPEN
 
MSG_FASTOPEN


	)

215 
	mMSG_CMSG_CLOEXEC
 = 0x40000000

218 
	#MSG_CMSG_CLOEXEC
 
MSG_CMSG_CLOEXEC


	)

224 
	smsghdr


226 *
	mmsg_me
;

227 
sockn_t
 
	mmsg_m
;

229 
iovec
 *
	mmsg_iov
;

230 
size_t
 
	mmsg_iovn
;

232 *
	mmsg_cڌ
;

233 
size_t
 
	mmsg_cڌn
;

238 
	mmsg_ags
;

242 
	scmsghdr


244 
size_t
 
	mcmsg_n
;

249 
	mcmsg_v
;

250 
	mcmsg_ty
;

251 #i(!
defed
 
__STRICT_ANSI__
 && 
__GNUC__
 >2|| 
__STDC_VERSION__
 >= 199901L

252 
__exnsi__
 
__cmsg_da
 
	m__exr
;

257 #i(!
defed
 
__STRICT_ANSI__
 && 
__GNUC__
 >2|| 
__STDC_VERSION__
 >= 199901L

258 
	#CMSG_DATA
(
cmsg
((cmsg)->
__cmsg_da
)

	)

260 
	#CMSG_DATA
(
cmsg
((*((
cmsghdr
 *(cmsg+ 1))

	)

262 
	#CMSG_NXTHDR
(
mhdr
, 
cmsg

	`__cmsg_nxthdr
 (mhdr, cmsg)

	)

263 
	#CMSG_FIRSTHDR
(
mhdr
) \

264 ((
size_t
(
mhdr
)->
msg_cڌn
 > (
cmsghdr
) \

265 ? (
cmsghdr
 *(
mhdr
)->
msg_cڌ
 : (cmsghd*0)

	)

266 
	#CMSG_ALIGN
(
n
((֒+  (
size_t
) - 1) \

267 & (
size_t
~( (size_t- 1))

	)

268 
	#CMSG_SPACE
(
n
(
	`CMSG_ALIGN
 (len) \

269 + 
	`CMSG_ALIGN
 ( (
cmsghdr
)))

	)

270 
	#CMSG_LEN
(
n
(
	`CMSG_ALIGN
 ( (
cmsghdr
)+ (n))

	)

272 
cmsghdr
 *
	$__cmsg_nxthdr
 (
msghdr
 *
__mhdr
,

273 
cmsghdr
 *
__cmsg

__THROW
;

274 #ifde
__USE_EXTERN_INLINES


275 #ide
_EXTERN_INLINE


276 
	#_EXTERN_INLINE
 
__ex_le


	)

278 
_EXTERN_INLINE
 
cmsghdr
 *

279 
	`__NTH
 (
	$__cmsg_nxthdr
 (
msghdr
 *
__mhdr
, 
cmsghdr
 *
__cmsg
))

281 i((
size_t

__cmsg
->
cmsg_n
 <  (
cmsghdr
))

283  (
cmsghdr
 *) 0;

285 
__cmsg
 = (
cmsghdr
 *) ((*) __cmsg

286 + 
	`CMSG_ALIGN
 (
__cmsg
->
cmsg_n
));

287 i((*(
__cmsg
 + 1> ((*
__mhdr
->
msg_cڌ


288 + 
__mhdr
->
msg_cڌn
)

289 || ((*
__cmsg
 + 
	`CMSG_ALIGN
 (__cmsg->
cmsg_n
)

290 > ((*
__mhdr
->
msg_cڌ
 + __mhdr->
msg_cڌn
)))

292  (
cmsghdr
 *) 0;

293  
__cmsg
;

294 
	}
}

301 
	mSCM_RIGHTS
 = 0x01

302 
	#SCM_RIGHTS
 
SCM_RIGHTS


	)

303 #ifde
__USE_GNU


304 , 
	mSCM_CREDENTIALS
 = 0x02

305 
	#SCM_CREDENTIALS
 
SCM_CREDENTIALS


	)

309 #ifde
__USE_GNU


311 
	sued


313 
pid_t
 
	mpid
;

314 
uid_t
 
	muid
;

315 
gid_t
 
	mgid
;

320 #i!
defed
 
__USE_MISC
 && !defed 
__USE_GNU


321 #ide
FIOGETOWN


322 
	#__SYS_SOCKET_H_undef_FIOGETOWN


	)

324 #ide
FIOSETOWN


325 
	#__SYS_SOCKET_H_undef_FIOSETOWN


	)

327 #ide
SIOCATMARK


328 
	#__SYS_SOCKET_H_undef_SIOCATMARK


	)

330 #ide
SIOCGPGRP


331 
	#__SYS_SOCKET_H_undef_SIOCGPGRP


	)

333 #ide
SIOCGSTAMP


334 
	#__SYS_SOCKET_H_undef_SIOCGSTAMP


	)

336 #ide
SIOCGSTAMPNS


337 
	#__SYS_SOCKET_H_undef_SIOCGSTAMPNS


	)

339 #ide
SIOCSPGRP


340 
	#__SYS_SOCKET_H_undef_SIOCSPGRP


	)

345 
	~<asm/sock.h
>

347 #i!
defed
 
__USE_MISC
 && !defed 
__USE_GNU


348 #ifde
__SYS_SOCKET_H_undef_FIOGETOWN


349 #unde
__SYS_SOCKET_H_undef_FIOGETOWN


350 #unde
FIOGETOWN


352 #ifde
__SYS_SOCKET_H_undef_FIOSETOWN


353 #unde
__SYS_SOCKET_H_undef_FIOSETOWN


354 #unde
FIOSETOWN


356 #ifde
__SYS_SOCKET_H_undef_SIOCATMARK


357 #unde
__SYS_SOCKET_H_undef_SIOCATMARK


358 #unde
SIOCATMARK


360 #ifde
__SYS_SOCKET_H_undef_SIOCGPGRP


361 #unde
__SYS_SOCKET_H_undef_SIOCGPGRP


362 #unde
SIOCGPGRP


364 #ifde
__SYS_SOCKET_H_undef_SIOCGSTAMP


365 #unde
__SYS_SOCKET_H_undef_SIOCGSTAMP


366 #unde
SIOCGSTAMP


368 #ifde
__SYS_SOCKET_H_undef_SIOCGSTAMPNS


369 #unde
__SYS_SOCKET_H_undef_SIOCGSTAMPNS


370 #unde
SIOCGSTAMPNS


372 #ifde
__SYS_SOCKET_H_undef_SIOCSPGRP


373 #unde
__SYS_SOCKET_H_undef_SIOCSPGRP


374 #unde
SIOCSPGRP


379 
	slg


381 
	ml_off
;

382 
	ml_lg
;

	@/usr/include/bits/socket2.h

19 #ide
_SYS_SOCKET_H


23 
ssize_t
 
__cv_chk
 (
__fd
, *
__buf
, 
size_t
 
__n
, size_
__bu
,

24 
__ags
);

25 
ssize_t
 
__REDIRECT
 (
__cv_s
, (
__fd
, *
__buf
, 
size_t
 
__n
,

26 
__ags
), 
cv
);

27 
ssize_t
 
__REDIRECT
 (
__cv_chk_wn
,

28 (
__fd
, *
__buf
, 
size_t
 
__n
, size_
__bu
,

29 
__ags
), 
__cv_chk
)

30 
__wǉr
 ("recv called with biggerengthhan size of destination "

33 
__ftify_funi
 
ssize_t


34 
	$cv
 (
__fd
, *
__buf
, 
size_t
 
__n
, 
__ags
)

36 i(
	`__bos0
 (
__buf
!(
size_t
) -1)

38 i(!
	`__but_cڡt_p
 (
__n
))

39  
	`__cv_chk
 (
__fd
, 
__buf
, 
__n
, 
	`__bos0
 (__buf), 
__ags
);

41 i(
__n
 > 
	`__bos0
 (
__buf
))

42  
	`__cv_chk_wn
 (
__fd
, 
__buf
, 
__n
, 
	`__bos0
 (__buf), 
__ags
);

44  
	`__cv_s
 (
__fd
, 
__buf
, 
__n
, 
__ags
);

45 
	}
}

47 
ssize_t
 
__cvom_chk
 (
__fd
, *
__ri
 
__buf
, 
size_t
 
__n
,

48 
size_t
 
__bu
, 
__ags
,

49 
__SOCKADDR_ARG
 
__addr
,

50 
sockn_t
 *
__ri
 
__addr_n
);

51 
ssize_t
 
__REDIRECT
 (
__cvom_s
,

52 (
__fd
, *
__ri
 
__buf
, 
size_t
 
__n
,

53 
__ags
, 
__SOCKADDR_ARG
 
__addr
,

54 
sockn_t
 *
__ri
 
__addr_n
), 
cvom
);

55 
ssize_t
 
__REDIRECT
 (
__cvom_chk_wn
,

56 (
__fd
, *
__ri
 
__buf
, 
size_t
 
__n
,

57 
size_t
 
__bu
, 
__ags
,

58 
__SOCKADDR_ARG
 
__addr
,

59 
sockn_t
 *
__ri
 
__addr_n
), 
__cvom_chk
)

60 
__wǉr
 ("recvfrom called with biggerengthhan size of "

63 
__ftify_funi
 
ssize_t


64 
	$cvom
 (
__fd
, *
__ri
 
__buf
, 
size_t
 
__n
, 
__ags
,

65 
__SOCKADDR_ARG
 
__addr
, 
sockn_t
 *
__ri
 
__addr_n
)

67 i(
	`__bos0
 (
__buf
!(
size_t
) -1)

69 i(!
	`__but_cڡt_p
 (
__n
))

70  
	`__cvom_chk
 (
__fd
, 
__buf
, 
__n
, 
	`__bos0
 (__buf), 
__ags
,

71 
__addr
, 
__addr_n
);

72 i(
__n
 > 
	`__bos0
 (
__buf
))

73  
	`__cvom_chk_wn
 (
__fd
, 
__buf
, 
__n
, 
	`__bos0
 (__buf), 
__ags
,

74 
__addr
, 
__addr_n
);

76  
	`__cvom_s
 (
__fd
, 
__buf
, 
__n
, 
__ags
, 
__addr
, 
__addr_n
);

77 
	}
}

	@/usr/include/bits/uio.h

18 #i!
defed
 
_SYS_UIO_H
 && !defed 
_FCNTL_H


22 #ide
_BITS_UIO_H


23 
	#_BITS_UIO_H
 1

	)

25 
	~<sys/tys.h
>

39 
	#UIO_MAXIOV
 1024

	)

43 
	siovec


45 *
	miov_ba
;

46 
size_t
 
	miov_n
;

52 #ifde
__USE_GNU


53 #i
defed
 
_SYS_UIO_H
 && !defed 
_BITS_UIO_H_FOR_SYS_UIO_H


54 
	#_BITS_UIO_H_FOR_SYS_UIO_H
 1

	)

56 
__BEGIN_DECLS


59 
ssize_t
 
	$oss_vm_adv
 (
pid_t
 
__pid
, cڡ 
iovec
 *
__lvec
,

60 
__liovt
,

61 cڡ 
iovec
 *
__rvec
,

62 
__riovt
,

63 
__ags
)

64 
__THROW
;

67 
ssize_t
 
	$oss_vm_wrev
 (
pid_t
 
__pid
, cڡ 
iovec
 *
__lvec
,

68 
__liovt
,

69 cڡ 
iovec
 *
__rvec
,

70 
__riovt
,

71 
__ags
)

72 
__THROW
;

74 
__END_DECLS


	@/usr/include/gconv.h

22 #ide
_GCONV_H


23 
	#_GCONV_H
 1

	)

25 
	~<us.h
>

26 
	#__ed_mbe_t


	)

27 
	#__ed_wt_t


	)

28 
	~<wch.h
>

29 
	#__ed_size_t


	)

30 
	#__ed_wch_t


	)

31 
	~<ddef.h
>

34 
	#__UNKNOWN_10646_CHAR
 ((
wch_t
0xfffd)

	)

39 
	m__GCONV_OK
 = 0,

40 
	m__GCONV_NOCONV
,

41 
	m__GCONV_NODB
,

42 
	m__GCONV_NOMEM
,

44 
	m__GCONV_EMPTY_INPUT
,

45 
	m__GCONV_FULL_OUTPUT
,

46 
	m__GCONV_ILLEGAL_INPUT
,

47 
	m__GCONV_INCOMPLETE_INPUT
,

49 
	m__GCONV_ILLEGAL_DESCRIPTOR
,

50 
	m__GCONV_INTERNAL_ERROR


57 
	m__GCONV_IS_LAST
 = 0x0001,

58 
	m__GCONV_IGNORE_ERRORS
 = 0x0002,

59 
	m__GCONV_SWAP
 = 0x0004

64 
	g__gcv_
;

65 
	g__gcv__da
;

66 
	g__gcv_lded_obje
;

67 
	g__gcv_s_da
;

71 (*
	t__gcv_f
(
	t__gcv_
 *, 
	t__gcv__da
 *,

73 **, 
	tsize_t
 *, , );

76 
	$wt_t
 (*
	t__gcv_btowc_f
(
	t__gcv_
 *, );

79 (*
	t__gcv__f
(
	t__gcv_
 *);

80 (*
	t__gcv_d_f
(
	t__gcv_
 *);

84 (*
	t__gcv_s_f
(
	t__gcv_
 *,

85 
	t__gcv__da
 *, *,

89 
	tsize_t
 *);

92 (*
	t__gcv_s_cڋxt_f
) (*, const *,

97 (*
	t__gcv_s_quy_f
) (const *, const ***,

98 
	tsize_t
 *);

101 (*
	t__gcv_s__f
) (**, const *);

102 (*
	t__gcv_s_d_f
) (*);

104 
	s__gcv_s_da


107 
__gcv_s_f
 
__s_f
;

108 
__gcv_s_cڋxt_f
 
__s_cڋxt_f
;

109 
__gcv_s_d_f
 
__s_d_f
;

110 *
__da
;

111 
__gcv_s_da
 *
__xt
;

116 
	s__gcv_


118 
__gcv_lded_obje
 *
__shlib_hd
;

119 cڡ *
__modme
;

121 
__cou
;

123 *
__om_me
;

124 *
__to_me
;

126 
__gcv_f
 
__f
;

127 
__gcv_btowc_f
 
__btowc_f
;

128 
__gcv__f
 
___f
;

129 
__gcv_d_f
 
__d_f
;

133 
__m_eded_om
;

134 
__max_eded_om
;

135 
__m_eded_to
;

136 
__max_eded_to
;

139 
__eful
;

141 *
__da
;

146 
	s__gcv__da


148 *
__outbuf
;

149 *
__outbund
;

153 
__ags
;

157 
__voti_cou
;

161 
___u
;

163 
__mbe_t
 *
__
;

164 
__mbe_t
 
__e
;

168 
__gcv_s_da
 *
__s
;

173 
	s__gcv_fo


175 
size_t
 
__ns
;

176 
__gcv_
 *
__s
;

177 
__exnsi__
 
__gcv__da
 
__da
 
__exr
;

178 } *
	t__gcv_t
;

	@/usr/include/gnu/stubs-32.h

6 #ifde
_LIBC


7 #r 
Alitis
 
may
 
n
 
defe
 
the
 
mao
 
_LIBC


10 
	#__ub_chags


	)

11 
	#__ub_ach


	)

12 
	#__ub_fchags


	)

13 
	#__ub_fdach


	)

14 
	#__ub_gy


	)

15 
	#__ub_lchmod


	)

16 
	#__ub_voke


	)

17 
	#__ub_og


	)

18 
	#__ub_sigtu


	)

19 
	#__ub_sk


	)

20 
	#__ub_ty


	)

	@/usr/include/gnu/stubs-64.h

6 #ifde
_LIBC


7 #r 
Alitis
 
may
 
n
 
defe
 
the
 
mao
 
_LIBC


10 
	#__ub_bdush


	)

11 
	#__ub_chags


	)

12 
	#__ub_ach


	)

13 
	#__ub_fchags


	)

14 
	#__ub_fdach


	)

15 
	#__ub_gmsg


	)

16 
	#__ub_gy


	)

17 
	#__ub_lchmod


	)

18 
	#__ub_putmsg


	)

19 
	#__ub_voke


	)

20 
	#__ub_og


	)

21 
	#__ub_sigtu


	)

22 
	#__ub_sk


	)

23 
	#__ub_ty


	)

	@/usr/include/gnu/stubs-x32.h

6 #ifde
_LIBC


7 #r 
Alitis
 
may
 
n
 
defe
 
the
 
mao
 
_LIBC


10 
	#__ub_bdush


	)

11 
	#__ub_chags


	)

12 
	#__ub__modu


	)

13 
	#__ub_ach


	)

14 
	#__ub_fchags


	)

15 
	#__ub_fdach


	)

16 
	#__ub_g_kl_syms


	)

17 
	#__ub_gmsg


	)

18 
	#__ub_gy


	)

19 
	#__ub_lchmod


	)

20 
	#__ub_nfsrvl


	)

21 
	#__ub_putmsg


	)

22 
	#__ub_quy_modu


	)

23 
	#__ub_voke


	)

24 
	#__ub_og


	)

25 
	#__ub_sigtu


	)

26 
	#__ub_sk


	)

27 
	#__ub_ty


	)

28 
	#__ub_ulib


	)

	@/usr/include/linux/posix_types.h

1 #ide
_LINUX_POSIX_TYPES_H


2 
	#_LINUX_POSIX_TYPES_H


	)

4 
	~<lux/ddef.h
>

21 #unde
__FD_SETSIZE


22 
	#__FD_SETSIZE
 1024

	)

25 
	mfds_bs
[
__FD_SETSIZE
 / (8 * ())];

26 } 
	t__kl_fd_t
;

29 (*
	t__kl_sighdr_t
)();

32 
	t__kl_key_t
;

33 
	t__kl_mqd_t
;

35 
	~<asm/posix_tys.h
>

	@/usr/include/linux/sysinfo.h

1 #ide
_LINUX_SYSINFO_H


2 
	#_LINUX_SYSINFO_H


	)

4 
	~<lux/tys.h
>

6 
	#SI_LOAD_SHIFT
 16

	)

7 
	ssysfo
 {

8 
__kl_lg_t
 
	muime
;

9 
__kl_ulg_t
 
	mlds
[3];

10 
__kl_ulg_t
 
	mtٮm
;

11 
__kl_ulg_t
 
	m䓿m
;

12 
__kl_ulg_t
 
	mshedm
;

13 
__kl_ulg_t
 
	mbufam
;

14 
__kl_ulg_t
 
	mtٮsw
;

15 
__kl_ulg_t
 
	msw
;

16 
__u16
 
	mocs
;

17 
__u16
 
	md
;

18 
__kl_ulg_t
 
	mtٮhigh
;

19 
__kl_ulg_t
 
	mhigh
;

20 
__u32
 
	mmem_un
;

21 
	m_f
[20-2*(
__kl_ulg_t
)-(
__u32
)];

	@/usr/include/sys/uio.h

18 #ide
_SYS_UIO_H


19 
	#_SYS_UIO_H
 1

	)

21 
	~<us.h
>

23 
	~<sys/tys.h
>

25 
	g__BEGIN_DECLS


28 
	~<bs/uio.h
>

39 
ssize_t
 
	$adv
 (
__fd
, cڡ 
iovec
 *
__iovec
, 
__cou
)

40 
__wur
;

50 
ssize_t
 
	$wrev
 (
__fd
, cڡ 
iovec
 *
__iovec
, 
__cou
)

51 
__wur
;

54 #ifde
__USE_BSD


55 #ide
__USE_FILE_OFFSET64


65 
ssize_t
 
	$dv
 (
__fd
, cڡ 
iovec
 *
__iovec
, 
__cou
,

66 
__off_t
 
__offt

__wur
;

77 
ssize_t
 
	$pwrev
 (
__fd
, cڡ 
iovec
 *
__iovec
, 
__cou
,

78 
__off_t
 
__offt

__wur
;

80 #ifde
__REDIRECT


81 
ssize_t
 
	`__REDIRECT
 (
dv
, (
__fd
, cڡ 
iovec
 *
__iovec
,

82 
__cou
, 
__off64_t
 
__offt
),

83 
dv64

__wur
;

84 
ssize_t
 
	`__REDIRECT
 (
pwrev
, (
__fd
, cڡ 
iovec
 *
__iovec
,

85 
__cou
, 
__off64_t
 
__offt
),

86 
pwrev64

__wur
;

88 
	#dv
 
dv64


	)

89 
	#pwrev
 
pwrev64


	)

93 #ifde
__USE_LARGEFILE64


103 
ssize_t
 
	$dv64
 (
__fd
, cڡ 
iovec
 *
__iovec
, 
__cou
,

104 
__off64_t
 
__offt

__wur
;

115 
ssize_t
 
	$pwrev64
 (
__fd
, cڡ 
iovec
 *
__iovec
, 
__cou
,

116 
__off64_t
 
__offt

__wur
;

120 
__END_DECLS


	@/usr/include/wchar.h

23 #ide
_WCHAR_H


25 #i!
defed
 
__ed_mbe_t
 && !defed 
__ed_wt_t


26 
	#_WCHAR_H
 1

	)

27 
	~<us.h
>

30 #ifde
_WCHAR_H


32 
	#__ed___FILE


	)

33 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K


34 
	#__ed_FILE


	)

36 
	~<dio.h
>

38 
	#__ed___va_li


	)

39 
	~<dg.h
>

41 
	~<bs/wch.h
>

44 
	#__ed_size_t


	)

45 
	#__ed_wch_t


	)

46 
	#__ed_NULL


	)

48 #i
defed
 
_WCHAR_H
 || defed 
__ed_wt_t
 || !defed 
__WINT_TYPE__


49 #unde
__ed_wt_t


50 
	#__ed_wt_t


	)

51 
	~<ddef.h
>

55 #ide
_WINT_T


60 
	#_WINT_T


	)

61 
	twt_t
;

65 #i
defed
 
__lulus
 && defed 
_GLIBCPP_USE_NAMESPACES
 \

66 && 
defed
 
__WINT_TYPE__


67 
__BEGIN_NAMESPACE_STD


68 
__WINT_TYPE__
 
	twt_t
;

69 
	g__END_NAMESPACE_STD


74 #i
defed
 
__lulus
 && 
__GNUC_PREREQ
 (4, 4)

75 
	#__CORRECT_ISO_CPP_WCHAR_H_PROTO


	)

79 #i(
defed
 
_WCHAR_H
 || defed 
__ed_mbe_t
&& !defed 
____mbe_t_defed


80 
	#____mbe_t_defed
 1

	)

84 
	m__cou
;

87 #ifde
__WINT_TYPE__


88 
__WINT_TYPE__
 
	m__wch
;

90 
wt_t
 
	m__wch
;

92 
	m__wchb
[4];

93 } 
	m__vue
;

94 } 
	t__mbe_t
;

96 #unde
__ed_mbe_t


101 #ifde
_WCHAR_H


103 #ide
__mbe_t_defed


104 
__BEGIN_NAMESPACE_C99


106 
__mbe_t
 
	tmbe_t
;

107 
	g__END_NAMESPACE_C99


108 
	#__mbe_t_defed
 1

	)

111 #ifde
__USE_GNU


112 
	$__USING_NAMESPACE_C99
(
mbe_t
)

115 #ide
WCHAR_MIN


117 
	#WCHAR_MIN
 
__WCHAR_MIN


	)

118 
	#WCHAR_MAX
 
__WCHAR_MAX


	)

121 #ide
WEOF


122 
	#WEOF
 (0xffffffffu)

	)

127 #i
defed
 
__USE_XOPEN
 && !defed 
__USE_UNIX98


128 
	~<wy.h
>

132 
__BEGIN_DECLS


134 
__BEGIN_NAMESPACE_STD


137 
tm
;

138 
__END_NAMESPACE_STD


142 
	$__USING_NAMESPACE_STD
(
tm
)

145 
__BEGIN_NAMESPACE_STD


147 
wch_t
 *
	$wcsy
 (
wch_t
 *
__ri
 
__de
,

148 cڡ 
wch_t
 *
__ri
 
__c

__THROW
;

150 
wch_t
 *
	$wcy
 (
wch_t
 *
__ri
 
__de
,

151 cڡ 
wch_t
 *
__ri
 
__c
, 
size_t
 
__n
)

152 
__THROW
;

155 
wch_t
 *
	$wcst
 (
wch_t
 *
__ri
 
__de
,

156 cڡ 
wch_t
 *
__ri
 
__c

__THROW
;

158 
wch_t
 *
	$wct
 (
wch_t
 *
__ri
 
__de
,

159 cڡ 
wch_t
 *
__ri
 
__c
, 
size_t
 
__n
)

160 
__THROW
;

163 
	$wcscmp
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
)

164 
__THROW
 
__ibu_pu__
;

166 
	$wccmp
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
, 
size_t
 
__n
)

167 
__THROW
 
__ibu_pu__
;

168 
__END_NAMESPACE_STD


170 #ifde
__USE_XOPEN2K8


172 
	$wcscmp
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2

__THROW
;

175 
	$wccmp
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
,

176 
size_t
 
__n

__THROW
;

180 
	~<xlo.h
>

182 
	$wcscmp_l
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
,

183 
__lo_t
 
__loc

__THROW
;

185 
	$wccmp_l
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
,

186 
size_t
 
__n
, 
__lo_t
 
__loc

__THROW
;

189 
__BEGIN_NAMESPACE_STD


192 
	$wcscl
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2

__THROW
;

196 
size_t
 
	$wcsxm
 (
wch_t
 *
__ri
 
__s1
,

197 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n

__THROW
;

198 
__END_NAMESPACE_STD


200 #ifde
__USE_XOPEN2K8


206 
	$wcscl_l
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
,

207 
__lo_t
 
__loc

__THROW
;

212 
size_t
 
	$wcsxm_l
 (
wch_t
 *
__s1
, cڡ wch_*
__s2
,

213 
size_t
 
__n
, 
__lo_t
 
__loc

__THROW
;

216 
wch_t
 *
	$wcsdup
 (cڡ 
wch_t
 *
__s

__THROW
 
__ibu_mloc__
;

219 
__BEGIN_NAMESPACE_STD


221 #ifde
__CORRECT_ISO_CPP_WCHAR_H_PROTO


222 "C++" 
wch_t
 *
	$wcschr
 (
wch_t
 *
__wcs
, wch_
__wc
)

223 
__THROW
 
	`__asm
 ("wcschr"
__ibu_pu__
;

224 "C++" cڡ 
wch_t
 *
	$wcschr
 (cڡ 
wch_t
 *
__wcs
, wch_
__wc
)

225 
__THROW
 
	`__asm
 ("wcschr"
__ibu_pu__
;

227 
wch_t
 *
	$wcschr
 (cڡ 
wch_t
 *
__wcs
, wch_
__wc
)

228 
__THROW
 
__ibu_pu__
;

231 #ifde
__CORRECT_ISO_CPP_WCHAR_H_PROTO


232 "C++" 
wch_t
 *
	$wcchr
 (
wch_t
 *
__wcs
, wch_
__wc
)

233 
__THROW
 
	`__asm
 ("wcchr"
__ibu_pu__
;

234 "C++" cڡ 
wch_t
 *
	$wcchr
 (cڡ 
wch_t
 *
__wcs
, wch_
__wc
)

235 
__THROW
 
	`__asm
 ("wcchr"
__ibu_pu__
;

237 
wch_t
 *
	$wcchr
 (cڡ 
wch_t
 *
__wcs
, wch_
__wc
)

238 
__THROW
 
__ibu_pu__
;

240 
__END_NAMESPACE_STD


242 #ifde
__USE_GNU


245 
wch_t
 *
	$wcschul
 (cڡ 
wch_t
 *
__s
, wch_
__wc
)

246 
__THROW
 
__ibu_pu__
;

249 
__BEGIN_NAMESPACE_STD


252 
size_t
 
	$wcscn
 (cڡ 
wch_t
 *
__wcs
, cڡ wch_*
__je
)

253 
__THROW
 
__ibu_pu__
;

256 
size_t
 
	$wcsn
 (cڡ 
wch_t
 *
__wcs
, cڡ wch_*
__ac
)

257 
__THROW
 
__ibu_pu__
;

259 #ifde
__CORRECT_ISO_CPP_WCHAR_H_PROTO


260 "C++" 
wch_t
 *
	$wcbrk
 (
wch_t
 *
__wcs
, cڡ wch_*
__ac
)

261 
__THROW
 
	`__asm
 ("wcbrk"
__ibu_pu__
;

262 "C++" cڡ 
wch_t
 *
	$wcbrk
 (cڡ 
wch_t
 *
__wcs
,

263 cڡ 
wch_t
 *
__ac
)

264 
__THROW
 
	`__asm
 ("wcbrk"
__ibu_pu__
;

266 
wch_t
 *
	$wcbrk
 (cڡ 
wch_t
 *
__wcs
, cڡ wch_*
__ac
)

267 
__THROW
 
__ibu_pu__
;

270 #ifde
__CORRECT_ISO_CPP_WCHAR_H_PROTO


271 "C++" 
wch_t
 *
	$wcsr
 (
wch_t
 *
__hayack
, cڡ wch_*
__ed
)

272 
__THROW
 
	`__asm
 ("wcsr"
__ibu_pu__
;

273 "C++" cڡ 
wch_t
 *
	$wcsr
 (cڡ 
wch_t
 *
__hayack
,

274 cڡ 
wch_t
 *
__ed
)

275 
__THROW
 
	`__asm
 ("wcsr"
__ibu_pu__
;

277 
wch_t
 *
	$wcsr
 (cڡ 
wch_t
 *
__hayack
, cڡ wch_*
__ed
)

278 
__THROW
 
__ibu_pu__
;

282 
wch_t
 *
	$wcok
 (
wch_t
 *
__ri
 
__s
,

283 cڡ 
wch_t
 *
__ri
 
__dim
,

284 
wch_t
 **
__ri
 
__r

__THROW
;

287 
size_t
 
	$wc
 (cڡ 
wch_t
 *
__s

__THROW
 
__ibu_pu__
;

288 
__END_NAMESPACE_STD


290 #ifde
__USE_XOPEN


292 #ifde
__CORRECT_ISO_CPP_WCHAR_H_PROTO


293 "C++" 
wch_t
 *
	$wcswcs
 (
wch_t
 *
__hayack
, cڡ wch_*
__ed
)

294 
__THROW
 
	`__asm
 ("wcswcs"
__ibu_pu__
;

295 "C++" cڡ 
wch_t
 *
	$wcswcs
 (cڡ 
wch_t
 *
__hayack
,

296 cڡ 
wch_t
 *
__ed
)

297 
__THROW
 
	`__asm
 ("wcswcs"
__ibu_pu__
;

299 
wch_t
 *
	$wcswcs
 (cڡ 
wch_t
 *
__hayack
, cڡ wch_*
__ed
)

300 
__THROW
 
__ibu_pu__
;

304 #ifde
__USE_XOPEN2K8


306 
size_t
 
	$wcn
 (cڡ 
wch_t
 *
__s
, 
size_t
 
__maxn
)

307 
__THROW
 
__ibu_pu__
;

311 
__BEGIN_NAMESPACE_STD


313 #ifde
__CORRECT_ISO_CPP_WCHAR_H_PROTO


314 "C++" 
wch_t
 *
	$wmemchr
 (
wch_t
 *
__s
, wch_
__c
, 
size_t
 
__n
)

315 
__THROW
 
	`__asm
 ("wmemchr"
__ibu_pu__
;

316 "C++" cڡ 
wch_t
 *
	$wmemchr
 (cڡ 
wch_t
 *
__s
, wch_
__c
,

317 
size_t
 
__n
)

318 
__THROW
 
	`__asm
 ("wmemchr"
__ibu_pu__
;

320 
wch_t
 *
	$wmemchr
 (cڡ 
wch_t
 *
__s
, wch_
__c
, 
size_t
 
__n
)

321 
__THROW
 
__ibu_pu__
;

325 
	$wmemcmp
 (cڡ 
wch_t
 *
__s1
, cڡ wch_*
__s2
, 
size_t
 
__n
)

326 
__THROW
 
__ibu_pu__
;

329 
wch_t
 *
	$wmemy
 (
wch_t
 *
__ri
 
__s1
,

330 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n

__THROW
;

334 
wch_t
 *
	$wmemmove
 (
wch_t
 *
__s1
, cڡ wch_*
__s2
, 
size_t
 
__n
)

335 
__THROW
;

338 
wch_t
 *
	$wmemt
 (
wch_t
 *
__s
, wch_
__c
, 
size_t
 
__n

__THROW
;

339 
__END_NAMESPACE_STD


341 #ifde
__USE_GNU


344 
wch_t
 *
	$wmempy
 (
wch_t
 *
__ri
 
__s1
,

345 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n
)

346 
__THROW
;

350 
__BEGIN_NAMESPACE_STD


353 
wt_t
 
	$btowc
 (
__c

__THROW
;

357 
	$wob
 (
wt_t
 
__c

__THROW
;

361 
	$mbs
 (cڡ 
mbe_t
 *
__ps

__THROW
 
__ibu_pu__
;

365 
size_t
 
	$mbowc
 (
wch_t
 *
__ri
 
__pwc
,

366 cڡ *
__ri
 
__s
, 
size_t
 
__n
,

367 
mbe_t
 *
__ri
 
__p

__THROW
;

370 
size_t
 
	$wtomb
 (*
__ri
 
__s
, 
wch_t
 
__wc
,

371 
mbe_t
 *
__ri
 
__ps

__THROW
;

374 
size_t
 
	$__mb
 (cڡ *
__ri
 
__s
, 
size_t
 
__n
,

375 
mbe_t
 *
__ri
 
__ps

__THROW
;

376 
size_t
 
	$mb
 (cڡ *
__ri
 
__s
, 
size_t
 
__n
,

377 
mbe_t
 *
__ri
 
__ps

__THROW
;

378 
__END_NAMESPACE_STD


380 #ifde
__USE_EXTERN_INLINES


386 
wt_t
 
	$__btowc_s
 (
__c

	`__asm
 ("btowc");

387 
__ex_le
 
wt_t


388 
	`__NTH
 (
	$btowc
 (
__c
))

389 {  (
	`__but_cڡt_p
 (
__c
) && __c >= '\0' && __c <= '\x7f'

390 ? (
wt_t

__c
 : 
	`__btowc_s
 (__c)); 
	}
}

392 
	$__wob_s
 (
wt_t
 
__c

	`__asm
 ("wctob");

393 
__ex_le
 

394 
	`__NTH
 (
	$wob
 (
wt_t
 
__wc
))

395 {  (
	`__but_cڡt_p
 (
__wc
&& __w>
L
'\0' && __wc <= L'\x7f'

396 ? (
__wc
 : 
	`__wob_s
 (__wc)); 
	}
}

398 
__ex_le
 
size_t


399 
__NTH
 (
	$mb
 (cڡ *
__ri
 
__s
, 
size_t
 
__n
,

400 
mbe_t
 *
__ri
 
__ps
))

401 {  (
__ps
 !
NULL


402 ? 
	`mbowc
 (
NULL
, 
__s
, 
__n
, 
__ps
: 
	`__mb
 (__s, __n, NULL)); 
	}
}

405 
__BEGIN_NAMESPACE_STD


408 
size_t
 
	$mbtowcs
 (
wch_t
 *
__ri
 
__d
,

409 cڡ **
__ri
 
__c
, 
size_t
 
__n
,

410 
mbe_t
 *
__ri
 
__ps

__THROW
;

414 
size_t
 
	$wctombs
 (*
__ri
 
__d
,

415 cڡ 
wch_t
 **
__ri
 
__c
, 
size_t
 
__n
,

416 
mbe_t
 *
__ri
 
__ps

__THROW
;

417 
__END_NAMESPACE_STD


420 #ifdef 
__USE_XOPEN2K8


423 
size_t
 
	$mbowcs
 (
wch_t
 *
__ri
 
__d
,

424 cڡ **
__ri
 
__c
, 
size_t
 
__nmc
,

425 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps

__THROW
;

429 
size_t
 
	$wcombs
 (*
__ri
 
__d
,

430 cڡ 
wch_t
 **
__ri
 
__c
,

431 
size_t
 
__nwc
, size_
__n
,

432 
mbe_t
 *
__ri
 
__ps

__THROW
;

437 #ifde
__USE_XOPEN


439 
	$wcwidth
 (
wch_t
 
__c

__THROW
;

443 
	$wcswidth
 (cڡ 
wch_t
 *
__s
, 
size_t
 
__n

__THROW
;

447 
__BEGIN_NAMESPACE_STD


450 
	$wcod
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

451 
wch_t
 **
__ri
 
__dr

__THROW
;

452 
__END_NAMESPACE_STD


454 #ifde
__USE_ISOC99


455 
__BEGIN_NAMESPACE_C99


457 
	$wcof
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

458 
wch_t
 **
__ri
 
__dr

__THROW
;

459 
	$wcd
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

460 
wch_t
 **
__ri
 
__dr

__THROW
;

461 
__END_NAMESPACE_C99


465 
__BEGIN_NAMESPACE_STD


468 
	$wc
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

469 
wch_t
 **
__ri
 
__dr
, 
__ba

__THROW
;

473 
	$wcoul
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

474 
wch_t
 **
__ri
 
__dr
, 
__ba
)

475 
__THROW
;

476 
__END_NAMESPACE_STD


478 #ifde
__USE_ISOC99


479 
__BEGIN_NAMESPACE_C99


482 
__exnsi__


483 
	$wcl
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

484 
wch_t
 **
__ri
 
__dr
, 
__ba
)

485 
__THROW
;

489 
__exnsi__


490 
	$wcou
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

491 
wch_t
 **
__ri
 
__dr
,

492 
__ba

__THROW
;

493 
__END_NAMESPACE_C99


496 #ifde
__USE_GNU


499 
__exnsi__


500 
	$wcoq
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

501 
wch_t
 **
__ri
 
__dr
, 
__ba
)

502 
__THROW
;

506 
__exnsi__


507 
	$wcouq
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

508 
wch_t
 **
__ri
 
__dr
,

509 
__ba

__THROW
;

512 #ifde
__USE_GNU


526 
	~<xlo.h
>

530 
	$wc_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

531 
wch_t
 **
__ri
 
__dr
, 
__ba
,

532 
__lo_t
 
__loc

__THROW
;

534 
	$wcoul_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

535 
wch_t
 **
__ri
 
__dr
,

536 
__ba
, 
__lo_t
 
__loc

__THROW
;

538 
__exnsi__


539 
	$wcl_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

540 
wch_t
 **
__ri
 
__dr
,

541 
__ba
, 
__lo_t
 
__loc

__THROW
;

543 
__exnsi__


544 
	$wcou_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

545 
wch_t
 **
__ri
 
__dr
,

546 
__ba
, 
__lo_t
 
__loc
)

547 
__THROW
;

549 
	$wcod_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

550 
wch_t
 **
__ri
 
__dr
, 
__lo_t
 
__loc
)

551 
__THROW
;

553 
	$wcof_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

554 
wch_t
 **
__ri
 
__dr
, 
__lo_t
 
__loc
)

555 
__THROW
;

557 
	$wcd_l
 (cڡ 
wch_t
 *
__ri
 
__Ō
,

558 
wch_t
 **
__ri
 
__dr
,

559 
__lo_t
 
__loc

__THROW
;

563 #ifde
__USE_XOPEN2K8


566 
wch_t
 *
	$wy
 (
wch_t
 *
__ri
 
__de
,

567 cڡ 
wch_t
 *
__ri
 
__c

__THROW
;

571 
wch_t
 *
	$wny
 (
wch_t
 *
__ri
 
__de
,

572 cڡ 
wch_t
 *
__ri
 
__c
, 
size_t
 
__n
)

573 
__THROW
;

580 
__FILE
 *
	$ݒ_wmemam
 (
wch_t
 **
__buoc
, 
size_t
 *
__sizoc

__THROW
;

583 #i
defed
 
__USE_ISOC95
 || defed 
__USE_UNIX98


584 
__BEGIN_NAMESPACE_STD


587 
	$fwide
 (
__FILE
 *
__
, 
__mode

__THROW
;

594 
	`fwtf
 (
__FILE
 *
__ri
 
__am
,

595 cڡ 
wch_t
 *
__ri
 
__fm
, ...)

601 
	`wtf
 (cڡ 
wch_t
 *
__ri
 
__fm
, ...)

604 
	$swtf
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

605 cڡ 
wch_t
 *
__ri
 
__fm
, ...)

606 
__THROW
 ;

612 
	`vfwtf
 (
__FILE
 *
__ri
 
__s
,

613 cڡ 
wch_t
 *
__ri
 
__fm
,

614 
__gnuc_va_li
 
__g
)

620 
	`vwtf
 (cڡ 
wch_t
 *
__ri
 
__fm
,

621 
__gnuc_va_li
 
__g
)

625 
	$vswtf
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

626 cڡ 
wch_t
 *
__ri
 
__fm
,

627 
__gnuc_va_li
 
__g
)

628 
__THROW
 ;

635 
	`fwsnf
 (
__FILE
 *
__ri
 
__am
,

636 cڡ 
wch_t
 *
__ri
 
__fm
, ...)

642 
	`wsnf
 (cڡ 
wch_t
 *
__ri
 
__fm
, ...)

645 
	$swsnf
 (cڡ 
wch_t
 *
__ri
 
__s
,

646 cڡ 
wch_t
 *
__ri
 
__fm
, ...)

647 
__THROW
 ;

649 #i
defed
 
__USE_ISOC99
 && !defed 
__USE_GNU
 \

650 && (!
defed
 
__LDBL_COMPAT
 || !defed 
__REDIRECT
) \

651 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

652 #ifde
__REDIRECT


656 
	`__REDIRECT
 (
fwsnf
, (
__FILE
 *
__ri
 
__am
,

657 cڡ 
wch_t
 *
__ri
 
__fm
, ...),

658 
__isoc99_fwsnf
)

660 
	`__REDIRECT
 (
wsnf
, (cڡ 
wch_t
 *
__ri
 
__fm
, ...),

661 
__isoc99_wsnf
)

663 
	`__REDIRECT_NTH
 (
swsnf
, (cڡ 
wch_t
 *
__ri
 
__s
,

664 cڡ 
wch_t
 *
__ri
 
__fm
,

665 ...), 
__isoc99_swsnf
)

668 
	`__isoc99_fwsnf
 (
__FILE
 *
__ri
 
__am
,

669 cڡ 
wch_t
 *
__ri
 
__fm
, ...);

670 
	`__isoc99_wsnf
 (cڡ 
wch_t
 *
__ri
 
__fm
, ...);

671 
	$__isoc99_swsnf
 (cڡ 
wch_t
 *
__ri
 
__s
,

672 cڡ 
wch_t
 *
__ri
 
__fm
, ...)

673 
__THROW
;

674 
	#fwsnf
 
__isoc99_fwsnf


	)

675 
	#wsnf
 
__isoc99_wsnf


	)

676 
	#swsnf
 
__isoc99_swsnf


	)

680 
__END_NAMESPACE_STD


683 #ifde
__USE_ISOC99


684 
__BEGIN_NAMESPACE_C99


689 
	`vfwsnf
 (
__FILE
 *
__ri
 
__s
,

690 cڡ 
wch_t
 *
__ri
 
__fm
,

691 
__gnuc_va_li
 
__g
)

697 
	`vwsnf
 (cڡ 
wch_t
 *
__ri
 
__fm
,

698 
__gnuc_va_li
 
__g
)

701 
	$vswsnf
 (cڡ 
wch_t
 *
__ri
 
__s
,

702 cڡ 
wch_t
 *
__ri
 
__fm
,

703 
__gnuc_va_li
 
__g
)

704 
__THROW
 ;

706 #i!
defed
 
__USE_GNU
 \

707 && (!
defed
 
__LDBL_COMPAT
 || !defed 
__REDIRECT
) \

708 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

709 #ifde
__REDIRECT


710 
	`__REDIRECT
 (
vfwsnf
, (
__FILE
 *
__ri
 
__s
,

711 cڡ 
wch_t
 *
__ri
 
__fm
,

712 
__gnuc_va_li
 
__g
), 
__isoc99_vfwsnf
)

714 
	`__REDIRECT
 (
vwsnf
, (cڡ 
wch_t
 *
__ri
 
__fm
,

715 
__gnuc_va_li
 
__g
), 
__isoc99_vwsnf
)

717 
	`__REDIRECT_NTH
 (
vswsnf
, (cڡ 
wch_t
 *
__ri
 
__s
,

718 cڡ 
wch_t
 *
__ri
 
__fm
,

719 
__gnuc_va_li
 
__g
), 
__isoc99_vswsnf
)

722 
	`__isoc99_vfwsnf
 (
__FILE
 *
__ri
 
__s
,

723 cڡ 
wch_t
 *
__ri
 
__fm
,

724 
__gnuc_va_li
 
__g
);

725 
	`__isoc99_vwsnf
 (cڡ 
wch_t
 *
__ri
 
__fm
,

726 
__gnuc_va_li
 
__g
);

727 
	$__isoc99_vswsnf
 (cڡ 
wch_t
 *
__ri
 
__s
,

728 cڡ 
wch_t
 *
__ri
 
__fm
,

729 
__gnuc_va_li
 
__g

__THROW
;

730 
	#vfwsnf
 
__isoc99_vfwsnf


	)

731 
	#vwsnf
 
__isoc99_vwsnf


	)

732 
	#vswsnf
 
__isoc99_vswsnf


	)

736 
__END_NAMESPACE_C99


740 
__BEGIN_NAMESPACE_STD


745 
wt_t
 
	`fgwc
 (
__FILE
 *
__am
);

746 
wt_t
 
	`gwc
 (
__FILE
 *
__am
);

752 
wt_t
 
	`gwch
 ();

759 
wt_t
 
	`utwc
 (
wch_t
 
__wc
, 
__FILE
 *
__am
);

760 
wt_t
 
	`putwc
 (
wch_t
 
__wc
, 
__FILE
 *
__am
);

766 
wt_t
 
	`putwch
 (
wch_t
 
__wc
);

774 
wch_t
 *
	`fgws
 (wch_*
__ri
 
__ws
, 
__n
,

775 
__FILE
 *
__ri
 
__am
);

781 
	`utws
 (cڡ 
wch_t
 *
__ri
 
__ws
,

782 
__FILE
 *
__ri
 
__am
);

789 
wt_t
 
	`ungwc
 (wt_
__wc
, 
__FILE
 *
__am
);

790 
__END_NAMESPACE_STD


793 #ifde
__USE_GNU


801 
wt_t
 
	`gwc_uocked
 (
__FILE
 *
__am
);

802 
wt_t
 
	`gwch_uocked
 ();

810 
wt_t
 
	`fgwc_uocked
 (
__FILE
 *
__am
);

818 
wt_t
 
	`utwc_uocked
 (
wch_t
 
__wc
, 
__FILE
 *
__am
);

827 
wt_t
 
	`putwc_uocked
 (
wch_t
 
__wc
, 
__FILE
 *
__am
);

828 
wt_t
 
	`putwch_uocked
 (
wch_t
 
__wc
);

837 
wch_t
 *
	`fgws_uocked
 (wch_*
__ri
 
__ws
, 
__n
,

838 
__FILE
 *
__ri
 
__am
);

846 
	`utws_uocked
 (cڡ 
wch_t
 *
__ri
 
__ws
,

847 
__FILE
 *
__ri
 
__am
);

851 
__BEGIN_NAMESPACE_C99


855 
size_t
 
	$wcsime
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__maxsize
,

856 cڡ 
wch_t
 *
__ri
 
__fm
,

857 cڡ 
tm
 *
__ri
 
__

__THROW
;

858 
__END_NAMESPACE_C99


860 #ifde
__USE_GNU


861 
	~<xlo.h
>

865 
size_t
 
	$wcsime_l
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__maxsize
,

866 cڡ 
wch_t
 *
__ri
 
__fm
,

867 cڡ 
tm
 *
__ri
 
__
,

868 
__lo_t
 
__loc

__THROW
;

877 #i
defed
 
__USE_UNIX98
 && !defed 
__USE_GNU


878 
	#__ed_iswxxx


	)

879 
	~<wy.h
>

883 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


884 
	~<bs/wch2.h
>

887 #ifde
__LDBL_COMPAT


888 
	~<bs/wch-ldbl.h
>

891 
__END_DECLS


899 #unde
__ed_mbe_t


900 #unde
__ed_wt_t


	@/usr/include/bits/sockaddr.h

23 #ide
_BITS_SOCKADDR_H


24 
	#_BITS_SOCKADDR_H
 1

	)

28 
	t_my_t
;

34 
	#__SOCKADDR_COMMON
(
_efix
) \

35 
_my_t
 
_efix
##
my


	)

37 
	#__SOCKADDR_COMMON_SIZE
 ( ())

	)

	@/usr/include/bits/socket_type.h

19 #ide
_SYS_SOCKET_H


24 
	e__sock_ty


26 
	mSOCK_STREAM
 = 1,

28 
	#SOCK_STREAM
 
SOCK_STREAM


	)

29 
	mSOCK_DGRAM
 = 2,

31 
	#SOCK_DGRAM
 
SOCK_DGRAM


	)

32 
	mSOCK_RAW
 = 3,

33 
	#SOCK_RAW
 
SOCK_RAW


	)

34 
	mSOCK_RDM
 = 4,

35 
	#SOCK_RDM
 
SOCK_RDM


	)

36 
	mSOCK_SEQPACKET
 = 5,

38 
	#SOCK_SEQPACKET
 
SOCK_SEQPACKET


	)

39 
	mSOCK_DCCP
 = 6,

40 
	#SOCK_DCCP
 
SOCK_DCCP


	)

41 
	mSOCK_PACKET
 = 10,

44 
	#SOCK_PACKET
 
SOCK_PACKET


	)

49 
	mSOCK_CLOEXEC
 = 02000000,

51 
	#SOCK_CLOEXEC
 
SOCK_CLOEXEC


	)

52 
	mSOCK_NONBLOCK
 = 00004000

54 
	#SOCK_NONBLOCK
 
SOCK_NONBLOCK


	)

	@/usr/include/bits/wchar-ldbl.h

19 #ide
_WCHAR_H


23 #i
defed
 
__USE_ISOC95
 || defed 
__USE_UNIX98


24 
__BEGIN_NAMESPACE_C99


25 
__LDBL_REDIR_DECL
 (
fwtf
);

26 
__LDBL_REDIR_DECL
 (
wtf
);

27 
__LDBL_REDIR_DECL
 (
swtf
);

28 
__LDBL_REDIR_DECL
 (
vfwtf
);

29 
__LDBL_REDIR_DECL
 (
vwtf
);

30 
__LDBL_REDIR_DECL
 (
vswtf
);

31 #i
defed
 
__USE_ISOC99
 && !defed 
__USE_GNU
 \

32 && !
defed
 
	g__REDIRECT
 \

33 && (
defed
 
	g__STRICT_ANSI__
 || defed 
	g__USE_XOPEN2K
)

34 
	$__LDBL_REDIR1_DECL
 (
fwsnf
, 
__dbl___isoc99_fwsnf
)

35 
	$__LDBL_REDIR1_DECL
 (
wsnf
, 
__dbl___isoc99_wsnf
)

36 
	$__LDBL_REDIR1_DECL
 (
swsnf
, 
__dbl___isoc99_swsnf
)

38 
	`__LDBL_REDIR_DECL
 (
fwsnf
);

39 
	`__LDBL_REDIR_DECL
 (
wsnf
);

40 
	`__LDBL_REDIR_DECL
 (
swsnf
);

42 
__END_NAMESPACE_C99


45 #ifde
__USE_ISOC99


46 
__BEGIN_NAMESPACE_C99


47 
	`__LDBL_REDIR1_DECL
 (
wcd
, 
wcod
);

48 #i!
defed
 
__USE_GNU
 && !defed 
__REDIRECT
 \

49 && (
defed
 
__STRICT_ANSI__
 || defed 
__USE_XOPEN2K
)

50 
	$__LDBL_REDIR1_DECL
 (
vfwsnf
, 
__dbl___isoc99_vfwsnf
)

51 
	$__LDBL_REDIR1_DECL
 (
vwsnf
, 
__dbl___isoc99_vwsnf
)

52 
	$__LDBL_REDIR1_DECL
 (
vswsnf
, 
__dbl___isoc99_vswsnf
)

54 
	`__LDBL_REDIR_DECL
 (
vfwsnf
);

55 
	`__LDBL_REDIR_DECL
 (
vwsnf
);

56 
	`__LDBL_REDIR_DECL
 (
vswsnf
);

58 
__END_NAMESPACE_C99


61 #ifde
__USE_GNU


62 
	`__LDBL_REDIR1_DECL
 (
wcd_l
, 
wcod_l
);

65 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


66 
	$__LDBL_REDIR_DECL
 (
__swtf_chk
)

67 
	$__LDBL_REDIR_DECL
 (
__vswtf_chk
)

68 #i
__USE_FORTIFY_LEVEL
 > 1

69 
	$__LDBL_REDIR_DECL
 (
__fwtf_chk
)

70 
	$__LDBL_REDIR_DECL
 (
__wtf_chk
)

71 
	$__LDBL_REDIR_DECL
 (
__vfwtf_chk
)

72 
	$__LDBL_REDIR_DECL
 (
__vwtf_chk
)

	@/usr/include/bits/wchar2.h

19 #ide
_WCHAR_H


24 
wch_t
 *
	$__wmemy_chk
 (
wch_t
 *
__ri
 
__s1
,

25 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n
,

26 
size_t
 
__ns1

__THROW
;

27 
wch_t
 *
	`__REDIRECT_NTH
 (
__wmemy_s
,

28 (
wch_t
 *
__ri
 
__s1
,

29 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n
),

30 
wmemy
);

31 
wch_t
 *
	`__REDIRECT_NTH
 (
__wmemy_chk_wn
,

32 (
wch_t
 *
__ri
 
__s1
,

33 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n
,

34 
size_t
 
__ns1
), 
__wmemy_chk
)

35 
	`__wǉr
 ("wmemcpy called withength biggerhan size of destination "

38 
__ftify_funi
 
wch_t
 *

39 
	`__NTH
 (
	$wmemy
 (
wch_t
 *
__ri
 
__s1
, cڡ wch_*__ri 
__s2
,

40 
size_t
 
__n
))

42 i(
	`__bos0
 (
__s1
!(
size_t
) -1)

44 i(!
	`__but_cڡt_p
 (
__n
))

45  
	`__wmemy_chk
 (
__s1
, 
__s2
, 
__n
,

46 
	`__bos0
 (
__s1
/  (
wch_t
));

48 i(
__n
 > 
	`__bos0
 (
__s1
/  (
wch_t
))

49  
	`__wmemy_chk_wn
 (
__s1
, 
__s2
, 
__n
,

50 
	`__bos0
 (
__s1
/  (
wch_t
));

52  
	`__wmemy_s
 (
__s1
, 
__s2
, 
__n
);

53 
	}
}

56 
wch_t
 *
	$__wmemmove_chk
 (
wch_t
 *
__s1
, cڡ wch_*
__s2
,

57 
size_t
 
__n
, size_
__ns1

__THROW
;

58 
wch_t
 *
	`__REDIRECT_NTH
 (
__wmemmove_s
, (wch_*
__s1
,

59 cڡ 
wch_t
 *
__s2
,

60 
size_t
 
__n
), 
wmemmove
);

61 
wch_t
 *
	`__REDIRECT_NTH
 (
__wmemmove_chk_wn
,

62 (
wch_t
 *
__s1
, cڡ wch_*
__s2
,

63 
size_t
 
__n
, size_
__ns1
), 
__wmemmove_chk
)

64 
	`__wǉr
 ("wmemmove called withength biggerhan size of destination "

67 
__ftify_funi
 
wch_t
 *

68 
	`__NTH
 (
	$wmemmove
 (
wch_t
 *
__s1
, cڡ wch_*
__s2
, 
size_t
 
__n
))

70 i(
	`__bos0
 (
__s1
!(
size_t
) -1)

72 i(!
	`__but_cڡt_p
 (
__n
))

73  
	`__wmemmove_chk
 (
__s1
, 
__s2
, 
__n
,

74 
	`__bos0
 (
__s1
/  (
wch_t
));

76 i(
__n
 > 
	`__bos0
 (
__s1
/  (
wch_t
))

77  
	`__wmemmove_chk_wn
 (
__s1
, 
__s2
, 
__n
,

78 
	`__bos0
 (
__s1
/  (
wch_t
));

80  
	`__wmemmove_s
 (
__s1
, 
__s2
, 
__n
);

81 
	}
}

84 #ifde
__USE_GNU


85 
wch_t
 *
	$__wmempy_chk
 (
wch_t
 *
__ri
 
__s1
,

86 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n
,

87 
size_t
 
__ns1

__THROW
;

88 
wch_t
 *
	`__REDIRECT_NTH
 (
__wmempy_s
,

89 (
wch_t
 *
__ri
 
__s1
,

90 cڡ 
wch_t
 *
__ri
 
__s2
,

91 
size_t
 
__n
), 
wmempy
);

92 
wch_t
 *
	`__REDIRECT_NTH
 (
__wmempy_chk_wn
,

93 (
wch_t
 *
__ri
 
__s1
,

94 cڡ 
wch_t
 *
__ri
 
__s2
, 
size_t
 
__n
,

95 
size_t
 
__ns1
), 
__wmempy_chk
)

96 
	`__wǉr
 ("wmempcpy called withength biggerhan size of destination "

99 
__ftify_funi
 
wch_t
 *

100 
	`__NTH
 (
	$wmempy
 (
wch_t
 *
__ri
 
__s1
, cڡ wch_*__ri 
__s2
,

101 
size_t
 
__n
))

103 i(
	`__bos0
 (
__s1
!(
size_t
) -1)

105 i(!
	`__but_cڡt_p
 (
__n
))

106  
	`__wmempy_chk
 (
__s1
, 
__s2
, 
__n
,

107 
	`__bos0
 (
__s1
/  (
wch_t
));

109 i(
__n
 > 
	`__bos0
 (
__s1
/  (
wch_t
))

110  
	`__wmempy_chk_wn
 (
__s1
, 
__s2
, 
__n
,

111 
	`__bos0
 (
__s1
/  (
wch_t
));

113  
	`__wmempy_s
 (
__s1
, 
__s2
, 
__n
);

114 
	}
}

118 
wch_t
 *
	$__wmemt_chk
 (
wch_t
 *
__s
, wch_
__c
, 
size_t
 
__n
,

119 
size_t
 
__ns

__THROW
;

120 
wch_t
 *
	`__REDIRECT_NTH
 (
__wmemt_s
, (wch_*
__s
, wch_
__c
,

121 
size_t
 
__n
), 
wmemt
);

122 
wch_t
 *
	`__REDIRECT_NTH
 (
__wmemt_chk_wn
,

123 (
wch_t
 *
__s
, wch_
__c
, 
size_t
 
__n
,

124 
size_t
 
__ns
), 
__wmemt_chk
)

125 
	`__wǉr
 ("wmemset called withength biggerhan size of destination "

128 
__ftify_funi
 
wch_t
 *

129 
	`__NTH
 (
	$wmemt
 (
wch_t
 *
__s
, wch_
__c
, 
size_t
 
__n
))

131 i(
	`__bos0
 (
__s
!(
size_t
) -1)

133 i(!
	`__but_cڡt_p
 (
__n
))

134  
	`__wmemt_chk
 (
__s
, 
__c
, 
__n
, 
	`__bos0
 (__s/  (
wch_t
));

136 i(
__n
 > 
	`__bos0
 (
__s
/  (
wch_t
))

137  
	`__wmemt_chk_wn
 (
__s
, 
__c
, 
__n
,

138 
	`__bos0
 (
__s
/  (
wch_t
));

140  
	`__wmemt_s
 (
__s
, 
__c
, 
__n
);

141 
	}
}

144 
wch_t
 *
	$__wcsy_chk
 (
wch_t
 *
__ri
 
__de
,

145 cڡ 
wch_t
 *
__ri
 
__c
,

146 
size_t
 
__n

__THROW
;

147 
wch_t
 *
	`__REDIRECT_NTH
 (
__wcsy_s
,

148 (
wch_t
 *
__ri
 
__de
,

149 cڡ 
wch_t
 *
__ri
 
__c
), 
wcsy
);

151 
__ftify_funi
 
wch_t
 *

152 
	`__NTH
 (
	$wcsy
 (
wch_t
 *
__ri
 
__de
, cڡ wch_*__ri 
__c
))

154 i(
	`__bos
 (
__de
!(
size_t
) -1)

155  
	`__wcsy_chk
 (
__de
, 
__c
, 
	`__bos
 (__de/  (
wch_t
));

156  
	`__wcsy_s
 (
__de
, 
__c
);

157 
	}
}

160 
wch_t
 *
	$__wy_chk
 (
wch_t
 *
__ri
 
__de
,

161 cڡ 
wch_t
 *
__ri
 
__c
,

162 
size_t
 
__den

__THROW
;

163 
wch_t
 *
	`__REDIRECT_NTH
 (
__wy_s
,

164 (
wch_t
 *
__ri
 
__de
,

165 cڡ 
wch_t
 *
__ri
 
__c
), 
wy
);

167 
__ftify_funi
 
wch_t
 *

168 
	`__NTH
 (
	$wy
 (
wch_t
 *
__ri
 
__de
, cڡ wch_*__ri 
__c
))

170 i(
	`__bos
 (
__de
!(
size_t
) -1)

171  
	`__wy_chk
 (
__de
, 
__c
, 
	`__bos
 (__de/  (
wch_t
));

172  
	`__wy_s
 (
__de
, 
__c
);

173 
	}
}

176 
wch_t
 *
	$__wcy_chk
 (
wch_t
 *
__ri
 
__de
,

177 cڡ 
wch_t
 *
__ri
 
__c
, 
size_t
 
__n
,

178 
size_t
 
__den

__THROW
;

179 
wch_t
 *
	`__REDIRECT_NTH
 (
__wcy_s
,

180 (
wch_t
 *
__ri
 
__de
,

181 cڡ 
wch_t
 *
__ri
 
__c
,

182 
size_t
 
__n
), 
wcy
);

183 
wch_t
 *
	`__REDIRECT_NTH
 (
__wcy_chk_wn
,

184 (
wch_t
 *
__ri
 
__de
,

185 cڡ 
wch_t
 *
__ri
 
__c
,

186 
size_t
 
__n
, size_
__den
), 
__wcy_chk
)

187 
	`__wǉr
 ("wcsncpy called withength biggerhan size of destination "

190 
__ftify_funi
 
wch_t
 *

191 
	`__NTH
 (
	$wcy
 (
wch_t
 *
__ri
 
__de
, cڡ wch_*__ri 
__c
,

192 
size_t
 
__n
))

194 i(
	`__bos
 (
__de
!(
size_t
) -1)

196 i(!
	`__but_cڡt_p
 (
__n
))

197  
	`__wcy_chk
 (
__de
, 
__c
, 
__n
,

198 
	`__bos
 (
__de
/  (
wch_t
));

199 i(
__n
 > 
	`__bos
 (
__de
/  (
wch_t
))

200  
	`__wcy_chk_wn
 (
__de
, 
__c
, 
__n
,

201 
	`__bos
 (
__de
/  (
wch_t
));

203  
	`__wcy_s
 (
__de
, 
__c
, 
__n
);

204 
	}
}

207 
wch_t
 *
	$__wny_chk
 (
wch_t
 *
__ri
 
__de
,

208 cڡ 
wch_t
 *
__ri
 
__c
, 
size_t
 
__n
,

209 
size_t
 
__den

__THROW
;

210 
wch_t
 *
	`__REDIRECT_NTH
 (
__wny_s
,

211 (
wch_t
 *
__ri
 
__de
,

212 cڡ 
wch_t
 *
__ri
 
__c
,

213 
size_t
 
__n
), 
wny
);

214 
wch_t
 *
	`__REDIRECT_NTH
 (
__wny_chk_wn
,

215 (
wch_t
 *
__ri
 
__de
,

216 cڡ 
wch_t
 *
__ri
 
__c
,

217 
size_t
 
__n
, size_
__den
), 
__wny_chk
)

218 
	`__wǉr
 ("wcpncpy called withength biggerhan size of destination "

221 
__ftify_funi
 
wch_t
 *

222 
	`__NTH
 (
	$wny
 (
wch_t
 *
__ri
 
__de
, cڡ wch_*__ri 
__c
,

223 
size_t
 
__n
))

225 i(
	`__bos
 (
__de
!(
size_t
) -1)

227 i(!
	`__but_cڡt_p
 (
__n
))

228  
	`__wny_chk
 (
__de
, 
__c
, 
__n
,

229 
	`__bos
 (
__de
/  (
wch_t
));

230 i(
__n
 > 
	`__bos
 (
__de
/  (
wch_t
))

231  
	`__wny_chk_wn
 (
__de
, 
__c
, 
__n
,

232 
	`__bos
 (
__de
/  (
wch_t
));

234  
	`__wny_s
 (
__de
, 
__c
, 
__n
);

235 
	}
}

238 
wch_t
 *
	$__wcst_chk
 (
wch_t
 *
__ri
 
__de
,

239 cڡ 
wch_t
 *
__ri
 
__c
,

240 
size_t
 
__den

__THROW
;

241 
wch_t
 *
	`__REDIRECT_NTH
 (
__wcst_s
,

242 (
wch_t
 *
__ri
 
__de
,

243 cڡ 
wch_t
 *
__ri
 
__c
), 
wcst
);

245 
__ftify_funi
 
wch_t
 *

246 
	`__NTH
 (
	$wcst
 (
wch_t
 *
__ri
 
__de
, cڡ wch_*__ri 
__c
))

248 i(
	`__bos
 (
__de
!(
size_t
) -1)

249  
	`__wcst_chk
 (
__de
, 
__c
, 
	`__bos
 (__de/  (
wch_t
));

250  
	`__wcst_s
 (
__de
, 
__c
);

251 
	}
}

254 
wch_t
 *
	$__wct_chk
 (
wch_t
 *
__ri
 
__de
,

255 cڡ 
wch_t
 *
__ri
 
__c
,

256 
size_t
 
__n
, size_
__den

__THROW
;

257 
wch_t
 *
	`__REDIRECT_NTH
 (
__wct_s
,

258 (
wch_t
 *
__ri
 
__de
,

259 cڡ 
wch_t
 *
__ri
 
__c
,

260 
size_t
 
__n
), 
wct
);

262 
__ftify_funi
 
wch_t
 *

263 
	`__NTH
 (
	$wct
 (
wch_t
 *
__ri
 
__de
, cڡ wch_*__ri 
__c
,

264 
size_t
 
__n
))

266 i(
	`__bos
 (
__de
!(
size_t
) -1)

267  
	`__wct_chk
 (
__de
, 
__c
, 
__n
,

268 
	`__bos
 (
__de
/  (
wch_t
));

269  
	`__wct_s
 (
__de
, 
__c
, 
__n
);

270 
	}
}

273 
	$__swtf_chk
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

274 
__ag
, 
size_t
 
__s_n
,

275 cڡ 
wch_t
 *
__ri
 
__fm
, ...)

276 
__THROW
 ;

278 
	`__REDIRECT_NTH_LDBL
 (
__swtf_s
,

279 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

280 cڡ 
wch_t
 *
__ri
 
__fmt
, ...),

281 
swtf
);

283 #ifde
__va_g_ck


284 
__ftify_funi
 

285 
	`__NTH
 (
	$swtf
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

286 cڡ 
wch_t
 *
__ri
 
__fmt
, ...))

288 i(
	`__bos
 (
__s
!(
size_t
-1 || 
__USE_FORTIFY_LEVEL
 > 1)

289  
	`__swtf_chk
 (
__s
, 
__n
, 
__USE_FORTIFY_LEVEL
 - 1,

290 
	`__bos
 (
__s
/  (
wch_t
),

291 
__fmt
, 
	`__va_g_ck
 ());

292  
	`__swtf_s
 (
__s
, 
__n
, 
__fmt
, 
	`__va_g_ck
 ());

293 
	}
}

294 #i!
defed
 
__lulus


296 
	#swtf
(
s
, 
n
, ...) \

297 (
	`__bos
 (
s
!(
size_t
-1 || 
__USE_FORTIFY_LEVEL
 > 1 \

298 ? 
	`__swtf_chk
 (
s
, 
n
, 
__USE_FORTIFY_LEVEL
 - 1, \

299 
	`__bos
 (
s
/  (
wch_t
), 
__VA_ARGS__
) \

300 : 
	`swtf
 (
s
, 
n
, 
__VA_ARGS__
))

	)

303 
	$__vswtf_chk
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

304 
__ag
, 
size_t
 
__s_n
,

305 cڡ 
wch_t
 *
__ri
 
__fm
,

306 
__gnuc_va_li
 
__g
)

307 
__THROW
 ;

309 
	`__REDIRECT_NTH_LDBL
 (
__vswtf_s
,

310 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

311 cڡ 
wch_t
 *
__ri
 
__fmt
,

312 
__gnuc_va_li
 
__
), 
vswtf
);

314 
__ftify_funi
 

315 
	`__NTH
 (
	$vswtf
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__n
,

316 cڡ 
wch_t
 *
__ri
 
__fmt
, 
__gnuc_va_li
 
__
))

318 i(
	`__bos
 (
__s
!(
size_t
-1 || 
__USE_FORTIFY_LEVEL
 > 1)

319  
	`__vswtf_chk
 (
__s
, 
__n
, 
__USE_FORTIFY_LEVEL
 - 1,

320 
	`__bos
 (
__s
/  (
wch_t
), 
__fmt
, 
__
);

321  
	`__vswtf_s
 (
__s
, 
__n
, 
__fmt
, 
__
);

322 
	}
}

325 #i
__USE_FORTIFY_LEVEL
 > 1

327 
__fwtf_chk
 (
__FILE
 *
__ri
 
__am
, 
__ag
,

328 cڡ 
wch_t
 *
__ri
 
__fm
, ...);

329 
__wtf_chk
 (
__ag
, cڡ 
wch_t
 *
__ri
 
__fm
,

331 
__vfwtf_chk
 (
__FILE
 *
__ri
 
__am
, 
__ag
,

332 cڡ 
wch_t
 *
__ri
 
__fm
,

333 
__gnuc_va_li
 
__
);

334 
__vwtf_chk
 (
__ag
, cڡ 
wch_t
 *
__ri
 
__fm
,

335 
__gnuc_va_li
 
__
);

337 #ifde
__va_g_ck


338 
__ftify_funi
 

339 
	$wtf
 (cڡ 
wch_t
 *
__ri
 
__fmt
, ...)

341  
	`__wtf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
	`__va_g_ck
 ());

342 
	}
}

344 
__ftify_funi
 

345 
	$fwtf
 (
__FILE
 *
__ri
 
__am
, cڡ 
wch_t
 *__ri 
__fmt
, ...)

347  
	`__fwtf_chk
 (
__am
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

348 
	`__va_g_ck
 ());

349 
	}
}

350 #i!
defed
 
__lulus


351 
	#wtf
(...) \

352 
	`__wtf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

353 
	#fwtf
(
am
, ...) \

354 
	`__fwtf_chk
 (
am
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

357 
__ftify_funi
 

358 
	$vwtf
 (cڡ 
wch_t
 *
__ri
 
__fmt
, 
__gnuc_va_li
 
__
)

360  
	`__vwtf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__
);

361 
	}
}

363 
__ftify_funi
 

364 
	$vfwtf
 (
__FILE
 *
__ri
 
__am
,

365 cڡ 
wch_t
 *
__ri
 
__fmt
, 
__gnuc_va_li
 
__
)

367  
	`__vfwtf_chk
 (
__am
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__
);

368 
	}
}

372 
wch_t
 *
	$__fgws_chk
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__size
, 
__n
,

373 
__FILE
 *
__ri
 
__am

__wur
;

374 
wch_t
 *
	`__REDIRECT
 (
__fgws_s
,

375 (
wch_t
 *
__ri
 
__s
, 
__n
,

376 
__FILE
 *
__ri
 
__am
), 
fgws

__wur
;

377 
wch_t
 *
	`__REDIRECT
 (
__fgws_chk_wn
,

378 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__size
, 
__n
,

379 
__FILE
 *
__ri
 
__am
), 
__fgws_chk
)

380 
__wur
 
	`__wǉr
 ("fgetws called with bigger sizehanength "

383 
__ftify_funi
 
__wur
 
wch_t
 *

384 
	$fgws
 (
wch_t
 *
__ri
 
__s
, 
__n
, 
__FILE
 *__ri 
__am
)

386 i(
	`__bos
 (
__s
!(
size_t
) -1)

388 i(!
	`__but_cڡt_p
 (
__n
) || __n <= 0)

389  
	`__fgws_chk
 (
__s
, 
	`__bos
 (__s/  (
wch_t
),

390 
__n
, 
__am
);

392 i((
size_t

__n
 > 
	`__bos
 (
__s
/  (
wch_t
))

393  
	`__fgws_chk_wn
 (
__s
, 
	`__bos
 (__s/  (
wch_t
),

394 
__n
, 
__am
);

396  
	`__fgws_s
 (
__s
, 
__n
, 
__am
);

397 
	}
}

399 #ifde
__USE_GNU


400 
wch_t
 *
	$__fgws_uocked_chk
 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__size
,

401 
__n
, 
__FILE
 *
__ri
 
__am
)

402 
__wur
;

403 
wch_t
 *
	`__REDIRECT
 (
__fgws_uocked_s
,

404 (
wch_t
 *
__ri
 
__s
, 
__n
,

405 
__FILE
 *
__ri
 
__am
), 
fgws_uocked
)

406 
__wur
;

407 
wch_t
 *
	`__REDIRECT
 (
__fgws_uocked_chk_wn
,

408 (
wch_t
 *
__ri
 
__s
, 
size_t
 
__size
, 
__n
,

409 
__FILE
 *
__ri
 
__am
),

410 
__fgws_uocked_chk
)

411 
__wur
 
	`__wǉr
 ("fgetws_unlocked called with bigger sizehanength "

414 
__ftify_funi
 
__wur
 
wch_t
 *

415 
	$fgws_uocked
 (
wch_t
 *
__ri
 
__s
, 
__n
, 
__FILE
 *__ri 
__am
)

417 i(
	`__bos
 (
__s
!(
size_t
) -1)

419 i(!
	`__but_cڡt_p
 (
__n
) || __n <= 0)

420  
	`__fgws_uocked_chk
 (
__s
, 
	`__bos
 (__s/  (
wch_t
),

421 
__n
, 
__am
);

423 i((
size_t

__n
 > 
	`__bos
 (
__s
/  (
wch_t
))

424  
	`__fgws_uocked_chk_wn
 (
__s
, 
	`__bos
 (__s/  (
wch_t
),

425 
__n
, 
__am
);

427  
	`__fgws_uocked_s
 (
__s
, 
__n
, 
__am
);

428 
	}
}

432 
size_t
 
	$__wtomb_chk
 (*
__ri
 
__s
, 
wch_t
 
__wch
,

433 
mbe_t
 *
__ri
 
__p
,

434 
size_t
 
__bu

__THROW
 
__wur
;

435 
size_t
 
	`__REDIRECT_NTH
 (
__wtomb_s
,

436 (*
__ri
 
__s
, 
wch_t
 
__wch
,

437 
mbe_t
 *
__ri
 
__ps
), 
wtomb

__wur
;

439 
__ftify_funi
 
__wur
 
size_t


440 
	`__NTH
 (
	$wtomb
 (*
__ri
 
__s
, 
wch_t
 
__wch
,

441 
mbe_t
 *
__ri
 
__ps
))

446 
	#__WCHAR_MB_LEN_MAX
 16

	)

447 #i
defed
 
MB_LEN_MAX
 && MB_LEN_MAX !
__WCHAR_MB_LEN_MAX


450 i(
	`__bos
 (
__s
!(
size_t
-1 && 
__WCHAR_MB_LEN_MAX
 > __bos (__s))

451  
	`__wtomb_chk
 (
__s
, 
__wch
, 
__ps
, 
	`__bos
 (__s));

452  
	`__wtomb_s
 (
__s
, 
__wch
, 
__ps
);

453 
	}
}

456 
size_t
 
	$__mbtowcs_chk
 (
wch_t
 *
__ri
 
__d
,

457 cڡ **
__ri
 
__c
,

458 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
,

459 
size_t
 
__dn

__THROW
;

460 
size_t
 
	`__REDIRECT_NTH
 (
__mbtowcs_s
,

461 (
wch_t
 *
__ri
 
__d
,

462 cڡ **
__ri
 
__c
,

463 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
),

464 
mbtowcs
);

465 
size_t
 
	`__REDIRECT_NTH
 (
__mbtowcs_chk_wn
,

466 (
wch_t
 *
__ri
 
__d
,

467 cڡ **
__ri
 
__c
,

468 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
,

469 
size_t
 
__dn
), 
__mbtowcs_chk
)

470 
	`__wǉr
 ("mbsrtowcs called with dst buffer smallerhanen "

473 
__ftify_funi
 
size_t


474 
	`__NTH
 (
	$mbtowcs
 (
wch_t
 *
__ri
 
__d
, cڡ **__ri 
__c
,

475 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
))

477 i(
	`__bos
 (
__d
!(
size_t
) -1)

479 i(!
	`__but_cڡt_p
 (
__n
))

480  
	`__mbtowcs_chk
 (
__d
, 
__c
, 
__n
, 
__ps
,

481 
	`__bos
 (
__d
/  (
wch_t
));

483 i(
__n
 > 
	`__bos
 (
__d
/  (
wch_t
))

484  
	`__mbtowcs_chk_wn
 (
__d
, 
__c
, 
__n
, 
__ps
,

485 
	`__bos
 (
__d
/  (
wch_t
));

487  
	`__mbtowcs_s
 (
__d
, 
__c
, 
__n
, 
__ps
);

488 
	}
}

491 
size_t
 
	$__wctombs_chk
 (*
__ri
 
__d
,

492 cڡ 
wch_t
 **
__ri
 
__c
,

493 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
,

494 
size_t
 
__dn

__THROW
;

495 
size_t
 
	`__REDIRECT_NTH
 (
__wctombs_s
,

496 (*
__ri
 
__d
,

497 cڡ 
wch_t
 **
__ri
 
__c
,

498 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
),

499 
wctombs
);

500 
size_t
 
	`__REDIRECT_NTH
 (
__wctombs_chk_wn
,

501 (*
__ri
 
__d
,

502 cڡ 
wch_t
 **
__ri
 
__c
,

503 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
,

504 
size_t
 
__dn
), 
__wctombs_chk
)

505 
	`__wǉr
 ("wcsrtombs called with dst buffer smallerhanen");

507 
__ftify_funi
 
size_t


508 
	`__NTH
 (
	$wctombs
 (*
__ri
 
__d
, cڡ 
wch_t
 **__ri 
__c
,

509 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
))

511 i(
	`__bos
 (
__d
!(
size_t
) -1)

513 i(!
	`__but_cڡt_p
 (
__n
))

514  
	`__wctombs_chk
 (
__d
, 
__c
, 
__n
, 
__ps
, 
	`__bos
 (__dst));

516 i(
__n
 > 
	`__bos
 (
__d
))

517  
	`__wctombs_chk_wn
 (
__d
, 
__c
, 
__n
, 
__ps
, 
	`__bos
 (__dst));

519  
	`__wctombs_s
 (
__d
, 
__c
, 
__n
, 
__ps
);

520 
	}
}

523 #ifde
__USE_GNU


524 
size_t
 
	$__mbowcs_chk
 (
wch_t
 *
__ri
 
__d
,

525 cڡ **
__ri
 
__c
, 
size_t
 
__nmc
,

526 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
,

527 
size_t
 
__dn

__THROW
;

528 
size_t
 
	`__REDIRECT_NTH
 (
__mbowcs_s
,

529 (
wch_t
 *
__ri
 
__d
,

530 cڡ **
__ri
 
__c
, 
size_t
 
__nmc
,

531 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
),

532 
mbowcs
);

533 
size_t
 
	`__REDIRECT_NTH
 (
__mbowcs_chk_wn
,

534 (
wch_t
 *
__ri
 
__d
,

535 cڡ **
__ri
 
__c
, 
size_t
 
__nmc
,

536 
size_t
 
__n
, 
mbe_t
 *
__ri
 
__ps
,

537 
size_t
 
__dn
), 
__mbowcs_chk
)

538 
	`__wǉr
 ("mbsnrtowcs called with dst buffer smallerhanen "

541 
__ftify_funi
 
size_t


542 
	`__NTH
 (
	$mbowcs
 (
wch_t
 *
__ri
 
__d
, cڡ **__ri 
__c
,

543 
size_t
 
__nmc
, size_
__n
, 
mbe_t
 *
__ri
 
__ps
))

545 i(
	`__bos
 (
__d
!(
size_t
) -1)

547 i(!
	`__but_cڡt_p
 (
__n
))

548  
	`__mbowcs_chk
 (
__d
, 
__c
, 
__nmc
, 
__n
, 
__ps
,

549 
	`__bos
 (
__d
/  (
wch_t
));

551 i(
__n
 > 
	`__bos
 (
__d
/  (
wch_t
))

552  
	`__mbowcs_chk_wn
 (
__d
, 
__c
, 
__nmc
, 
__n
, 
__ps
,

553 
	`__bos
 (
__d
/  (
wch_t
));

555  
	`__mbowcs_s
 (
__d
, 
__c
, 
__nmc
, 
__n
, 
__ps
);

556 
	}
}

559 
size_t
 
	$__wcombs_chk
 (*
__ri
 
__d
,

560 cڡ 
wch_t
 **
__ri
 
__c
,

561 
size_t
 
__nwc
, size_
__n
,

562 
mbe_t
 *
__ri
 
__ps
, 
size_t
 
__dn
)

563 
__THROW
;

564 
size_t
 
	`__REDIRECT_NTH
 (
__wcombs_s
,

565 (*
__ri
 
__d
,

566 cڡ 
wch_t
 **
__ri
 
__c
,

567 
size_t
 
__nwc
, size_
__n
,

568 
mbe_t
 *
__ri
 
__ps
), 
wcombs
);

569 
size_t
 
	`__REDIRECT_NTH
 (
__wcombs_chk_wn
,

570 (*
__ri
 
__d
,

571 cڡ 
wch_t
 **
__ri
 
__c
,

572 
size_t
 
__nwc
, size_
__n
,

573 
mbe_t
 *
__ri
 
__ps
,

574 
size_t
 
__dn
), 
__wcombs_chk
)

575 
	`__wǉr
 ("wcsnrtombs called with dst buffer smallerhanen");

577 
__ftify_funi
 
size_t


578 
	`__NTH
 (
	$wcombs
 (*
__ri
 
__d
, cڡ 
wch_t
 **__ri 
__c
,

579 
size_t
 
__nwc
, size_
__n
, 
mbe_t
 *
__ri
 
__ps
))

581 i(
	`__bos
 (
__d
!(
size_t
) -1)

583 i(!
	`__but_cڡt_p
 (
__n
))

584  
	`__wcombs_chk
 (
__d
, 
__c
, 
__nwc
, 
__n
, 
__ps
,

585 
	`__bos
 (
__d
));

587 i(
__n
 > 
	`__bos
 (
__d
))

588  
	`__wcombs_chk_wn
 (
__d
, 
__c
, 
__nwc
, 
__n
, 
__ps
,

589 
	`__bos
 (
__d
));

591  
	`__wcombs_s
 (
__d
, 
__c
, 
__nwc
, 
__n
, 
__ps
);

592 
	}
}

	@/usr/include/gnu/option-groups.h

10 #ide
__GNU_OPTION_GROUPS_H


11 
	#__GNU_OPTION_GROUPS_H


	)

13 
	#__OPTION_EGLIBC_ADVANCED_INET6
 1

	)

14 
	#__OPTION_EGLIBC_BACKTRACE
 1

	)

15 
	#__OPTION_EGLIBC_BIG_MACROS
 1

	)

16 
	#__OPTION_EGLIBC_BSD
 1

	)

17 
	#__OPTION_EGLIBC_CATGETS
 1

	)

18 
	#__OPTION_EGLIBC_CHARSETS
 1

	)

19 
	#__OPTION_EGLIBC_CRYPT
 1

	)

20 
	#__OPTION_EGLIBC_CRYPT_UFC
 1

	)

21 
	#__OPTION_EGLIBC_CXX_TESTS
 1

	)

22 
	#__OPTION_EGLIBC_DB_ALIASES
 1

	)

23 
	#__OPTION_EGLIBC_ENVZ
 1

	)

24 
	#__OPTION_EGLIBC_FCVT
 1

	)

25 
	#__OPTION_EGLIBC_FMTMSG
 1

	)

26 
	#__OPTION_EGLIBC_FSTAB
 1

	)

27 
	#__OPTION_EGLIBC_FTRAVERSE
 1

	)

28 
	#__OPTION_EGLIBC_GETLOGIN
 1

	)

29 
	#__OPTION_EGLIBC_IDN
 1

	)

30 
	#__OPTION_EGLIBC_INET
 1

	)

31 
	#__OPTION_EGLIBC_INET_ANL
 1

	)

32 
	#__OPTION_EGLIBC_LIBM
 1

	)

33 
	#__OPTION_EGLIBC_LOCALES
 1

	)

34 
	#__OPTION_EGLIBC_LOCALE_CODE
 1

	)

35 
	#__OPTION_EGLIBC_MEMUSAGE
 1

	)

36 
	#__OPTION_EGLIBC_NIS
 1

	)

37 
	#__OPTION_EGLIBC_NSSWITCH
 1

	)

38 
	#__OPTION_EGLIBC_RCMD
 1

	)

39 
	#__OPTION_EGLIBC_RTLD_DEBUG
 1

	)

40 
	#__OPTION_EGLIBC_SPAWN
 1

	)

41 
	#__OPTION_EGLIBC_STREAMS
 1

	)

42 
	#__OPTION_EGLIBC_SUNRPC
 1

	)

43 
	#__OPTION_EGLIBC_UTMP
 1

	)

44 
	#__OPTION_EGLIBC_UTMPX
 1

	)

45 
	#__OPTION_EGLIBC_WORDEXP
 1

	)

46 
	#__OPTION_POSIX_C_LANG_WIDE_CHAR
 1

	)

47 
	#__OPTION_POSIX_REGEXP
 1

	)

48 
	#__OPTION_POSIX_REGEXP_GLIBC
 1

	)

49 
	#__OPTION_POSIX_WIDE_CHAR_DEVICE_IO
 1

	)

	@/usr/include/linux/stddef.h

	@/usr/include/wctype.h

23 #ide
_WCTYPE_H


25 
	~<us.h
>

26 
	~<bs/tys.h
>

28 #ide
__ed_iswxxx


29 
	#_WCTYPE_H
 1

	)

32 
	#__ed_wt_t


	)

33 
	~<wch.h
>

37 #ide
WEOF


38 
	#WEOF
 (0xffffffffu)

	)

41 #unde
__ed_iswxxx


46 #ide
__iswxxx_defed


47 
	#__iswxxx_defed
 1

	)

49 
__BEGIN_NAMESPACE_C99


52 
	twy_t
;

53 
	g__END_NAMESPACE_C99


55 #ide
_ISwb


60 
	~<dn.h
>

61 #i
__BYTE_ORDER
 =
__BIG_ENDIAN


62 
	#_ISwb
(
b
(1 << (b))

	)

64 
	#_ISwb
(
b
) \

65 ((
b
) < 8 ? () ((1UL << (bit)) << 24) \

66 : ((
b
) < 16 ? () ((1UL << (bit)) << 8) \

67 : ((
b
) < 24 ? () ((1UL << (bit)) >> 8) \

68 : (((1UL << (
b
)>> 24))))

	)

73 
	m__ISwu
 = 0,

74 
	m__ISwlow
 = 1,

75 
	m__ISwpha
 = 2,

76 
	m__ISwdig
 = 3,

77 
	m__ISwxdig
 = 4,

78 
	m__ISwa
 = 5,

79 
	m__ISwt
 = 6,

80 
	m__ISwgph
 = 7,

81 
	m__ISwbnk
 = 8,

82 
	m__ISwl
 = 9,

83 
	m__ISwpun
 = 10,

84 
	m__ISwnum
 = 11,

86 
	m_ISwu
 = 
_ISwb
 (
__ISwu
),

87 
	m_ISwlow
 = 
_ISwb
 (
__ISwlow
),

88 
	m_ISwpha
 = 
_ISwb
 (
__ISwpha
),

89 
	m_ISwdig
 = 
_ISwb
 (
__ISwdig
),

90 
	m_ISwxdig
 = 
_ISwb
 (
__ISwxdig
),

91 
	m_ISwa
 = 
_ISwb
 (
__ISwa
),

92 
	m_ISwt
 = 
_ISwb
 (
__ISwt
),

93 
	m_ISwgph
 = 
_ISwb
 (
__ISwgph
),

94 
	m_ISwbnk
 = 
_ISwb
 (
__ISwbnk
),

95 
	m_ISwl
 = 
_ISwb
 (
__ISwl
),

96 
	m_ISwpun
 = 
_ISwb
 (
__ISwpun
),

97 
	m_ISwnum
 = 
_ISwb
 (
__ISwnum
)

102 
__BEGIN_DECLS


104 
__BEGIN_NAMESPACE_C99


111 
	$iswnum
 (
wt_t
 
__wc

__THROW
;

117 
	$iswpha
 (
wt_t
 
__wc

__THROW
;

120 
	$iswl
 (
wt_t
 
__wc

__THROW
;

124 
	$iswdig
 (
wt_t
 
__wc

__THROW
;

128 
	$iswgph
 (
wt_t
 
__wc

__THROW
;

133 
	$iswlow
 (
wt_t
 
__wc

__THROW
;

136 
	$iswt
 (
wt_t
 
__wc

__THROW
;

141 
	$iswpun
 (
wt_t
 
__wc

__THROW
;

146 
	$iswa
 (
wt_t
 
__wc

__THROW
;

151 
	$iswu
 (
wt_t
 
__wc

__THROW
;

156 
	$iswxdig
 (
wt_t
 
__wc

__THROW
;

161 #ifde
__USE_ISOC99


162 
	$iswbnk
 (
wt_t
 
__wc

__THROW
;

171 
wy_t
 
	$wy
 (cڡ *
__ݔty

__THROW
;

175 
	$iswy
 (
wt_t
 
__wc
, 
wy_t
 
__desc

__THROW
;

176 
__END_NAMESPACE_C99


183 
__BEGIN_NAMESPACE_C99


186 cڡ 
	t__t32_t
 *
	twns_t
;

187 
__END_NAMESPACE_C99


188 #ifde
__USE_GNU


189 
	$__USING_NAMESPACE_C99
(
wns_t
)

192 
__BEGIN_NAMESPACE_C99


194 
wt_t
 
	$towlow
 (
wt_t
 
__wc

__THROW
;

197 
wt_t
 
	$towu
 (
wt_t
 
__wc

__THROW
;

198 
__END_NAMESPACE_C99


200 
__END_DECLS


207 #ifde
_WCTYPE_H


213 
__BEGIN_DECLS


215 
__BEGIN_NAMESPACE_C99


218 
wns_t
 
	$wns
 (cڡ *
__ݔty

__THROW
;

221 
wt_t
 
	$towns
 (
wt_t
 
__wc
, 
wns_t
 
__desc

__THROW
;

222 
__END_NAMESPACE_C99


224 #ifde
__USE_XOPEN2K8


226 
	~<xlo.h
>

230 
	$iswnum_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

236 
	$iswpha_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

239 
	$iswl_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

243 
	$iswdig_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

247 
	$iswgph_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

252 
	$iswlow_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

255 
	$iswt_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

260 
	$iswpun_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

265 
	$iswa_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

270 
	$iswu_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

275 
	$iswxdig_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

280 
	$iswbnk_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

284 
wy_t
 
	$wy_l
 (cڡ *
__ݔty
, 
__lo_t
 
__lo
)

285 
__THROW
;

289 
	$iswy_l
 (
wt_t
 
__wc
, 
wy_t
 
__desc
, 
__lo_t
 
__lo
)

290 
__THROW
;

298 
wt_t
 
	$towlow_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

301 
wt_t
 
	$towu_l
 (
wt_t
 
__wc
, 
__lo_t
 
__lo

__THROW
;

305 
wns_t
 
	$wns_l
 (cڡ *
__ݔty
, 
__lo_t
 
__lo
)

306 
__THROW
;

309 
wt_t
 
	$towns_l
 (
wt_t
 
__wc
, 
wns_t
 
__desc
,

310 
__lo_t
 
__lo

__THROW
;

314 
__END_DECLS


	@
1
.
1
/usr/include
410
8329
ASCIICType.h
AVLTree.h
Assertions.cpp
Assertions.h
Atomics.cpp
Atomics.h
AutodrainedPool.h
Bag.h
BagToHashMap.h
BitVector.cpp
BitVector.h
Bitmap.h
BlockStack.h
BloomFilter.h
BoundsCheckedPointer.h
BumpPointerAllocator.h
ByteOrder.h
ByteSpinLock.h
CheckedArithmetic.h
CheckedBoolean.h
CommaPrinter.h
CompilationThread.cpp
CompilationThread.h
Compiler.h
Compression.cpp
Compression.h
CryptographicUtilities.cpp
CryptographicUtilities.h
CryptographicallyRandomNumber.cpp
CryptographicallyRandomNumber.h
CurrentTime.cpp
CurrentTime.h
DataLog.cpp
DataLog.h
DateMath.cpp
DateMath.h
DecimalNumber.cpp
DecimalNumber.h
DeferrableRefCounted.h
Deque.h
DisallowCType.h
DoublyLinkedList.h
ExportMacros.h
FastBitVector.cpp
FastBitVector.h
FastMalloc.cpp
FastMalloc.h
FeatureDefines.h
FilePrintStream.cpp
FilePrintStream.h
FlipBytes.h
Forward.h
FunctionDispatcher.cpp
FunctionDispatcher.h
Functional.h
GetPtr.h
GregorianDateTime.cpp
GregorianDateTime.h
HashCountedSet.h
HashFunctions.h
HashIterators.h
HashMap.h
HashMethod.h
HashSet.h
HashTable.cpp
HashTable.h
HashTraits.h
HexNumber.h
InlineASM.h
Insertion.h
IteratorAdaptors.h
IteratorRange.h
ListDump.h
ListHashSet.h
Locker.h
MD5.cpp
MD5.h
MainThread.cpp
MainThread.h
MallocPtr.h
MathExtras.h
MediaTime.cpp
MediaTime.h
MessageQueue.h
MetaAllocator.cpp
MetaAllocator.h
MetaAllocatorHandle.h
NeverDestroyed.h
NoLock.h
Noncopyable.h
NumberOfCores.cpp
NumberOfCores.h
OSAllocator.h
OSAllocatorPosix.cpp
OSAllocatorWin.cpp
OSRandomSource.cpp
OSRandomSource.h
ObjcRuntimeExtras.h
Optional.h
OwnPtr.h
OwnPtrCommon.h
PackedIntVector.h
PageAllocation.h
PageAllocationAligned.cpp
PageAllocationAligned.h
PageBlock.cpp
PageBlock.h
PageReservation.h
ParallelJobs.h
ParallelJobsGeneric.cpp
ParallelJobsGeneric.h
ParallelJobsLibdispatch.h
ParallelJobsOpenMP.h
PassOwnPtr.h
PassRef.h
PassRefPtr.h
Platform.h
PossiblyNull.h
PrintStream.cpp
PrintStream.h
ProcessID.h
RAMSize.cpp
RAMSize.h
RandomNumber.cpp
RandomNumber.h
RandomNumberSeed.h
RawPointer.h
RedBlackTree.h
Ref.h
RefCounted.h
RefCountedArray.h
RefCountedLeakCounter.cpp
RefCountedLeakCounter.h
RefPtr.h
RefPtrHashMap.h
RetainPtr.h
RunLoop.cpp
RunLoop.h
RunLoopTimer.h
RunLoopTimerCF.cpp
SHA1.cpp
SHA1.h
SaturatedArithmetic.h
SchedulePair.h
SchedulePairCF.cpp
SegmentedVector.h
SentinelLinkedList.h
SimpleStats.h
SinglyLinkedList.h
SixCharacterHash.cpp
SixCharacterHash.h
SizeLimits.cpp
Spectrum.h
StackBounds.cpp
StackBounds.h
StackStats.cpp
StackStats.h
StaticConstructors.h
StdLibExtras.h
StreamBuffer.h
StringExtras.h
StringHashDumpContext.h
StringHasher.h
StringPrintStream.cpp
StringPrintStream.h
TCPackedCache.h
TCPageMap.h
TCSpinLock.h
TCSystemAlloc.cpp
TCSystemAlloc.h
TemporaryChange.h
ThreadFunctionInvocation.h
ThreadIdentifierDataPthreads.cpp
ThreadIdentifierDataPthreads.h
ThreadSafeRefCounted.h
ThreadSpecific.h
ThreadSpecificWin.cpp
Threading.cpp
Threading.h
ThreadingPrimitives.h
ThreadingPthreads.cpp
ThreadingWin.cpp
TriState.h
UniStdExtras.h
UnionFind.h
VMTags.h
ValueCheck.h
Vector.h
VectorTraits.h
WTFThreadData.cpp
WTFThreadData.h
WeakPtr.h
WindowsExtras.h
cf/RunLoopCF.cpp
cf/TypeCasts.h
dtoa.cpp
dtoa.h
dtoa/bignum-dtoa.cc
dtoa/bignum-dtoa.h
dtoa/bignum.cc
dtoa/bignum.h
dtoa/cached-powers.cc
dtoa/cached-powers.h
dtoa/diy-fp.cc
dtoa/diy-fp.h
dtoa/double-conversion.cc
dtoa/double-conversion.h
dtoa/double.h
dtoa/fast-dtoa.cc
dtoa/fast-dtoa.h
dtoa/fixed-dtoa.cc
dtoa/fixed-dtoa.h
dtoa/strtod.cc
dtoa/strtod.h
dtoa/utils.h
efl/EflTypedefs.h
efl/MainThreadEfl.cpp
efl/RunLoopEfl.cpp
efl/UniquePtrEfl.h
gobject/GMainLoopSource.cpp
gobject/GMainLoopSource.h
gobject/GMutexLocker.h
gobject/GRefPtr.cpp
gobject/GRefPtr.h
gobject/GTypedefs.h
gobject/GUniquePtr.h
gobject/GlibUtilities.cpp
gobject/GlibUtilities.h
gtk/MainThreadGtk.cpp
gtk/RunLoopGtk.cpp
ios/WebCoreThread.cpp
ios/WebCoreThread.h
mbmalloc.cpp
text/ASCIIFastPath.h
text/AtomicString.cpp
text/AtomicString.h
text/AtomicStringHash.h
text/AtomicStringImpl.h
text/AtomicStringTable.cpp
text/AtomicStringTable.h
text/Base64.cpp
text/Base64.h
text/CString.cpp
text/CString.h
text/ConversionMode.h
text/IntegerToStringConversion.h
text/LChar.h
text/StringBuffer.h
text/StringBuilder.cpp
text/StringBuilder.h
text/StringConcatenate.h
text/StringHash.h
text/StringImpl.cpp
text/StringImpl.h
text/StringOperators.h
text/StringStatics.cpp
text/StringView.h
text/TextPosition.h
text/WTFString.cpp
text/WTFString.h
text/cf/AtomicStringCF.cpp
text/cf/StringCF.cpp
text/cf/StringImplCF.cpp
text/cf/StringViewCF.cpp
threads/BinarySemaphore.cpp
threads/BinarySemaphore.h
threads/win/BinarySemaphoreWin.cpp
unicode/CharacterNames.h
unicode/Collator.h
unicode/CollatorDefault.cpp
unicode/UTF8.cpp
unicode/UTF8.h
unicode/icu/CollatorICU.cpp
win/GDIObject.h
win/MainThreadWin.cpp
win/RunLoopWin.cpp
/usr/include/arpa/inet.h
/usr/include/ctype.h
/usr/include/dlfcn.h
/usr/include/errno.h
/usr/include/execinfo.h
/usr/include/fcntl.h
/usr/include/inttypes.h
/usr/include/limits.h
/usr/include/malloc.h
/usr/include/math.h
/usr/include/pthread.h
/usr/include/sched.h
/usr/include/signal.h
/usr/include/stdint.h
/usr/include/stdio.h
/usr/include/stdlib.h
/usr/include/string.h
/usr/include/strings.h
/usr/include/sys/mman.h
/usr/include/sys/param.h
/usr/include/sys/sysctl.h
/usr/include/sys/time.h
/usr/include/sys/timeb.h
/usr/include/sys/types.h
/usr/include/sys/utsname.h
/usr/include/time.h
/usr/include/unistd.h
/usr/include/zlib.h
/usr/include/alloca.h
/usr/include/bits/confname.h
/usr/include/bits/dlfcn.h
/usr/include/bits/environments.h
/usr/include/bits/errno.h
/usr/include/bits/fcntl.h
/usr/include/bits/fcntl2.h
/usr/include/bits/huge_val.h
/usr/include/bits/huge_valf.h
/usr/include/bits/huge_vall.h
/usr/include/bits/inf.h
/usr/include/bits/math-finite.h
/usr/include/bits/mathcalls.h
/usr/include/bits/mathdef.h
/usr/include/bits/mathinline.h
/usr/include/bits/mman.h
/usr/include/bits/nan.h
/usr/include/bits/param.h
/usr/include/bits/posix1_lim.h
/usr/include/bits/posix2_lim.h
/usr/include/bits/posix_opt.h
/usr/include/bits/pthreadtypes.h
/usr/include/bits/sched.h
/usr/include/bits/setjmp.h
/usr/include/bits/sigaction.h
/usr/include/bits/sigcontext.h
/usr/include/bits/siginfo.h
/usr/include/bits/signum.h
/usr/include/bits/sigset.h
/usr/include/bits/sigstack.h
/usr/include/bits/sigthread.h
/usr/include/bits/stat.h
/usr/include/bits/stdio-ldbl.h
/usr/include/bits/stdio.h
/usr/include/bits/stdio2.h
/usr/include/bits/stdio_lim.h
/usr/include/bits/stdlib-bsearch.h
/usr/include/bits/stdlib-float.h
/usr/include/bits/stdlib-ldbl.h
/usr/include/bits/stdlib.h
/usr/include/bits/string.h
/usr/include/bits/string2.h
/usr/include/bits/string3.h
/usr/include/bits/sys_errlist.h
/usr/include/bits/sysctl.h
/usr/include/bits/time.h
/usr/include/bits/types.h
/usr/include/bits/unistd.h
/usr/include/bits/utsname.h
/usr/include/bits/waitflags.h
/usr/include/bits/waitstatus.h
/usr/include/bits/wchar.h
/usr/include/bits/wordsize.h
/usr/include/bits/xopen_lim.h
/usr/include/endian.h
/usr/include/features.h
/usr/include/getopt.h
/usr/include/libio.h
/usr/include/linux/sysctl.h
/usr/include/netinet/in.h
/usr/include/sys/select.h
/usr/include/sys/sysmacros.h
/usr/include/sys/ucontext.h
/usr/include/xlocale.h
/usr/include/_G_config.h
/usr/include/bits/byteswap.h
/usr/include/bits/endian.h
/usr/include/bits/fcntl-linux.h
/usr/include/bits/in.h
/usr/include/bits/libio-ldbl.h
/usr/include/bits/local_lim.h
/usr/include/bits/mman-linux.h
/usr/include/bits/select.h
/usr/include/bits/select2.h
/usr/include/bits/stdio-lock.h
/usr/include/bits/timex.h
/usr/include/bits/typesizes.h
/usr/include/gnu/stubs.h
/usr/include/linux/errno.h
/usr/include/linux/kernel.h
/usr/include/linux/limits.h
/usr/include/linux/param.h
/usr/include/linux/types.h
/usr/include/stdc-predef.h
/usr/include/sys/cdefs.h
/usr/include/sys/socket.h
/usr/include/bits/byteswap-16.h
/usr/include/bits/libc-lock.h
/usr/include/bits/socket.h
/usr/include/bits/socket2.h
/usr/include/bits/uio.h
/usr/include/gconv.h
/usr/include/gnu/stubs-32.h
/usr/include/gnu/stubs-64.h
/usr/include/gnu/stubs-x32.h
/usr/include/linux/posix_types.h
/usr/include/linux/sysinfo.h
/usr/include/sys/uio.h
/usr/include/wchar.h
/usr/include/bits/sockaddr.h
/usr/include/bits/socket_type.h
/usr/include/bits/wchar-ldbl.h
/usr/include/bits/wchar2.h
/usr/include/gnu/option-groups.h
/usr/include/linux/stddef.h
/usr/include/wctype.h
